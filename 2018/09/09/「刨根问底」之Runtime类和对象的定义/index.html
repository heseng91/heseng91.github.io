<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heseng91.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="runtime简介依照苹果文档的说法，runtime是： 12The Objective-C language defers as many decisions as it can from compile time and link time to runtime. （尽量将决定放到运行的时候，而不是在编译和链接过程）  如何理解这段话呢，我们首先要知道，一段代码从写完到最终执行的过程中发生了什">
<meta property="og:type" content="article">
<meta property="og:title" content="刨根问底」之Objective-C 2.0 中类与对象的定义">
<meta property="og:url" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/index.html">
<meta property="og:site_name" content="和僧">
<meta property="og:description" content="runtime简介依照苹果文档的说法，runtime是： 12The Objective-C language defers as many decisions as it can from compile time and link time to runtime. （尽量将决定放到运行的时候，而不是在编译和链接过程）  如何理解这段话呢，我们首先要知道，一段代码从写完到最终执行的过程中发生了什">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/iOS%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.png">
<meta property="og:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/class-diagram.jpg">
<meta property="og:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/Runtime%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA.png">
<meta property="og:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%AB%98%E5%9C%B0%E4%BD%8D%E6%80%BB%E6%98%AF0.png">
<meta property="og:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%BD%8E%E4%BD%8D%E8%AE%BE%E7%BD%AE%E4%B8%BA1.png">
<meta property="og:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/NSNumber%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA.png">
<meta property="og:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E9%99%85%E5%8D%A0%E7%94%A8%E5%92%8C%E5%88%86%E9%85%8D%E5%88%B0%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F.png">
<meta property="og:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%83%85%E5%86%B5.png">
<meta property="og:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E9%99%85%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F.png">
<meta property="og:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B1%BB%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA.png">
<meta property="og:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%8A%A8%E6%80%81%E7%9A%84%E9%83%A8%E5%88%86%E6%8F%90%E5%8F%96%E4%B8%BAclass_rw_ext_t%E5%90%8E%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84.png">
<meta property="article:published_time" content="2018-09-08T18:10:09.000Z">
<meta property="article:modified_time" content="2022-11-02T16:51:31.778Z">
<meta property="article:author" content="和僧">
<meta property="article:tag" content="和僧-技术博客，技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/iOS%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.png">

<link rel="canonical" href="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>刨根问底」之Objective-C 2.0 中类与对象的定义 | 和僧</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">和僧</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="和僧">
      <meta itemprop="description" content="技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和僧">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          刨根问底」之Objective-C 2.0 中类与对象的定义
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-09 02:10:09" itemprop="dateCreated datePublished" datetime="2018-09-09T02:10:09+08:00">2018-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-03 00:51:31" itemprop="dateModified" datetime="2022-11-03T00:51:31+08:00">2022-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/" itemprop="url" rel="index"><span itemprop="name">刨根问底</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="runtime简介"><a href="#runtime简介" class="headerlink" title="runtime简介"></a>runtime简介</h2><p>依照苹果文档的说法，runtime是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The Objective-C language defers as many decisions as it can from compile time and link time to runtime. </span><br><span class="line">（尽量将决定放到运行的时候，而不是在编译和链接过程）</span><br></pre></td></tr></table></figure>

<p>如何理解这段话呢，我们首先要知道，一段代码从写完到最终执行的过程中发生了什么。</p>
<a id="more"></a>

<h3 id="从代码到可执行文件的过程"><a href="#从代码到可执行文件的过程" class="headerlink" title="从代码到可执行文件的过程"></a>从代码到可执行文件的过程</h3><p>具体过程见下图：</p>
<img src="/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/iOS%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.png" class title="iOS从代码到可执行文件">

<p>主要过程可以简化成三个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 编译</span><br><span class="line">- 链接</span><br><span class="line">- 运行</span><br></pre></td></tr></table></figure>

<p>编译：将代码转换成底层可执行的语言（如汇编），简单来讲，就是把你能看懂的语言，转换成系统底层可以看懂的东西，这中间通常会有优化，先预处理，再编译。</p>
<p>链接：在编译的过程中，如果有调用其他的类的方法等，是不会检查或者报警的，编译的时候会默认你已经实现了。而链接就是去检查调用的方法或者类等是否确实存在。</p>
<p>运行：执行最终的可执行文件</p>
<p>如果是普通的C语言代码，我们使用的是传统的编译运行，那么一个函数的执行内容，在编译阶段其实就确定了，执行的时候只要去执行对应的内存地址的程序就好。</p>
<p>因为Objc是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个 Objc 运行框架的一块基石。 </p>
<p>Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 maxOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。</p>
<h3 id="Runtime之发送消息（objc-msgSend）"><a href="#Runtime之发送消息（objc-msgSend）" class="headerlink" title="Runtime之发送消息（objc_msgSend）"></a>Runtime之发送消息（objc_msgSend）</h3><p>还记得刚学 Objective-C 时把 <code>[receiver message]</code> 当成简单的方法调用，而无视了<strong>“发送消息”</strong>这句话的深刻含义。其实 <code>[receiver message]</code> 会被编译器转化为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure>

<p>如果消息含有参数，则为： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<p>如果消息的接收者能够找到对应的 <code>selector</code>，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个 <code>selector</code> 对应的实现内容，要么就干脆玩完崩溃掉。</p>
<p>消息发送等下章详细表述。本文基于源码为 objc4-756.2，先来介绍一下 Objective-C 2.0 中类与对象的相关定义，仅作为参考，暂不做深入的分析。</p>
<h2 id="Runtime-基础数据结构"><a href="#Runtime-基础数据结构" class="headerlink" title="Runtime 基础数据结构"></a>Runtime 基础数据结构</h2><p>前面提到的<code>objc_msgSend:</code>的真身是这样的： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_msgSend</span> <span class="params">( id self, SEL op, ... )</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面将会逐渐展开介绍一些术语，其实它们都对应着数据结构。</p>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在Objc中的表示类型（Swift中是<code>Selector</code>类）。<code>selector</code>是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是<code>SEL</code>: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br></pre></td></tr></table></figure>

<p>其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令 <code>@selector()</code> 或者 Runtime 系统的 <code>sel_registerName</code> 函数来获得一个 <code>SEL</code> 类型的方法选择器。 </p>
<p>不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(参见：<code>NSNumber</code> 一堆抽象工厂方法)，Cocoa 中也有好多长长的方法。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p><code>objc_msgSend</code> 第一个参数类型为<code>id</code>，大家对它都不陌生，它是一个指向类实例的指针： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure>

<p>那<code>objc_object</code>又是啥呢，参考 objc-private.h 文件部分源码： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line">    ... 此处省略其他方法声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objc_object</code> 结构体包含一个 <code>isa</code> 指针，类型为 <code>isa_t</code> 联合体。根据 <code>isa</code> 就可以顺藤摸瓜找到对象所属的类。</p>
<p>PS: <code>isa</code> 指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用 <code>class</code> 方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的 <code>isa</code> 指针指向一个中间类而不是真实的类，这是一种叫做 <strong>isa-swizzling</strong> 的技术，详见<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="isa-t"><a href="#isa-t" class="headerlink" title="isa_t"></a>isa_t</h3><p><code>objc_object</code> 中的 <code>isa</code> 是一个 <code>isa_t</code> 类型的共用体（union），在objc-private.h 文件中定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 <code>ISA_BITFIELD</code>在 isa.h文件中定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_PACKED_ISA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// extra_rc must be the MSB-most field (so it matches carry/overflow flags)</span></span><br><span class="line">    <span class="comment">// nonpointer must be the LSB (fixme or get rid of it)</span></span><br><span class="line">    <span class="comment">// shiftcls must occupy the same bits that a real class pointer would</span></span><br><span class="line">    <span class="comment">// bits + RC_ONE is equivalent to extra_rc + 1</span></span><br><span class="line">    <span class="comment">// RC_HALF is the high bit of extra_rc (i.e. half of its range)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// future expansion:</span></span><br><span class="line">    <span class="comment">// uintptr_t fast_rr : 1;     // no r/r overrides</span></span><br><span class="line">    <span class="comment">// uintptr_t lock : 2;        // lock for atomic property, @synch</span></span><br><span class="line">    <span class="comment">// uintptr_t extraBytes : 1;  // allocated with extra bytes</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                        \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;56)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">error</span> unknown architecture for packed isa</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>SUPPORT_PACKED_ISA</code> 用于标记是否支持优化的 <code>isa</code> 指针，其字面含义意思是 <code>isa</code> 的内容不再是类的指针了，而是包含了更多信息，比如引用计数，析构状态，被其他 weak 变量引用情况。判断方法也是根据设备类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define SUPPORT_PACKED_ISA=1 on platforms that store the class in the isa </span></span><br><span class="line"><span class="comment">// field as a maskable pointer with other data around it.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (!__LP64__  ||  TARGET_OS_WIN32  ||  \</span></span><br><span class="line">     (TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_IOSMAC))</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_PACKED_ISA 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_PACKED_ISA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>综合看来目前只有 arm64 架构的设备支持，下面列出了 <code>isa</code> 指针中变量对应的含义：</p>
<table>
<thead>
<tr>
<th align="left">变量名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nonpointer</td>
<td align="left">0 表示普通的 <code>isa</code> 指针，1 表示使用优化，存储引用计数</td>
</tr>
<tr>
<td align="left">has_assoc</td>
<td align="left">表示该对象是否包含 associated object，如果没有，则析构时会更快</td>
</tr>
<tr>
<td align="left">has_cxx_dtor</td>
<td align="left">表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快</td>
</tr>
<tr>
<td align="left">shiftcls</td>
<td align="left">类的指针</td>
</tr>
<tr>
<td align="left">magic</td>
<td align="left">固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。</td>
</tr>
<tr>
<td align="left">weakly_referenced</td>
<td align="left">表示该对象是否有被弱引用指向过，如果没有，则析构时更快</td>
</tr>
<tr>
<td align="left">deallocating</td>
<td align="left">表示该对象是否正在析构</td>
</tr>
<tr>
<td align="left">has_sidetable_rc</td>
<td align="left">表示该对象的引用计数值是否过大无法存储在 <code>isa</code> 指针</td>
</tr>
<tr>
<td align="left">extra_rc</td>
<td align="left">存储引用计数值减一后的结果</td>
</tr>
</tbody></table>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p><code>Class</code> 其实是一个指向 <code>objc_class</code> 结构体的指针： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure>

<p>而 <code>objc_class</code> 包含很多方法，主要都为围绕它的几个成员做文章： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line"><span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objc_class</code> 继承于 <code>objc_object</code>，也就是说一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似 <code>[NSObject alloc]</code> 的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code> 这条消息发给类对象的时候，<code>objc_msgSend()</code> 会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。 </p>
<img src="/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/class-diagram.jpg" class title="class-diagram">

<p>上图实线是 <code>superclass</code> 指针，虚线是<code>isa</code>指针。 有趣的是根元类的超类是 <code>NSObject</code>，而 <code>isa</code> 指向了自己，而 <code>NSObject</code>的超类为 <code>nil</code>，也就是它没有超类。 </p>
<h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">... </span><br><span class="line"><span class="comment">//省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>bucket_t *_buckets</code> 是一个散列表，用来存储 <code>Method</code> 方法列表，而 <code>bucket_t</code> 结构体定义如下，包含了一个 <code>unsigned long</code> 类型的 <code>_key</code> 和一个 <code>IMP</code> 类型的 <code>_imp</code>，存储了指针与 IMP 的键值对。<code>IMP</code> 是一个函数指针，指向了一个方法的具体实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// IMP-first is better for arm64e ptrauth and no worse for arm64.</span></span><br><span class="line">    <span class="comment">// SEL-first is better for armv7* and i386 and x86_64.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> _imp;</span><br><span class="line">    SEL _sel;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    SEL _sel;</span><br><span class="line">    <span class="keyword">uintptr_t</span> _imp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">... </span><br><span class="line">省略其他方法</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>cache_t</code> 中另外两个变量 <code>_mask</code> 和 <code>_occupied</code>，它们的类型为 <code>mask_t</code>，定义如下，其实是一个 <code>unsigned int</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;  <span class="comment">// x86_64 &amp; arm64 asm are less efficient with 16-bits</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">mask_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>_mask</code> 和 <code>_occupied</code> 对应于 <code>vtable</code>：</p>
<ul>
<li><code>_mask</code>：分配用来缓存 bucket 的总数。</li>
<li><code>_occupied</code>：表明目前实际占用的缓存 bucket 的个数。</li>
</ul>
<blockquote>
<p><code>cache</code> 的作用主要是对方法调用的性能进行优化。通俗地讲，每当实例对象接收到一个消息时，它不会直接在其 <code>isa</code> 指向的类（或类的 <code>isa</code> 指向的父类）的方法列表中遍历查找能够响应消息的方法实现，因为这样效率太低了，而是优先在 <code>cache</code> 中查找。Runtime 系统会把被调用过的方法存到该类对象的 <code>cache</code> 中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。</p>
</blockquote>
<p>有关缓存的实现细节，可以查看 objc-cache.mm 文件。</p>
<h3 id="class-data-bits-t"><a href="#class-data-bits-t" class="headerlink" title="class_data_bits_t"></a>class_data_bits_t</h3><p><code>objc_class</code> 中最复杂的是 <code>bits</code>，<code>class_data_bits_t</code> 结构体所包含的信息太多了，主要包含 <code>class_rw_t</code>, <code>retain/release/autorelease/retainCount</code> 和 <code>alloc</code> 等信息，很多存取方法也是围绕它展开。查看 objc-runtime-new.h 源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getBit</span><span class="params">(<span class="keyword">uintptr_t</span> <span class="built_in">bit</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; <span class="built_in">bit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">省略其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>objc_class</code> 的 <code>data</code> 方法直接将 <code>class_data_bits_t</code> 的<code>data</code> 方法返回，最终是返回 <code>class_rw_t</code>，保了好几层。</p>
<p>可以看到 <code>class_data_bits_t</code> 里又包了一个 <code>bits</code>，这个指针跟不同的 <code>FAST_</code> 前缀的 flag 掩码做按位与操作，就可以获取不同的数据。<code>bits</code> 在内存中每个位的含义有三种排列顺序：</p>
<p>32 位：</p>
<table>
<thead>
<tr>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2 - 31</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FAST_IS_SWIFT_LEGACY</td>
<td align="left">FAST_IS_SWIFT_STABLE</td>
<td align="left">FAST_DATA_MASK</td>
</tr>
</tbody></table>
<p>64 位兼容版：</p>
<table>
<thead>
<tr>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3 - 46</th>
<th align="left">47 - 63</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FAST_IS_SWIFT_LEGACY</td>
<td align="left">FAST_IS_SWIFT_STABLE</td>
<td align="left">FAST_HAS_DEFAULT_RR</td>
<td align="left">FAST_DATA_MASK</td>
<td align="left">空闲</td>
</tr>
</tbody></table>
<p>64 位不兼容版：</p>
<table>
<thead>
<tr>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3 - 46</th>
<th align="left">47</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FAST_IS_SWIFT_LEGACY</td>
<td align="left">FAST_IS_SWIFT_STABLE</td>
<td align="left">FAST_ALLOC</td>
<td align="left">FAST_DATA_MASK</td>
<td align="left">FAST_HAS_CXX_CTOR</td>
</tr>
<tr>
<td align="left">48</td>
<td align="left">49</td>
<td align="left">50</td>
<td align="left">51</td>
<td align="left">52 - 63</td>
</tr>
<tr>
<td align="left">FAST_HAS_DEFAULT_AWZ</td>
<td align="left">FAST_HAS_DEFAULT_RR</td>
<td align="left">FAST_REQUIRES_RAW_ISA</td>
<td align="left">FAST_HAS_CXX_DTOR</td>
<td align="left">空闲</td>
</tr>
</tbody></table>
<p>其中 64 位不兼容版每个宏对应的含义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class is a Swift class from the pre-stable Swift ABI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT_LEGACY    (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// class is a Swift class from the stable Swift ABI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT_STABLE    (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="comment">// summary bit for fast alloc path: !hasCxxCtor and </span></span><br><span class="line"><span class="comment">//   !instancesRequireRawIsa and instanceSize fits into shiftedSize</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_ALLOC              (1UL&lt;&lt;2)</span></span><br><span class="line"><span class="comment">// data pointer</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br><span class="line"><span class="comment">// class or superclass has .cxx_construct implementation</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_CXX_CTOR       (1UL&lt;&lt;47)</span></span><br><span class="line"><span class="comment">// class or superclass has default alloc/allocWithZone: implementation</span></span><br><span class="line"><span class="comment">// Note this is is stored in the metaclass.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_DEFAULT_AWZ    (1UL&lt;&lt;48)</span></span><br><span class="line"><span class="comment">// class or superclass has default retain/release/autorelease/retainCount/</span></span><br><span class="line"><span class="comment">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;49)</span></span><br><span class="line"><span class="comment">// class's instances requires raw isa</span></span><br><span class="line"><span class="comment">//   This bit is aligned with isa_t-&gt;hasCxxDtor to save an instruction.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;50)</span></span><br><span class="line"><span class="comment">// class or superclass has .cxx_destruct implementation</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_CXX_DTOR       (1UL&lt;&lt;51)</span></span><br><span class="line"><span class="comment">// instance size in units of 16 bytes</span></span><br><span class="line"><span class="comment">//   or 0 if the instance size is too big in this field</span></span><br><span class="line"><span class="comment">//   This field must be LAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_SHIFTED_SIZE_SHIFT 52</span></span><br></pre></td></tr></table></figure>

<p>这里面除了 <code>FAST_DATA_MASK</code> 是用一段空间存储数据外，其他宏都是只用 1 bit 存储 bool 值。<code>class_data_bits_t</code> 提供了三个方法用于位操作：<code>getBit</code>, <code>setBits</code> 和 <code>clearBits</code>，对应到存储 bool 值的掩码也有封装函数，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCxxCtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBit(FAST_HAS_CXX_CTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHasCxxCtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setBits(FAST_HAS_CXX_CTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重头戏在于最大的那块存储区域<code>FAST_DATA_MASK</code>，它其实就存储了指向 <code>class_rw_t</code> 的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对这片内存读写处于并发环境，但并不需要加锁，因为会通过对一些状态（realization or construction）判断来决定是否可读写。</p>
<p><code>class_data_bits_t</code> 甚至还包含了一些对 <code>class_rw_t</code> 中 <code>flags</code> 成员存取的封装函数。</p>
<h4 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h4><p><code>objc_class</code> 包含了 <code>class_data_bits_t</code>，<code>class_data_bits_t</code> 存储了 <code>class_rw_t</code> 的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;</span><br><span class="line">    <span class="keyword">property_array_t</span> properties;</span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">省略操作 flags 的相关方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>class_rw_t</code> 中使用的 <code>method_array_t</code>, <code>property_array_t</code>, <code>protocol_array_t</code> 都继承自 <code>list_array_tt&lt;Element, List&gt;</code>, 它可以不断扩张，因为它可以存储 list 指针，内容有三种：</p>
<ol>
<li>空</li>
<li>一个 <code>entsize_list_tt</code> 指针</li>
<li><code>entsize_list_tt</code> 指针数组</li>
</ol>
<p><code>class_rw_t</code> 的内容是可以在运行时被动态修改的，可以说运行时对类的拓展大都是存储在这里的。</p>
<p><code>class_rw_t-&gt;flags</code> 存储的值并不是编辑器设置的，其中有些值可能将来会作为 ABI 的一部分。下面这些 <code>RW_</code> 前缀的宏标记了 <code>flags</code> 一些位置的含义。这些 bool 值标记了类的一些状态，涉及到声明周期和内存管理。有些位目前甚至还空着。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Values for class_rw_t-&gt;flags</span></span><br><span class="line"><span class="comment">// These are not emitted by the compiler and are never used in class_ro_t. </span></span><br><span class="line"><span class="comment">// Their presence should be considered in future ABI versions.</span></span><br><span class="line"><span class="comment">// class_t-&gt;data is class_rw_t, not class_ro_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_REALIZED           (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// class is unresolved future class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_FUTURE             (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// class is initialized</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INITIALIZED        (1&lt;&lt;29)</span></span><br><span class="line"><span class="comment">// class is initializing</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INITIALIZING       (1&lt;&lt;28)</span></span><br><span class="line"><span class="comment">// class_rw_t-&gt;ro is heap copy of class_ro_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_COPIED_RO          (1&lt;&lt;27)</span></span><br><span class="line"><span class="comment">// class allocated but not yet registered</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_CONSTRUCTING       (1&lt;&lt;26)</span></span><br><span class="line"><span class="comment">// class allocated and registered</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_CONSTRUCTED        (1&lt;&lt;25)</span></span><br><span class="line"><span class="comment">// available for use; was RW_FINALIZE_ON_MAIN_THREAD</span></span><br><span class="line"><span class="comment">// #define RW_24 (1&lt;&lt;24)</span></span><br><span class="line"><span class="comment">// class +load has been called</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_LOADED             (1&lt;&lt;23)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"><span class="comment">// class instances may have associative references</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS (1&lt;&lt;22)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// class has instance-specific GC layout</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_HAS_INSTANCE_SPECIFIC_LAYOUT (1 &lt;&lt; 21)</span></span><br><span class="line"><span class="comment">// class does not allow associated objects on its instances</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_FORBIDS_ASSOCIATED_OBJECTS       (1&lt;&lt;20)</span></span><br><span class="line"><span class="comment">// class has started realizing but not yet completed it</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_REALIZING          (1&lt;&lt;19)</span></span><br></pre></td></tr></table></figure>

<p><code>demangledName</code> 是计算机语言用于解决实体名称唯一性的一种方法，做法是向名称中添加一些类型信息，用于从编译器中向链接器传递更多语义信息。</p>
<h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h3><p><code>class_rw_t</code> 提供了运行时对类拓展的能力，而 <code>class_ro_t</code> 存储的大多是类在编译时就已经确定的信息。二者都存有类的方法、属性（成员变量）、协议等信息，不过存储它们的列表实现方式不同。</p>
<p><code>class_ro_t</code> 中的 <code>method_list_t</code>, <code>ivar_list_t</code>, <code>property_list_t</code> 结构体都继承自 <code>entsize_list_tt&lt;Element, List, FlagMask&gt;</code>。结构为 <code>xxx_list_t</code> 的列表元素结构为 <code>xxx_t</code>，命名很工整。<code>protocol_list_t</code> 与前三个不同，它存储的是 <code>protocol_t *</code> 指针列表，实现比较简单。</p>
<p><code>entsize_list_tt</code> 实现了 non-fragile 特性的数组结构。假如苹果在新版本的 SDK 中向 <code>NSObject</code> 类增加了一些内容，<code>NSObject</code> 的占据的内存区域会扩大，开发者以前编译出的二进制中的子类就会与新的 <code>NSObject</code> 内存有重叠部分。于是在编译期会给 <code>instanceStart</code> 和 <code>instanceSize</code> 赋值，确定好编译时每个类的所占内存区域起始偏移量和大小，这样只需将子类与基类的这两个变量作对比即可知道子类是否与基类有重叠，如果有，也可知道子类需要挪多少偏移量。更多细节可以参考后面的章节 Non Fragile ivars。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This field exists only when RO_HAS_SWIFT_INITIALIZER is set.</span></span><br><span class="line">    _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">省略其他方法</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>class_ro_t-&gt;flags</code> 存储了很多在编译时期就确定的类的信息，也是 ABI 的一部分。下面这些 <code>RO_</code> 前缀的宏标记了 <code>flags</code> 一些位置的含义。其中后三个并不需要被编译器赋值，是预留给运行时加载和初始化类的标志位，涉及到与 <code>class_rw_t</code> 的类型强转。运行时会用到它做判断，后面会讲解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class_data_bits_t is the class_t-&gt;data field (class_rw_t pointer plus flags)</span></span><br><span class="line"><span class="comment">// The extra bits are optimized for the retain/release and alloc/dealloc paths.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Values for class_ro_t-&gt;flags</span></span><br><span class="line"><span class="comment">// These are emitted by the compiler and are part of the ABI.</span></span><br><span class="line"><span class="comment">// Note: See CGObjCNonFragileABIMac::BuildClassRoTInitializer in clang</span></span><br><span class="line"><span class="comment">// class is a metaclass</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_META               (1&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// class is a root class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_ROOT               (1&lt;&lt;1)</span></span><br><span class="line"><span class="comment">// class has .cxx_construct/destruct implementations</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_CXX_STRUCTORS  (1&lt;&lt;2)</span></span><br><span class="line"><span class="comment">// class has +load implementation</span></span><br><span class="line"><span class="comment">// #define RO_HAS_LOAD_METHOD    (1&lt;&lt;3)</span></span><br><span class="line"><span class="comment">// class has visibility=hidden set</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HIDDEN             (1&lt;&lt;4)</span></span><br><span class="line"><span class="comment">// class has attribute(objc_exception): OBJC_EHTYPE_$_ThisClass is non-weak</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_EXCEPTION          (1&lt;&lt;5)</span></span><br><span class="line"><span class="comment">// class has ro field for Swift metadata initializer callback</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_SWIFT_INITIALIZER (1&lt;&lt;6)</span></span><br><span class="line"><span class="comment">// class compiled with ARC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_IS_ARC             (1&lt;&lt;7)</span></span><br><span class="line"><span class="comment">// class has .cxx_destruct but no .cxx_construct (with RO_HAS_CXX_STRUCTORS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_CXX_DTOR_ONLY  (1&lt;&lt;8)</span></span><br><span class="line"><span class="comment">// class is not ARC but has ARC-style weak ivar layout </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_WEAK_WITHOUT_ARC (1&lt;&lt;9)</span></span><br><span class="line"><span class="comment">// class does not allow associated objects on instances</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class is in an unloadable bundle - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FROM_BUNDLE        (1&lt;&lt;29)</span></span><br><span class="line"><span class="comment">// class is unrealized future class - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FUTURE             (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// class is realized - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_REALIZED           (1&lt;&lt;31)</span></span><br></pre></td></tr></table></figure>

<h4 id="realizeClass"><a href="#realizeClass" class="headerlink" title="realizeClass"></a>realizeClass</h4><p>在某个类初始化之前，<code>objc_class-&gt;data()</code> 返回的指针指向的其实是个 <code>class_ro_t</code> 结构体。等到 <code>static Class realizeClass(Class cls)</code> 静态方法在类第一次初始化时被调用，它会:</p>
<ol>
<li>从 <code>class_data_bits_t</code> 调用 <code>data</code> 方法，将结果从 <code>class_rw_t</code> 强制转换为 <code>class_ro_t</code> 指针</li>
<li>初始化一个 <code>class_rw_t</code> 结构体</li>
<li>设置结构体 <code>ro</code> 的值以及 <code>flag</code></li>
<li>最后设置正确的 <code>data</code>。</li>
</ol>
<p>将 <code>class_ro_t</code> 指针赋值给 <code>class_rw_t-&gt;ro</code>。这种偷天换日的行为是靠 <code>RO_FUTURE</code> 标志位来记录的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* realizeClassWithoutSwift</span></span><br><span class="line"><span class="comment">* Performs first-time initialization on class cls, </span></span><br><span class="line"><span class="comment">* including allocating its read-write data.</span></span><br><span class="line"><span class="comment">* Does not perform any Swift-side initialization.</span></span><br><span class="line"><span class="comment">* Returns the real class structure for the class. </span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be write-locked by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">realizeClassWithoutSwift</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;data();</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;data();</span><br><span class="line">        ro = cls-&gt;data()-&gt;ro;</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">        rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">        rw-&gt;ro = ro;</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">省略逻辑实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意之前 RO 和 RW flags 宏标记的一个细节：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FUTURE             (1&lt;&lt;30)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_REALIZED           (1&lt;&lt;31)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_REALIZED           (1&lt;&lt;31)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_FUTURE             (1&lt;&lt;30)</span></span><br></pre></td></tr></table></figure>

<p>也就是说 <code>ro = (const class_ro_t *)cls-&gt;data();</code> 这种强转对于接下来的 <code>ro-&gt;flags &amp; RO_FUTURE</code> 操作完全是 OK 的，两种结构体第一个成员都是 <code>flags</code>，<code>RO_FUTURE</code> 与 <code>RW_FUTURE</code> 值一样的。</p>
<p>经过 <code>realizeClass</code> 函数处理的类才是『真正的』类，调用它时不能对类做写操作。</p>
<h2 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h2><p>在 <strong>objc-private.h</strong> 中，<code>Ivar</code> 被定义为一个指向 <code>ivar_t</code> 结构体的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__typedef struct ivar_t *Ivar;</span></span><br></pre></td></tr></table></figure>

<p><code>ivar_t</code> 结构体在 <strong>objc-runtime-new.h</strong> 中定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __x86_64__</span></span><br><span class="line">    <span class="comment">// *offset was originally 64-bit on some x86_64 platforms.</span></span><br><span class="line">    <span class="comment">// We read and write only 32 bits of it.</span></span><br><span class="line">    <span class="comment">// Some metadata provides all 64 bits. This is harmless for unsigned </span></span><br><span class="line">    <span class="comment">// little-endian values.</span></span><br><span class="line">    <span class="comment">// Some code uses all 64 bits. class_addIvar() over-allocates the </span></span><br><span class="line">    <span class="comment">// offset for their benefit.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">alignment</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (alignment_raw == ~(<span class="keyword">uint32_t</span>)<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1U</span> &lt;&lt; WORD_SHIFT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Ivar</code> 用于表示类中实例变量（成员变量）的类型，<code>ivar_t</code> 中定义了实例变量的名字和类型。而ivar 的修饰信息存放在了 Class 的 Ivar Layout 中。ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型。</p>
<p>举个例子说明，若类定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface Foo : NSObject &#123;</span><br><span class="line">    __strong id ivar0;</span><br><span class="line">    __weak id ivar1;</span><br><span class="line">    __weak id ivar2;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>则储存 strong ivar 的 ivarLayout 的值为 <strong>0x012000</strong></p>
<p>储存 weak ivar 的 weakIvarLayout 的值为 <strong>0x1200</strong></p>
<p>一个 uint8_t 在 16 进制下是两位，所以编码的值每两位一对儿，以上面的 ivarLayout 为例：</p>
<ol>
<li>前两位 <strong>01</strong> 表示有 0 个非 strong 对象和 1 个 strong 对象</li>
<li>之后两位 <strong>20</strong> 表示有 2 个非 strong 对象和 0 个 strong 对象</li>
<li>最后两位 <strong>00</strong> 为结束符，就像 cstring 的 <strong>\0</strong> 一样</li>
</ol>
<p>同理，上面的 weakIvarLayout：</p>
<ol>
<li>前两位 <strong>12</strong> 表示有 1 个非 weak 对象和接下来连续 2 个 weak 对象</li>
<li><strong>00</strong> 结束符</li>
</ol>
<p>这样，用两个 layout 编码值就可以排查出一个 ivar 是属于 strong 还是 weak 的，若都没有找到，就说明这个对象是 unsafe_unretained.</p>
<h2 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h2><p>我们知道，<code>@property</code> 用于声明类中的属性，在 Runtime 系统中，<code>objc_property_t</code> 是一个指向<code>objc_property</code> 结构体的指针，在 <strong>objc-private.h</strong> 中定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__typedef struct property_t *objc_property_t;</span></span><br></pre></td></tr></table></figure>

<p><code>property_t</code> 结构体在 <strong>objc-runtime-new.h</strong> 中定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p><code>Method</code>是一种代表类中的某个方法的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__typedef struct method_t *Method;</span></span><br></pre></td></tr></table></figure>

<p>而 <code>objc_method</code> 在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SortBySELAddress</span> :</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">std</span>::binary_function&lt;<span class="keyword">const</span> <span class="keyword">method_t</span>&amp;,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="keyword">method_t</span>&amp;, <span class="keyword">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">method_t</span>&amp; lhs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">method_t</span>&amp; rhs)</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法名类型为 <code>SEL</code>，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。 </li>
<li>方法类型 <code>types</code> 是个<code>char</code>指针，其实存储着方法的参数类型和返回值类型。</li>
<li><code>imp</code> 指向了方法的实现，本质上是一个函数指针，后面会详细讲到。 </li>
</ul>
<h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p><code>Category</code> 为现有的类提供了拓展性，它是 <code>category_t</code> 结构体的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__typedef struct category_t *Category;</span></span><br></pre></td></tr></table></figure>

<p><code>category_t</code> 存储了类别中可以拓展的实例方法、类方法、协议、实例属性和类属性。类属性是 Objective-C 2016 年新增的特性，沾 Swift 的光。所以 <code>category_t</code> 中有些成员变量是为了兼容 Swift 的特性，Objective-C 暂没提供接口，仅做了底层数据结构上的兼容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta, struct header_info *hi)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 App 启动加载镜像文件时，会在 <code>_read_images</code> 函数间接调用到 <code>attachCategories</code> 函数，完成向类中添加 <code>Category</code> 的工作。原理就是向 <code>class_rw_t</code> 中的 <code>method_array_t</code>, <code>property_array_t</code>, <code>protocol_array_t</code> 数组中分别添加 <code>method_list_t</code>, <code>property_list_t</code>, <code>protocol_list_t</code> 指针。之前讲过 <code>xxx_array_t</code> 可以存储对应 <code>xxx_list_t</code> 的指针数组。</p>
<p>在调用 <code>attachCategories</code> 函数之前，会先使用 <code>unattachedCategoriesForClass</code> 函数获取类中还未添加的类别列表。这个列表类型为 <code>locstamped_category_list_t</code>，它封装了 <code>category_t</code> 以及对应的 <code>header_info</code>。<code>header_info</code> 存储了实体在镜像中的加载和初始化状态，以及一些偏移量，在加载 Mach-O 文件相关函数中经常用到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locstamped_category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">category_t</span> *cat;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">header_info</span> *<span class="title">hi</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locstamped_category_list_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">locstamped_category_t</span> <span class="built_in">list</span>[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以更具体来说 <code>attachCategories</code> 做的就是将 <code>locstamped_category_list_t.list</code> 列表中每个 <code>locstamped_category_t.cat</code> 中的那方法、协议和属性分别添加到类的 <code>class_rw_t</code> 对应列表中。<code>header_info</code> 中的信息决定了是否是元类，从而选择应该是添加实例方法还是类方法、实例属性还是类属性等。源码在 objc-runtime-new.mm 文件中，很好理解。</p>
<h3 id="protocol-t"><a href="#protocol-t" class="headerlink" title="protocol_t"></a>protocol_t</h3><p>虽然 Objective-C 的 <code>Category</code> 和 <code>protocol</code> 拓展能力有限，但也得为了将就 Swift 的感受，充个胖子。</p>
<p><code>flags</code> 32 位指针最后两位是给加载 Mach-O 的 fix-up 阶段使用的，前 16 位预留给 Swift 用的。</p>
<p><code>protocol</code> 主要内容其实是（可选）方法，其次就是继承其他 <code>protocol</code>。Swift 还支持 <code>protocol</code> 多继承，所以需要 <code>protocols</code> 数组来做兼容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protocol_t</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *instanceMethods;</span><br><span class="line">    <span class="keyword">method_list_t</span> *classMethods;</span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalInstanceMethods;</span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalClassMethods;</span><br><span class="line">    <span class="keyword">property_list_t</span> *instanceProperties;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="built_in">size</span>;   <span class="comment">// sizeof(protocol_t)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **_extendedMethodTypes;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *_demangledName;</span><br><span class="line">    <span class="keyword">property_list_t</span> *_classProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">demangledName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">nameForLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demangledName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">... </span><br><span class="line">省略一些封装的便捷 <span class="built_in">get</span> 方法</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p><code>IMP</code>在<code>objc.h</code>中的定义是： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p>它就是一个<a href="http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/" target="_blank" rel="noopener">函数指针</a>，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 <code>IMP</code> 这个函数指针就指向了这个方法的实现。既然得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面会提到。 </p>
<p>你会发现 <code>IMP</code> 指向的方法与 <code>objc_msgSend</code> 函数类型相同，参数都包含 <code>id</code> 和 <code>SEL</code> 类型。每个方法名都对应一个 <code>SEL</code> 类型的方法选择器，而每个实例对象中的 <code>SEL</code> 对应的方法实现肯定是唯一的，通过一组 <code>id</code> 和 <code>SEL</code> 参数就能确定唯一的方法实现地址；反之亦然。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以用如下这张图来分别表示 Objective-C 2.0 版本中类和对象的定义，及相关数据结构的关系：<img src="/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/Runtime%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class title="Runtime之类和对象的数据结构"></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p><code>isa</code> 这里还涉及到 <strong>Tagged Pointer</strong> 等概念。因为 <code>isa_t</code> 使用 <code>union</code> 实现，所以可能表示多种形态，既可以当成是指针，也可以存储标志位。</p>
<p><strong>Tagged Pointer：</strong>一种特殊标记的对象，Tagged Pointer 通过在其最后一个 bit 位设置为特殊标记位，并且把数据直接保存在指针本身中。Tagged Pointer 是一个”伪”对象，使用 Tagged Pointer 有 3 倍的访问速度提升，100 倍的创建、销毁速度提升。</p>
<p><strong>Tips：</strong><a href="https://developer.apple.com/videos/play/wwdc2013/404/" target="_blank" rel="noopener">Advances in Objective-C</a></p>
<p>在我们查看对象指针时，在 64 位系统中，我们会看到 16 进制地址如<code>0x00000001003041e0</code>，我们把它转换为二进制表示如下图</p>
<img src="/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA.png" class title="对象指针二进制表示">

<p>在 64 位系统中，我们有 64 位可以表示一个对象指针，但是我们通常没有真正使用到所有这些位。由于内存对齐要求的存在，低位始终为0，对象必须始终位于指针大小倍数的地址中。由于地址空间有限，所以高位也始终为0。所以实际上我们只在一个真正的对象指针中使用了中间的这些位，而不会用到用到2^64，这些高位和低位总是0。</p>
<img src="/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%AB%98%E5%9C%B0%E4%BD%8D%E6%80%BB%E6%98%AF0.png" class title="对象指针二进制表示高地位总是0">

<p>苹果从这些始终为0的位中选择了低位并把它设置为1。以标识这不是一个真正的对象指针，然后就可以给其他位赋予一些其他的意义，苹果称这种指针为tagged pointer。</p>
<img src="/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%BD%8E%E4%BD%8D%E8%AE%BE%E7%BD%AE%E4%B8%BA1.png" class title="对象指针二进制表示低位设置为1">

<p>例如：NSNumber指针，苹果在其它位中塞入的是一个数值。（PS：这些值实际上是通过与进程启动时初始化的随机值相结合而被混淆的）。<img src="/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/NSNumber%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA.png" class title="NSNumber对象指针二进制表示"></p>
<p>在设置为 1 表示为 Tagged Pointer 对象之后，在最低位之后的 3 位，苹果给他赋予类型意义，由于只有 3 位，所以它可以表示 7 种数据类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">OBJC_TAG_NSDate            = <span class="number">6</span>, </span><br><span class="line">OBJC_TAG_7                 = <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>在剩余的字段中，我们可以赋予他所包含的数据。在 Intel 中，我们 Tagged Pointer 对象的表示如下</p>


<p><code>OBJC_TAG_7</code>类型的 Tagged Pointer 是个例外，它可以将接下来后 8 位作为它的扩展类型字段，基于此我们可以多支持 256 中类型的 Tagged Pointer，如 UIColors 或 NSIndexSets 之类的对象。</p>


<h3 id="OC对象占用的大小"><a href="#OC对象占用的大小" class="headerlink" title="OC对象占用的大小"></a>OC对象占用的大小</h3><h4 id="初始OC对象占用内存"><a href="#初始OC对象占用内存" class="headerlink" title="初始OC对象占用内存"></a>初始OC对象占用内存</h4><p>OC中对象大部分继承至NSObject。NSObject类的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OBJC_AVAILABLE(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line">OBJC_ROOT_CLASS</span><br><span class="line">OBJC_EXPORT</span><br><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">"-Wobjc-interface-ivars"</span></span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上文中提到Class其实就是一个指向 <code>struct objc_class</code> 结构体类型的指针.。那么也就是说 <code>NSObject</code> 对象对应的结构体只包含一个 <code>isa</code> 指针变量 ，一个指针变量在 64 位的机器上大小是 8 个字节。</p>
<p>那是不是说一个 <code>NSObject</code> 对象就占用8个字节大小的内存呢？实际上不是的. 答案其实是: <strong>所有的OC对象至少为16字节</strong>.</p>
<p>我们先来验证一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F; insert code here...</span><br><span class="line">        NSObject *obj &#x3D; [[NSObject alloc] init];</span><br><span class="line">        NSLog(@&quot;Hello, World! %@&quot;,obj);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 打印语句加个断点。</p>
<img src="/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E9%99%85%E5%8D%A0%E7%94%A8%E5%92%8C%E5%88%86%E9%85%8D%E5%88%B0%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F.png" class title="对象实际占用和分配到内存大小">

<p>lldb中打印得出：对象实际占用的内存大小为8，实际分配的内存大小为16。</p>


<p>lldb查看布情况，可以看出创建的对象后面几个字节全部为 00。</p>
<p>我们可以通过阅读 <code>objc4</code> 的源码来找到答案。通过查看跟踪 <code>obj4</code> 中 <code>alloc</code> 和 <code>allocWithZone</code> 两个函数的实现，会发现这个连个函数都会调用一个 <code>instanceSize</code> 的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="keyword">size_t</span> extraBytes)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">size_t</span> <span class="built_in">size</span> = alignedInstanceSize() + extraBytes;</span><br><span class="line">      <span class="comment">// CF requires all objects be at least 16bytes.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">16</span>) <span class="built_in">size</span> = <span class="number">16</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">size</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面源码中我们看出了答案, 最少会开辟16个字节. 那么为什么非要用 16 个字节来存储 8 个字节的内容呢? 这里简单解释一下 .</p>
<p>其实这里主要是涉及到硬件问题, 因为不同厂商之间需要一套标准化方案来解决不同厂商之间规则不同导致内存读取使用出现不统一的情况.为了解决这种问题而产生的 <strong>字节对齐</strong>.</p>
<p>讲到这里,我还想继续看下 当这个对象包含多个属性时使用内存情况. 以便我们彻底搞明白 OC 对象使用内存情况.</p>
<h4 id="包含其他属性占用内存情况"><a href="#包含其他属性占用内存情况" class="headerlink" title="包含其他属性占用内存情况"></a>包含其他属性占用内存情况</h4><p>创建一个 <code>Person</code> 类,继承与 <code>NSObject</code> , 其包含三个 <code>int</code> 属性。修改main.m 文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic, assign) int age;</span><br><span class="line">@property (nonatomic, assign) int height;</span><br><span class="line">@property (nonatomic, assign) int row;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Person *obj &#x3D; [[Person alloc] init];</span><br><span class="line">        obj.age &#x3D; 4;</span><br><span class="line">        obj.height &#x3D; 5;</span><br><span class="line">        obj.row &#x3D; 6;</span><br><span class="line">        NSLog(@&quot;Hello, World! %@&quot;,obj);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lldb打印对象内存情况如下</p>
<img src="/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%83%85%E5%86%B5.png" class title="对象内存情况">

<p>对象实际占用内存大小为24，实际分配的内存大小为32。</p>
<img src="/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E9%99%85%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F.png" class title="对象实际占用内存大小">

<p>这里就出现一个比较奇怪的现象 , 实际需要内存大小 <strong>24</strong>, 为什么呢 ? 其实这里就是 <strong>结构体内存分配的原理</strong>了.</p>
<blockquote>
<ul>
<li>结构体每个成员相对于结构体首地址的偏移量都是这个成员大小的整数倍，如果有需要，编译器会在成员之间加上填充字节</li>
<li>结构体的总大小为结构体最宽成员大小的整数倍。</li>
<li>结构体变量的首地址能够被其最宽基本类型成员的大小所整除。</li>
<li>对于结构体成员属性中包含结构体变量的复合型结构体，在确定最宽基本类型成员时，应当包括复合类型成员的子成员。但在确定复合类型成员的偏移位置时则是将复合类型作为整体看待。</li>
</ul>
</blockquote>
<p><strong>由于原本结构体 <code>isa</code>指针占用8个 , <code>age</code>属性占用4个, <code>height</code>占用 4个, <code>row</code>属性再占用4个 , 这中间由于满足整除并没有自动偏移补充. 而由于 : 结构体的总大小为结构体最宽成员大小的整数倍 , 而且对线开辟满足 16 字节对齐原则 ( 可以在 libmaclloc 源码查找到 ) , 因此实际总占用内存为24. 而实际开辟则满足对齐标准开辟为 32.</strong></p>
<p>在 <code>libmaclloc</code> 源码 , <code>nano_malloc.c</code> 中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MALLOC_INLINE <span class="keyword">size_t</span></span><br><span class="line">segregated_size_to_fit(<span class="keyword">nanozone_t</span> *nanozone, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> *pKey)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> k, slot_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">size</span>) &#123;</span><br><span class="line">        <span class="built_in">size</span> = NANO_REGIME_QUANTA_SIZE; <span class="comment">// Historical behavior</span></span><br><span class="line">    &#125;</span><br><span class="line">    k = (<span class="built_in">size</span> + NANO_REGIME_QUANTA_SIZE - <span class="number">1</span>) &gt;&gt; SHIFT_NANO_QUANTUM; <span class="comment">// round up and shift for number of quanta</span></span><br><span class="line">    slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM;                            <span class="comment">// multiply by power of two quanta size</span></span><br><span class="line">    *pKey = k - <span class="number">1</span>;                                                    <span class="comment">// Zero-based!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slot_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中NANO_REGIME_QUANTA_SIZE 和 SHIFT_NANO_QUANTUM在nano_zone_common.h中定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT_NANO_QUANTUM        4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NANO_REGIME_QUANTA_SIZE    (1 &lt;&lt; SHIFT_NANO_QUANTUM)    <span class="comment">// 16</span></span></span><br></pre></td></tr></table></figure>

<p>所以16字节对齐算法为：size + (2<sup>^4</sup> - 1) &gt;&gt; 4 &lt;&lt; 4。</p>
<h3 id="总结-只考虑64位"><a href="#总结-只考虑64位" class="headerlink" title="总结 (只考虑64位):"></a>总结 (只考虑<code>64</code>位):</h3><blockquote>
<ul>
<li>OC对象 最少占用 <code>16</code>个字节内存 .</li>
<li>当对象中包含属性, 会按属性占用内存开辟空间. 在结构体内存分配原则下自动偏移和补齐 .</li>
<li>对象最终满足 <code>16</code>字节对齐标准 .</li>
<li>属性最终满足 <code>8</code>字节对齐标准 .</li>
<li>可以通过 #pragma pack() 自定义对齐方式 .</li>
</ul>
</blockquote>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>在2020年WWDC中，Runtime又有了一些更新。详见：<a href="https://developer.apple.com/videos/play/wwdc2020/10163/" target="_blank" rel="noopener" title="标题">2020 – Advancements in the Objective-C runtime</a>主要更新内容如下:</p>
<h3 id="数据结构的变化"><a href="#数据结构的变化" class="headerlink" title="数据结构的变化"></a>数据结构的变化</h3><p>在介绍更新之前，先了解一下二进制类在磁盘中的表示。</p>
<img src="/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B1%BB%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA.png" class title="二进制类在磁盘中的表示">

<p>首先是类对象本身，包含最常访问的信息：指向元类，超类和方法缓存的指针，在类结构之中有指向包含更多数据的结构体<code>class_ro_t</code>的指针，包含了类的名称，方法，协议，实例变量等等编译期确定的信息。</p>
<p>当类被 Runtime 加载之后，类的结构会发生一些变化，在了解这些变化之前，我们需要知道2个概念：</p>
<p><strong>Clean Memory：</strong>加载后不会发生更改的内存块，<code>class_ro_t</code>属于<code>Clean Memory</code>，因为它是只读的。</p>
<p><strong>Dirty Memory：</strong>运行时会进行更改的内存块，类一旦被加载，就会变成<code>Dirty Memory</code>，例如，我们可以在 Runtime 给类动态的添加方法。</p>
<p>这里要明确，<code>Dirty Memory</code>比<code>Clean Memory</code>要昂贵得多。因为它需要更多的内存信息，并且只要进程正在运行，就必须保留它。对于我们来说，越多的<code>Clean Memory</code>显然是更好的，因为它可以节约更多的内存。我们可以通过分离出永不更改的数据部分，将大多数类数据保留为<code>Clean Memory</code>，如何怎么做的呢？</p>
<p>在介绍优化方法之前，我们先来看一下，在类加载之后，类的结构会变成如何呢？</p>
<img src="/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%84.png" class title="类加载之后的结构">

<p>在类加载到 Runtime 中后会被分配用于读取/写入数据的结构体<code>class_rw_t</code>。</p>
<blockquote>
<p><strong>Tips：</strong><code>class_ro_t</code>是只读的，存放的是编译期间就确定的字段信息；而<code>class_rw_t</code>是在 runtime 时才创建的，它会先将<code>class_ro_t</code>的内容拷贝一份，再将类的分类的属性、方法、协议等信息添加进去，之所以要这么设计是因为 Objective-C 是动态语言，你可以在运行时更改它们方法，属性等，并且分类可以在不改变类设计的前提下，将新方法添加到类中。</p>
</blockquote>
<p>事实证明，<code>class_rw_t</code>会占用比<code>class_ro_t</code>占用更多的内存，在 iPhone 中，我们在系统测量了大约 30MB 的这些<code>class_rw_t</code>结构。应该如何优化这些内存呢？通过测量实际设备上的使用情况，我们发现大约 10％ 的类实际会存在动态的更改行为，如动态添加方法，使用 Category 方法等。因此，我们能可以把这部分动态的部分提取出来，我们称之为<code>class_rw_ext_t</code>，所以，结构会变成这个样子。</p>
<img src="/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/%E5%8A%A8%E6%80%81%E7%9A%84%E9%83%A8%E5%88%86%E6%8F%90%E5%8F%96%E4%B8%BAclass_rw_ext_t%E5%90%8E%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84.png" class title="动态的部分提取为class_rw_ext_t后类的结构">

<p>经过拆分，可以把 90% 的类优化为<code>Clean Memory</code>，在系统层面，取得效果是节省了大约 14MB 的内存，使内存可用于更有效的用途。</p>
<blockquote>
<p><strong>Tips：</strong><code>head xxxxx | egrep &#39;class_rw|COUNT’</code> 你可以使用此命令来查看 <code>class_rw_t</code> 消耗的内存。xxxx可以替换为需要测量的 App 名称。如：<code>head Mail | egrep &#39;class_rw|COUNT’\&#39;</code>查看 Mail 应用的使用情况。</p>
</blockquote>
<h3 id="Tagged-pointer格式的变化"><a href="#Tagged-pointer格式的变化" class="headerlink" title="Tagged pointer格式的变化"></a>Tagged pointer格式的变化</h3><p>相比于之前的Tagged pointer，在 ARM64 中格式有些变化。</p>


<p>不同于以往，苹果使用最高位代表 Tagged Pointer 标识位，低位 3 位标识 Tagged Pointer 的类型，接下去的位来表示包含的数据（可能包含扩展类型字段），为什么我们使用高位指示 ARM上 的 Tagged Pointer，而不是像 Intel 一样使用低位标记？</p>
<p>它实际是对 objc_msgSend 的微小优化。我们希望 msgSend 中最常用的路径尽可能快。最常用的路径表示普通对象指针。我们有两种不常见的情况：Tagged Pointer 指针和 nil。事实证明，当我们使用最高位时，可以通过一次比较来检查两者。与分别检查 nil 和 Tagged Pointer 指针相比，这会为 msgSend 中的节省了条件分支。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="判断类有没有初始化"><a href="#判断类有没有初始化" class="headerlink" title="判断类有没有初始化"></a>判断类有没有初始化</h3><p>很多技术博客里都提到了，ObjC类的meta class里，自带了一个标记自己有没有初始化过的flag，即class_rw_t–&gt;flags里的RW_INITIALIZED。objc_class类中有提供了封装的函数供外部快速获取该flag值。调用相关代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc_class 代码片段</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInitialized</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// NOT identical to this-&gt;ISA when this is a metaclass</span></span><br><span class="line">    <span class="function">Class <span class="title">getMeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMetaClass()) <span class="keyword">return</span> (Class)<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>-&gt;ISA();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">        <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可惜的是，这些方法对我们app来说，是不可见的，没办法直接调用。所以如果想要在运行过程中获取类的初始化状态，只能另想办法。从方法的调用情况看到方法的过程大概分为4步：</p>
<ol>
<li>我们要先找到类的meta class。</li>
<li>获取objc_class的成员变量bits（class_data_bits_t结构体）</li>
<li>调用class_data_bits_t结构体的data()方法，对结构体的bits属性进行位运算，获取class_rw_t结构体</li>
<li>最后获取class_rw_t结构体的成员变量flags并进行位运算</li>
</ol>
<p>因为runtime源代码是用C++来写的，所以我们可以通过偏移地址获取到用到的变量，直接用指针来搞定问题。</p>
<p>针对第一步，获取类的meta class，是个runtime里可见的方法，直接调用objc_getMetaClass()方法就能拿到。</p>
<p>第二步获取objc_class的成员变量bits。回到<code>objc_class</code>的头部几行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">  objc_class(<span class="keyword">const</span> objc_class&amp;) = <span class="keyword">delete</span>;<span class="comment">// 0 bytes</span></span><br><span class="line">  objc_class(objc_class&amp;&amp;) = <span class="keyword">delete</span>;<span class="comment">// 0 bytes</span></span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> objc_class&amp;) = <span class="keyword">delete</span>;<span class="comment">// 0 bytes</span></span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(objc_class&amp;&amp;) = <span class="keyword">delete</span>;<span class="comment">// 0 bytes</span></span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass; <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先objc_class 继承至 objc_object，对于子结构体来说，是需要继承父结构体的成员变量的。runtime源代码是用C++来写的，函数都不会占用类meta信息（或者说实例）的内存地址，只有成员变量会占用地址。objc_object父结构如前表述，仅包含<code>isa</code>这个成员变量，占用类实例的头8个bytes，也就是64位CPU的一个指针的长度；而下面的一堆方法，在实例里面一点内存都不占用。然后看完整个结构体，只有这么一个成员变量，所以总长度也就8个bytes。</p>
<p><code>objc_class</code>内前面几行那几个函数禁用语句，不会产生内存地址的偏移，先不管它们。</p>
<p><code>superclass</code>作为一个指针（对，<code>Class</code>类型实际上是一个指向结构体的指针），长度为8 bytes。</p>
<p>接下来是<code>cache_t</code>类型的变量<code>cache</code>，它占用了多少bytes我们就要展开看看了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;  <span class="comment">// x86_64 &amp; arm64 asm are less efficient with 16-bits</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">mask_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    explicit_atomic&lt;<span class="keyword">uintptr_t</span>&gt; _bucketsAndMaybeMask;<span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            explicit_atomic&lt;<span class="keyword">mask_t</span>&gt;    _maybeMask;<span class="comment">//4 bytes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line">            <span class="keyword">uint16_t</span>                   _flags;<span class="comment">//2 bytes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">uint16_t</span>                   _occupied;<span class="comment">//2 bytes</span></span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;<span class="keyword">preopt_cache_t</span> *&gt; _originalPreoptCache;<span class="comment">// 8 bytes</span></span><br><span class="line">    &#125;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先说一下<code>explicit_atomic&lt;T&gt;</code>，它只是负责把模板里的类型包成atomic的，不会对变量占用的内存长度产生影响。</p>
<p>然后要说一下<code>union</code>，C++的老朋友了，联合体内部的成员取最长的一个内存长度，就是联合体的内存长度，这里就是8 bytes。</p>
<p><code>mask_t</code>的定义在文件头就能找到，其实在64位CPU下就是一个<code>uint32_t</code>而已。</p>
<p>基于上面的介绍，可以推断出整个<code>cache_t</code>结构体的长度就是8 bytes + 8 bytes = 16 bytes。</p>
<p>综上，bits 偏移量为：父结构体objc_object的isa成员变量（8 bytes）+ objc_class结构体的superclass成员变量（8 bytes）+ objc_class结构体的cache成员变量（16 bytes） = 32 bytes。</p>
<p>第三步、第四步，很凑巧的是<code>bits</code>和<code>flags</code>都是两个结构体里的第一个成员变量，那么我们就不需要继续计算偏移了，只需要关注<code>data()</code>函数的具体取值方法即可。</p>
<p>最终我们从一个Class类型，取到它有没有被初始化过的代码大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class metaCls &#x3D; objc_getMetaClass(class_getName(cls));</span><br><span class="line">if (metaCls) &#123;</span><br><span class="line">    uint64_t *bits &#x3D; (__bridge void *)metaCls + 32; &#x2F;&#x2F; 在 metaClass 基地址上加上 32 bits 的偏移</span><br><span class="line">    uint32_t *data &#x3D; (uint32_t *)(*bits &amp; FAST_DATA_MASK); &#x2F;&#x2F; 模拟 data() 函数取值</span><br><span class="line">    return (*data &amp; RW_INITIALIZED); &#x2F;&#x2F; 模拟 isInitialized() 函数最后一步与操作</span><br><span class="line">&#125;</span><br><span class="line">return NO;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/08/18/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/" rel="prev" title="刨根问底」之Runtime消息发送和转发">
      <i class="fa fa-chevron-left"></i> 刨根问底」之Runtime消息发送和转发
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/10/01/%E3%80%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8B%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F/" rel="next" title="「性能优化」之包体大小">
      「性能优化」之包体大小 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#runtime简介"><span class="nav-number">1.</span> <span class="nav-text">runtime简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从代码到可执行文件的过程"><span class="nav-number">1.1.</span> <span class="nav-text">从代码到可执行文件的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runtime之发送消息（objc-msgSend）"><span class="nav-number">1.2.</span> <span class="nav-text">Runtime之发送消息（objc_msgSend）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime-基础数据结构"><span class="nav-number">2.</span> <span class="nav-text">Runtime 基础数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SEL"><span class="nav-number">2.1.</span> <span class="nav-text">SEL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#id"><span class="nav-number">2.2.</span> <span class="nav-text">id</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isa-t"><span class="nav-number">2.3.</span> <span class="nav-text">isa_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class"><span class="nav-number">2.4.</span> <span class="nav-text">Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache-t"><span class="nav-number">2.5.</span> <span class="nav-text">cache_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-data-bits-t"><span class="nav-number">2.6.</span> <span class="nav-text">class_data_bits_t</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class-rw-t"><span class="nav-number">2.6.1.</span> <span class="nav-text">class_rw_t</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-ro-t"><span class="nav-number">2.7.</span> <span class="nav-text">class_ro_t</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#realizeClass"><span class="nav-number">2.7.1.</span> <span class="nav-text">realizeClass</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ivar"><span class="nav-number">3.</span> <span class="nav-text">Ivar</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Property"><span class="nav-number">4.</span> <span class="nav-text">Property</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method"><span class="nav-number">4.1.</span> <span class="nav-text">Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Category"><span class="nav-number">4.2.</span> <span class="nav-text">Category</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protocol-t"><span class="nav-number">4.3.</span> <span class="nav-text">protocol_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IMP"><span class="nav-number">4.4.</span> <span class="nav-text">IMP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓展"><span class="nav-number">6.</span> <span class="nav-text">拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tagged-Pointer"><span class="nav-number">6.1.</span> <span class="nav-text">Tagged Pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OC对象占用的大小"><span class="nav-number">6.2.</span> <span class="nav-text">OC对象占用的大小</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始OC对象占用内存"><span class="nav-number">6.2.1.</span> <span class="nav-text">初始OC对象占用内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包含其他属性占用内存情况"><span class="nav-number">6.2.2.</span> <span class="nav-text">包含其他属性占用内存情况</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-只考虑64位"><span class="nav-number">6.3.</span> <span class="nav-text">总结 (只考虑64位):</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新"><span class="nav-number">7.</span> <span class="nav-text">更新</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构的变化"><span class="nav-number">7.1.</span> <span class="nav-text">数据结构的变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tagged-pointer格式的变化"><span class="nav-number">7.2.</span> <span class="nav-text">Tagged pointer格式的变化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用"><span class="nav-number">8.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#判断类有没有初始化"><span class="nav-number">8.1.</span> <span class="nav-text">判断类有没有初始化</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">和僧</p>
  <div class="site-description" itemprop="description">技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">和僧</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
