<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heseng91.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="应用程序内存管理是在程序运行时分配内存，使用它并在使用完后释放它的过程。编写良好的程序将使用尽可能少的内存。在 Objective-C 中，它也可以看作是在许多数据和代码之间分配有限内存资源所有权的一种方式。掌握内存管理知识，我们就可以很好地管理对象生命周期并在不再需要它们时释放它们，从而管理应用程序的内存。本文从内存管理概念开始，介绍内存管理的思想、方式和系统实现，阅读本文后你将对内存管理有一个">
<meta property="og:type" content="article">
<meta property="og:title" content="「刨根问底」之内存管理">
<meta property="og:url" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="和僧">
<meta property="og:description" content="应用程序内存管理是在程序运行时分配内存，使用它并在使用完后释放它的过程。编写良好的程序将使用尽可能少的内存。在 Objective-C 中，它也可以看作是在许多数据和代码之间分配有限内存资源所有权的一种方式。掌握内存管理知识，我们就可以很好地管理对象生命周期并在不再需要它们时释放它们，从而管理应用程序的内存。本文从内存管理概念开始，介绍内存管理的思想、方式和系统实现，阅读本文后你将对内存管理有一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%8A%9E%E5%85%AC%E5%AE%A4%E7%85%A7%E6%98%8E.png">
<meta property="og:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%8A%9E%E5%85%AC%E5%AE%A4%E7%85%A7%E6%98%8E%E9%97%AE%E9%A2%98.png">
<meta property="og:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%8A%9E%E5%85%AC%E5%AE%A4%E7%85%A7%E6%98%8E%E7%9A%84%E7%AE%A1%E7%90%86.png">
<meta property="og:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png">
<meta property="og:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/memory_management_2x.png">
<meta property="og:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA.png">
<meta property="og:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%AB%98%E5%9C%B0%E4%BD%8D%E6%80%BB%E6%98%AF0.png">
<meta property="og:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%BD%8E%E4%BD%8D%E8%AE%BE%E7%BD%AE%E4%B8%BA1.png">
<meta property="og:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/alloc%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8%E8%B0%83%E7%94%A8%E6%A0%88.png">
<meta property="og:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/autorelease%E5%92%8Crelease%E5%8C%BA%E5%88%AB.png">
<meta property="og:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/next%E6%8C%87%E9%92%88.png">
<meta property="og:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%93%A8%E5%85%B5%E5%AF%B9%E8%B1%A1.png">
<meta property="og:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/AutoreleasePoolPage%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png">
<meta property="article:published_time" content="2018-08-02T00:02:00.000Z">
<meta property="article:modified_time" content="2022-11-02T16:43:49.517Z">
<meta property="article:author" content="和僧">
<meta property="article:tag" content="和僧-技术博客，技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%8A%9E%E5%85%AC%E5%AE%A4%E7%85%A7%E6%98%8E.png">

<link rel="canonical" href="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>「刨根问底」之内存管理 | 和僧</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">和僧</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="和僧">
      <meta itemprop="description" content="技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和僧">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          「刨根问底」之内存管理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-02 08:02:00" itemprop="dateCreated datePublished" datetime="2018-08-02T08:02:00+08:00">2018-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-03 00:43:49" itemprop="dateModified" datetime="2022-11-03T00:43:49+08:00">2022-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/" itemprop="url" rel="index"><span itemprop="name">刨根问底</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>应用程序内存管理是在程序运行时分配内存，使用它并在使用完后释放它的过程。编写良好的程序将使用尽可能少的内存。在 Objective-C 中，它也可以看作是在许多数据和代码之间分配有限内存资源所有权的一种方式。掌握内存管理知识，我们就可以很好地管理对象生命周期并在不再需要它们时释放它们，从而管理应用程序的内存。本文从内存管理概念开始，介绍内存管理的思想、方式和系统实现，阅读本文后你将对内存管理有一个整体认知。</p>
<a id="more"></a>


<h2 id="什么是内存管理"><a href="#什么是内存管理" class="headerlink" title="什么是内存管理"></a>什么是内存管理</h2><p>Objective-C 中的内存管理，也就是引用计数。</p>
<p>引用计数机制可以用开关房间的灯为例来说明。假设办公室里的照明设备只有一个。上班进入办公室的人需要照明，所以要把灯打开。而对于下班离开办公室的人来说，已经不需要照明了，所以要把灯关掉。</p>
<img src="/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%8A%9E%E5%85%AC%E5%AE%A4%E7%85%A7%E6%98%8E.png" class title="办公室照明">

<p>若是很多人上下班，每个人都开灯或者关灯，那么办公室的情况又将如何呢？最早下班的人如果关了灯，那就会像下图那样，办公室里还没走的所有人都将处于一片黑暗之中。</p>
<img src="/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%8A%9E%E5%85%AC%E5%AE%A4%E7%85%A7%E6%98%8E%E9%97%AE%E9%A2%98.png" class title="办公室照明问题">

<p>解决这一问题的办法就是使办公室在还有至少一人的情况下保持开灯状态，而在无人时保持关灯状态。</p>
<p>（1）最早进入办公室的人开灯。 </p>
<p>（2）之后进入办公室的人，需要照明。 </p>
<p>（3）下班离开办公室的人，不需要照明。 </p>
<p>（4）最后离开办公室的人关灯（此时已无人需要照明）。</p>
<p>为判断是否还有人在办公室里，这里导入计数功能来计算 “需要照明的人数”。下面让我们来看看这一功能是如何运作的吧。</p>
<p>（1）第一个人进入办公室，“需要照明的人数” 加 1。计数值从 0 变成了 1，因此要开灯。 </p>
<p>（2）之后每当有人进入办公室，“需要照明的人数” 就加 1。如计数值从 1 变成 2。</p>
<p>（3）每当有人下班离开办公室，“需要照明的人数” 就减 1。如计数值从 2 变成 1。 </p>
<p>（4）最后一个人下班离开办公室，“需要照明的人数” 减 1。计数值从 1 变成了 0，因此要关灯。</p>
<p>这样就能在不需要照明的时候保持关灯状态。办公室中仅有的照明设备得到了很好的管理，如下图所示：</p>
<img src="/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%8A%9E%E5%85%AC%E5%AE%A4%E7%85%A7%E6%98%8E%E7%9A%84%E7%AE%A1%E7%90%86.png" class title="办公室照明的管理">

<p>在 Objective-C 中，“对象” 相当于办公室里的照明设备。在现实世界中办公室里的照明设备只有一个，但在 Objective-C 的世界里，虽然计算机的资源有限，但一台计算机可以同时处理好几个对象。</p>
<p>此外，“对象的使用环境” 相当于上班进入办公室的人。虽然这里的 “环境” 有时也指在运行中的程序代码、变量、变量作用域、对象等，但在概念上就是使用对象的环境。上班进入办公室的人对办公室照明设备发出的动作，与 Objective-C 中的对应关系则如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">对照明设备所做的动作</th>
<th align="left">对 Objective-C 对象所做的动作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">开灯</td>
<td align="left">生成对象</td>
</tr>
<tr>
<td align="left">需要照明</td>
<td align="left">持有对象</td>
</tr>
<tr>
<td align="left">不需要照明</td>
<td align="left">释放对象</td>
</tr>
<tr>
<td align="left">关灯</td>
<td align="left">废弃对象</td>
</tr>
</tbody></table>
<p>使用计数功能计算需要照明的人数，使办公室的照明得到了很好的管理。同样，使用引用计数功能，对象也就能够得到很好的管理，这就是 Objective-C 的内存管理。如下图所示：</p>
<img src="/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png" class title="引用计数的内存管理">

<h2 id="内存管理实现"><a href="#内存管理实现" class="headerlink" title="内存管理实现"></a>内存管理实现</h2><p>看到引用计数，我们便会不自觉地将注意力放到计数上。但这往往会适得其反，因为这样是在从实现细节而非实现目标角度来理解内存管理。其实，更加客观、正确的思考内存管理方式应该是从对象所有权和<strong>对象图</strong>的角度。</p>
<blockquote>
<p><strong>对象图：</strong>在面向对象编程中，一组组的对象根据彼此之间直接或者间接的持有关系形成一个网络。这样的一组组数据就称为对象图。对象图或大或小，或简单或复杂，多种多样。 例如，一个包含单一字符串对象的数组表示一个小而简单的对象图。而持有application对象的一组对象，可能表示的就是一个大的而复杂的对象图，因为application对象会持有多个windows、menus、视图以及其它其他支持对象。有时，您可能希望将对象图(通常只是应用程序中整个对象图的一部分)转换为一种可以保存到文件或传输到另一个进程或机器的形式，然后重新构建。这个过程被称为“归档”。有些对象图可能是不完整的——这些通常被称为<em>部分对象图</em>。 部分对象图包含有占位符对象，这些占位符对象表示图的边界，便于在后续阶段进行填充。例如：包含文件所有者占位符的nib文件。</p>
</blockquote>
<p>内存管理模型是基于对象所有权的。任何对象都可能有一个或多个持有者。只要一个对象至少有一个持有者，它就会继续存在。如果对象没有持有者，运行时系统会自动销毁它。为了确保清楚地知道什么时候持有一个对象，什么时候不持有，苹果设置了以下<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-SW1" target="_blank" rel="noopener">内存管理策略</a>:</p>
<ul>
<li>自己生成的对象，自己持有</li>
<li>非自己生成的对象自己也能持有</li>
<li>不再需要自己持有的对象时释放</li>
<li>非自己持有的对象无法释放</li>
</ul>
<p>上述生成、持有、释放等内存管理的相关操作，实际上不包括在 Objective-C 语言中，而是包含在Cocoa框架中，由NSObject类负责。内存管理的相关方法定义在NSObject协议中。NSObject类还定义了一个方法dealloc，当一个对象被销毁时，它会自动调用。另外，Cocoa还使用了一个简单的命名约定来指示何时应持有一个由方法返回的对象。对象操作与 Objective-C 方法的对应关系如下：</p>
<table>
<thead>
<tr>
<th align="left">对象操作</th>
<th align="left">Objective-C 方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">生成并持有对象</td>
<td align="left">alloc/new/copy/mutableCopy 等方法和以它们驼峰命名开头的方法</td>
</tr>
<tr>
<td align="left">持有对象</td>
<td align="left">retain 方法</td>
</tr>
<tr>
<td align="left">释放对象</td>
<td align="left">release方法</td>
</tr>
<tr>
<td align="left">销毁对象</td>
<td align="left">dealloc方法</td>
</tr>
</tbody></table>
<p>虽然通常在单个对象级别上考虑内存管理，但实际上我们的目标是管理<strong>对象图</strong>，要保证在内存中只保留需要用到的对象，确保没有发生内存泄漏。</p>
<img src="/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/memory_management_2x.png" class title="memory_management_2x">

<p>Objective-C 在iOS中提供了两种内存管理方法：MRC 和 ARC。MRC时期，iOS 开发需要通过跟踪自己持有的对象来显式管理内存。这是使用一个称为 “引用计数” 的模型来实现的，由 Foundation 框架的 NSObject 类与运行时环境一起提供。为了降低程序崩溃、内存泄露等风险的同时，比较大程度减少开发程序的工作量，苹果在iOS 5时推出了ARC。ARC，全称 Automatic Reference Counting，就是让编译器进行内存管理，这样就无需再次键入retain或release代码。编译器完全清楚目标对象，并能立即释放哪些不再被使用的对象，从而提高应用程序的可预测性，保证程序能流畅运行，速度也将大幅提高。</p>
<h2 id="内存管理源码探究"><a href="#内存管理源码探究" class="headerlink" title="内存管理源码探究"></a>内存管理源码探究</h2><p>上文提到Objective-C 中的内存管理，也就是引用计数管理。下面我们围绕引用计数源码来探究一下内存管理，本次探索基于objc4-756.2，使用Xcode 11.3.1 (11C504)。阅读之前需要对<a href="https://heseng91.github.io/2021/10/31/刨根问底之-Runtime类和对象的定义/">类和对象的结构</a>有所了解。</p>
<h3 id="引用计数存储"><a href="#引用计数存储" class="headerlink" title="引用计数存储"></a>引用计数存储</h3><h4 id="对象引用计数存储"><a href="#对象引用计数存储" class="headerlink" title="对象引用计数存储"></a>对象引用计数存储</h4><p>上文中提到在iOS中，内存管理的相关操作是由NSObject类负责。NSObject在NSObject.h中的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">"-Wobjc-interface-ivars"</span></span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NSObject类只包含一个<code>Class</code>类型成员变量。<code>Class</code> 其实是一个指向 <code>objc_class</code> 结构体的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure>

<p><code>objc_class</code>结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/*...*/</span></span><br><span class="line">  	<span class="comment">// 对象是否重写了以下内存管理方法：retain/release/autorelease/retainCount/_tryRetain/_isdealocation /retainWeakReference/allowsWeakReference</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCustomRR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ! bits.hasDefaultRR();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 设置类或父类以下内存管理方法是否有默认实现：retain/release/autorelease/retainCount/_tryRetain/_isdealocation /retainWeakReference/allowsWeakReference</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHasDefaultRR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(isInitializing());</span><br><span class="line">        bits.setHasDefaultRR();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHasCustomRR</span><span class="params">(<span class="keyword">bool</span> inherited = <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printCustomRR</span><span class="params">(<span class="keyword">bool</span> inherited)</span></span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 对象是否自定义实现了 alloc/allocWithZone: 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCustomAWZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ! bits.hasDefaultAWZ();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 类或父类有默认的 alloc/allocWithZone: 方法实现，信息存储在元类中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHasDefaultAWZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(isInitializing());</span><br><span class="line">        bits.setHasDefaultAWZ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHasCustomAWZ</span><span class="params">(<span class="keyword">bool</span> inherited = <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printCustomAWZ</span><span class="params">(<span class="keyword">bool</span> inherited)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  	<span class="comment">// 类或父类具有有c++ 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCxxCtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// addSubclass() propagates this flag from the superclass.</span></span><br><span class="line">        assert(isRealized());</span><br><span class="line">        <span class="keyword">return</span> bits.hasCxxCtor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHasCxxCtor</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        bits.setHasCxxCtor();</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 类或父类具有有c++ 析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCxxDtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// addSubclass() propagates this flag from the superclass.</span></span><br><span class="line">        assert(isRealized());</span><br><span class="line">        <span class="keyword">return</span> bits.hasCxxDtor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHasCxxDtor</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        bits.setHasCxxDtor();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>objc_class</code>结构体拥有 <code>superclass</code>、<code>cache</code> 和 <code>bits</code>三个成员变量，以及封装了获取和更改bits数据的一些函数、计算等实力大小等的函数。</p>
<p><code>cache</code>成员变量的类型为<code>cache_t</code>，用于对方法调用的性能进行优化。<code>cache_t</code>定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>bucket_t *_buckets</code> 是一个散列表，用来存储 <code>Method</code> 方法列表；<code>_mask</code>：分配用来缓存 bucket 的总数；<code>_occupied</code>：表明目前实际占用的缓存 bucket 的个数。</p>
<p><code>bits</code>是<code>objc_class</code> 中最复杂的，类型为<code>class_data_bits_t</code>，用于存储属性、方法等类的源数据。<code>class_data_bits_t</code>结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getBit</span><span class="params">(<span class="keyword">uintptr_t</span> <span class="built_in">bit</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; <span class="built_in">bit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>bits</code> 在内存中每个位的含义定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Values for class_rw_t-&gt;flags or class_t-&gt;bits</span></span><br><span class="line"><span class="comment">// These flags are optimized for retain/release and alloc/dealloc</span></span><br><span class="line"><span class="comment">// 64-bit stores more of them in class_t-&gt;bits to reduce pointer indirection.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__LP64__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class or superclass has .cxx_construct implementation</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_HAS_CXX_CTOR       (1&lt;&lt;18)</span></span><br><span class="line"><span class="comment">// class or superclass has .cxx_destruct implementation</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_HAS_CXX_DTOR       (1&lt;&lt;17)</span></span><br><span class="line"><span class="comment">// class or superclass has default alloc/allocWithZone: implementation</span></span><br><span class="line"><span class="comment">// Note this is is stored in the metaclass.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_HAS_DEFAULT_AWZ    (1&lt;&lt;16)</span></span><br><span class="line"><span class="comment">// class's instances requires raw isa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_REQUIRES_RAW_ISA   (1&lt;&lt;15)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// class or superclass has default retain/release/autorelease/retainCount/</span></span><br><span class="line"><span class="comment">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_HAS_DEFAULT_RR     (1&lt;&lt;14)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class is a Swift class from the pre-stable Swift ABI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT_LEGACY  (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// class is a Swift class from the stable Swift ABI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT_STABLE  (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="comment">// data pointer</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK        0xfffffffcUL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 1</span></span><br><span class="line"><span class="comment">// Leaks-compatible version that steals low bits only.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class or superclass has .cxx_construct implementation</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_HAS_CXX_CTOR       (1&lt;&lt;18)</span></span><br><span class="line"><span class="comment">// class or superclass has .cxx_destruct implementation</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_HAS_CXX_DTOR       (1&lt;&lt;17)</span></span><br><span class="line"><span class="comment">// class or superclass has default alloc/allocWithZone: implementation</span></span><br><span class="line"><span class="comment">// Note this is is stored in the metaclass.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_HAS_DEFAULT_AWZ    (1&lt;&lt;16)</span></span><br><span class="line"><span class="comment">// class's instances requires raw isa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_REQUIRES_RAW_ISA   (1&lt;&lt;15)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class is a Swift class from the pre-stable Swift ABI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT_LEGACY    (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// class is a Swift class from the stable Swift ABI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT_STABLE    (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="comment">// class or superclass has default retain/release/autorelease/retainCount/</span></span><br><span class="line"><span class="comment">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;2)</span></span><br><span class="line"><span class="comment">// data pointer</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// Leaks-incompatible version that steals lots of bits.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class is a Swift class from the pre-stable Swift ABI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT_LEGACY    (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// class is a Swift class from the stable Swift ABI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT_STABLE    (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="comment">// summary bit for fast alloc path: !hasCxxCtor and </span></span><br><span class="line"><span class="comment">//   !instancesRequireRawIsa and instanceSize fits into shiftedSize</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_ALLOC              (1UL&lt;&lt;2)</span></span><br><span class="line"><span class="comment">// data pointer</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br><span class="line"><span class="comment">// class or superclass has .cxx_construct implementation</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_CXX_CTOR       (1UL&lt;&lt;47)</span></span><br><span class="line"><span class="comment">// class or superclass has default alloc/allocWithZone: implementation</span></span><br><span class="line"><span class="comment">// Note this is is stored in the metaclass.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_DEFAULT_AWZ    (1UL&lt;&lt;48)</span></span><br><span class="line"><span class="comment">// class or superclass has default retain/release/autorelease/retainCount/</span></span><br><span class="line"><span class="comment">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;49)</span></span><br><span class="line"><span class="comment">// class's instances requires raw isa</span></span><br><span class="line"><span class="comment">//   This bit is aligned with isa_t-&gt;hasCxxDtor to save an instruction.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;50)</span></span><br><span class="line"><span class="comment">// class or superclass has .cxx_destruct implementation</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_CXX_DTOR       (1UL&lt;&lt;51)</span></span><br><span class="line"><span class="comment">// instance size in units of 16 bytes</span></span><br><span class="line"><span class="comment">//   or 0 if the instance size is too big in this field</span></span><br><span class="line"><span class="comment">//   This field must be LAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_SHIFTED_SIZE_SHIFT 52</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FAST_ALLOC means</span></span><br><span class="line"><span class="comment">//   FAST_HAS_CXX_CTOR is set</span></span><br><span class="line"><span class="comment">//   FAST_REQUIRES_RAW_ISA is not set</span></span><br><span class="line"><span class="comment">//   FAST_SHIFTED_SIZE is not zero</span></span><br><span class="line"><span class="comment">// FAST_ALLOC does NOT check FAST_HAS_DEFAULT_AWZ because that </span></span><br><span class="line"><span class="comment">// bit is stored on the metaclass.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_ALLOC_MASK  (FAST_HAS_CXX_CTOR | FAST_REQUIRES_RAW_ISA)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_ALLOC_VALUE (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这里面除了 <code>FAST_DATA_MASK</code> 是用一段空间存储数据外，其他宏都是只用 1 bit 存储 bool 值。<code>class_data_bits_t</code> 提供了三个方法用于位操作：<code>getBit</code>, <code>setBits</code> 和 <code>clearBits</code>，对应到存储 bool 值的掩码也有封装函数，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCxxCtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBit(FAST_HAS_CXX_CTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHasCxxCtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setBits(FAST_HAS_CXX_CTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objc_class</code>结构体继承至 <code>object_object</code>， <code>object_object</code>定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objc_object</code> 结构体包含一个 <code>isa</code> 指针，类型为 <code>isa_t</code> 联合体。根据 <code>isa</code> 就可以顺藤摸瓜找到对象所属的类。 <code>isa_t</code> 类型的共用体（union），在objc-private.h 文件中定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 <code>ISA_BITFIELD</code>在 isa.h文件中定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_PACKED_ISA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// extra_rc must be the MSB-most field (so it matches carry/overflow flags)</span></span><br><span class="line">    <span class="comment">// nonpointer must be the LSB (fixme or get rid of it)</span></span><br><span class="line">    <span class="comment">// shiftcls must occupy the same bits that a real class pointer would</span></span><br><span class="line">    <span class="comment">// bits + RC_ONE is equivalent to extra_rc + 1</span></span><br><span class="line">    <span class="comment">// RC_HALF is the high bit of extra_rc (i.e. half of its range)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// future expansion:</span></span><br><span class="line">    <span class="comment">// uintptr_t fast_rr : 1;     // no r/r overrides</span></span><br><span class="line">    <span class="comment">// uintptr_t lock : 2;        // lock for atomic property, @synch</span></span><br><span class="line">    <span class="comment">// uintptr_t extraBytes : 1;  // allocated with extra bytes</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                        \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;56)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">error</span> unknown architecture for packed isa</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>SUPPORT_PACKED_ISA</code> 用于标记是否支持优化的 <code>isa</code> 指针，其字面含义意思是 <code>isa</code> 的内容不再是类的指针了，而是包含了更多信息，比如引用计数，析构状态，被其他 weak 变量引用情况。判断方法也是根据设备类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define SUPPORT_PACKED_ISA=1 on platforms that store the class in the isa </span></span><br><span class="line"><span class="comment">// field as a maskable pointer with other data around it.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (!__LP64__  ||  TARGET_OS_WIN32  ||  \</span></span><br><span class="line">     (TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_IOSMAC))</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_PACKED_ISA 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_PACKED_ISA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>综合看来目前只有 arm64 架构的设备支持，下面列出了 <code>isa</code> 指针中变量对应的含义：</p>
<table>
<thead>
<tr>
<th align="left">变量名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nonpointer</td>
<td align="left">0 表示普通的 <code>isa</code> 指针，1 表示使用优化，存储引用计数</td>
</tr>
<tr>
<td align="left">has_assoc</td>
<td align="left">表示该对象是否包含 associated object，如果没有，则析构时会更快</td>
</tr>
<tr>
<td align="left">has_cxx_dtor</td>
<td align="left">表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快</td>
</tr>
<tr>
<td align="left">shiftcls</td>
<td align="left">类的指针</td>
</tr>
<tr>
<td align="left">magic</td>
<td align="left">固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。</td>
</tr>
<tr>
<td align="left">weakly_referenced</td>
<td align="left">表示该对象是否有过 <code>weak</code> 对象，如果没有，则析构时更快</td>
</tr>
<tr>
<td align="left">deallocating</td>
<td align="left">表示该对象是否正在析构</td>
</tr>
<tr>
<td align="left">has_sidetable_rc</td>
<td align="left">表示该对象的引用计数值是否过大无法存储在 <code>isa</code> 指针</td>
</tr>
<tr>
<td align="left">extra_rc</td>
<td align="left">存储引用计数值减一后的结果</td>
</tr>
</tbody></table>
<p>在 64 位环境下，优化的 <code>isa</code> 指针并不是就一定会存储引用计数，毕竟用 19bit （iOS 系统）保存引用计数不一定够。需要注意的是这 19 位保存的是<strong>引用计数的值减一</strong>。<code>has_sidetable_rc</code> 的值如果为 1，那么引用计数会存储在一个叫 <code>SideTable</code> 的类的属性中。<code>SideTable</code> 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;<span class="comment">//保证原子操作的自选锁</span></span><br><span class="line">    RefcountMap refcnts;<span class="comment">//引用计数表，保存引用计数的散列表</span></span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;<span class="comment">//保存 weak 引用的全局散列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>SideTable</code> 用于管理引用计数表和 <code>weak</code> 表，并使用 <code>spinlock_lock</code> 自旋锁来防止操作表结构时可能的竞态条件。它用一个 64*128 大小的 <code>uint8_t</code> 静态数组作为 buffer 来保存所有的 <code>SideTable</code> 实例。<code>RefcountMap</code>定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,<span class="keyword">size_t</span>,<span class="literal">true</span>&gt; RefcountMap;</span><br></pre></td></tr></table></figure>

<p> <code>DenseMap</code> 类中包含好多映射实例到其引用计数的键值对，并支持用 <code>DenseMapIterator</code> 迭代器快速查找遍历这些键值对。键的类型为 <code>DisguisedPtr&lt;objc_object&gt;</code>，<code>DisguisedPtr</code> 类是对 <code>objc_object *</code> 指针及其一些操作进行的封装，目的就是为了让它给人看起来不会有内存泄露的样子，其内容可以理解为对象的内存地址；值的类型为 <code>size_t</code>，<code>size_t</code> 是为了方便系统之间的移植而定义的，在32位系统上定义为 <code>unsigned int</code>，在64位系统上定义为 <code>unsigned long</code>。其实这里保存的值也是等于<strong>引用计数减一</strong>。使用散列表保存引用计数的设计很好，即使出现故障导致对象的内存块损坏，只要引用计数表没有被破坏，依然可以顺藤摸瓜找到内存块的位置。</p>
<h4 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h4><p><code>isa</code> 这里还涉及到 Tagged Pointer 等概念。因为 <code>isa_t</code> 使用 <code>union</code> 实现，所以可能表示多种形态，既可以当成是指针，也可以存储标志位。</p>
<p>Tagged Pointer 是一种特殊标记的对象，Tagged Pointer 通过在其最后一个 bit 位设置为特殊标记位，并且把数据直接保存在指针本身中。Tagged Pointer 是一个”伪”对象，使用 Tagged Pointer 有 3 倍的访问速度提升，100 倍的创建、销毁速度提升。</p>
<p><strong>Tips：</strong><a href="https://developer.apple.com/videos/play/wwdc2013/404/" target="_blank" rel="noopener">Advances in Objective-C</a></p>
<p>在我们查看对象指针时，在 64 位系统中，我们会看到 16 进制地址如<code>0x00000001003041e0</code>，我们把它转换为二进制表示如下图</p>
<img src="/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA.png" class title="对象指针二进制表示">

<p>在 64 位系统中，我们有 64 位可以表示一个对象指针，但是我们通常没有真正使用到所有这些位。由于内存对齐要求的存在，低位始终为0，对象必须始终位于指针大小倍数的地址中。由于地址空间有限，所以高位也始终为0。所以实际上我们只在一个真正的对象指针中使用了中间的这些位，而不会用到用到2^64，这些高位和低位总是0。</p>
<img src="/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E9%AB%98%E5%9C%B0%E4%BD%8D%E6%80%BB%E6%98%AF0.png" class title="对象指针二进制表示高地位总是0">

<p>苹果从这些始终为0的位中选择了低位并把它设置为1。以标识这不是一个真正的对象指针，然后就可以给其他位赋予一些其他的意义，苹果称这种指针为tagged pointer。</p>
<img src="/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%BD%8E%E4%BD%8D%E8%AE%BE%E7%BD%AE%E4%B8%BA1.png" class title="对象指针二进制表示低位设置为1">

<p>例如：NSNumber指针，苹果在其它位中塞入的是一个数值。（PS：这些值实际上是通过与进程启动时初始化的随机值相结合而被混淆的）。</p>
<p>在设置为 1 表示为 Tagged Pointer 对象之后，在最低位之后的 3 位，苹果给他赋予类型意义，由于只有 3 位，所以它可以表示 7 种数据类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">OBJC_TAG_NSDate            = <span class="number">6</span>, </span><br><span class="line">OBJC_TAG_7                 = <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>在剩余的字段中，我们可以赋予他所包含的数据。在 Intel 中，我们 Tagged Pointer 对象的表示如下：</p>


<p><code>OBJC_TAG_7</code>类型的 Tagged Pointer 是个例外，它可以将接下来后 8 位作为它的扩展类型字段，基于此我们可以多支持 256 中类型的 Tagged Pointer，如 UIColors 或 NSIndexSets 之类的对象。</p>


<p>对象如果支持使用 TaggedPointer，苹果会直接将其指针值作为引用计数返回。</p>
<h3 id="获取引用计数"><a href="#获取引用计数" class="headerlink" title="获取引用计数"></a>获取引用计数</h3><p>在非 ARC 环境可以使用 <code>retainCount</code> 方法获取某个对象的引用计数，其会调用 <code>objc_object</code> 的 <code>rootRetainCount()</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> ((id)self)-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ARC 时代除了使用 Core Foundation 库的 <code>CFGetRetainCount()</code> 方法，也可以使用 Runtime 的 <code>_objc_rootRetainCount(id obj)</code> 方法来获取引用计数，此时需要引入 <code>&lt;objc/runtime.h&gt;</code> 头文件。这个函数也是调用 <code>objc_object</code> 的 <code>rootRetainCount()</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">uintptr_t</span> </span><br><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">// 如果是 tagged pointer，直接返回 this</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)<span class="keyword">this</span>;</span><br><span class="line">		<span class="comment">// sidetable加锁</span></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    <span class="comment">// 获取 isa </span></span><br><span class="line">    <span class="keyword">isa_t</span> bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">    <span class="comment">// 如果 isa 是 nonpointer</span></span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;</span><br><span class="line">      	<span class="comment">// 获取extra_rc中保存的引用计数并+1</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> rc = <span class="number">1</span> + bits.extra_rc;</span><br><span class="line">      	<span class="comment">// 如果sidetable中存储有对象的引用计数值</span></span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">          	<span class="comment">// 获取sidetable中保存的引用计数值并和前面获取到的引用计数相加</span></span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// sidetable解锁</span></span><br><span class="line">        sidetable_unlock();</span><br><span class="line">      	<span class="comment">// 返回获取到的引用计数</span></span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// sidetable解锁</span></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">  	<span class="comment">// 从sidetable中查找保存的对象引用计数值+1之后返回</span></span><br><span class="line">    <span class="keyword">return</span> sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rootRetainCount()</code> 方法对引用计数存储逻辑进行了判断，</p>
<ol>
<li><p>如果是 tagged pointer，直接返回对象本身；</p>
<p><code>isTaggedPointer()</code>定义在 <code>objc-object.h</code>文件中，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline bool </span><br><span class="line">objc_object::isTaggedPointer() </span><br><span class="line">&#123;</span><br><span class="line">    return _objc_isTaggedPointer(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法只是调用了<code>_objc_isTaggedPointer()</code>方法，对对象指针进行位运算，获取标识位的值并返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline bool </span><br><span class="line">_objc_isTaggedPointer(const void * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) &#x3D;&#x3D; _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_OBJC_TAG_MASK</code>定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OBJC_MSB_TAGGED_POINTERS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_INDEX_SHIFT 60</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_SLOT_SHIFT 60</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_PAYLOAD_LSHIFT 4</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_PAYLOAD_RSHIFT 4</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_MASK (0xfUL&lt;&lt;60)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_INDEX_SHIFT 52</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_SLOT_SHIFT 52</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_PAYLOAD_LSHIFT 12</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK 1UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_INDEX_SHIFT 1</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_SLOT_SHIFT 0</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_PAYLOAD_LSHIFT 0</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_PAYLOAD_RSHIFT 4</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_MASK 0xfUL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_INDEX_SHIFT 4</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_SLOT_SHIFT 4</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_PAYLOAD_LSHIFT 0</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其中<code>OBJC_MSB_TAGGED_POINTERS</code>定义如下，根据设备类型不同，标识位的位置也会有所不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__</span></span><br><span class="line">    <span class="comment">// 64-bit Mac - tag bit is LSB</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// Everything else - tag bit is MSB</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>sidetable加锁；</p>
</li>
<li><p>调用 <code>LoadExclusive</code>，获取 isa；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE</span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">LoadExclusive(<span class="keyword">uintptr_t</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __c11_atomic_load((_Atomic(<span class="keyword">uintptr_t</span>) *)src, __ATOMIC_RELAXED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__c11_atomic_load()</code> 函数是以原子方式加载并返回指向的原子变量的当前值<code>obj</code>。该操作是原子读取操作。</p>
</li>
<li><p>调用 <code>ClearExclusive()</code> 在独占访问结束时，清除cpu中本地处理器针对某块内存区域的独占访问标志（核中的某个状态寄存器），以防在未清除时的其他操作，对系统产生影响。对于是否同时清除全局的独占访问标志，需要在设计cpu时的架构师决定。<code>ClearExclusive()</code> 在只针对arm64架构生效，其它架构下为空实现。arm64架构下<code>ClearExclusive()</code> 在函数只是简单调用__builtin_arm_clrex()来实现实际功能；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__ &amp;&amp; !__arm64e__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ClearExclusive(<span class="keyword">uintptr_t</span> *dst __unused)</span><br><span class="line">&#123;</span><br><span class="line">    __builtin_arm_clrex();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ClearExclusive(<span class="keyword">uintptr_t</span> *dst __unused)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是 nonpointer isa，获取前文说的isa_t结构体的 <code>extra_rc</code> 中保存的引用计数并在此基础上 <strong>+1</strong> ，这也就是为什么之前说<strong>引用计数存储的值为实际引用计数减一</strong>。然后判断如果<code>has_sidetable_rc</code> 的值为 1，即引用计数还有部分存储在side table。调用<code>sidetable_getExtraRC_nolock()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> </span><br><span class="line">objc_object::sidetable_getExtraRC_nolock()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer);</span><br><span class="line">    <span class="comment">// 查找到对象所在的SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    <span class="comment">// 在SideTables的引用计数表（RefcountMap）中查找对象的应用计数值</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.<span class="built_in">find</span>(<span class="keyword">this</span>);</span><br><span class="line">  	<span class="comment">// 如果没有查找到，则返回0</span></span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 否则对查找到的值进行向右移位操作获取保存的引用计数并返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取当前实例对应的 <code>SideTable</code> 对象，其 <code>refcnts</code> 属性就是存储引用计数的散列表，这里将其类型简写为 <code>RefcountMap</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,<span class="keyword">size_t</span>,<span class="literal">true</span>&gt; RefcountMap;</span><br></pre></td></tr></table></figure>

<p>然后在引用计数表中用迭代器查找当前实例对应的键值对，获取引用计数值，并和之前获取的引用计数相加，然后返回；</p>
<p>需要注意的是为什么这里把键值对的值做了向右移位操作（<code>it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT</code>）:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The order of these bits is important.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)  <span class="comment">// MSB-ward of weak bit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)  <span class="comment">// MSB-ward of deallocating bit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_SHIFT 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1)</span></span><br></pre></td></tr></table></figure>

<p>可以看出值的第一个 bit 表示该对象是否有过 <code>weak</code> 对象，如果没有，在析构释放内存时可以更快，原因请看后面对象销毁部分；第二个 bit 表示该对象是否正在析构。从第三个 bit 开始才是存储引用计数数值的地方。所以这里要做向右移两位的操作，而对引用计数的 +1 和 -1 可以使用 <code>SIDE_TABLE_RC_ONE</code>，还可以用 <code>SIDE_TABLE_RC_PINNED</code> 来判断是否引用计数值有可能溢出。</p>
</li>
<li><p>sidetable解锁；</p>
</li>
<li><p>调用 <code>sidetable_retainCount()</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">objc_object::sidetable_retainCount()</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 查找到对象所在的SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">		<span class="comment">// 设置的引用计数为1</span></span><br><span class="line">    <span class="keyword">size_t</span> refcnt_result = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// sidetable加锁</span></span><br><span class="line">    table.lock();</span><br><span class="line">  	<span class="comment">// 在SideTables的引用计数表（RefcountMap）中查找对象的应用计数值</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.<span class="built_in">find</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.<span class="built_in">end</span>()) &#123;<span class="comment">// 如果查找到了</span></span><br><span class="line">        <span class="comment">// this is valid for SIDE_TABLE_RC_PINNED too</span></span><br><span class="line">      	<span class="comment">// 将查找到的值进行向右移位操作获取保存的引用计数并+1</span></span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sidetable解锁</span></span><br><span class="line">    table.unlock();</span><br><span class="line">  	<span class="comment">// 返回引用计数</span></span><br><span class="line">    <span class="keyword">return</span> refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑和前面<code>sidetable_getExtraRC_nolock</code>方法类似，获取当前实例对应的 <code>SideTable</code> 对象，其 <code>refcnts</code> 属性就是之前说的存储引用计数的散列表，然后在引用计数表中用迭代器查找当前实例对应的键值对，一样向右移位操作（<code>it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT</code>）获取引用计数值，+1然后返回。所以说<strong>引用计数表存储的值也为实际引用计数减一</strong>。</p>
</li>
</ol>
<h3 id="生成对象"><a href="#生成对象" class="headerlink" title="生成对象"></a>生成对象</h3><p>前文说到，生成对象对应的Objective-C方法为 <code>alloc/new/copy/mutableCopy</code> 等。下面我们逐个解析源码实现。</p>
<h4 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h4><p>在objc4-756.2源码中，新建一个target，在对象alloc的地方下一个端点，调用栈如下图：</p>
<img src="/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/alloc%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8%E8%B0%83%E7%94%A8%E6%A0%88.png" class title="alloc第一次调用调用栈">

<p>通过调用栈发现，<code>[Person alloc]</code>首先会调用<code>objc_alloc()</code>。<code>objc_alloc()</code>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calls [cls alloc].</span></span><br><span class="line">id</span><br><span class="line">objc_alloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">true</span><span class="comment">/*checkNil*/</span>, <span class="literal">false</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法只是调用了<code>callAlloc()</code>，<code>callAlloc()</code>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class="line"><span class="comment">// shortcutting optimizations.</span></span><br><span class="line"><span class="comment">// 调用 [cls alloc] or [cls allocWithZone:nil] 会来到这个函数</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//  如果 (checkNil &amp;&amp; !cls)，直接返回 nil</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__ <span class="comment">// 判断是否是 Objective-C 2.0</span></span></span><br><span class="line">  	<span class="comment">// 如果 cls 没有重写 alloc/allocWithZone: 方法</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        <span class="comment">// No alloc/allocWithZone implementation. Go straight to the allocator.</span></span><br><span class="line">        <span class="comment">// fixme store hasCustomAWZ in the non-meta class and </span></span><br><span class="line">        <span class="comment">// add it to canAllocFast's summary</span></span><br><span class="line">      	<span class="comment">// canAllocFast()函数返回false，所以只会执行else中的代码</span></span><br><span class="line">        <span class="keyword">if</span> (fastpath(cls-&gt;canAllocFast())) &#123; </span><br><span class="line">            <span class="comment">// No ctors, raw isa, etc. Go straight to the metal.</span></span><br><span class="line">            <span class="keyword">bool</span> dtor = cls-&gt;hasCxxDtor();</span><br><span class="line">            id obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, cls-&gt;bits.fastInstanceSize());</span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Has ctor or raw isa or something. Use the slower path.</span></span><br><span class="line">            id obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:nil];</span><br><span class="line">    <span class="keyword">return</span> [cls alloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要以下几步：</p>
<ol>
<li><p>如果入参传入的checkNil为true，且class为nil，则直接return；这里牵扯到 fastpath &amp;&amp; slowpath 的概念。</p>
<blockquote>
<p><strong>fastpath &amp;&amp; slowpath</strong> 是定义在 <code>objc-os.h</code>中的两个宏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastpath(x) (__builtin_expect(bool(x), 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> slowpath(x) (__builtin_expect(bool(x), 0))</span></span><br></pre></td></tr></table></figure>

<p> <code>fastpath</code> 和 <code>slowpath</code> 其实就是为了告诉编译器，<code>if</code> 中的判断条件是大概率 ( fastpath ) 还是小概率 ( slowpath ) 事件，从而让编译器对代码进行优化。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">39</span>;</span><br></pre></td></tr></table></figure>

<p>由于计算机并非一次只读取一条指令，而是读取多条指令，所以在读到 if 语句时也会把 <code>return 1</code>读取进来。如果 x 为 0，那么会重新读取 <code>return 39</code>，重读指令相对来说比较耗时。</p>
<p>如过 x 有非常大的概率是 0，那么 <code>return 1</code>这条指令每次不可避免的会被读取，并且实际上几乎没有机会执行， 造成了不必要的指令重读。当然，最简单的优化就是: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!x) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">39</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>然而对程序员来说，每次都做这样的判断非常不友好，而且容易出错。于是 GCC 提供了一个内置函数 <code>__builtin_expect</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __builtin_expect (<span class="keyword">long</span> EXP, <span class="keyword">long</span> C)</span><br></pre></td></tr></table></figure>

<p>它的返回值就是整个函数的返回值，参数 C 代表预计的值，表示程序员知道 EXP 的值很可能就是 C。比如上文中的例子可以这样写:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(x, <span class="number">0</span>)) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">39</span>;</span><br></pre></td></tr></table></figure>

<p>虽然写法逻辑不变，但是编译器会把汇编代码优化成 <code>if(!x)</code> 的形式。</p>
<p>因此，在苹果定义的两个宏中，<code>fastpath(x)</code>依然返回 x，只是告诉编译器 x 的值一般不为 0，从而编译器可以进行优化。同理，<code>slowpath(x)</code>表示 x 的值很可能为 0，希望编译器进行优化。</p>
</blockquote>
<p>这里因为传入的 checkNil 为false，所以这一步忽略；</p>
</li>
<li><p>接着判断如果没有自己实现 <code>alloc/allocWithZone:</code>方法，接着判断是否 <code>canAllocFast</code> 然后执行相关的初始化方法;</p>
<p>判断有没有自己实现  <code>alloc/allocWithZone:</code> 方法，是通过调用类的结构体 <code>objc_class</code> 中的<code>hasCustomAWZ()</code> 方法判断的。 <code>hasCustomAWZ()</code>方法，定义在 <code>objc-runtime-new.h</code>文件的 <code>objc_class</code> 结构体中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCustomAWZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> ! bits.hasDefaultAWZ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hasDefaultAWZ()</code> 实现如下 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasDefaultAWZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBit(FAST_HAS_DEFAULT_AWZ);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHasDefaultAWZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setBits(FAST_HAS_DEFAULT_AWZ);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHasCustomAWZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    clearBits(FAST_HAS_DEFAULT_AWZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实是位运算获取 <code>bits</code> 中用来标识用户是否自己实现了 <code>alloc/allocWithZone:</code> 的标记位，该标记位保存在<code>metaclass</code>中。</p>
<p>由于类是有懒加载概念的，当第一次给该类发消息之前，类并没有被加载，因此，当类第一次调用 <code>alloc</code>，进入到 <code>hasCustomAWZ</code>时，并没有 <code>DefaultAWZ</code>，所以 <code>hasCustomAWZ</code>则为 <code>true</code>，因此会直接调用 <code>[cls alloc]</code>。</p>
<p><code>[cls alloc]</code> 是通过<a href="https://heseng91.github.io/2021/10/31/刨根问底」之Runtime消息发送和转发/">消息机制</a>触发，向对象发送消息的时候，会判断如果对象没有没有实例化则进行处理：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    <span class="keyword">bool</span> triedResolver = NO;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  判断类是否已经Realized，如果没有，需要先Realized</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">        <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  判断如果入参传入的initialize为true，且类未实例化，需要先实例化</span></span><br><span class="line">    <span class="keyword">if</span> (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">        <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If sel == initialize, class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化之后，Person类的<code>DefaultAWZ</code> 为 <code>true</code> 。</p>
<p><code>alloc</code> 在 NSObject.mm 文件中的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法只是调用了<code>_objc_rootAlloc()</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base class implementation of +alloc. cls is not nil.</span></span><br><span class="line"><span class="comment">// Calls [cls allocWithZone:nil].</span></span><br><span class="line">id</span><br><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_objc_rootAlloc()</code>也只是做了转发，又一次调用<code>callAlloc()</code>，不过入参不同。此时 <code>DefaultAWZ</code> 为 <code>true</code>，那么 <code>hasCustomAWZ</code> 则为 <code>false</code>，因此<code>(fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ()))</code>判断为true。执行if 判断中的代码。首先会判断canAllocFast，相关源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canAllocFast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(!isFuture());</span><br><span class="line">    <span class="keyword">return</span> bits.canAllocFast();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FAST_ALLOC</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">canAllocFast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; FAST_ALLOC;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">canAllocFast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>参见前文中<code>bits</code> 在内存中每个位的含义定义，<code>FAST_ALLOC</code> 的定义是在最后一个 <code>else</code> 中，但前面是 <code>#elif 1</code>，这个条件是恒真的，因此永远不会走到最后一个 <code>else</code>，也就是说，<code>FAST_ALLOC</code>永远不会被赋值，所以<code>canAllocFast</code> 返回 <code>false</code>。因此 <code>callAlloc</code> 会进入上面 <code>else</code> 分之。执行 <code>class_createInstance()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">class_createInstance(Class cls, <span class="keyword">size_t</span> extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>class_createInstance()</code> 调用了 <code>_class_createInstanceFromZone()</code>来真正创建对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* class_createInstance</span></span><br><span class="line"><span class="comment">* fixme</span></span><br><span class="line"><span class="comment">* Locking: none</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __attribute__((always_inline)) </span><br><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, <span class="keyword">size_t</span> extraBytes, <span class="keyword">void</span> *zone, </span><br><span class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>, </span><br><span class="line">                              <span class="keyword">size_t</span> *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 如果入参 cls 为nil，直接返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 校验对象是否已经Realized</span></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class's info bits all at once for performance</span></span><br><span class="line">  	<span class="comment">// 读取 class 中的bits信息中标识信息</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxCtor = cls-&gt;hasCxxCtor();</span><br><span class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    <span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">            obj = (id)malloc_zone_calloc ((<span class="keyword">malloc_zone_t</span> *)zone, <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be </span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span><br><span class="line">        obj = _objc_constructOrFree(obj, cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法包含如下几步：</p>
<ol>
<li><p>判断如果入参 cls 为nil，直接返回nil；</p>
</li>
<li><p>断言校验对象是否已经Realized</p>
<blockquote>
<p><strong>realizeClass：</strong>在某个类初始化之前，<code>objc_class-&gt;data()</code> 返回的指针指向的其实是个 <code>class_ro_t</code> 结构体。等到 <code>static Class realizeClass(Class cls)</code> 静态方法在类第一次初始化时被调用，它会:</p>
<ol>
<li>从 <code>class_data_bits_t</code> 调用 <code>data</code> 方法，将结果从 <code>class_rw_t</code> 强制转换为 <code>class_ro_t</code> 指针</li>
<li>初始化一个 <code>class_rw_t</code> 结构体</li>
<li>设置结构体 <code>ro</code> 的值以及 <code>flag</code></li>
<li>最后设置正确的 <code>data</code>。</li>
</ol>
<p><code>class_rw_t</code> 的内容是可以在运行时被动态修改的，可以说运行时对类的拓展大都是存储在这里的，而 <code>class_ro_t</code> 存储的大多是类在编译时就已经确定的信息。</p>
<p>经过 <code>realizeClass</code> 函数处理的类才是『真正的』类，调用它时不能对类做写操作。</p>
</blockquote>
</li>
<li><p>读取 class 中的bits信息中标识信息，此处<code>hasCxxCtor = false</code>, <code>hasCxxDtor = false</code>, <code>fast = true</code>；</p>
<p><code>hasCxxCtor()</code> 用于获取类或父类是否有c++ 构造函数，相关源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCxxCtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// addSubclass() propagates this flag from the superclass.</span></span><br><span class="line">    assert(isRealized());</span><br><span class="line">    <span class="keyword">return</span> bits.hasCxxCtor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FAST_HAS_CXX_CTOR</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCxxCtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBit(FAST_HAS_CXX_CTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHasCxxCtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setBits(FAST_HAS_CXX_CTOR);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCxxCtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data()-&gt;flags &amp; RW_HAS_CXX_CTOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHasCxxCtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data()-&gt;setFlags(RW_HAS_CXX_CTOR);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>hasCxxDtor()</code>函数用于获取类或父类是否有c++ 析构函数，相关源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCxxDtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// addSubclass() propagates this flag from the superclass.</span></span><br><span class="line">    assert(isRealized());</span><br><span class="line">    <span class="keyword">return</span> bits.hasCxxDtor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FAST_HAS_CXX_DTOR</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCxxDtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBit(FAST_HAS_CXX_DTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHasCxxDtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setBits(FAST_HAS_CXX_DTOR);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCxxDtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data()-&gt;flags &amp; RW_HAS_CXX_DTOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHasCxxDtor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data()-&gt;setFlags(RW_HAS_CXX_DTOR);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>canAllocNonpointer()</code> 用于获取类的实例是否需要raw isa，相关源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canAllocNonpointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(!isFuture());</span><br><span class="line">    <span class="keyword">return</span> !instancesRequireRawIsa();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">instancesRequireRawIsa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bits.instancesRequireRawIsa();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FAST_REQUIRES_RAW_ISA</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">instancesRequireRawIsa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBit(FAST_REQUIRES_RAW_ISA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInstancesRequireRawIsa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setBits(FAST_REQUIRES_RAW_ISA);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">instancesRequireRawIsa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data()-&gt;flags &amp; RW_REQUIRES_RAW_ISA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInstancesRequireRawIsa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data()-&gt;setFlags(RW_REQUIRES_RAW_ISA);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">instancesRequireRawIsa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInstancesRequireRawIsa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其中 <code>SUPPORT_NONPOINTER_ISA</code> 宏定义和含义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa </span></span><br><span class="line"><span class="comment">// field as an index into a class table.</span></span><br><span class="line"><span class="comment">// Note, keep this in sync with any .s files which also define it.</span></span><br><span class="line"><span class="comment">// Be sure to edit objc-abi.h as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_INDEXED_ISA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_INDEXED_ISA 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define SUPPORT_PACKED_ISA=1 on platforms that store the class in the isa </span></span><br><span class="line"><span class="comment">// field as a maskable pointer with other data around it.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (!__LP64__  ||  TARGET_OS_WIN32  ||  \</span></span><br><span class="line">     (TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_IOSMAC))</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_PACKED_ISA 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_PACKED_ISA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define SUPPORT_NONPOINTER_ISA=1 on any platform that may store something</span></span><br><span class="line"><span class="comment">// in the isa field that is not a raw pointer.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !SUPPORT_INDEXED_ISA  &amp;&amp;  !SUPPORT_PACKED_ISA</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_NONPOINTER_ISA 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_NONPOINTER_ISA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果是64位设备，<code>canAllocNonpointer()</code>函数返回值为true。</p>
</li>
<li><p>计算所需开辟内存空间，这里涉及到了经常被提及的<a href="https://baike.baidu.com/item/内存对齐/9537460?fr=aladdin" target="_blank" rel="noopener"> <strong>内存对齐</strong></a>；</p>
<p>一样通过源码来解读一下，<code>objc_class</code> 中有获取实例占用内存大小的函数 <code>instanceSize</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="keyword">size_t</span> extraBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="comment">// CF 要求 all objects 需要最少为 16 bytes.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">16</span>) <span class="built_in">size</span> = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class's ivar size 四舍五入 to a pointer-size boundary.</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">word_align</span><span class="params">(<span class="keyword">uint32_t</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_SHIFT 3UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_MASK 7UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_BITS 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_SHIFT 2UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_MASK 3UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_BITS 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>instanceSize</code>传入参数 <code>extraBytes</code>为 <strong>0</strong>，从上面源码我们首先可以看到，属性<strong>64</strong>位下满足 <strong>8</strong>字节对齐，<strong>32</strong>位下满足 <strong>4</strong>字节对齐。</p>
<p>使用的是 <code>(x + WORD_MASK) &amp; ~WORD_MASK ;</code>。跟位运算左移三位右移三位是同样的效果，类结构体 <code>RO</code>中的信息在编译期就已经确定了 ( <code>data()-&gt;ro-&gt;instanceSize</code>，也就是 <code>unalignedInstanceSize</code>) 。</p>
<p>同时，满足最小 <code>16</code>字节 ( <code>if (size &lt; 16) size = 16</code>) 。</p>
</li>
</ol>
<ol start="5">
<li><p>因为入参zone 为 nil，且如果是64位设备，fast为true，所以 if 判断为true；</p>
<p>执行如下代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj;</span><br><span class="line">if (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">    obj &#x3D; (id)calloc(1, size);</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line">    obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用<code>calloc()</code> 函数在内存中分配1个长度为size的连续空间。<code>calloc()</code> 函数分配的对象内存是按 16 字节对齐标准的。 <code>calloc()</code> 开辟了内存空间后返回一个指向该内存地址的指针。如果内存分配不成功，则直接返回 nil。否则执行<code>initInstanceIsa()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    assert(hasCxxDtor &#x3D;&#x3D; cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法调用<code>initIsa()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">    if (!nonpointer) &#123;</span><br><span class="line">        isa.cls &#x3D; cls;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        assert(!DisableNonpointerIsa);</span><br><span class="line">        assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line">        isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA </span><br><span class="line">        assert(cls-&gt;classArrayIndex() &gt; 0);</span><br><span class="line">        newisa.bits &#x3D; ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">        newisa.indexcls &#x3D; (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line">#else</span><br><span class="line">        newisa.bits &#x3D; ISA_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">        newisa.shiftcls &#x3D; (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This write must be performed in a single store in some cases</span><br><span class="line">        &#x2F;&#x2F; (for example when realizing a class because other threads</span><br><span class="line">        &#x2F;&#x2F; may simultaneously try to use the class).</span><br><span class="line">        &#x2F;&#x2F; fixme use atomics here to guarantee single-store and to</span><br><span class="line">        &#x2F;&#x2F; guarantee memory order w.r.t. the class index table</span><br><span class="line">        &#x2F;&#x2F; ...but not too atomic because we don&#39;t want to hurt instantiation</span><br><span class="line">        isa &#x3D; newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是初始化 <code>isa</code>，并将 <code>isa</code> 的 <code>bits</code> 赋值为 <code>ISA_MAGIC_VALUE</code>。<code>ISA_MAGIC_VALUE</code>初始化了 <code>isa</code> 的 <code>magic</code> 和 <code>nonpointer</code> 字段，并绑定指向 <code>cls</code>：<code>newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3</code>。参考前面 <code>ISA_BITFIELD</code>介绍，前三位分别是<code>nonpointer</code>、<code>has_assoc</code>和<code>has_cxx_dtor</code>，各占一位。后面就是固定位数为<code>shiftcls</code>。在初始化 <code>isa</code> 的时候，并没有对<code>extra_rc</code> 进行操作。也就是说 <code>alloc</code> 方法实际上并没有设置对象的引用计数值为 1。</p>
</li>
</ol>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><h6 id="1、从调用栈中可以看到-NSObject-是有-alloc-类方法的，那么我们外部所写的-NSObject-alloc-为什么不调用-alloc-类方法-反而来到了-objc-alloc-中呢？"><a href="#1、从调用栈中可以看到-NSObject-是有-alloc-类方法的，那么我们外部所写的-NSObject-alloc-为什么不调用-alloc-类方法-反而来到了-objc-alloc-中呢？" class="headerlink" title="1、从调用栈中可以看到 NSObject 是有 alloc 类方法的，那么我们外部所写的 [NSObject alloc] 为什么不调用 alloc 类方法 , 反而来到了 objc_alloc 中呢？"></a>1、从调用栈中可以看到 <code>NSObject</code> 是有 <code>alloc</code> 类方法的，那么我们外部所写的 <code>[NSObject alloc]</code> 为什么不调用 <code>alloc</code> 类方法 , 反而来到了 <code>objc_alloc</code> 中呢？</h6><p>对于OC运行时，入口方法如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法中调用的 <code>map_images</code> 会调用 <code>map_images_nolock</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* map_images</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>map_images_nolock</code> 方法会调用 <code>_read_images</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* map_images_nolock</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">* All class registration and fixups are performed (or deferred pending</span></span><br><span class="line"><span class="comment">* discovery of missing superclasses etc), and +load methods are called.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* info[] is in bottom-up order i.e. libobjc will be earlier in the </span></span><br><span class="line"><span class="comment">* array than any library that links to libobjc.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: loadMethodLock(old) or runtimeLock(new) acquired by map_images.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"objc-file.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"objc-file-old.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">map_images_nolock(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span><br><span class="line">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    firstTime = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>_read_images</code> 方法中会调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _read_images</span></span><br><span class="line"><span class="comment">* Perform initial processing of the headers in the linked </span></span><br><span class="line"><span class="comment">* list beginning with headerList. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Called by: map_images_nolock</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock acquired by map_images</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_FIXUP</span></span><br><span class="line">    <span class="comment">// Fix up old objc_msgSend_fixup call sites</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">message_ref_t</span> *refs = _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintVtables) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"VTABLES: repairing %zu unsupported vtable dispatch "</span></span><br><span class="line">                         <span class="string">"call sites in %s"</span>, count, hi-&gt;fname());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            fixupMessageRef(refs+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">"IMAGE TIMES: fix up objc_msgSend_fixup"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fixupMessageRef</code> 方法中 <code>alloc</code> 对应符号会被设置为 <code>objc_alloc</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* fixupMessageRef</span></span><br><span class="line"><span class="comment">* Repairs an old vtable dispatch call site. </span></span><br><span class="line"><span class="comment">* vtable dispatch itself is not supported.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">fixupMessageRef(<span class="keyword">message_ref_t</span> *msg)</span><br><span class="line">&#123;    </span><br><span class="line">    msg-&gt;sel = sel_registerName((<span class="keyword">const</span> <span class="keyword">char</span> *)msg-&gt;sel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;imp == &amp;objc_msgSend_fixup) &#123; </span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;sel == SEL_alloc) &#123;</span><br><span class="line">            msg-&gt;imp = (IMP)&amp;objc_alloc;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;sel == SEL_allocWithZone) &#123;</span><br><span class="line">            msg-&gt;imp = (IMP)&amp;objc_allocWithZone;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;sel == SEL_retain) &#123;</span><br><span class="line">            msg-&gt;imp = (IMP)&amp;objc_retain;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;sel == SEL_release) &#123;</span><br><span class="line">            msg-&gt;imp = (IMP)&amp;objc_release;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg-&gt;sel == SEL_autorelease) &#123;</span><br><span class="line">            msg-&gt;imp = (IMP)&amp;objc_autorelease;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg-&gt;imp = &amp;objc_msgSend_fixedup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SUPPORT_FIXUP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h6 id="2、为什么-alloc-没有设置引用计数值为-1呢？"><a href="#2、为什么-alloc-没有设置引用计数值为-1呢？" class="headerlink" title="2、为什么 alloc 没有设置引用计数值为 1呢？"></a>2、为什么 alloc 没有设置引用计数值为 1呢？</h6><p>前文说到，引用计数存储的值为实际引用计数减一，在获取对象的引用计数时，会对存储的值进行+1操作，因此这里就不需要设置引用计数值为 1。</p>
<h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><p>alloc 执行完之后，则会调用 <code>init</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Replaced by CF (throws an NSException)</span></span><br><span class="line">+ (id)init &#123;</span><br><span class="line">    <span class="keyword">return</span> (id)self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_objc_rootInit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// In practice, it will be hard to rely on this function.</span></span><br><span class="line">    <span class="comment">// Many classes do not properly chain -init calls.</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>init</code> 默认返回方法调用者。这个设计其实是为了方便工程设计，以便于在初始化对象时做一些初始化或者赋值操作。</p>
<h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)<span class="keyword">new</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [callAlloc(self, <span class="literal">false</span><span class="comment">/*checkNil*/</span>) init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>new</code>相当于 <code>alloc</code> + <code>init</code>。但是使用 <code>new</code> 并不能调用我们所重写的各种 <code>init</code>工厂方法 。</p>
<h4 id="copy-和-mutableCopy"><a href="#copy-和-mutableCopy" class="headerlink" title="copy 和 mutableCopy"></a>copy 和 mutableCopy</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)copy &#123;</span><br><span class="line">    <span class="keyword">return</span> [(id)self copyWithZone:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)mutableCopy &#123;</span><br><span class="line">    <span class="keyword">return</span> [(id)self mutableCopyWithZone:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>copy</code> 和 <code>mutableCopy</code> 都是基于 <code>NSCopying</code> 和 <code>NSMutableCopying</code> 方法约定，分别调用各类自己实现的 <code>copyWithZone:</code> 和 <code>mutableCopyWithZone:</code> 方法。这些方法无论实现方式是深拷贝还是浅拷贝，都会增加引用计数。（有些类的策略是懒拷贝，只增加引用计数但并不真的拷贝，等对象内容发生变化时再拷贝一份出来，比如 <code>NSArray</code>）。</p>
<h3 id="持有对象"><a href="#持有对象" class="headerlink" title="持有对象"></a>持有对象</h3><p>在非 ARC 环境下可以使用 <code>retain</code> 方法对引用计数进行+1操作。上文中提到，runtime 初始化的时候，会进行符号绑定。 <code>retain</code> 对应符号会被设置为 <code>objc_retain</code> 。所以我们从<code>objc_retain</code> 方法开始探究：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* Optimized retain/release/autorelease entrypoints</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line"></span><br><span class="line">__attribute__((aligned(<span class="number">16</span>)))</span><br><span class="line">id </span><br><span class="line">objc_retain(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;retain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OBJC2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// not OBJC2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_retain</span><span class="params">(id obj)</span> </span>&#123; <span class="keyword">return</span> [obj retain]; &#125;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果是<code>__OBJC2__</code>，则调用<code>objc_object::retain</code>函数；否则调用<code>retain</code>方法。<code>objc_object::retain</code>函数实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Equivalent to calling [this retain], with shortcuts if there is no override</span></span><br><span class="line"><span class="keyword">inline</span> id </span><br><span class="line">objc_object::retain()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        <span class="keyword">return</span> rootRetain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((id(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_retain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果以下内存管理方法：<code>retain/release/autorelease/retainCount/_tryRetain/_isdealocation /retainWeakReference/allowsWeakReference</code> 没有被重写，直接调用 <code>objc_object::rootRetain</code>，这是快捷方式；否则调用 <code>retain</code> 方法。</p>
<p> <code>retain</code> 方法实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (id)retain &#123;</span><br><span class="line">    <span class="keyword">return</span> (id)self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">- (id)retain &#123;</span><br><span class="line">    <span class="keyword">return</span> ((id)self)-&gt;rootRetain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是类对象，则直接返回自身，否则调用 <code>rootRetain()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRetain(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法只是做了转发，实际负责修改引用计数的是<code>objc_object::rootRetain()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 如果是 tagged pointer，直接返回 this</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> transcribeToSideTable = <span class="literal">false</span>; <span class="comment">// 是否需要将部分引用计数迁移到 sideTable 中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">isa_t</span> oldisa;</span><br><span class="line">    <span class="keyword">isa_t</span> newisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">      	<span class="comment">// 获取 isa</span></span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">      	<span class="comment">// 如果不是 nonpointer isa</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">          	<span class="comment">// tryRetain == false，调用 sidetable_retain，获取 SideTable 的引用计数表中保存的对象引用计数值，并判断如果没有溢出，更新引用计数值为原来的值+1</span></span><br><span class="line">            <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> sidetable_tryRetain() ? (id)<span class="keyword">this</span> : nil;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sidetable_retain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">uintptr_t</span> carry; <span class="comment">// 用于判断 isa 的 extra_rc 是否溢出</span></span><br><span class="line">      	<span class="comment">// 将 `extra_rc` 中的引用计数值 +1</span></span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line">				</span><br><span class="line">      	<span class="comment">// 如果 extra_rc 溢出</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">          	<span class="comment">// 如果 handleOverflow == false，调用 rootRetain_overflow</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                <span class="keyword">return</span> rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Leave half of the retain counts inline and </span></span><br><span class="line">            <span class="comment">// prepare to copy the other half to the side table.</span></span><br><span class="line">          	<span class="comment">// 保留一半的引用计数在 extra_rc 中</span></span><br><span class="line">            <span class="comment">// 准备把另一半引用计数存储到 Sidetable 中</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>; <span class="comment">// 设置 transcribeToSideTable 为 true</span></span><br><span class="line">            newisa.extra_rc = RC_HALF; <span class="comment">// 设置 extra_rc 的值为 RC_HALF   # define RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>; <span class="comment">// 设置 has_sidetable_rc 为 true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits))); <span class="comment">// 更新 isa.bits 成功</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 如果需要将溢出的引用计数存储到 sidetable 中</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        <span class="comment">// Copy the other half of the retain counts to the side table.</span></span><br><span class="line">        <span class="comment">// 将 `extra_rc` 中引用计数值的一半，迁移至 side table</span></span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>忽略部分细节和不会执行的代码，方法主要包含以下几步：</p>
<p>【第一步】校验如果是 tagged pointer，直接返回 this</p>
<p>【第二步】定义局部变量</p>
<p>【第三步】进入 do-while 循环</p>
<ol>
<li><p>获取isa并保存在局部变量中</p>
</li>
<li><p>如果 isa 不是 nonpointer</p>
<ul>
<li><p>判断如果入参 <code>tryRetain</code> 为false 且 sidetable上锁了，解锁sidetable；</p>
</li>
<li><p>执行 <code>sidetable_retain()</code>，获取 SideTable 的引用计数表中保存的对象引用计数值，并判断如果没有溢出，更新引用计数值为原来的值+1；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  	<span class="comment">// 根据对象查找到SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    <span class="comment">// SideTable 上锁</span></span><br><span class="line">    table.lock();</span><br><span class="line">  	<span class="comment">// 获取 SideTable 的引用计数表中保存的对象引用计数值</span></span><br><span class="line">    <span class="keyword">size_t</span>&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</span><br><span class="line">  	<span class="comment">// 如果获取到的对象引用计数值没有溢出</span></span><br><span class="line">    <span class="keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">      	<span class="comment">// 更新对象引用计数表中对象的引用计数值为原来的值+1</span></span><br><span class="line">        refcntStorage += SIDE_TABLE_RC_ONE; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SideTable 上锁</span></span><br><span class="line">    table.unlock();</span><br><span class="line">		<span class="comment">// 返回对象本身</span></span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>SIDE_TABLE_RC_PINNED</code> 和 <code>SIDE_TABLE_RC_ONE</code>定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The order of these bits is important.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)  <span class="comment">// MSB-ward of weak bit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)  <span class="comment">// MSB-ward of deallocating bit</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_SHIFT 3UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_MASK 7UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_BITS 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_SHIFT 2UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_MASK 3UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_BITS 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>如果 <code>isa</code> 是 <code>nonpointer</code>，就会调用 <code>addc</code> 将 <code>extra_rc</code> 中的引用计数值 +1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">uintptr_t</span> </span><br><span class="line">addc(<span class="keyword">uintptr_t</span> lhs, <span class="keyword">uintptr_t</span> rhs, <span class="keyword">uintptr_t</span> carryin, <span class="keyword">uintptr_t</span> *carryout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __builtin_addcl(lhs, rhs, carryin, carryout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用就是增加引用计数。</p>
</li>
<li><p>判断如果 <code>extra_rc</code> 溢出</p>
<ul>
<li><p>判断如果入参 <code>handleOverflow</code> 为false，就会调用<code>rootRetain_overflow</code>并返回；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE id </span><br><span class="line">objc_object::rootRetain_overflow(<span class="keyword">bool</span> tryRetain)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRetain(tryRetain, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数又调用了 <code>rootRetain</code>，但参数 <code>handleOverflow</code> 传 <code>true</code>。</p>
</li>
<li><p>否则，将 <code>extra_rc</code> 中保存的引用计数值的一半迁移到 <code>sideTable</code>，并更新isa的 <code>extra_rc</code> 和 <code>has_sidetable_rc</code></p>
</li>
</ul>
</li>
<li><p>循环退出条件为 <code>StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)  == true</code>，即成功更新isa.bits</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE</span><br><span class="line">bool</span><br><span class="line">StoreExclusive(uintptr_t *dst, uintptr_t oldvalue, uintptr_t value)</span><br><span class="line">&#123;</span><br><span class="line">    return __c11_atomic_compare_exchange_weak((_Atomic(uintptr_t) *)dst, &amp;oldvalue, value, __ATOMIC_RELAXED, __ATOMIC_RELAXED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__c11_atomic_compare_exchange_weak()</code> 函数是将 <code>dst</code> 与 <code>oldvalue</code>进行原子比较，如果相等，则用<code>value</code>替换 <code>dst</code>（执行读取 - 修改 - 写入操作）。否则，将 <code>dst</code> 的值修改为 <code>oldvalue</code>（进行负载操作） 。返回值：<code>true</code>如果<code>dst</code>等于<code>oldvalue</code>，否则<code>false</code>；</p>
</li>
</ol>
<p>【第四步】如果上一步循环中判断<code>extra_rc</code>中溢出了，则执行 <code>sidetable_addExtraRC_nolock()</code>将 <code>extra_rc</code> 中的引用计数值的一半，迁移至 side table</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move some retain counts to the side table from the isa field.</span></span><br><span class="line"><span class="comment">// Returns true if the object is now pinned.</span></span><br><span class="line"><span class="keyword">bool</span> </span><br><span class="line">objc_object::sidetable_addExtraRC_nolock(<span class="keyword">size_t</span> delta_rc)</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer);</span><br><span class="line">  	<span class="comment">// 根据对象查找到SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">		<span class="comment">// 获取 SideTable 的引用计数表中保存的对象引用计数值</span></span><br><span class="line">    <span class="keyword">size_t</span>&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</span><br><span class="line">    <span class="keyword">size_t</span> oldRefcnt = refcntStorage;</span><br><span class="line">    <span class="comment">// isa-side bits should not be set here</span></span><br><span class="line">    assert((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == <span class="number">0</span>);</span><br><span class="line">    assert((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 如果获取到的对象引用计数值溢出了，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> carry;</span><br><span class="line">  	<span class="comment">// 调用 addc 将前面获取到的 SideTable 的引用计数表中保存的对象引用计数值加上 `extra_rc` 中的引用计数值的一半</span></span><br><span class="line">    <span class="keyword">size_t</span> newRefcnt = </span><br><span class="line">        addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, <span class="number">0</span>, &amp;carry);</span><br><span class="line">  	<span class="comment">// 如果相加之后溢出了</span></span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">      	<span class="comment">// 更新对象引用计数表中对象的引用计数值标记为溢出</span></span><br><span class="line">        refcntStorage =</span><br><span class="line">            SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);</span><br><span class="line">     		 <span class="comment">// 返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 更新对象引用计数表中对象的引用计数值相加之后的值</span></span><br><span class="line">        refcntStorage = newRefcnt;</span><br><span class="line">      	<span class="comment">// 返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>extra_rc</code> 溢出了，就会调用 <code>sidetable_addExtraRC_nolock</code> 将 <code>extra_rc</code> 的一半引用计数转移到 <code>sidetable</code> 中存储，也是调用 <code>addc</code> 对 <code>refcnt</code> 引用计数表进行引用计数增加操作，进行相应容错处理后，更新引用计数表中的引用计数值。</p>
<h3 id="释放对象"><a href="#释放对象" class="headerlink" title="释放对象"></a>释放对象</h3><p>当我们在不需要使用（持有）对象的时候，需要调用一下<code>release</code>方法进行释放。<code>release</code>方法会将对象的引用计数 -1。同样的，由于runtime 初始化的时候，会进行符号绑定。 <code>release</code> 对应符号会被设置为 <code>objc_release</code> 。所以我们从 <code>objc_release</code> 方法开始探究：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* Optimized retain/release/autorelease entrypoints</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">__attribute__((aligned(<span class="number">16</span>)))</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_release(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OBJC2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// not OBJC2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_release</span><span class="params">(id obj)</span> </span>&#123; [obj <span class="built_in">release</span>]; &#125;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果是 <code>__OBJC2__</code>，则调用 <code>objc_object::release</code> 函数；否则调用 <code>release</code> 方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Equivalent to calling [this release], with shortcuts if there is no override</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::<span class="built_in">release</span>()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        rootRelease();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果以下内存管理方法：<code>retain/release/autorelease/retainCount/_tryRetain/_isdealocation /retainWeakReference/allowsWeakReference</code> 没有被重写，直接调用<code>objc_object::rootRelease</code>；否则调用<code>release</code>方法。<code>release</code>方法实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (oneway void)release &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Replaced by ObjectAlloc</span><br><span class="line">- (oneway void)release &#123;</span><br><span class="line">    ((id)self)-&gt;rootRelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是实例对象调用 <code>objc_object::rootRelease()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base release implementation, ignoring overrides.</span></span><br><span class="line"><span class="comment">// Does not call -dealloc.</span></span><br><span class="line"><span class="comment">// Returns true if the object should now be deallocated.</span></span><br><span class="line"><span class="comment">// This does not check isa.fast_rr; if there is an RR override then </span></span><br><span class="line"><span class="comment">// it was already called and it chose to call [super release].</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// handleUnderflow=false is the frameless fast path.</span></span><br><span class="line"><span class="comment">// handleUnderflow=true is the framed slow path including side table borrow</span></span><br><span class="line"><span class="comment">// The code is structured this way to prevent duplication.</span></span><br><span class="line"></span><br><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootRelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rootRelease(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法只是做了转发，实际负责修改引用计数的是<code>objc_object::rootRelease()</code>，该方法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">objc_object::rootRelease(<span class="keyword">bool</span> performDealloc, <span class="keyword">bool</span> handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">// 如果是 tagged pointer，直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">isa_t</span> oldisa;</span><br><span class="line">    <span class="keyword">isa_t</span> newisa;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    		<span class="comment">// 获取 isa</span></span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="comment">// 如果不是 nonpointer isa</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="comment">// 调用 sidetable_release</span></span><br><span class="line">            <span class="keyword">return</span> sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don't check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> carry;</span><br><span class="line">        newisa.bits = subc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc--</span></span><br><span class="line">        <span class="comment">// 如果发现 extra_rc 中的引用计数已经为 0 了</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// don't ClearExclusive()</span></span><br><span class="line">            <span class="comment">// 跳转到 underflow </span></span><br><span class="line">            <span class="keyword">goto</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits))); <span class="comment">// 保存更新后的 isa.bits</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> underflow:</span><br><span class="line">    <span class="comment">// newisa.extra_rc-- underflowed: borrow from side table or deallocate</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// abandon newisa to undo the decrement</span></span><br><span class="line">    <span class="comment">// 如果引用计数为0，丢弃对extra_rc--操作</span></span><br><span class="line">    newisa = oldisa;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果 isa 的 has_sidetable_rc 字段值为 1</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.has_sidetable_rc)) &#123;</span><br><span class="line">    		<span class="comment">// 如果 handleUnderflow == false，调用 rootRelease_underflow</span></span><br><span class="line">        <span class="keyword">if</span> (!handleUnderflow) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">return</span> rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Transfer retain count from side table to inline storage.</span></span><br><span class="line">        <span class="comment">// 将引用计数从 sidetable 中转到 extra_rc 中存储</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sideTableLocked) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// Need to start over to avoid a race against </span></span><br><span class="line">            <span class="comment">// the nonpointer -&gt; raw pointer transition.</span></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Try to remove some retain counts from the side table. </span></span><br><span class="line">        <span class="comment">// 尝试从 sidetable 中删除（借出）一些引用计数，传入 RC_HALF</span></span><br><span class="line">        <span class="comment">// borrowed 为 sidetable 实际删除（借出）的引用计数</span></span><br><span class="line">        <span class="keyword">size_t</span> borrowed = sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To avoid races, has_sidetable_rc must remain set </span></span><br><span class="line">        <span class="comment">// even if the side table count is now zero.</span></span><br><span class="line">        <span class="comment">// 为了避免竞争，has_sidetable_rc 必须保持设置</span></span><br><span class="line">        <span class="comment">// 即使 sidetable 中的引用计数现在是 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (borrowed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Side table retain count decreased.</span></span><br><span class="line">            <span class="comment">// Try to add them to the inline count.</span></span><br><span class="line">            <span class="comment">// 将它进行 -1，赋值给 extra_rc </span></span><br><span class="line">            newisa.extra_rc = borrowed - <span class="number">1</span>;  <span class="comment">// redo the original decrement too</span></span><br><span class="line">            <span class="comment">// 存储更改后的 isa.bits</span></span><br><span class="line">            <span class="keyword">bool</span> stored = StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);</span><br><span class="line">            <span class="comment">// 如果存储失败，立刻重试一次</span></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed. </span></span><br><span class="line">                <span class="comment">// Try it again right now. This prevents livelock on LL/SC </span></span><br><span class="line">                <span class="comment">// architectures where the side table access itself may have </span></span><br><span class="line">                <span class="comment">// dropped the reservation.</span></span><br><span class="line">                <span class="keyword">isa_t</span> oldisa2 = LoadExclusive(&amp;isa.bits);</span><br><span class="line">                <span class="keyword">isa_t</span> newisa2 = oldisa2;</span><br><span class="line">                <span class="keyword">if</span> (newisa2.nonpointer) &#123;</span><br><span class="line">                    <span class="keyword">uintptr_t</span> <span class="built_in">overflow</span>;</span><br><span class="line">                    newisa2.bits = </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed<span class="number">-1</span>), <span class="number">0</span>, &amp;<span class="built_in">overflow</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">overflow</span>) &#123;</span><br><span class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">						<span class="comment">// 如果还是存储失败，把引用计数再重新保存到 sidetable 中</span></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed.</span></span><br><span class="line">                <span class="comment">// Put the retains back in the side table.</span></span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Decrement successful after borrowing from side table.</span></span><br><span class="line">            <span class="comment">// This decrement cannot be the deallocating decrement - the side </span></span><br><span class="line">            <span class="comment">// table lock and has_sidetable_rc bit ensure that if everyone </span></span><br><span class="line">            <span class="comment">// else tried to -release while we worked, the last one would block.</span></span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Side table is empty after all. Fall-through to the dealloc path.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果引用计数为 0，dealloc 对象</span></span><br><span class="line">    <span class="comment">// Really deallocate.</span></span><br><span class="line">		<span class="comment">// 如果当前 newisa 处于 deallocating 状态，保证对象只会 dealloc 一次</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">        <span class="comment">// 调用 overrelease_error</span></span><br><span class="line">        <span class="keyword">return</span> overrelease_error();</span><br><span class="line">        <span class="comment">// does not actually return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 newisa 为 deallocating 状态</span></span><br><span class="line">    newisa.deallocating = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果存储失败，继续重试</span></span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) <span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">  	<span class="comment">// 如果 performDealloc == true，给对象发送一条 dealloc 消息</span></span><br><span class="line">    <span class="keyword">if</span> (performDealloc) &#123;</span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>忽略部分细节和不会执行的代码，方法主要包含以下几步：</p>
<p>【第一步】校验如果是 tagged pointer，直接返回 false</p>
<p>【第二步】定义局部变量</p>
<p>【第三步】进入 do-while 循环</p>
<ol>
<li><p>获取isa并保存在局部变量中</p>
</li>
<li><p>如果不是 nonpointer isa</p>
<ul>
<li><p>判断如果sidetable上锁了，则进行解锁；</p>
</li>
<li><p>执行 <code>sidetable_retain()</code>，找到对象所在的引用计数表，并将引用计数 -1；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rdar://20206767</span></span><br><span class="line"><span class="comment">// return uintptr_t instead of bool so that the various raw-isa </span></span><br><span class="line"><span class="comment">// -release paths all return zero in eax</span></span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">objc_object::sidetable_release(<span class="keyword">bool</span> performDealloc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  	<span class="comment">// 根据对象查找到所在的SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 标识是否需要销毁对象</span></span><br><span class="line">    <span class="keyword">bool</span> do_dealloc = <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">// SideTable 上锁</span></span><br><span class="line">    table.lock();</span><br><span class="line">  	<span class="comment">// 在SideTables的引用计数表（RefcountMap）中查找对象的应用计数</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.<span class="built_in">find</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.<span class="built_in">end</span>()) &#123;<span class="comment">// 如果没有查找到</span></span><br><span class="line">      	<span class="comment">// 标识对象需要销毁</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">      	<span class="comment">// 将正在销毁标识（1UL&lt;&lt;1）保存为对象在引用计数表中的引用计数值</span></span><br><span class="line">        table.refcnts[<span class="keyword">this</span>] = SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;<span class="comment">// 如果查找到了，但是引用计数值为 0</span></span><br><span class="line">        <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.</span></span><br><span class="line">      	<span class="comment">// 标识对象需要销毁</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">      	<span class="comment">// 将对象标记正在销毁</span></span><br><span class="line">        it-&gt;second |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;<span class="comment">// 如果对象没有溢出</span></span><br><span class="line">      	<span class="comment">// 将引用计数值-1</span></span><br><span class="line">        it-&gt;second -= SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// SideTable 解锁</span></span><br><span class="line">    table.unlock();</span><br><span class="line">  	<span class="comment">// 如果对象需要销毁 且 入参为true</span></span><br><span class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">      	<span class="comment">// 发送dealloc消息，销毁对象</span></span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 返回是否需要销毁对象标识</span></span><br><span class="line">    <span class="keyword">return</span> do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法会查找对象所在的SideTable并从引用计数表中查找对象的引用计数。如果引用计数表中没有查找到对象的引用计数（<code>it == table.refcnts.end()</code>），则标记对象为正在销毁；如果对象的引用计数值为 0（<code>it-&gt;second &lt; SIDE_TABLE_DEALLOCATING</code>），将对象标记为正在销毁（<code>it-&gt;second |= SIDE_TABLE_DEALLOCATING</code>）；否则就将引用计数减一（<code>it-&gt;second -= SIDE_TABLE_RC_ONE</code>）。</p>
<p>这也解释了为什么在存储引用计数时<strong>总是真正的引用计数值减一</strong>。因为 release 本来是要将引用计数-1，所以存储引用计数时先预留了-1，在-1之前会先判断引用计数值是否为 0 ，如果是，那就将对象标记为正在销毁，否则才进行-1，这样就避免了负数的产生。</p>
</li>
</ul>
</li>
<li><p>针对nonpointer isa，执行 <code>subc()</code>，对<code>extra_rc</code>进行-1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">uintptr_t</span> </span><br><span class="line">subc(<span class="keyword">uintptr_t</span> lhs, <span class="keyword">uintptr_t</span> rhs, <span class="keyword">uintptr_t</span> carryin, <span class="keyword">uintptr_t</span> *carryout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __builtin_subcl(lhs, rhs, carryin, carryout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>判断如果此时 <code>extra_rc</code> 中存储的引用计数为0</p>
<p>a. 撤消 <code>extra_rc--</code> 操作</p>
<p>b. 如果 <code>SideTable</code> 中存储有对象引用计数，</p>
<ul>
<li><p>如果入参 <code>handleUnderflow</code> 为 <code>false</code>，调用 <code>rootRelease_underflow()</code> 并返回；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE bool </span><br><span class="line">objc_object::rootRelease_underflow(bool performDealloc)</span><br><span class="line">&#123;</span><br><span class="line">    return rootRelease(performDealloc, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数又调用了<code>rootRelease</code>，但参数<code>handleUnderflow</code>传<code>true</code>。</p>
</li>
<li><p>判断如果当前sideTable 不在加锁状态，为了保证线程安全，将sideTable 加锁，并跳转到【第三步】从头开始执行；</p>
</li>
<li><p>调用 <code>sidetable_subExtraRC_nolock()</code> 将 <code>sidetable</code> 中存储的一些引用计数值转移到<code>isa</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Move some retain counts from the side table to the isa field.</span></span><br><span class="line"><span class="comment">// Returns the actual count subtracted, which may be less than the request.</span></span><br><span class="line"><span class="keyword">size_t</span> </span><br><span class="line">objc_object::sidetable_subExtraRC_nolock(<span class="keyword">size_t</span> delta_rc)</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer);</span><br><span class="line">  	<span class="comment">// 根据对象查找到SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    </span><br><span class="line">    RefcountMap::iterator it = table.refcnts.<span class="built_in">find</span>(<span class="keyword">this</span>);</span><br><span class="line">  	<span class="comment">// 如果引用计数表中没有查找到对象的引用计数值或者查找到的引用计数值为0，直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.<span class="built_in">end</span>()  ||  it-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Side table retain count is zero. Can't borrow.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 取出引用计数表中查找到的引用计数值</span></span><br><span class="line">    <span class="keyword">size_t</span> oldRefcnt = it-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isa-side bits should not be set here</span></span><br><span class="line">    assert((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == <span class="number">0</span>);</span><br><span class="line">    assert((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == <span class="number">0</span>);</span><br><span class="line">		<span class="comment">// 将对象的引用计数值减去入参传入的要迁移的值</span></span><br><span class="line">    <span class="keyword">size_t</span> newRefcnt = oldRefcnt - (delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT);</span><br><span class="line">    assert(oldRefcnt &gt; newRefcnt);  <span class="comment">// shouldn't underflow</span></span><br><span class="line">  	<span class="comment">// 更新引用计数表中对象的引用计数值为新值</span></span><br><span class="line">    it-&gt;second = newRefcnt;</span><br><span class="line">  	<span class="comment">// 返回入参</span></span><br><span class="line">    <span class="keyword">return</span> delta_rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数会查询 SideTables 中对象的引用计数，如果引用计数表中没有查找到该对象会查找到的引用计数为0，则直接返回0；否则，将查找到的引用计数值减去对入参进行向右移位操作（<code>it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT</code>）获取到的引用计数值，获取到新的引用计数值，校验之后用新的引用计数值更新引用计数表中对象的引用计数并返回。</p>
</li>
<li><p>如果实际迁移的值大于0</p>
<p>1）将迁移值减一之后存入isa bits的 <code>extra_rc</code>中。</p>
<p>2）然后调用 <code>StoreReleaseExclusive()</code> 存储更改后的 <code>isa.bits</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE</span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">StoreReleaseExclusive(<span class="keyword">uintptr_t</span> *dst, <span class="keyword">uintptr_t</span> oldvalue, <span class="keyword">uintptr_t</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __c11_atomic_compare_exchange_weak((_Atomic(<span class="keyword">uintptr_t</span>) *)dst, &amp;oldvalue, value, __ATOMIC_RELEASE, __ATOMIC_RELAXED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数和前文中 <code>retain</code> 一样调用 <code>__c11_atomic_compare_exchange_weak()</code> 。</p>
<p>3）如果存储不成功，立即重试更新：重新获取isa，判断如果是 nonpointer isa，调用  <code>addc</code> 将 <code>extra_rc</code> 中的引用计数加上迁移的值减一，然后判断如果 <code>extra_rc</code> 没有溢出，则调用 <code>StoreReleaseExclusive()</code> 存储更改后的 <code>isa.bits</code></p>
</li>
<li><p>如果还是没有保存成功，则执行 <code>sidetable_addExtraRC_nolock()</code>将迁移的引用计数值，重新存储在引用计数表中，并跳转到【第三步】从头开始执行</p>
</li>
<li><p>SideTable 解锁，并返回false</p>
</li>
</ul>
</li>
<li><p>判断如果对象正在销毁，SideTable如果正在上锁状态则解锁，然后执行 <code>overrelease_error()</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE</span><br><span class="line"><span class="keyword">bool</span> </span><br><span class="line">objc_object::overrelease_error()</span><br><span class="line">&#123;</span><br><span class="line">    _objc_inform_now_and_on_crash(<span class="string">"%s object %p overreleased while already deallocating; break on objc_overrelease_during_dealloc_error to debug"</span>, object_getClassName((id)<span class="keyword">this</span>), <span class="keyword">this</span>);</span><br><span class="line">    objc_overrelease_during_dealloc_error();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// allow rootRelease() to tail-call this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前对象处于<code>deallocating</code>状态，再次<code>release</code>就会执行<code>overrelease_error</code>，该函数就是用来在过度调用<code>release</code>的时候报错用的。其中 <code>objc_overrelease_during_dealloc_error()</code>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BREAKPOINT_FUNCTION(</span><br><span class="line">    <span class="keyword">void</span> objc_overrelease_during_dealloc_error(<span class="keyword">void</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将对象标记为“正在析构”</p>
</li>
<li><p>如果调用 <code>StoreExclusive()</code> 存储更改后的 <code>isa.bits</code> 失败。跳转到【第三步】从头开始执行</p>
</li>
<li><p>SideTable如果正在上锁状态则解锁</p>
</li>
<li><p>调用 <code>__sync_synchronize()</code> 设置内存屏障</p>
</li>
<li><p>调用 <code>dealloc</code>方法销毁对象</p>
</li>
<li><p>返回 true</p>
</li>
<li><p>循环退出条件为 <code>StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)  == true</code>，即更新 <code>isa.bit</code> 成功则退出循环；</p>
</li>
<li><p>SideTable如果正在上锁状态则解锁</p>
</li>
<li><p>返回 false</p>
</li>
</ol>
<h3 id="销毁对象"><a href="#销毁对象" class="headerlink" title="销毁对象"></a>销毁对象</h3><p>在 <code>release</code> 相关逻辑里，如果对象的引用计数为 0，则标记为正在销毁，并调用 <code>dealloc</code> 方法，销毁对象。 <code>dealloc</code> 方法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Replaced by NSZombies</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_objc_rootDealloc</code> 函数实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_objc_rootDealloc(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_objc_rootDealloc</code> 函数除了断言外，也只是调用了<code>rootDealloc</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="comment">// 判断如果是 tagged pointer，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  <span class="comment">// 如果是 nonpointer isa</span></span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  <span class="comment">// 没有被弱引用指向过</span></span><br><span class="line">                 !isa.has_assoc  &amp;&amp;   <span class="comment">// 对象没有关联对象</span></span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  <span class="comment">// 没有 C++ 的析构函数</span></span><br><span class="line">                 !isa.has_sidetable_rc)) <span class="comment">// 没有额外采用 SideTabel 进行引用计数存储</span></span><br><span class="line">    &#123;</span><br><span class="line">      	<span class="comment">// 断言校验对象不在 side table（应用计数表 和 弱引用表）中 </span></span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">      	<span class="comment">// 释放对象内存空间</span></span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 析构对象并释放对象内存空间</span></span><br><span class="line">        object_dispose((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法逻辑如下：</p>
<p>【第一步】判断如果是 tagged pointer，直接返回；</p>
<p>【第二步】判断如果满足如下条件：是nonpointer isa 且 没有被弱引用指向过 且 对象没有关联对象 且 对象没有 C++ 或 ARC 的析构函数 且 对象的引用计数值有在side table存储</p>
<ol>
<li><p>调用 <code>sidetable_present</code> 断言校验对象不在 side table（应用计数表 和 弱引用表）中 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line"><span class="comment">// Used to assert that an object is not present in the side table.</span></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">objc_object::sidetable_present()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line"></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.<span class="built_in">find</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.<span class="built_in">end</span>()) result = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (weak_is_registered_no_lock(&amp;table.weak_table, (id)<span class="keyword">this</span>)) result = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    table.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>仅在 DEBUG 有效</p>
</li>
<li><p>调用 <code>free</code> 释放对象内存空间</p>
</li>
</ol>
<p>【第三步】如果【第二步】判断条件没有满足，调用 <code>object_dispose</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* object_dispose</span></span><br><span class="line"><span class="comment">* fixme</span></span><br><span class="line"><span class="comment">* Locking: none</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数首先判断如果对象已经不存在了，直接返回nil，否则调用 <code>objc_destructInstance</code>  析构对象，然后调用 <code>free</code> 释放对象并返回nil，<code>objc_destructInstance</code> 实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_destructInstance</span></span><br><span class="line"><span class="comment">* Destroys an instance without freeing memory. </span></span><br><span class="line"><span class="comment">* Calls C++ destructors.</span></span><br><span class="line"><span class="comment">* Calls ARC ivar cleanup.</span></span><br><span class="line"><span class="comment">* Removes associative references.</span></span><br><span class="line"><span class="comment">* Returns `obj`. Does nothing if `obj` is nil.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果对象存在，则判断对象是否有 C++ 析构函数，如果有则调用 <code>object_cxxDestruct</code> 从对象继承树中查找C++ 析构函数并调用，相关源代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* object_cxxDestruct.</span></span><br><span class="line"><span class="comment">* Call C++ destructors on obj, if any.</span></span><br><span class="line"><span class="comment">* Uses methodListLock and cacheUpdateLock. The caller must hold neither.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">object_cxxDestruct</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line">    object_cxxDestructFromClass(obj, obj-&gt;ISA());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* object_cxxDestructFromClass.</span></span><br><span class="line"><span class="comment">* Call C++ destructors on obj, starting with cls's </span></span><br><span class="line"><span class="comment">*   dtor method (if any) followed by superclasses' dtors (if any), </span></span><br><span class="line"><span class="comment">*   stopping at cls's dtor (if any).</span></span><br><span class="line"><span class="comment">* Uses methodListLock and cacheUpdateLock. The caller must hold neither.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">object_cxxDestructFromClass</span><span class="params">(id obj, Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*dtor)(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call cls's dtor first, then superclasses's dtors.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; cls; cls = cls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cls-&gt;hasCxxDtor()) <span class="keyword">return</span>; </span><br><span class="line">        dtor = (<span class="keyword">void</span>(*)(id))</span><br><span class="line">            lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct);</span><br><span class="line">        <span class="keyword">if</span> (dtor != (<span class="keyword">void</span>(*)(id))_objc_msgForward_impcache) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PrintCxxCtors) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"CXX: calling C++ destructors for class %s"</span>, </span><br><span class="line">                             cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            (*dtor)(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* lookupMethodInClassAndLoadCache.</span></span><br><span class="line"><span class="comment">* Like _class_lookupMethodAndLoadCache, but does not search superclasses.</span></span><br><span class="line"><span class="comment">* Caches and returns objc_msgForward if the method is not found in the class.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">IMP <span class="title">lookupMethodInClassAndLoadCache</span><span class="params">(Class cls, SEL sel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Method meth;</span><br><span class="line">    IMP imp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme this is incomplete - no resolver, +initialize - </span></span><br><span class="line">    <span class="comment">// but it's only used for .cxx_construct/destruct so we don't care</span></span><br><span class="line">    assert(sel == SEL_cxx_construct  ||  sel == SEL_cxx_destruct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search cache first.</span></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache miss. Search method list.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">        <span class="comment">// Hit in method list. Cache it.</span></span><br><span class="line">        cache_fill(cls, sel, meth-&gt;imp, nil);</span><br><span class="line">        <span class="keyword">return</span> meth-&gt;imp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Miss in method list. Cache objc_msgForward.</span></span><br><span class="line">        cache_fill(cls, sel, _objc_msgForward_impcache, nil);</span><br><span class="line">        <span class="keyword">return</span> _objc_msgForward_impcache;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断对象是否有管理对象，如果有则调用 <code>_object_remove_assocations</code> 函数，移除关联对象</p>
</li>
<li><p>调用 <code>clearDeallocating</code> 清理side table 中对象相关数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要调用两个方法，针对不是 nonpointer 的 isa 调用 <code>sidetable_clearDeallocating()</code>，针对 nonpointer isa 判断如果有被弱引用指向过 或者 对象的引用计数值有在side table存储则调用 <code>clearDeallocating_slow()</code>，修改弱引用表 及 从引用计数表中清除对象相关数据。</p>
<p> <code>sidetable_clearDeallocating()</code> 函数实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_object::sidetable_clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear any weak table items</span></span><br><span class="line">    <span class="comment">// clear extra retain count and deallocating bit</span></span><br><span class="line">    <span class="comment">// (fixme warn or abort if extra retain count == 0 ?)</span></span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.<span class="built_in">find</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123;</span><br><span class="line">            weak_clear_no_lock(&amp;table.weak_table, (id)<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        table.refcnts.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>clearDeallocating_slow()</code> 函数实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Slow path of clearDeallocating() </span></span><br><span class="line"><span class="comment">// for objects with nonpointer isa</span></span><br><span class="line"><span class="comment">// that were ever weakly referenced </span></span><br><span class="line"><span class="comment">// or whose retain count ever overflowed to the side table.</span></span><br><span class="line">NEVER_INLINE <span class="keyword">void</span></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    table.lock();</span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h2><p>在前面内存管理策略部分有提到，通过<code>alloc/new/copy/mutableCopy</code> 等方法和以它们驼峰命名开头的方法会生成并持有对象。那么调用如 <code>[NSMutableArray array]</code> 等不以 <code>alloc/new/copy/mutableCopy</code> 开头的方法使取得的对象存在，但自己不持有对象，要怎么实现呢？这里就要引入另一个概念autoreleasepool。MRC 环境中，可以通过通过调用 <code>autorelease</code> 可以将对象注册到autoreleasepool中，使对象在超出指定的生存范围时能够自动并正确地释放。如下图所示加入autoreleasepool中的对象可以做到延迟释放：</p>
<img src="/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/autorelease%E5%92%8Crelease%E5%8C%BA%E5%88%AB.png" class title="autorelease和release区别">

<h3 id="autoreleasepool-1"><a href="#autoreleasepool-1" class="headerlink" title="@autoreleasepool"></a>@autoreleasepool</h3><p>众所周知，iOS项目都是以main函数为入口。新建一个iOS项目，可以看到main.m文件中代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到函数中使用 @autoreleasepool 包裹了实现语句，那么<code>@autoreleasepool</code> 到底是什么？</p>
<p>打开命令行，cd到工程目录，执行 <code>clang -rewrite-objc main.m</code> 让编译器重新改写main.m文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure>

<p>如遇如下报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.m:9:9: fatal error: &#39;UIKit&#x2F;UIKit.h&#39; file not found</span><br><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line">        ^~~~~~~~~~~~~~~</span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure>

<p>可将上面的命令替换成如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -x objective-c -rewrite-objc -isysroot &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneSimulator.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneSimulator.sdk main.m</span><br></pre></td></tr></table></figure>

<p>就会在当前目录下生成一个 <code>main.cpp</code> 文件。在文件末尾可以看到函数变成了这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"AppDelegate"</span>), sel_registerName(<span class="string">"class"</span>))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原先的@autoreleasepool没有了，取而代之的是一个 <code>__AtAutoreleasePool</code> 结构体。前面的注释写到 <code>/* @autoreleasepopl */</code>。也就是说 <code>@autoreleasepool {}</code> 被转换为一个 <code>__AtAutoreleasePool</code> 结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__AtAutoreleasePool __autoreleasepool;</span><br></pre></td></tr></table></figure>

<p>在 <code>main.cpp</code> 中查找 <code>__AtAutoreleasePool</code> 结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体会在初始化时调用 <code>objc_autoreleasePoolPush()</code> 方法，会在析构时调用 <code>objc_autoreleasePoolPop</code> 方法。</p>
<p>因此 <code>main</code> 函数在实际工作时其实是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    &#123; </span><br><span class="line">    		<span class="keyword">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">    		</span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"AppDelegate"</span>), sel_registerName(<span class="string">"class"</span>))));</span><br><span class="line">        </span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 方法在 NSObject.mm 中定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">objc_autoreleasePoolPush(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上述方法只是对 <code>AutoreleasePoolPage</code> 类对应静态方法 <code>push</code> 和 <code>pop</code> 的封装。</p>
<h3 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h3><p> <code>AutoreleasePoolPage</code> 类也定义在NSObject.mm中，包含如下成员变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is </span></span><br><span class="line">    <span class="comment">// pushed and it has never contained any objects. This saves memory </span></span><br><span class="line">    <span class="comment">// when the top level (i.e. libdispatch) pushes and pops pools but </span></span><br><span class="line">    <span class="comment">// never uses them.</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = </span><br><span class="line">#<span class="keyword">if</span> PROTECT_AUTORELEASEPOOL</span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(id);</span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;<span class="comment">// 16字节</span></span><br><span class="line">    id *next;<span class="comment">// 8字节</span></span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;<span class="comment">// 8字节</span></span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;<span class="comment">// 8字节</span></span><br><span class="line">    AutoreleasePoolPage *child;<span class="comment">// 8字节</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;<span class="comment">// 4字节</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;<span class="comment">// 4字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SIZE 表示每个page占用大小。相关宏定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set this to 1 to mprotect() autorelease pool contents</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_AUTORELEASEPOOL 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_MAX_SIZE           PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE               I386_PGBYTES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I386_PGBYTES            4096            <span class="comment">/* bytes per 80386 page */</span></span></span><br></pre></td></tr></table></figure>

<p>可知每个page占用 4096 字节。</p>
<p>类中包含的变量对应的含义如下：</p>
<ul>
<li><strong>magic：</strong>magic 用于对当前 <code>AutoreleasePoolPage</code> <strong>完整性</strong>的校验</li>
<li><strong>thread：</strong>AutoreleasePool是按线程一一对应的，thread指针指向当前线程</li>
<li><strong>parrent &amp; child：</strong>AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以<code>双向链表</code>的形式组合而成的，parent指针和child指针分别指向上下节点</li>
<li><strong>next：</strong>作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>
<li><strong>depth：</strong>page的深度，首次为0，以后每次初始化一个page都加1，4字节</li>
<li><strong>thread：</strong>用来计算pool中最多存放的对象个数</li>
</ul>
<h4 id="自动释放池中的栈"><a href="#自动释放池中的栈" class="headerlink" title="自动释放池中的栈"></a>自动释放池中的栈</h4><p>如果我们的一个 <code>AutoreleasePoolPage</code> 被初始化在内存的 <code>0x100816000 ~ 0x100817000</code> 中，它在内存中的结构如下：</p>


<p>其中有 56 bit 用于存储 <code>AutoreleasePoolPage</code> 的成员变量，剩下的 <code>0x100816038 ~ 0x100817000</code> 都是用来存储<strong>加入到自动释放池中的对象</strong>。</p>
<blockquote>
<p><code>begin()</code> 和 <code>end()</code> 这两个类的实例方法帮助我们快速获取 <code>0x100816038 ~ 0x100817000</code> 这一范围的边界地址。</p>
</blockquote>
<p><code>next</code> 指向了下一个为空的内存地址，如果 <code>next</code> 指向的地址加入一个 <code>object</code>，它就会如下图所示<strong>移动到下一个为空的内存地址中</strong>：</p>
<img src="/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/next%E6%8C%87%E9%92%88.png" class title="next指针">

<h4 id="POOL-SENTINEL（哨兵对象）"><a href="#POOL-SENTINEL（哨兵对象）" class="headerlink" title="POOL_SENTINEL（哨兵对象）"></a>POOL_SENTINEL（哨兵对象）</h4><p>细心的朋友可能会发现栈里有个陌生的东西 <code>POOL_SENTINEL</code> ， <code>POOL_SENTINEL</code> 只是 <code>nil</code> 的别名。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> POOL_BOUNDARY nil</span></span><br></pre></td></tr></table></figure>

<p>Objective-C</p>
<p>在每个自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 的时候，都会把一个 <code>POOL_SENTINEL</code> push 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code>哨兵对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do whatever you want</span></span><br><span class="line"></span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Objective-C</p>
<blockquote>
<p>上面的 <code>atautoreleasepoolobj</code> 就是一个 <code>POOL_SENTINEL</code>。</p>
</blockquote>
<p>而当方法 <code>objc_autoreleasePoolPop</code> 调用时，就会向自动释放池中的对象发送 <code>release</code> 消息，直到第一个 <code>POOL_SENTINEL</code>：</p>
<img src="/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%93%A8%E5%85%B5%E5%AF%B9%E8%B1%A1.png" class title="哨兵对象">

<h4 id="AutoreleasePoolPage双向链表"><a href="#AutoreleasePoolPage双向链表" class="headerlink" title="AutoreleasePoolPage双向链表"></a>AutoreleasePoolPage双向链表</h4><p>上面讲到的都是单个AutoreleasePoolPage。当对象比较多，一个AutoreleasePoolPage如果满了，会新建一个AutoreleasePoolPage对象，与原来页链表连接完成后，后来的autorelease对象在新的page加入。 <code>AutoreleasePoolPage</code> 是以<strong>双向链表</strong>的形式连接起来的：</p>
<img src="/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/AutoreleasePoolPage%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" class title="AutoreleasePoolPage双向链表">

<p>介绍完 <code>AutoreleasePoolPage</code> 之后，我们接下来来看两个关键方法。</p>
<h3 id="objc-autoreleasePoolPush-方法"><a href="#objc-autoreleasePoolPush-方法" class="headerlink" title="objc_autoreleasePoolPush 方法"></a>objc_autoreleasePoolPush 方法</h3><p><code>objc_autoreleasePoolPush()</code> 方法前文中有提到，只是调用了 <code>AutoreleasePoolPage</code> 结构体的 <code>push()</code> 方法。该方法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation) &#123;</span><br><span class="line">        <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>忽略debug相关代码，方法其实也只是调用了 <code>autoreleaseFast</code> 方法，并传入哨兵对象 <code>POOL_SENTINEL</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法分以下几步：</p>
<p>一、调用 <code>hotPage()</code> 方法获取当前正在操作的页，<code>hotPage()</code> 方法实现及相关变量定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> AutoreleasePoolPage *<span class="title">hotPage</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *result = (AutoreleasePoolPage *)</span><br><span class="line">        tls_get_direct(key);</span><br><span class="line">    <span class="keyword">if</span> ((id *)result == EMPTY_POOL_PLACEHOLDER) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (result) result-&gt;fastcheck();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>从线程局部存储（TLS）中根据key获取页对象，TLS 全称Thread Local Storage，是某个线程专有的存储内存空间，以key-value的形式进行读写。</li>
<li>判断获取到的页为占位对象返回nil</li>
<li>判断如果页存在，调用 <code>fastcheck()</code> 通过页的magic对完整性进行校验</li>
<li>返回获取到的页</li>
</ol>
<p>二、如果成功获取到 AutoreleasePoolPage 且 页没有满，则调用 <code>add</code> 方法添加对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(!full());</span><br><span class="line">    unprotect();</span><br><span class="line">    id *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></span><br><span class="line">    *next++ = obj;</span><br><span class="line">    protect();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法其实就是一个压栈的操作，将对象加入 <code>AutoreleasePoolPage</code> 然后移动栈顶的指针。</p>
<p>三、判断如果成功获取到 AutoreleasePoolPage 但 页已满，则调用 <code>autoreleaseFullPage()</code>，从传入的 <code>page</code> 开始向后遍历整个双向链表查找未满的 <code>AutoreleasePoolPage</code>，如果没有查找到，创建一个新的 <code>AutoreleasePoolPage</code> 并将page连接到链表。最后将查找到或者新建的page设置为hotpage。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line">    <span class="function">id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The hot page is full. </span></span><br><span class="line">    <span class="comment">// Step to the next non-full page, adding a new page if necessary.</span></span><br><span class="line">    <span class="comment">// Then add the object to that page.</span></span><br><span class="line">    assert(page == hotPage());</span><br><span class="line">    assert(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setHotPage</span><span class="params">(AutoreleasePoolPage *page)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (page) page-&gt;fastcheck();</span><br><span class="line">    tls_set_direct(key, (<span class="keyword">void</span> *)page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四、如果当前内存中不存在 <code>hotPage</code>，就会调用 <code>autoreleaseNoPage</code> 方法初始化一个 <code>AutoreleasePoolPage</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">BREAKPOINT_FUNCTION(<span class="keyword">void</span> objc_autoreleaseNoPool(id obj));   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">haveEmptyPoolPlaceholder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id *tls = (id *)tls_get_direct(key);</span><br><span class="line">    <span class="keyword">return</span> (tls == EMPTY_POOL_PLACEHOLDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id* <span class="title">setEmptyPoolPlaceholder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(tls_get_direct(key) == nil);</span><br><span class="line">    tls_set_direct(key, (<span class="keyword">void</span> *)EMPTY_POOL_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">return</span> EMPTY_POOL_PLACEHOLDER;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line"><span class="function">id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// "No page" could mean no pool has been pushed</span></span><br><span class="line">    <span class="comment">// or an empty placeholder pool has been pushed and has no contents yet</span></span><br><span class="line">    assert(!hotPage());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> pushExtraBoundary = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">        <span class="comment">// We are pushing a second pool over the empty placeholder pool</span></span><br><span class="line">        <span class="comment">// or pushing the first object into the empty placeholder pool.</span></span><br><span class="line">        <span class="comment">// Before doing that, push a pool boundary on behalf of the pool </span></span><br><span class="line">        <span class="comment">// that is currently represented by the empty placeholder.</span></span><br><span class="line">        pushExtraBoundary = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        <span class="comment">// We are pushing an object with no pool in place, </span></span><br><span class="line">        <span class="comment">// and no-pool debugging was requested by environment.</span></span><br><span class="line">        _objc_inform(<span class="string">"MISSING POOLS: (%p) Object %p of class %s "</span></span><br><span class="line">                     <span class="string">"autoreleased with no pool in place - "</span></span><br><span class="line">                     <span class="string">"just leaking - break on "</span></span><br><span class="line">                     <span class="string">"objc_autoreleaseNoPool() to debug"</span>, </span><br><span class="line">                     pthread_self(), (<span class="keyword">void</span>*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;</span><br><span class="line">        <span class="comment">// We are pushing a pool with no pool in place,</span></span><br><span class="line">        <span class="comment">// and alloc-per-pool debugging was not requested.</span></span><br><span class="line">        <span class="comment">// Install and return the empty pool placeholder.</span></span><br><span class="line">        <span class="keyword">return</span> setEmptyPoolPlaceholder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are pushing an object or a non-placeholder'd pool.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install the first page.</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">new</span> AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Push a boundary on behalf of the previously-placeholder'd pool.</span></span><br><span class="line">    <span class="keyword">if</span> (pushExtraBoundary) &#123;</span><br><span class="line">        page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Push the requested object or pool.</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次调用这个方法时，haveEmptyPoolPlaceholder()返回的是false，会执行 <code>setEmptyPoolPlaceholder</code>。这个方法调用完之后，再次进入autoreleaseNoPage()时，就会进入第一个if判断中了。接着就会走到这个方法的最后那部分，从头开始构建这个自动释放池的双向链表。初始化之后，将当前页标记为 <code>hotPage</code>，然后会先向这个 <code>page</code> 中添加一个 <code>POOL_SENTINEL</code> 对象，来确保在 <code>pop</code> 调用的时候，不会出现异常。最后，将 <code>obj</code> 添加到自动释放池中。</p>
<h3 id="objc-autoreleasePoolPop-方法"><a href="#objc-autoreleasePoolPop-方法" class="headerlink" title="objc_autoreleasePoolPop 方法"></a>objc_autoreleasePoolPop 方法</h3><p>和<code>objc_autoreleasePoolPush()</code> 一样，<code>objc_autoreleasePoolPop</code>也只是调用了 <code>AutoreleasePoolPage</code> 结构体的 <code>pop()</code> 方法。该方法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *<span class="built_in">stop</span>;</span><br><span class="line">		<span class="comment">// ********** part1 **********</span></span><br><span class="line">    <span class="keyword">if</span> (token == (<span class="keyword">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        <span class="comment">// Popping the top-level placeholder pool.</span></span><br><span class="line">        <span class="keyword">if</span> (hotPage()) &#123;</span><br><span class="line">            <span class="comment">// Pool was used. Pop its contents normally.</span></span><br><span class="line">            <span class="comment">// Pool pages remain allocated for re-use as usual.</span></span><br><span class="line">            pop(coldPage()-&gt;<span class="built_in">begin</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Pool was never used. Clear the placeholder.</span></span><br><span class="line">            setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	page = pageForPointer(token);</span><br><span class="line">  	<span class="comment">// ********** part2 **********</span></span><br><span class="line">    <span class="built_in">stop</span> = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="built_in">stop</span> != POOL_BOUNDARY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stop</span> == page-&gt;<span class="built_in">begin</span>()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            <span class="comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span></span><br><span class="line">            <span class="comment">// 1. top-level pool is popped, leaving the cold page in place</span></span><br><span class="line">            <span class="comment">// 2. an object is autoreleased with no pool</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Error. For bincompat purposes this is not </span></span><br><span class="line">            <span class="comment">// fatal in executables built with old SDKs.</span></span><br><span class="line">            <span class="keyword">return</span> badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// ********** part3 **********</span></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(<span class="built_in">stop</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法大致可以分为如下3个部分：</p>
<ol>
<li><p>判断token是否是EMPTY_POOL_PLACEHOLDER，这是autoreleasepool首次push的时候返回的，也就是最顶层的page调用pop会执行这一部分</p>
</li>
<li><p>在非ARC情况下，在新创建的子线程中不使用autoreleasepool，直接调用autorelease方法时会出现自动释放池page双向链表表头page栈最底部不是哨兵对象的情况，这里针对这种情况进行处理。</p>
</li>
<li><p>多数情况下，都会进入到这一部分。重点说一下这个部分:</p>
<p>第一步，调用 <code>page = pageForPointer(token)</code> 根据token获取 <code>AutoreleasePoolPage</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> AutoreleasePoolPage *<span class="title">pageForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pageForPointer((<span class="keyword">uintptr_t</span>)p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> AutoreleasePoolPage *<span class="title">pageForPointer</span><span class="params">(<span class="keyword">uintptr_t</span> p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *result;</span><br><span class="line">    <span class="keyword">uintptr_t</span> offset = p % SIZE;</span><br><span class="line"></span><br><span class="line">    assert(offset &gt;= <span class="keyword">sizeof</span>(AutoreleasePoolPage));</span><br><span class="line"></span><br><span class="line">    result = (AutoreleasePoolPage *)(p - offset);</span><br><span class="line">    result-&gt;fastcheck();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取page的地址之后，接下来就调用 <code>releaseUntil</code> 方法来release对象，该方法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseUntil</span><span class="params">(id *<span class="built_in">stop</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Not recursive: we don't want to blow out the stack </span></span><br><span class="line">    <span class="comment">// if a thread accumulates a stupendous amount of garbage</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != <span class="built_in">stop</span>) &#123;</span><br><span class="line">        <span class="comment">// Restart from hotPage() every time, in case -release </span></span><br><span class="line">        <span class="comment">// autoreleased more objects</span></span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixme I think this `while` can be `if`, but I can't prove it</span></span><br><span class="line">        <span class="keyword">while</span> (page-&gt;empty()) &#123;</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        id obj = *--page-&gt;next;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span>*)page-&gt;next, SCRIBBLE, <span class="keyword">sizeof</span>(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setHotPage(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// we expect any children to be completely empty</span></span><br><span class="line">    <span class="keyword">for</span> (AutoreleasePoolPage *page = child; page; page = page-&gt;child) &#123;</span><br><span class="line">        assert(page-&gt;empty());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从next指针开始，一个一个向前调用release方法，直到碰到push时压入的token为止。</p>
<p>在释放完对象之后，接下来就是kill 空的  <code>AutoreleasePoolPage</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">        page-&gt;child-&gt;kill();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">        page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断如果child page存在，调用 <code>lessThanHalfFull()</code> 方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lessThanHalfFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (next - <span class="built_in">begin</span>() &lt; (<span class="built_in">end</span>() - <span class="built_in">begin</span>()) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断当前page小于一半满，则调用 <code>kill</code> 方法将当前页的所有孩子都释放掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Not recursive: we don't want to blow out the stack </span></span><br><span class="line">    <span class="comment">// if a thread accumulates a stupendous amount of garbage</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">while</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        deathptr = page;</span><br><span class="line">        page = page-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (page) &#123;</span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">            page-&gt;child = nil;</span><br><span class="line">            page-&gt;protect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> deathptr;</span><br><span class="line">    &#125; <span class="keyword">while</span> (deathptr != <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>否则，留下一个child，从孙子page开始杀。正是因为这一步，在autoreleaseFullPage()方法中才会有如下步骤</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">    <span class="keyword">else</span> page = <span class="keyword">new</span> AutoreleasePoolPage(page);</span><br><span class="line">&#125; <span class="keyword">while</span> (page-&gt;full());</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3 id="objc-autoreleaseReturnValue优化"><a href="#objc-autoreleaseReturnValue优化" class="headerlink" title="objc_autoreleaseReturnValue优化"></a>objc_autoreleaseReturnValue优化</h3><p>上文中提到，如 <code>[NSMutableArray array]</code> 等不以 <code>alloc/new/copy/mutableCopy</code> 开头的方法创建的对象。秉着谁创建谁释放的原则，返回值需要是一个autorelease对象才能配合调用方正确管理内存。比如如下一个工厂方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)person &#123;</span><br><span class="line">    return [[Person alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用</span><br><span class="line">Person *person &#x3D; [Person person];</span><br></pre></td></tr></table></figure>

<p>会被编译器改写成如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)person &#123;</span><br><span class="line">    id obj = objc_msgSend(Person, @selector(alloc));</span><br><span class="line">    objc_msgSend(obj, @selector(init));</span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">id obj = objc_msgSend(Person, @selector(person));</span><br><span class="line">objc_retainAutoreleasedReturnValue(obj);</span><br><span class="line">objc_release)(objc);</span><br></pre></td></tr></table></figure>

<p>objc_retainAutoreleasedReturnValue函数主要用于最优化程序运行。顾名思义，它是用于自己持有（retain）对象的函数，但它持有的对象应为返回注册在autoreleasepool中对象的方法，或是函数的返回值，在调用 <code>alloc/new/copy/mutableCopy</code> 以外的方法，有编译器插入该函数。</p>
<p>这种 objc_retainAutoreleasedReturnValue 函数是成对的，与之相对的函数是 objc_autoreleaseReturnValue。它用于 <code>alloc/new/copy/mutableCopy</code> 方法以外的，如 NSMutableArray 类的 array 类方法等返回对象的实现上。该方法会返回注册到autoreleasepool中的对象。但是 objc_autoreleaseReturnValue 函数同 objc_autorelease函数不同，一般不仅限于注册对象到 autoreleasepool中。</p>
<p>objc_autoreleaseReturnValue 函数会检查使用该函数的方法或函数调用方的执行命令列表，如果方法或函数的调用方在调用了方法或函数后紧接着调用 objc_retainAutoreleasedReturnValue() 函数，那么就不将返回的对象注册到 autoreleasepool中，而是直接传递到方法或函数的调用方。objc_retainAutoreleasedReturnValue 函数与 objc_retain 函数不同，它即便不注册到 autoreleasepool 而返回对象，也能够正确地获取对象。通过 objc_autoreleaseReturnValue 函数和 objc_retainAutoreleasedReturnValue 函数的协作，可以不将对象注册到 autoreleasepool 中而直接传递，这一过程达到了最优化。</p>


<h3 id="Autorelease-释放时机"><a href="#Autorelease-释放时机" class="headerlink" title="Autorelease 释放时机"></a>Autorelease 释放时机</h3><p>有runloop的情况下，Autorelease对象是在当前的<code>runloop</code>迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop。</p>
<p><code>autoreleasepool</code>在没有<code>runloop</code>的情况下何时释放呢？</p>
<ol>
<li><p>局部<code>autoreleasepool drain</code>的时候，就是常规的<code>page push</code>以及对应的<code>page pop</code>；</p>
</li>
<li><p>线程退出的时候；那么线程退出释放是如何确定的呢？</p>
<p>在<code>runtime</code>初始化的过程中，会调用<code>AutoReleasePoolPage::init</code>方法注册<code>tls_dealloc</code>， AutoreleasePoolPage 类的初始化方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r __unused = pthread_key_init_np(AutoreleasePoolPage::key, </span><br><span class="line">                                         AutoreleasePoolPage::tls_dealloc);</span><br><span class="line">    assert(r == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>tls_dealloc</code> 方法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tls_dealloc</span><span class="params">(<span class="keyword">void</span> *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == (<span class="keyword">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        <span class="comment">// No objects or pool pages to clean up here.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reinstate TLS value while we work</span></span><br><span class="line">    setHotPage((AutoreleasePoolPage *)p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AutoreleasePoolPage *page = coldPage()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!page-&gt;empty()) pop(page-&gt;<span class="built_in">begin</span>());  <span class="comment">// pop all of the pools</span></span><br><span class="line">        <span class="keyword">if</span> (DebugMissingPools || DebugPoolAllocation) &#123;</span><br><span class="line">            <span class="comment">// pop() killed the pages already</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            page-&gt;kill();  <span class="comment">// free all of the pages</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// clear TLS value so TLS destruction doesn't loop</span></span><br><span class="line">    setHotPage(nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合这两段代码，我们大致可以猜测下<code>phtread_key_init_np</code>是将<code>tls_dealloc</code>注册给某个回调使用。那具体是干嘛的？</p>
<p>实际上<code>phtread_key_init_np</code>时给<code>thread</code>注册了线程销毁时的自定义析构函数，这里我们可以一起来看看<code>darwin-apple</code>的<code>libpthread</code>代码，这里我直接简化掉流程，输出大致的过程：</p>
<p><code>_pthread_exit</code> 在线程销毁时调用 -&gt; <code>_pthread_tsd_cleanup</code> -&gt; <code>_pthread_tsd_cleanup_new</code> -&gt; <code>_pthread_tsd_cleanup_key</code>。</p>
<p>在最终的函数里，会遍历所有的自定义销毁函数，逐个触发：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_pthread_tsd_cleanup_key(<span class="keyword">pthread_t</span> self, <span class="keyword">pthread_key_t</span> key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">if</span> (_pthread_key_get_destructor(key, &amp;destructor)) &#123;</span><br><span class="line">        <span class="keyword">void</span> **ptr = &amp;self-&gt;tsd[key];</span><br><span class="line">        <span class="keyword">void</span> *value = *ptr;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            *ptr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (destructor) &#123;</span><br><span class="line">                destructor(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3 id="问题案例"><a href="#问题案例" class="headerlink" title="问题案例"></a>问题案例</h3><p>NSAttributedString的autorelease内存风暴: <a href="http://wereadteam.github.io/2020/11/11/AttributeString/" target="_blank" rel="noopener">http://wereadteam.github.io/2020/11/11/AttributeString/</a></p>
<p>Autorelease 之不经意间可能被影响的优化: <a href="http://satanwoo.github.io/2019/07/02/RevisitAutorelease/#disqus_thread" target="_blank" rel="noopener">http://satanwoo.github.io/2019/07/02/RevisitAutorelease/#disqus_thread</a></p>
<h2 id="属性Property"><a href="#属性Property" class="headerlink" title="属性Property"></a>属性Property</h2><h3 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h3><p>ARC有效时，id类型和对象类型上必须附加所有权修饰符。所有权修饰符一共有4种。</p>
<p><strong>__strong 修饰符：</strong><code>__strong</code> 修饰符是id类型和对象类型默认的所有权修饰符。id和对象类型在没有明确指定所有权修饰符时，默认是 <code>__strong</code> 修饰符。附有 <code>__strong</code> 修饰符的变量 obj 在超出其变量作用域时，即在该变量被废弃时，会释放其被赋予的对象。 <code>__strong</code> 和 <code>__weak</code>、<code>__autorelease</code>修饰符一起，可以保证附有这些修饰符的自动变量初始化为nil。</p>
<p><strong>__weak 修饰符：</strong> 为了解决仅使用 <code>__strong</code> 修饰符编译器所不能解决的重大问题–引用计数式内存管理中必然会发生的”循环引用”问题，可以使用与 <code>__strong</code> 对应的 <code>__weak</code>。也就是说使用 <code>__weak</code> 可以避免循环引用。 <code>__weak</code> 修饰符与  <code>__strong</code>  修饰符相反，提供弱引用，弱引用不能持有对象实例。 <code>__weak</code> 修饰符还有另一优点。在持有对象的弱引用时，若该对象被废弃，则此弱引用将自动失效并被置为nil。</p>
<p><strong>__unsafe_unretained 修饰符：</strong> <code>__weak</code> 修饰符只能用于 iOS 5 以上及 OS X Lion 以上版本的应用程序。在 iOS 4以及OS X Snow Leopard的应用程序中可使用 <code>__unsafe_unretained</code> 修饰符来代替。<code>__unsafe_unretained</code> 修饰符正如其名 unsafe所示，是不安全的所有权修饰符。尽管 ARC 式的内存管理时编译器的工作，但附有 <code>__unsafe_unretained</code> 修饰符的变量不属于编译器的内存管理对象。附有 <code>__unsafe_unretained</code> 修饰符的变量同附有 <code>__weak</code> 修饰符的变量一样，不会改变对象的引用计数。同时因为附有 <code>__unsafe_unretained</code> 修饰符的变量不属于编译器的内存管理对象，所以弱引用不会被自动置为nil，所以在使用附有 <code>__unsafe_unretained</code> 修饰符的变量是，需要确保其确实存在，否则程序会崩溃。</p>
<p><strong>__autoreleasing 修饰符：</strong> ARC有效时，不能使用 autorelease方法，而是通过将对象赋值给附加了<code>__autoreleasing</code> 修饰符的变量来替代。对象赋值给附有 <code>__autoreleasing</code> 修饰符的变量等价于在ARC无效时调用对象的 autorelease 方法，即对象被注册到 autorelease。前文中提到，编译器会检查如果方法名不是以<code>alloc/new/copy/mutableCopy</code> 和以它们驼峰命名开头的，会自动将返回值的对象注册到 autoreleasepool。另外虽然 <code>__weak</code> 修饰符是为了避免循环引用而使用的，但在访问附有 <code>__weak</code> 修饰符的变量是，实际上必定要访问注册到 autoreleasepool 的对象。这是因为 <code>__weak</code> 修饰符只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果把要访问的对象注册到 autoreleasepool 中，那么在 @autoreleasepool 块结束之前都能确保该对象存在。因此，在使用附有  <code>__weak</code> 修饰符的变量时，就必定要使用注册到 autoreleasepool 中的对象。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>我们知道，在声明属性的时候，是可以指定内存管理特性的。property属性的内存管理特性包含如下几种：</p>
<table>
<thead>
<tr>
<th align="left">属性声明的属性</th>
<th align="left">所有权修饰符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">assign</td>
<td align="left">__unsafe_unretained 修饰符</td>
</tr>
<tr>
<td align="left">copy</td>
<td align="left">__strong 修饰符（但是赋值的是被复制的对象）</td>
</tr>
<tr>
<td align="left">retain</td>
<td align="left">__strong 修饰符</td>
</tr>
<tr>
<td align="left">strong</td>
<td align="left">__strong 修饰符</td>
</tr>
<tr>
<td align="left">unsafe_unretained</td>
<td align="left">__unsafe_unretained 修饰符</td>
</tr>
<tr>
<td align="left">weak</td>
<td align="left">__weak 修饰符</td>
</tr>
</tbody></table>
<p>只有copy属性不是简单的赋值，它赋值的是通过 NSCopying 接口的 copyWithZone: 方法复制赋值源所生成的对象。</p>
<p><strong>assign（默认参数）：</strong>setter方法直接赋值，不进行任何retain操作，不改变引用计数。该方法只会针对“纯量类型”(CGFloat或NSInteger等)和C数据类型（int, float, double, char, 等等）的简单赋值操作。基础数据类型： 如short、int、double、long等他们不在【堆】中，可能在【全局区】也可能在【栈】中，根据他们定义的位置而定，而这些内存都是由系统自动管理的，所以基本数据类型可以使用assign来生成set方法直接进行赋值。</p>
<p><strong>retain：</strong>生成符合内存管理的set方法（release旧值，retain新值），适用于OC对象的成员变量。</p>
<p><strong>copy：</strong>生成符合内存管理的set方法（release旧值，copy新值），适用于NSString、NSArray等不可变对象。和strong类似，不过该属性会被复制一个新的副本。很多时候使用copy是为了防止Mutable（可变类型）在我们不知道的情况下修改了属性值，而用copy可以生成一个不可变的副本防止被修改。如果我们自己实现setter方法的话，需要手动copy。</p>
<p><strong>strong：</strong>强引用，其存亡直接决定了所指向对象的存亡。使用该特性实例变量在赋值时，会释放旧值同时设置新值，对对象产生一个强引用，即引用计数+1。如果不存在指向一个对象的引用，并且此对象不再显示在列表中，则此对象会被从内存中释放。适用于一般OC对象。</p>
<p><strong>weak：</strong>表示的是一个弱引用，这个引用不会增加对象的引用计数，并且在所指向的对象被释放之后，weak指针会被置为nil。weak引用通常是用于处理循环引用的问题，如代理及block的使用中，相对会较多的使用到weak。即使一个对象被持有无数个弱引用，只要没有强引用指向它，那么还是会被清除。相比于assign，声明为weak的指针，指针指向的地址一旦被释放，这些指针都将被赋值为 nil。这样的好处能有效的防止野指针。因为ViewController对控件强引用，如果delegate声明为strong，UI控件代理一般指向ViewController本身，那么就会造成循环引用。不过非UI控件的delegate的属性声明是weak还是strong就要视情况而定。一般iOS的ARC中的代理delegate属性都会用weak，有时候也用于UI控件(如果是懒加载则必须用strong)。</p>
<h3 id="Property源码探究"><a href="#Property源码探究" class="headerlink" title="Property源码探究"></a>Property源码探究</h3><p>新建一个项目，在ViewController.m中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *str;</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *arr;</span><br><span class="line">@property (nonatomic, copy) NSDictionary *dic;</span><br><span class="line">@property (nonatomic, weak) id delegate;</span><br><span class="line">@property (nonatomic, assign) NSInteger num;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    _str &#x3D; [NSString new];</span><br><span class="line">    </span><br><span class="line">    _arr &#x3D; [NSMutableArray array];</span><br><span class="line">    </span><br><span class="line">    _dic &#x3D; [[NSDictionary alloc] init];</span><br><span class="line">    </span><br><span class="line">    NSObject *obj &#x3D; [NSObject new];</span><br><span class="line">    _delegate &#x3D; obj;</span><br><span class="line">    </span><br><span class="line">    _num &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>和前文一样，打开命令行，cd到工程目录，执行前文中的命令让编译器重新改写ViewController.m文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -x objective-c -rewrite-objc -isysroot &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneSimulator.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneSimulator.sdk ViewController.m</span><br></pre></td></tr></table></figure>

<p>如遇如下报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;folders&#x2F;0b&#x2F;z9zhp5nd1m31p32z0jbmyfhm0000gn&#x2F;T&#x2F;ViewController-d731ff.mi:60126:1: error: </span><br><span class="line">      cannot synthesize weak property because the current deployment target does</span><br><span class="line">      not support weak references</span><br><span class="line">@implementation ViewController</span><br></pre></td></tr></table></figure>

<p>可执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime&#x3D;ios-8.0.0 ViewController.m -o ViewController.cpp</span><br></pre></td></tr></table></figure>

<p>找到生成的 ViewController.cpp 文件，在文件最下方找到如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _REWRITER_typedef_ViewController</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _REWRITER_typedef_ViewController</span></span><br><span class="line"><span class="comment">// 编译器将struct objc_object重命名为 ViewController类</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> <span class="title">ViewController</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>&#125; _objc_exc_ViewController;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了属性的偏移量，指实例变量在内存中存储的偏移量，通过这两个值就能够在内存中定位到这实例变量的位置。值是运行时计算出偏移量硬编码(hard code)写入的，是non-fragile 特性的一种体现</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_ViewController$_str;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_ViewController$_arr;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_ViewController$_dic;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_ViewController$_delegate;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> OBJC_IVAR_$_ViewController$_num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该结构体就是ViewController类实现，struct ViewController_IMPL结构体只有一个Class isa结构体指针变量，指向类对象，用于获取ViewController类的方法列表、实例变量列表、属性列表、版本等信息。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ViewController_IMPL</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">UIViewController_IMPL</span> <span class="title">UIViewController_IVARS</span>;</span></span><br><span class="line">	NSString *__strong _str;</span><br><span class="line">	NSMutableArray *__strong _arr;</span><br><span class="line">	NSDictionary *__strong _dic;</span><br><span class="line">	__weak id _delegate;</span><br><span class="line">	NSInteger _num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* @end */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @interface ViewController ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @property (nonatomic, copy) NSString *str;</span></span><br><span class="line"><span class="comment">// @property (nonatomic, strong) NSMutableArray *arr;</span></span><br><span class="line"><span class="comment">// @property (nonatomic, copy) NSDictionary *dic;</span></span><br><span class="line"><span class="comment">// @property (nonatomic, weak) id delegate;</span></span><br><span class="line"><span class="comment">// @property (nonatomic, assign) NSInteger num;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* @end */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @implementation ViewController</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_ViewController_viewDidLoad(ViewController * self, SEL _cmd) &#123;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"ViewController"</span>))&#125;, sel_registerName(<span class="string">"viewDidLoad"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    (*(NSString *__strong *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_ViewController$_str)) = ((NSString *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSString"</span>), sel_registerName(<span class="string">"new"</span>));</span><br><span class="line"></span><br><span class="line">    (*(NSMutableArray *__strong *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_ViewController$_arr)) = ((NSMutableArray * _Nonnull (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSMutableArray"</span>), sel_registerName(<span class="string">"array"</span>));</span><br><span class="line"></span><br><span class="line">    (*(NSDictionary *__strong *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_ViewController$_dic)) = ((NSDictionary *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSDictionary *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSDictionary"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line"></span><br><span class="line">    NSObject *obj = ((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"new"</span>));</span><br><span class="line">    (*(__weak id *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_ViewController$_delegate)) = obj;</span><br><span class="line"></span><br><span class="line">    (*(NSInteger *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_ViewController$_num)) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_ViewController_didReceiveMemoryWarning(ViewController * self, SEL _cmd) &#123;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"ViewController"</span>))&#125;, sel_registerName(<span class="string">"didReceiveMemoryWarning"</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性的 setter 和 getter 方法</span></span><br><span class="line"><span class="keyword">static</span> NSString * _I_ViewController_str(ViewController * self, SEL _cmd) &#123; <span class="keyword">return</span> (*(NSString *__strong *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_ViewController$_str)); &#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> <span class="title">objc_setProperty</span> <span class="params">(id, SEL, <span class="keyword">long</span>, id, <span class="keyword">bool</span>, <span class="keyword">bool</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_ViewController_setStr_(ViewController * self, SEL _cmd, NSString *str) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct ViewController, _str), (id)str, <span class="number">0</span>, <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> NSMutableArray * _I_ViewController_arr(ViewController * self, SEL _cmd) &#123; <span class="keyword">return</span> (*(NSMutableArray *__strong *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_ViewController$_arr)); &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_ViewController_setArr_(ViewController * self, SEL _cmd, NSMutableArray *arr) &#123; (*(NSMutableArray *__strong *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_ViewController$_arr)) = arr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> NSDictionary * _I_ViewController_dic(ViewController * self, SEL _cmd) &#123; <span class="keyword">return</span> (*(NSDictionary *__strong *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_ViewController$_dic)); &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_ViewController_setDic_(ViewController * self, SEL _cmd, NSDictionary *dic) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct ViewController, _dic), (id)dic, <span class="number">0</span>, <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> id _I_ViewController_delegate(ViewController * self, SEL _cmd) &#123; <span class="keyword">return</span> (*(__weak id *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_ViewController$_delegate)); &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_ViewController_setDelegate_(ViewController * self, SEL _cmd, id delegate) &#123; (*(__weak id *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_ViewController$_delegate)) = delegate; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> NSInteger _I_ViewController_num(ViewController * self, SEL _cmd) &#123; <span class="keyword">return</span> (*(NSInteger *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_ViewController$_num)); &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_ViewController_setNum_(ViewController * self, SEL _cmd, NSInteger num) &#123; (*(NSInteger *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_ViewController$_num)) = num; &#125;</span><br><span class="line"><span class="comment">// @end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)，member对于(结构体类型)type起始的偏移，type一般为一个结构体类型</span></span><br><span class="line"><span class="comment">// 这两句代码是使用__OFFSETOFIVAR__(TYPE, MEMBER)宏定义来计算偏移量，并存储在上文提到的偏移量中</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> OBJC_IVAR_$_ViewController$_str __attribute__ ((used, section (<span class="string">"__DATA,__objc_ivar"</span>))) = __OFFSETOFIVAR__(struct ViewController, _str);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> OBJC_IVAR_$_ViewController$_arr __attribute__ ((used, section (<span class="string">"__DATA,__objc_ivar"</span>))) = __OFFSETOFIVAR__(struct ViewController, _arr);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> OBJC_IVAR_$_ViewController$_dic __attribute__ ((used, section (<span class="string">"__DATA,__objc_ivar"</span>))) = __OFFSETOFIVAR__(struct ViewController, _dic);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> OBJC_IVAR_$_ViewController$_delegate __attribute__ ((used, section (<span class="string">"__DATA,__objc_ivar"</span>))) = __OFFSETOFIVAR__(struct ViewController, _delegate);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> OBJC_IVAR_$_ViewController$_num __attribute__ ((used, section (<span class="string">"__DATA,__objc_ivar"</span>))) = __OFFSETOFIVAR__(struct ViewController, _num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员变量列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">ivar_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">ivar_t</span> <span class="title">ivar_list</span>[5];</span></span><br><span class="line">&#125; _OBJC_$_INSTANCE_VARIABLES_ViewController __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="keyword">_ivar_t</span>),</span><br><span class="line">	<span class="number">5</span>,</span><br><span class="line">	&#123;&#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_ViewController$_str, <span class="string">"_str"</span>, <span class="string">"@\"NSString\""</span>, <span class="number">3</span>, <span class="number">8</span>&#125;,</span><br><span class="line">	 &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_ViewController$_arr, <span class="string">"_arr"</span>, <span class="string">"@\"NSMutableArray\""</span>, <span class="number">3</span>, <span class="number">8</span>&#125;,</span><br><span class="line">	 &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_ViewController$_dic, <span class="string">"_dic"</span>, <span class="string">"@\"NSDictionary\""</span>, <span class="number">3</span>, <span class="number">8</span>&#125;,</span><br><span class="line">	 &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_ViewController$_delegate, <span class="string">"_delegate"</span>, <span class="string">"@"</span>, <span class="number">3</span>, <span class="number">8</span>&#125;,</span><br><span class="line">	 &#123;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> *)&amp;OBJC_IVAR_$_ViewController$_num, <span class="string">"_num"</span>, <span class="string">"q"</span>, <span class="number">3</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[12];</span></span><br><span class="line">&#125; _OBJC_$_INSTANCE_METHODS_ViewController __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">	<span class="number">12</span>,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)<span class="string">"viewDidLoad"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_I_ViewController_viewDidLoad&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"didReceiveMemoryWarning"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_I_ViewController_didReceiveMemoryWarning&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"str"</span>, <span class="string">"@16@0:8"</span>, (<span class="keyword">void</span> *)_I_ViewController_str&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"setStr:"</span>, <span class="string">"v24@0:8@16"</span>, (<span class="keyword">void</span> *)_I_ViewController_setStr_&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"arr"</span>, <span class="string">"@16@0:8"</span>, (<span class="keyword">void</span> *)_I_ViewController_arr&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"setArr:"</span>, <span class="string">"v24@0:8@16"</span>, (<span class="keyword">void</span> *)_I_ViewController_setArr_&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"dic"</span>, <span class="string">"@16@0:8"</span>, (<span class="keyword">void</span> *)_I_ViewController_dic&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"setDic:"</span>, <span class="string">"v24@0:8@16"</span>, (<span class="keyword">void</span> *)_I_ViewController_setDic_&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"delegate"</span>, <span class="string">"@16@0:8"</span>, (<span class="keyword">void</span> *)_I_ViewController_delegate&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"setDelegate:"</span>, <span class="string">"v24@0:8@16"</span>, (<span class="keyword">void</span> *)_I_ViewController_setDelegate_&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"num"</span>, <span class="string">"q16@0:8"</span>, (<span class="keyword">void</span> *)_I_ViewController_num&#125;,</span><br><span class="line">	&#123;(struct objc_selector *)<span class="string">"setNum:"</span>, <span class="string">"v24@0:8q16"</span>, (<span class="keyword">void</span> *)_I_ViewController_setNum_&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">class_ro_t</span> _<span class="title">OBJC_METACLASS_RO_</span>$_<span class="title">ViewController</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>,__<span class="title">objc_const</span>"))) = &#123;</span></span><br><span class="line">	<span class="number">1</span>, <span class="keyword">sizeof</span>(struct <span class="keyword">_class_t</span>), <span class="keyword">sizeof</span>(struct <span class="keyword">_class_t</span>), </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="string">"ViewController"</span>,</span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">class_ro_t</span> _<span class="title">OBJC_CLASS_RO_</span>$_<span class="title">ViewController</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>,__<span class="title">objc_const</span>"))) = &#123;</span></span><br><span class="line">	<span class="number">0</span>, __OFFSETOFIVAR__(struct ViewController, _str), <span class="keyword">sizeof</span>(struct ViewController_IMPL), </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="string">"ViewController"</span>,</span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_INSTANCE_METHODS_ViewController,</span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_ivar_list_t</span> *)&amp;_OBJC_$_INSTANCE_VARIABLES_ViewController,</span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> <span class="title">OBJC_METACLASS_</span>$_<span class="title">UIViewController</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> <span class="title">OBJC_METACLASS_</span>$_<span class="title">NSObject</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> <span class="title">OBJC_METACLASS_</span>$_<span class="title">ViewController</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>,__<span class="title">objc_data</span>"))) = &#123;</span></span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_METACLASS_$_NSObject,</span></span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_METACLASS_$_UIViewController,</span></span><br><span class="line">	<span class="number">0</span>, <span class="comment">// (void *)&amp;_objc_empty_cache,</span></span><br><span class="line">	<span class="number">0</span>, <span class="comment">// unused, was (void *)&amp;_objc_empty_vtable,</span></span><br><span class="line">	&amp;_OBJC_METACLASS_RO_$_ViewController,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> <span class="title">OBJC_CLASS_</span>$_<span class="title">UIViewController</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> <span class="title">OBJC_CLASS_</span>$_<span class="title">ViewController</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>,__<span class="title">objc_data</span>"))) = &#123;</span></span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_METACLASS_$_ViewController,</span></span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_UIViewController,</span></span><br><span class="line">	<span class="number">0</span>, <span class="comment">// (void *)&amp;_objc_empty_cache,</span></span><br><span class="line">	<span class="number">0</span>, <span class="comment">// unused, was (void *)&amp;_objc_empty_vtable,</span></span><br><span class="line">	&amp;_OBJC_CLASS_RO_$_ViewController,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> OBJC_CLASS_SETUP_$_ViewController(<span class="keyword">void</span> ) &#123;</span><br><span class="line">	OBJC_METACLASS_$_ViewController.isa = &amp;OBJC_METACLASS_$_NSObject;</span><br><span class="line">	OBJC_METACLASS_$_ViewController.superclass = &amp;OBJC_METACLASS_$_UIViewController;</span><br><span class="line">	OBJC_METACLASS_$_ViewController.cache = &amp;_objc_empty_cache;</span><br><span class="line">	OBJC_CLASS_$_ViewController.isa = &amp;OBJC_METACLASS_$_ViewController;</span><br><span class="line">	OBJC_CLASS_$_ViewController.superclass = &amp;OBJC_CLASS_$_UIViewController;</span><br><span class="line">	OBJC_CLASS_$_ViewController.cache = &amp;_objc_empty_cache;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">".objc_inithooks$B"</span>, long, read, write)</span></span><br><span class="line">__declspec(allocate(<span class="string">".objc_inithooks$B"</span>)) <span class="keyword">static</span> <span class="keyword">void</span> *OBJC_CLASS_SETUP[] = &#123;</span><br><span class="line">	(<span class="keyword">void</span> *)&amp;OBJC_CLASS_SETUP_$_ViewController,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> *<span class="title">L_OBJC_LABEL_CLASS_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>, __<span class="title">objc_classlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>")))= &#123;</span></span><br><span class="line">	&amp;OBJC_CLASS_$_ViewController,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_INFO</span> &#123;</span> <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>



<p>在上述 setter 方法中可以看到，copy修饰的不可变系统类属性会调用用objc_setProperty方法，但是其它属性所有权修饰符修饰的属性都是直接复制。</p>
<p>在runtime源码的<code>objc-accessors.mm</code>文件中， <code>objc_setProperty</code> 方法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setProperty</span><span class="params">(id self, SEL _cmd, <span class="keyword">ptrdiff_t</span> offset, id newValue, BOOL atomic, <span class="keyword">signed</span> <span class="keyword">char</span> shouldCopy)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> copy = (shouldCopy &amp;&amp; shouldCopy != MUTABLE_COPY);</span><br><span class="line">    <span class="keyword">bool</span> mutableCopy = (shouldCopy == MUTABLE_COPY);</span><br><span class="line">    reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法会确定下一个方法的入参是 copy 还是 mutableCopy，然后调用 <code>reallySetProperty</code> 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reallySetProperty</span><span class="params">(id self, SEL _cmd, id newValue, <span class="keyword">ptrdiff_t</span> offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> copy, <span class="keyword">bool</span> mutableCopy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((<span class="keyword">char</span>*)self + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>方法首先会判断，如果偏移为0，说明是要更新当前类，调用 <code>object_setClass</code> 来初始化类，然后更新 isa。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* object_setClass.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">Class <span class="title">object_setClass</span><span class="params">(id obj, Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent a deadlock between the weak reference machinery</span></span><br><span class="line">    <span class="comment">// and the +initialize machinery by ensuring that no </span></span><br><span class="line">    <span class="comment">// weakly-referenced object has an un-+initialized isa.</span></span><br><span class="line">    <span class="comment">// Unresolved future classes are not so protected.</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isFuture()  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        <span class="comment">// use lookUpImpOrForward to indirectly provoke +initialize</span></span><br><span class="line">        <span class="comment">// to avoid duplicating the code to actually send +initialize</span></span><br><span class="line">        lookUpImpOrForward(cls, SEL_initialize, nil,</span><br><span class="line">                           YES<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj-&gt;changeIsa(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据偏移获取当前属性值</p>
</li>
<li><p>根据入参判断，如果入参 copy 为 true，调用 <code>copyWithZone:</code>方法，如果入参 mutableCopy 为 true，调用 <code>mutableCopyWithZone:</code>方法，否则，判断如果新属性值和旧值相等，调用 <code>objc_retain(newValue)</code>，增加引用计数</p>
</li>
<li><p>判断入参atomic，如果不为true，则保存旧属性值为oldValue，并使用新值更新属性值；否则，在进行前面操作的同时，使用PropertyLocks进行加锁，保证操作的原子性</p>
</li>
<li><p>调用 <code>objc_release</code> 释放旧值</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>参考：</p>
<ul>
<li><a href="http://book.douban.com/subject/10536953/" target="_blank" rel="noopener">Pro Multithreading and Memory Management for iOS and OS X</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011-SW1" target="_blank" rel="noopener">Advanced Memory Management Programming Guide</a></li>
<li><a href="https://juejin.cn/post/6844903443379798030" target="_blank" rel="noopener">深入理解 GCD</a></li>
<li><a href="https://juejin.cn/post/6844904063465685000" target="_blank" rel="noopener">https://juejin.cn/post/6844904063465685000</a></li>
<li><a href="https://draveness.me/autoreleasepool/#AutoreleasePoolPage" target="_blank" rel="noopener">https://draveness.me/autoreleasepool/#AutoreleasePoolPage</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2018/08/10/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRunloop/" rel="next" title="「刨根问底」之RunLoop">
      「刨根问底」之RunLoop <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是内存管理"><span class="nav-number">1.</span> <span class="nav-text">什么是内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理实现"><span class="nav-number">2.</span> <span class="nav-text">内存管理实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理源码探究"><span class="nav-number">3.</span> <span class="nav-text">内存管理源码探究</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数存储"><span class="nav-number">3.1.</span> <span class="nav-text">引用计数存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象引用计数存储"><span class="nav-number">3.1.1.</span> <span class="nav-text">对象引用计数存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tagged-Pointer"><span class="nav-number">3.1.2.</span> <span class="nav-text">Tagged Pointer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取引用计数"><span class="nav-number">3.2.</span> <span class="nav-text">获取引用计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成对象"><span class="nav-number">3.3.</span> <span class="nav-text">生成对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#alloc"><span class="nav-number">3.3.1.</span> <span class="nav-text">alloc</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#问题："><span class="nav-number">3.3.1.1.</span> <span class="nav-text">问题：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、从调用栈中可以看到-NSObject-是有-alloc-类方法的，那么我们外部所写的-NSObject-alloc-为什么不调用-alloc-类方法-反而来到了-objc-alloc-中呢？"><span class="nav-number">3.3.1.1.1.</span> <span class="nav-text">1、从调用栈中可以看到 NSObject 是有 alloc 类方法的，那么我们外部所写的 [NSObject alloc] 为什么不调用 alloc 类方法 , 反而来到了 objc_alloc 中呢？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、为什么-alloc-没有设置引用计数值为-1呢？"><span class="nav-number">3.3.1.1.2.</span> <span class="nav-text">2、为什么 alloc 没有设置引用计数值为 1呢？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#init"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">init</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new"><span class="nav-number">3.3.2.</span> <span class="nav-text">new</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy-和-mutableCopy"><span class="nav-number">3.3.3.</span> <span class="nav-text">copy 和 mutableCopy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持有对象"><span class="nav-number">3.4.</span> <span class="nav-text">持有对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#释放对象"><span class="nav-number">3.5.</span> <span class="nav-text">释放对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#销毁对象"><span class="nav-number">3.6.</span> <span class="nav-text">销毁对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#autoreleasepool"><span class="nav-number">4.</span> <span class="nav-text">autoreleasepool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#autoreleasepool-1"><span class="nav-number">4.1.</span> <span class="nav-text">@autoreleasepool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AutoreleasePoolPage"><span class="nav-number">4.2.</span> <span class="nav-text">AutoreleasePoolPage</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动释放池中的栈"><span class="nav-number">4.2.1.</span> <span class="nav-text">自动释放池中的栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#POOL-SENTINEL（哨兵对象）"><span class="nav-number">4.2.2.</span> <span class="nav-text">POOL_SENTINEL（哨兵对象）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AutoreleasePoolPage双向链表"><span class="nav-number">4.2.3.</span> <span class="nav-text">AutoreleasePoolPage双向链表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objc-autoreleasePoolPush-方法"><span class="nav-number">4.3.</span> <span class="nav-text">objc_autoreleasePoolPush 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objc-autoreleasePoolPop-方法"><span class="nav-number">4.4.</span> <span class="nav-text">objc_autoreleasePoolPop 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objc-autoreleaseReturnValue优化"><span class="nav-number">4.5.</span> <span class="nav-text">objc_autoreleaseReturnValue优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Autorelease-释放时机"><span class="nav-number">4.6.</span> <span class="nav-text">Autorelease 释放时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题案例"><span class="nav-number">4.7.</span> <span class="nav-text">问题案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性Property"><span class="nav-number">5.</span> <span class="nav-text">属性Property</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#所有权修饰符"><span class="nav-number">5.1.</span> <span class="nav-text">所有权修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性"><span class="nav-number">5.2.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Property源码探究"><span class="nav-number">5.3.</span> <span class="nav-text">Property源码探究</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">和僧</p>
  <div class="site-description" itemprop="description">技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">和僧</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
