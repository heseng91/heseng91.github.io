<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heseng91.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="上篇文章Runtime类和对象的定义 中提到了源代码到可执行文件需要需要经过编译和链接。其中编译通常会先预处理，再编译。iOS中预编译是使用Clang完成的。">
<meta property="og:type" content="article">
<meta property="og:title" content="刨根问底」之Runtime消息发送和转发">
<meta property="og:url" content="http://heseng91.github.io/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/index.html">
<meta property="og:site_name" content="和僧">
<meta property="og:description" content="上篇文章Runtime类和对象的定义 中提到了源代码到可执行文件需要需要经过编译和链接。其中编译通常会先预处理，再编译。iOS中预编译是使用Clang完成的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://heseng91.github.io/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/dispatch_table.gif">
<meta property="og:image" content="http://heseng91.github.io/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/runtime%E4%B9%8B%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B.png">
<meta property="article:published_time" content="2018-12-04T08:30:33.000Z">
<meta property="article:modified_time" content="2022-07-25T19:29:06.791Z">
<meta property="article:author" content="和僧">
<meta property="article:tag" content="和僧-技术博客，技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://heseng91.github.io/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/dispatch_table.gif">

<link rel="canonical" href="http://heseng91.github.io/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>刨根问底」之Runtime消息发送和转发 | 和僧</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">和僧</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://heseng91.github.io/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="和僧">
      <meta itemprop="description" content="技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和僧">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          刨根问底」之Runtime消息发送和转发
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-04 16:30:33" itemprop="dateCreated datePublished" datetime="2018-12-04T16:30:33+08:00">2018-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 03:29:06" itemprop="dateModified" datetime="2022-07-26T03:29:06+08:00">2022-07-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/" itemprop="url" rel="index"><span itemprop="name">刨根问底</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>上篇文章<a href="https://heseng91.github.io/2021/10/31/刨根问底之-Runtime类和对象的定义/">Runtime类和对象的定义</a> 中提到了源代码到可执行文件需要需要经过编译和链接。其中编译通常会先预处理，再编译。iOS中预编译是使用Clang完成的。</p>
<a id="more"></a>

<p>下面新建一个工程并修改一下main.m文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit&#x2F;UIKit.h&gt;</span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        UIViewController *vc &#x3D; [[UIViewController alloc] init];</span><br><span class="line">        [vc viewDidLoad];</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开终端，cd到工程目录，然后执行如下命令，对源文件进行clang rewrite，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator13.2 clang -rewrite-objc -F &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneOS13.2.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneOS.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks SecondViewController.m</span><br></pre></td></tr></table></figure>

<p>iphonesimulator13.2中 13.2 为当前xcode SDK版本号（指令xcodebuild -showsdks即可查看），在得到的main.cpp文件末尾，可以找到源代码clang后的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        UIViewController *vc = ((UIViewController *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((UIViewController *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"UIViewController"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)vc, sel_registerName(<span class="string">"viewDidLoad"</span>));</span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"AppDelegate"</span>), sel_registerName(<span class="string">"class"</span>))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中可以得知:  <code>[receiver message]</code> 其实会被编译器转化为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure>

<p>本篇就来详细分析一下Objective-C消息发送和转发机制。</p>
<p>消息发送和转发流程可以概括为：</p>
<ol>
<li><p>消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现；</p>
</li>
<li><p>消息转发（Message Forwarding）是在查找 IMP 失败后执行一系列转发流程的慢速通道，如果不作转发处理，则会打日志和抛出异常。</p>
</li>
</ol>
<p>本文将从源码角度分析消息发送和转发的原理。能够很好地阅读本文的前提是你对 <a href="https://heseng91.github.io/2021/10/31/刨根问底之-Runtime类和对象的定义/">Objective-C Runtime</a> 已经有一定的了解，关于什么是消息，Class 的结构，selector、IMP、元类等概念将不再赘述。本文用到的源码为  objc4-756.2，汇编语言架构为 arm64。</p>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><h3 id="函数简介"><a href="#函数简介" class="headerlink" title="函数简介"></a>函数简介</h3><p>此函数是消息发送必经之路。objc_msgSend函数究竟会干什么事情呢？从这篇<a href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/" target="_blank" rel="noopener">「objc_msgSend() Tour」</a>文章里面可以得到一个比较详细的结论。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. Check for ignored selectors (GC) and short-circuit.</span><br><span class="line"><span class="number">2.</span> Check <span class="keyword">for</span> nil target.</span><br><span class="line">   If nil &amp; nil receiver handler configured, jump to handler</span><br><span class="line">   If nil &amp; no handler (default), cleanup and return.</span><br><span class="line"><span class="number">3.</span> Search the <span class="class"><span class="keyword">class</span>’<span class="title">s</span> <span class="title">method</span> <span class="title">cache</span> <span class="title">for</span> <span class="title">the</span> <span class="title">method</span> <span class="title">IMP</span>(<span class="title">use</span> <span class="title">hash</span> <span class="title">to</span> <span class="title">find</span>&amp;<span class="title">store</span> <span class="title">method</span> <span class="title">in</span> <span class="title">cache</span>)</span></span><br><span class="line"><span class="class">   -1. <span class="title">If</span> <span class="title">found</span>, <span class="title">jump</span> <span class="title">to</span> <span class="title">it</span>.</span></span><br><span class="line"><span class="class">   -2. <span class="title">Not</span> <span class="title">found</span>:</span> lookup the method IMP in the <span class="class"><span class="keyword">class</span> <span class="title">itself</span> <span class="title">corresponding</span> <span class="title">its</span> <span class="title">hierarchy</span> <span class="title">chain</span>.</span></span><br><span class="line"><span class="class">       <span class="title">If</span> <span class="title">found</span>, <span class="title">load</span> <span class="title">it</span> <span class="title">into</span> <span class="title">cache</span> <span class="title">and</span> <span class="title">jump</span> <span class="title">to</span> <span class="title">it</span>.</span></span><br><span class="line"><span class="class">       <span class="title">If</span> <span class="title">not</span> <span class="title">found</span>, <span class="title">jump</span> <span class="title">to</span> <span class="title">forwarding</span> <span class="title">mechanism</span>.</span></span><br></pre></td></tr></table></figure>

<p>总结一下objc_msgSend会做以下几件事情：</p>
<ol>
<li><p>检测这个 selector是不是要忽略的。</p>
</li>
<li><p>检查target是不是为nil。</p>
<p>如果这里有相应的nil的处理函数，就跳转到相应的函数中。<br>如果没有处理nil的函数，就自动清理现场并返回。这一点就是为何在OC中给nil发送消息不会崩溃的原因。</p>
</li>
<li><p>确定不是给nil发消息之后，在该class的缓存中查找方法对应的IMP实现。</p>
<p>如果找到，就跳转进去执行。<br>如果没有找到，就在方法分发表里面继续查找，一直找到NSObject为止。</p>
</li>
</ol>
<img src="/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/dispatch_table.gif" class title="dispatch_table">

<ol start="4">
<li>如果还没有找到，那就需要开始消息转发阶段了。至此，发送消息Messaging阶段完成。这一阶段主要完成的是通过selecter快速查找IMP的过程。</li>
</ol>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>在这篇文章<a href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html" target="_blank" rel="noopener">Obj-C Optimization: The faster objc_msgSend</a>中看到了这样一段C版本的objc_msgSend的源码。</p>
<p>Objective-C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;objc/objc-runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">id  <span class="title">c_objc_msgSend</span><span class="params">( struct objc_class <span class="comment">/* ahem */</span> *self, SEL _cmd, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span>    *<span class="title">cls</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span>    *<span class="title">cache</span>;</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span>         hash;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span>   *<span class="title">method</span>;</span>   </span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span>         index;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>( self)</span><br><span class="line">   &#123;</span><br><span class="line">      cls   = self-&gt;isa;</span><br><span class="line">      cache = cls-&gt;cache;</span><br><span class="line">      hash  = cache-&gt;mask;</span><br><span class="line">      index = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) _cmd &amp; hash;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">         method = cache-&gt;buckets[ index];</span><br><span class="line">         <span class="keyword">if</span>( ! method)</span><br><span class="line">            <span class="keyword">goto</span> recache;</span><br><span class="line">         index = (index + <span class="number">1</span>) &amp; cache-&gt;mask;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>( method-&gt;method_name != _cmd);</span><br><span class="line">      <span class="keyword">return</span>( (*method-&gt;method_imp)( (id) self, _cmd));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>( (id) self);</span><br><span class="line"></span><br><span class="line">recache:</span><br><span class="line">   <span class="comment">/* ... */</span></span><br><span class="line">   <span class="keyword">return</span>( <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该源码中有一个do-while循环，这个循环就是前面提到的在方法分发表里面查找method的过程。</p>
<h4 id="objc-msgSend源码分析"><a href="#objc-msgSend源码分析" class="headerlink" title="_objc_msgSend源码分析"></a><code>_objc_msgSend</code>源码分析</h4><p>不过在 objc4-756.2里面<code>objc_msgSend</code> 是用汇编语言写的，针对不同架构有不同的实现。objc-msg-arm64.s文件中实现是如下一段汇编代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; objc_msgSend 汇编入口</span><br><span class="line">  ENTRY _objc_msgSend </span><br><span class="line">&#x2F;&#x2F; 无窗口</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; p0：objc_msgSend的第一个参数，即消息接受者</span><br><span class="line">&#x2F;&#x2F; cmp: 比较</span><br><span class="line">&#x2F;&#x2F; #0：nil</span><br><span class="line">&#x2F;&#x2F; 判断p0是否为空</span><br><span class="line">	cmp	p0, #0			&#x2F;&#x2F; nil check and tagged pointer check</span><br><span class="line">&#x2F;&#x2F;  支持taggedpointer的流程</span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">&#x2F;&#x2F; b.le: 执行标号，判断上面cmp值是小于等于，如果receiver为nil或taggedpointer，则执行LNilOrTagged</span><br><span class="line">	b.le	LNilOrTagged		&#x2F;&#x2F;  (MSB tagged pointer looks negative)</span><br><span class="line">#else</span><br><span class="line">&#x2F;&#x2F; b.eq: 执行标号，判断上面cmp值是等于，如果receiver为nil，则执行LReturnZero</span><br><span class="line">&#x2F;&#x2F; p0为空，返回空</span><br><span class="line">	b.eq	LReturnZero</span><br><span class="line">#endif</span><br><span class="line">&#x2F;&#x2F; p0不为空，即receiver 存在的流程</span><br><span class="line">&#x2F;&#x2F; ldr 把数据从内存中某处读取到寄存器</span><br><span class="line">&#x2F;&#x2F; p13 &#x3D; x0栈内存中的值，从x0寄存器指向的地址中取出 isa，并把isa赋值给p13</span><br><span class="line">	ldr	p13, [x0]		&#x2F;&#x2F; p13 &#x3D; isa</span><br><span class="line">&#x2F;&#x2F; 在64位架构下通过 p16 &#x3D; isa（p13） &amp; ISA_MASK，获取shiftcls，从而得到class信息</span><br><span class="line">	GetClassFromIsa_p16 p13		&#x2F;&#x2F; p16 &#x3D; class</span><br><span class="line">LGetIsaDone:</span><br><span class="line">&#x2F;&#x2F; 如果isa存在，调用CacheLookup，开始cache查找流程(快速查找流程sel-&gt;imp)</span><br><span class="line">&#x2F;&#x2F; 找到就返回imp，没找到就返回objc_msgSend_uncached</span><br><span class="line">	CacheLookup NORMAL		&#x2F;&#x2F; calls imp or objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 支持taggedpointer</span><br><span class="line">#if SUPPORT_TAGGED_POINTERS</span><br><span class="line">&#x2F;&#x2F; LNilOrTagged条件判断逻辑</span><br><span class="line">LNilOrTagged:</span><br><span class="line">&#x2F;&#x2F; 等于空，返回空</span><br><span class="line">	b.eq	LReturnZero		&#x2F;&#x2F; nil check</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; tagged</span><br><span class="line">	&#x2F;&#x2F; adrp 计算指定的数据地址到当前pc寄存器值相对偏移</span><br><span class="line">	&#x2F;&#x2F; 得到包含_objc_debug_taggedpointer_classes地址的page的基址，arm64架构中page大小为16kb。</span><br><span class="line">	&#x2F;&#x2F; 并将该page的基址存到寄存器X10中；</span><br><span class="line">	adrp	x10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class="line">	&#x2F;&#x2F; add 加</span><br><span class="line">	&#x2F;&#x2F; x10 &#x3D; x10 + _objc_debug_taggedpointer_classes@PAGEOFF（偏移量）</span><br><span class="line">	&#x2F;&#x2F; 即计算出_objc_debug_taggedpointer_classes的地址，并存到寄存器X10中</span><br><span class="line">	add	x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br><span class="line">	&#x2F;&#x2F; ubfx 无符号位段提取（ubfx Xd, Xn, #lsb, #width。表示从Wn寄存器的第lsb位开始，提取width位到Wd寄存器，剩余高位用0填充）</span><br><span class="line">	&#x2F;&#x2F; 从x0寄存器的第60位开始，提取4位到x11寄存器，剩余高位用0填充，即提取指针的最后四位（标记tagged pointer的位）存到x11寄存器</span><br><span class="line">	ubfx	x11, x0, #60, #4</span><br><span class="line">	&#x2F;&#x2F; ldr 加载字到寄存器</span><br><span class="line">	&#x2F;&#x2F; lsl 逻辑或算术左移</span><br><span class="line">	&#x2F;&#x2F; x16 &#x3D; x10 + (x11&lt;&lt;3)， 获取taggedpointer标识位，并存到x16寄存器</span><br><span class="line">	ldr	x16, [x10, x11, LSL #3]</span><br><span class="line">	adrp	x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE</span><br><span class="line">	add	x10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF</span><br><span class="line">	cmp	x10, x16</span><br><span class="line">	&#x2F;&#x2F; b.ne 判断上面cmp的值是不等于 执行标号，否则直接往下走</span><br><span class="line">	b.ne	LGetIsaDone</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; ext tagged</span><br><span class="line">	adrp	x10, _objc_debug_taggedpointer_ext_classes@PAGE</span><br><span class="line">	add	x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</span><br><span class="line">	ubfx	x11, x0, #52, #8</span><br><span class="line">	ldr	x16, [x10, x11, LSL #3]</span><br><span class="line">	b	LGetIsaDone</span><br><span class="line">&#x2F;&#x2F; SUPPORT_TAGGED_POINTERS</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">LReturnZero:</span><br><span class="line">	&#x2F;&#x2F; x0 is already zero</span><br><span class="line">	&#x2F;&#x2F; 1、首先先把 x1 清空，x0 这里是 self，已经是0，所以不需要清空</span><br><span class="line">	mov	x1, #0 </span><br><span class="line">	&#x2F;&#x2F; 2、清空 v 寄存器</span><br><span class="line">	movi	d0, #0 </span><br><span class="line">	movi	d1, #0</span><br><span class="line">	movi	d2, #0</span><br><span class="line">	movi	d3, #0</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure>

<p>主要有以下几步</p>
<p>【第一步】判断<code>objc_msgSend</code>方法的第一个参数<code>receiver</code>是否为空</p>
<ol>
<li><p>判断<code>receiver</code>如果为空，则直接返回空，即<code>LReturnZero</code>；</p>
</li>
<li><p>如果支持<code>tagged pointer</code>对象，判断如果为<code>tagged pointer</code>对象，跳转至【第二步】</p>
</li>
<li><p>否则，如果<code>receiver</code>不为<code>tagged pointer</code>对象且不为空，从<code>receiver</code>中取出<code>isa</code>存入<code>p13</code>寄存器，</p>
</li>
<li><p>通过 <code>GetClassFromIsa_p16</code>中，<code>arm64</code>架构下通过 <code>isa &amp; ISA_MASK</code> 获取<code>shiftcls</code>位域的类信息，即<code>class</code>，<code>GetClassFromIsa_p16</code>的汇编实现如下：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; .macro 汇编宏定义</span><br><span class="line">.macro GetClassFromIsa_p16 &#x2F;* src *&#x2F;</span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">&#x2F;&#x2F; mov指令是数据传送指令，用于将一个数据从源地址传送到目标地址，其特点是不破坏源地址单元的内容。</span><br><span class="line">&#x2F;&#x2F; 把传入的值src赋值给p16寄存器，p16 &#x3D; class</span><br><span class="line">		&#x2F;&#x2F; Indexed isa</span><br><span class="line">    mov	p16, $0			&#x2F;&#x2F; optimistically set dst &#x3D; src</span><br><span class="line">&#x2F;&#x2F; #   define ISA_INDEX_IS_NPI_BIT  0</span><br><span class="line">&#x2F;&#x2F; tbz 条件执行</span><br><span class="line">&#x2F;&#x2F; 判断p16寄存器中存储的class指针最后一位如果不为0，即如果是tagged pointer，则直接跳转到1，直接结束</span><br><span class="line">    tbz	p16, #ISA_INDEX_IS_NPI_BIT, 1f	&#x2F;&#x2F; done if not non-pointer isa</span><br><span class="line">&#x2F;&#x2F; adrp 计算指定的数据地址到当前pc寄存器值相对偏移</span><br><span class="line">	&#x2F;&#x2F; 得到包含_objc_indexed_classes地址的page的基址，arm64架构中page大小为16kb。</span><br><span class="line">	&#x2F;&#x2F; 并将该page的基址存到寄存器X10中；</span><br><span class="line">		&#x2F;&#x2F; isa in p16 is indexed</span><br><span class="line">    adrp	x10, _objc_indexed_classes@PAGE</span><br><span class="line">&#x2F;&#x2F; x10 &#x3D; x10 + _objc_indexed_classes@PAGEOFF（_objc_indexed_classes在page中的偏移量），即计算出_objc_debug_taggedpointer_classes的地址，并存到寄存器X10中</span><br><span class="line">    add	x10, x10, _objc_indexed_classes@PAGEOFF</span><br><span class="line">&#x2F;&#x2F;  ubfx:有符号和无符号位域提取。 将一个寄存器中相邻的位复制到另一个寄存器的最低有效位，并用符号或零扩展到 32 位。</span><br><span class="line">&#x2F;&#x2F;  从p16的第ISA_INDEX_SHIFT位开始，提取 ISA_INDEX_BITS 位 到 p16寄存器，剩余的高位用0补充</span><br><span class="line">&#x2F;&#x2F; #   define ISA_INDEX_SHIFT       2</span><br><span class="line">&#x2F;&#x2F; #   define ISA_INDEX_BITS        15</span><br><span class="line">&#x2F;&#x2F; 从p16寄存器的第2位开始，提取15位到p16寄存器，剩余高位用0填充</span><br><span class="line">    ubfx	p16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS  &#x2F;&#x2F; extract index</span><br><span class="line">&#x2F;&#x2F; #define PTRSHIFT 3  &#x2F;&#x2F; 1&lt;&lt;PTRSHIFT &#x3D;&#x3D; PTRSIZE</span><br><span class="line">&#x2F;&#x2F; #define UXTP UXTX</span><br><span class="line">    ldr	p16, [x10, p16, UXTP #PTRSHIFT]	&#x2F;&#x2F; load class from array</span><br><span class="line">1:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  如果是64位</span><br><span class="line">#elif __LP64__</span><br><span class="line">	&#x2F;&#x2F; 64-bit packed isa</span><br><span class="line">&#x2F;&#x2F;  p16 &#x3D; class &#x3D; isa &amp; ISA_MASK(位运算 &amp; 即获取isa中的shiftcls信息)</span><br><span class="line">    and	p16, $0, #ISA_MASK</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">    &#x2F;&#x2F; 32-bit raw isa</span><br><span class="line">    mov p16, $0</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">&#x2F;&#x2F;  宏定义结束</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>然后走到【第二步】</p>
<p>【第二步】获取isa完毕，调用<code>CacheLookup NORMAL</code>在缓存中查找方法。</p>
<h4 id="CacheLookup源码分析"><a href="#CacheLookup源码分析" class="headerlink" title="CacheLookup源码分析"></a><code>CacheLookup</code>源码分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  定义CacheLookup宏</span><br><span class="line">.macro CacheLookup</span><br><span class="line">	&#x2F;&#x2F;  ldp:从栈取&#x2F;存数据</span><br><span class="line">    &#x2F;&#x2F;  #define CACHE (2 * __SIZEOF_POINTER__)，其中 __SIZEOF_POINTER__表示pointer的大小 ，即 2*8 &#x3D; 16</span><br><span class="line">    &#x2F;&#x2F;  p11 &#x3D; mask|buckets，从x16（即isa）中平移16字节，获取cache地址。isa距离cache 正好16字节：isa（8字节）+ superClass（8字节）</span><br><span class="line">    &#x2F;&#x2F; 从cache中分别取出 buckets 和 occupied|mask 存入 p10（存储buckets） 和 p11（存储occupied|mask）</span><br><span class="line">    &#x2F;&#x2F; p1 &#x3D; SEL, p16 &#x3D; isa</span><br><span class="line">	ldp	p10, p11, [x16, #CACHE]	&#x2F;&#x2F; p10 &#x3D; buckets, p11 &#x3D; occupied|mask</span><br><span class="line">#if !__LP64__</span><br><span class="line">	and	w11, w11, 0xffff	&#x2F;&#x2F; p11 &#x3D; mask</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;&#x2F; and 按位“与”操作，key &amp; mask得到cache_hash</span><br><span class="line">	and	w12, w1, w11		&#x2F;&#x2F; x12 &#x3D; _cmd &amp; mask</span><br><span class="line">	add	p12, p10, p12, LSL #(1+PTRSHIFT)</span><br><span class="line">		             &#x2F;&#x2F; p12 &#x3D; buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;  从x12（即p12）中取出 bucket 分别将imp和sel 存入 p17（存储imp） 和 p9（存储sel）</span><br><span class="line">	ldp	p17, p9, [x12]		&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  比较 sel 与 p1（传入的参数cmd）</span><br><span class="line">1:	cmp	p9, p1			&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">    &#x2F;&#x2F;  如果不相等，即没有找到，跳转至 2f</span><br><span class="line">	b.ne	2f			&#x2F;&#x2F;     scan more</span><br><span class="line">    &#x2F;&#x2F;  如果相等，即缓存命中，执行cacheHit直接调用或返回imp</span><br><span class="line">	CacheHit $0			&#x2F;&#x2F; call or return imp</span><br><span class="line">	</span><br><span class="line">2:	&#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket</span><br><span class="line">    &#x2F;&#x2F;  如果一直都找不到，因为是normal，跳转至__objc_msgSend_uncached</span><br><span class="line">	CheckMiss $0			&#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0</span><br><span class="line">    &#x2F;&#x2F;  判断p12（当前的bucket）是否 是 p10（buckets数组第一个元素，）</span><br><span class="line">	cmp	p12, p10		&#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets</span><br><span class="line">    &#x2F;&#x2F;  如果想等，跳转至 3f</span><br><span class="line">	b.eq	3f</span><br><span class="line">    &#x2F;&#x2F;  从x12（即p12 buckets首地址）- 实际需要平移的内存大小BUCKET_SIZE，得到得到第二个bucket元素，imp-sel分别存入p17-p9，即向前查找</span><br><span class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket</span><br><span class="line">    &#x2F;&#x2F;  跳转至第1步，继续对比 sel 与 cmd</span><br><span class="line">	b	1b			&#x2F;&#x2F; loop</span><br><span class="line"></span><br><span class="line">3:	&#x2F;&#x2F; wrap: p12 &#x3D; first bucket, w11 &#x3D; mask</span><br><span class="line">    &#x2F;&#x2F; mask左移4位，直接定位到buckets的最后一个元素，缓存查找顺序是向前查找</span><br><span class="line">	add	p12, p12, w11, UXTW #(1+PTRSHIFT)</span><br><span class="line">		                        &#x2F;&#x2F; p12 &#x3D; buckets + (mask &lt;&lt; 1+PTRSHIFT)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Clone scanning loop to miss instead of hang when cache is corrupt.</span><br><span class="line">	&#x2F;&#x2F; The slow path may detect any corruption and halt later.</span><br><span class="line"></span><br><span class="line">	ldp	p17, p9, [x12]		&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket</span><br><span class="line">1:	cmp	p9, p1			&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">	b.ne	2f			&#x2F;&#x2F;     scan more</span><br><span class="line">	CacheHit $0			&#x2F;&#x2F; call or return imp</span><br><span class="line">	</span><br><span class="line">2:	&#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket</span><br><span class="line">    &#x2F;&#x2F;  判断p12（当前遍历到的bucket）是否等于 p10（buckets数组第一个元素）即前面已经没有了</span><br><span class="line">	CheckMiss $0			&#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0</span><br><span class="line">	cmp	p12, p10		&#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets</span><br><span class="line">	b.eq	3f</span><br><span class="line">    &#x2F;&#x2F;  偏移获取前一个bucket，并取出imp和sel分别存入p17、p9，即向前查找</span><br><span class="line">	ldp	p17, p9, [x12, #-BUCKET_SIZE]!	&#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket</span><br><span class="line">    &#x2F;&#x2F;  跳转至第1步，继续对比 sel 与 cmd</span><br><span class="line">	b	1b			&#x2F;&#x2F; loop</span><br><span class="line"></span><br><span class="line">3:	&#x2F;&#x2F; double wrap</span><br><span class="line">    &#x2F;&#x2F;  跳转至JumpMiss 因为是normal ，跳转至__objc_msgSend_uncached</span><br><span class="line">	JumpMiss $0</span><br><span class="line">	</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>主要分为以下几步</p>
<p>【第一步】通过<code>isa</code>首地址平移<code>16</code>字节（因为在objc_class中，<code>首地址</code>距离<code>cache</code>正好<code>16</code>字节，即<code>isa首地址</code> 占<code>8</code>字节，<code>superClass</code>占<code>8</code>字节），获取<code>cahce</code>，并将cache中的<code>buckets</code>存放到p10寄存器中，将cache中的<code>occupied|mask</code>存放到p11寄存器中</p>
<p>【第二步】由mask根据哈希算法计算出下标</p>
<ol>
<li>将<code>objc_msgSend</code>的参数<code>p1</code>（即第二个参数_cmd）和p11中存放的<code>msak</code>进行&amp;运算，得到需要查找存储sel-imp的bucket下标index，即<code>p12 = index = _cmd &amp; mask</code>。</li>
</ol>
<p>【第三步】根据所得的<code>哈希下标index</code> 和 <code>buckets首地址</code>，取出哈希下标对应的<code>bucket</code>，并存放到p12寄存器中<code>p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</code></p>
<ol>
<li><p>其中<code>PTRSHIFT</code>等于3，左移4位（即2^4 = 16字节）即是一个<code>bucket</code>实际占用的大小,结构体<code>bucket_t</code>中<code>sel</code>占<code>8</code>字节，<code>imp</code>占<code>8</code>字节</p>
</li>
<li><p>根据计算的哈希下标<code>index</code> 乘以单个<code>bucket</code>占用的内存大小，得到<code>bucket</code>相当于<code>buckets</code>首地址的<code>偏移量</code></p>
</li>
<li><p>通过<code>首地址 + 实际偏移量</code>，获取哈希下标index对应的<code>bucket</code></p>
</li>
</ol>
<p>【第四步】根据获取的<code>bucket</code>，取出其中的<code>imp</code>和<code>sel</code>分别存入p17和p9寄存器</p>
<p>【第五步】遍历<code>buckets</code>查找缓存的方法</p>
<ol>
<li><p>比较sel和传入的参数cmd是否相等，如果不相等，即没找到，执行下一步，否则如果相等，即缓存命中，执行<code>CacheHit</code>函数返回imp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; CacheHit: x17 &#x3D; cached IMP, x12 &#x3D; address of cached IMP, x1 &#x3D; SEL</span><br><span class="line">.macro CacheHit</span><br><span class="line">.if $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	TailCallCachedImp x17, x12, x1	&#x2F;&#x2F; authenticate and call imp</span><br><span class="line">.elseif $0 &#x3D;&#x3D; GETIMP</span><br><span class="line">	mov	p0, p17</span><br><span class="line">	cbz	p0, 9f			&#x2F;&#x2F; don&#39;t ptrauth a nil imp</span><br><span class="line">	AuthAndResignAsIMP x0, x12, x1	&#x2F;&#x2F; authenticate imp and re-sign as IMP</span><br><span class="line">9:	ret				&#x2F;&#x2F; return IMP</span><br><span class="line">.elseif $0 &#x3D;&#x3D; LOOKUP</span><br><span class="line">	&#x2F;&#x2F; No nil check for ptrauth: the caller would crash anyway when they</span><br><span class="line">	&#x2F;&#x2F; jump to a nil IMP. We don&#39;t care if that jump also fails ptrauth.</span><br><span class="line">	AuthAndResignAsIMP x17, x12, x1	&#x2F;&#x2F; authenticate imp and re-sign as IMP</span><br><span class="line">	ret				&#x2F;&#x2F; return imp via x17</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>这里传入的<code>$0</code>是<code>normal</code>会调用<code>TailCallCachedImp</code>执行imp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.macro TailCallCachedImp</span><br><span class="line">	&#x2F;&#x2F; $0 &#x3D; cached imp, $1 &#x3D; address of cached imp, $2 &#x3D; SEL</span><br><span class="line">	eor	$1, $1, $2	&#x2F;&#x2F; mix SEL into ptrauth modifier</span><br><span class="line">	brab	$0, $1</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>CheckMiss</code>，判断是否一直找不到（bucket-&gt;sel == 0），即遇到空通，说明cache中没有该method。因此可见cache解决hash冲突的方式为开放寻址法（线性探测）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.macro CheckMiss</span><br><span class="line">	&#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0</span><br><span class="line">.if $0 &#x3D;&#x3D; GETIMP</span><br><span class="line">	cbz	p9, LGetImpMiss</span><br><span class="line">.elseif $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	cbz	p9, __objc_msgSend_uncached</span><br><span class="line">.elseif $0 &#x3D;&#x3D; LOOKUP</span><br><span class="line">	cbz	p9, __objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>因为<code>$0</code>是<code>normal</code>，如果一直都找不到，会跳转至<code>__objc_msgSend_uncached</code>，即进入<code>慢速查找流程</code>。否则执行下一步</p>
</li>
<li><p>如果<code>根据index获取的bucket</code> 等于 <code>buckets的第一个元素</code>，则将<code>当前bucket设置为buckets的最后一个元素</code>（通过<code>buckets首地址+mask*16</code>（等同于左移4位）直接定位到buckets的最后一个元素），并读取bucket的imp<code>和</code>sel`分别存入p17和p9寄存器，然后执行【第六步】；否则执行下一步</p>
</li>
<li><p>通过地址偏移，得到前一个bucket元素，并读取bucket的imp<code>和</code>sel`分别存入p17和p9寄存器，然后重复1</p>
</li>
</ol>
<p>【第六步】第二次遍历查找：重复【第五步】的操作，与【第五步】中<code>唯一区别</code>是，如果当前的bucket还是等于 buckets的第一个元素，则直接跳转至<code>JumpMiss</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.macro JumpMiss</span><br><span class="line">.if $0 &#x3D;&#x3D; GETIMP</span><br><span class="line">	b	LGetImpMiss</span><br><span class="line">.elseif $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	b	__objc_msgSend_uncached</span><br><span class="line">.elseif $0 &#x3D;&#x3D; LOOKUP</span><br><span class="line">	b	__objc_msgLookup_uncached</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>此时的<code>$0</code>是<code>normal</code>，也是直接跳转至<code>__objc_msgSend_uncached</code>，即进入慢速查找流程。</p>
<h4 id="objc-msgSend-uncached源码分析"><a href="#objc-msgSend-uncached源码分析" class="headerlink" title="__objc_msgSend_uncached源码分析"></a><code>__objc_msgSend_uncached</code>源码分析</h4><p><code>__objc_msgSend_uncached</code>源码实现如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">&#x2F;&#x2F; Out-of-band p16 is the class to search</span><br><span class="line"></span><br><span class="line">MethodTableLookup</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>

<p>该方法中主要调用了<code>MethodTableLookup</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; push frame</span><br><span class="line">	SignLR</span><br><span class="line">	stp	fp, lr, [sp, #-16]!</span><br><span class="line">	mov	fp, sp</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; save parameter registers: x0..x8, q0..q7</span><br><span class="line">	sub	sp, sp, #(10*8 + 8*16)</span><br><span class="line">	stp	q0, q1, [sp, #(0*16)]</span><br><span class="line">	stp	q2, q3, [sp, #(2*16)]</span><br><span class="line">	stp	q4, q5, [sp, #(4*16)]</span><br><span class="line">	stp	q6, q7, [sp, #(6*16)]</span><br><span class="line">	stp	x0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">	stp	x2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">	stp	x4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">	stp	x6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">	str	x8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; receiver and selector already in x0 and x1</span><br><span class="line">	mov	x2, x16</span><br><span class="line">	bl	__class_lookupMethodAndLoadCache3</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; IMP in x0</span><br><span class="line">	mov	x17, x0</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; restore registers and return</span><br><span class="line">	ldp	q0, q1, [sp, #(0*16)]</span><br><span class="line">	ldp	q2, q3, [sp, #(2*16)]</span><br><span class="line">	ldp	q4, q5, [sp, #(4*16)]</span><br><span class="line">	ldp	q6, q7, [sp, #(6*16)]</span><br><span class="line">	ldp	x0, x1, [sp, #(8*16+0*8)]</span><br><span class="line">	ldp	x2, x3, [sp, #(8*16+2*8)]</span><br><span class="line">	ldp	x4, x5, [sp, #(8*16+4*8)]</span><br><span class="line">	ldp	x6, x7, [sp, #(8*16+6*8)]</span><br><span class="line">	ldr	x8,     [sp, #(8*16+8*8)]</span><br><span class="line"></span><br><span class="line">	mov	sp, fp</span><br><span class="line">	ldp	fp, lr, [sp], #16</span><br><span class="line">	AuthenticateLR</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>MethodTableLookup 可以算是个接口层宏，主要用于保存环境与准备参数，来调用 __class_lookupMethodAndLoadCache3函数（在objc-class-new.mm中）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _class_lookupMethodAndLoadCache.</span></span><br><span class="line"><span class="comment">* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().</span></span><br><span class="line"><span class="comment">* This lookup avoids optimistic cache scan because the dispatcher </span></span><br><span class="line"><span class="comment">* already tried that.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__class_lookupMethodAndLoadCache3函数也是个接口层（C编写），此函数提供相应参数配置，实际功能在lookUpImpOrForward函数中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* lookUpImpOrForward.</span></span><br><span class="line"><span class="comment">* The standard IMP lookup. </span></span><br><span class="line"><span class="comment">* initialize==NO tries to avoid +initialize (but sometimes fails)</span></span><br><span class="line"><span class="comment">* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)</span></span><br><span class="line"><span class="comment">* Most callers should use initialize==YES and cache==YES.</span></span><br><span class="line"><span class="comment">* inst is an instance of cls or a subclass thereof, or nil if none is known. </span></span><br><span class="line"><span class="comment">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</span></span><br><span class="line"><span class="comment">* May return _objc_msgForward_impcache. IMPs destined for external use </span></span><br><span class="line"><span class="comment">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span></span><br><span class="line"><span class="comment">*   If you don't want forwarding at all, use lookUpImpOrNil() instead.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    <span class="keyword">bool</span> triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  runtimeLock 本质上是对 Darwin 提供的线程读写锁 pthread_rwlock_t 的一层封装，提供了一些便捷的方法。</span></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="comment">//  如果使用缓存（cache 参数为 YES），那就调用 cache_getImp 方法从缓存查找 IMP。cache_getImp 是用汇编语言写的，也可以在 objc-msg-arm64.s 找到，其依然用了前文中说过的 CacheLookup 宏。因为 _class_lookupMethodAndLoadCache3 调用 lookUpImpOrForward 时 cache 参数为 NO，这步直接略过。</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during isRealized and isInitialized checking</span></span><br><span class="line">    <span class="comment">// to prevent races against concurrent realization.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during method search to make</span></span><br><span class="line">    <span class="comment">// method-lookup + cache-fill atomic with respect to method addition.</span></span><br><span class="line">    <span class="comment">// Otherwise, a category could be added but ignored indefinitely because</span></span><br><span class="line">    <span class="comment">// the cache was re-filled with the old value after the cache flush on</span></span><br><span class="line">    <span class="comment">// behalf of the category.</span></span><br><span class="line"></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    <span class="comment">//  判断是否是一个已知的类：判断当前类是否是已经被认可的类，即已经加载的类。</span></span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  判断类是否已经Realized，如果没有，需要先Realized</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">        <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  判断如果入参传入的initialize为true，且类未实例化，需要先实例化</span></span><br><span class="line">    <span class="keyword">if</span> (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">        <span class="comment">// runtimeLock may have been dropped but is now locked again</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If sel == initialize, class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="comment">//  runtimeLock 上锁</span></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try this class's cache.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  调用 cache_getImp 方法从缓存查找 IMP。</span></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    <span class="comment">//  如果找到直接返回imp。</span></span><br><span class="line">    <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try this class's method lists.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  在当前类中的方法列表（method list）中进行查找，也就是根据 selector 查找 Method</span></span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            <span class="comment">//  如果在当前类的方法列表成功找到了Method//  获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。</span></span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            <span class="comment">//  将找到的IMP直接返回imp</span></span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果在当前类中的方法列表（method list）中没有找到Method，尝试在逐级在父类的缓存和方法列表中查找</span></span><br><span class="line">    <span class="comment">// Try superclass caches and method lists.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> attempts = unreasonableClassCount();</span><br><span class="line">        <span class="comment">//  在继承层级中递归向父类中查找，和上一步类似，也是先查找缓存，缓存没中就查找方法列表</span></span><br><span class="line">        <span class="keyword">for</span> (Class curClass = cls-&gt;superclass;</span><br><span class="line">             curClass != nil;</span><br><span class="line">             curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">            <span class="keyword">if</span> (--attempts == <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Memory corruption in class list."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass cache.</span></span><br><span class="line">            <span class="comment">//  调用 cache_getImp 方法从父类的缓存查找 IMP。</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">                <span class="comment">//  如果找到的imp不是_objc_msgForward_impcache</span></span><br><span class="line">                <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">                    <span class="comment">//  将父类链中查找到的imp并填充到当前类的缓存中。</span></span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//  如果找到的imp是_objc_msgForward_impcache，退出循环</span></span><br><span class="line">                    <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                    <span class="comment">// Stop searching, but don't cache yet; call method </span></span><br><span class="line">                    <span class="comment">// resolver for this class first.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//  在当前父类中的方法列表（method list）中进行查找，也就是根据 selector 查找到 Method 后，获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。</span></span><br><span class="line">            <span class="comment">// Superclass method list.</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line">    <span class="comment">//  参数 resolver 为 YES且是第一次执行到这里的时侯，进行动态方法解析</span></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        <span class="comment">//  释放锁</span></span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        <span class="comment">//  间接地发送 +resolveInstanceMethod 或 +resolveClassMethod 消息。函数中实现了方法解析逻辑。如果 cls 是元类则会发送 +resolveClassMethod，然后根据 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 函数的结果来判断是否发送 +resolveInstanceMethod；如果不是元类，则只需要发送 +resolveInstanceMethod 消息。这里调用 +resolveInstanceMethod 或 +resolveClassMethod 时再次用到了 objc_msgSend，而且第三个参数正是传入 lookUpImpOrForward 的那个 sel。在发送方法解析消息之后还会调用 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 来判断是否已经添加上 sel 对应的 IMP 了，打印出结果。</span></span><br><span class="line">        resolveMethod(cls, sel, inst);</span><br><span class="line">        <span class="comment">//  读入锁加锁</span></span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line">    <span class="comment">//  将 _objc_msgForward_impcache 当做 IMP 并写入缓存</span></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先了<code>lookUpImpOrForward</code>方法，对  assert 进行 unlock：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtimeLock.assertUnlocked();</span><br></pre></td></tr></table></figure>

<p><code>runtimeLock</code> 本质上是对 Darwin 提供的线程读写锁 <code>pthread_rwlock_t</code> 的一层封装，提供了一些便捷的方法。</p>
<p>接着，<code>lookUpImpOrForward</code>做了如下两件事：</p>
<ol>
<li><p>如果使用缓存（<code>cache</code> 参数为 <code>YES</code>），那就调用 <code>cache_getImp</code> 方法从缓存查找 IMP。<code>cache_getImp</code> 是用汇编语言写的，实现如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY _cache_getImp</span><br><span class="line"></span><br><span class="line">	GetClassFromIsa_p16 p0</span><br><span class="line">	CacheLookup GETIMP</span><br><span class="line"></span><br><span class="line">LGetImpMiss:</span><br><span class="line">	mov	p0, #0</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	END_ENTRY _cache_getImp</span><br></pre></td></tr></table></figure>

<p>其依然用了之前说过的 <code>CacheLookup</code> 宏。因为 <code>_class_lookupMethodAndLoadCache3</code> 调用 <code>lookUpImpOrForward</code> 时 <code>cache</code> 参数为 <code>NO</code>，<strong>这步直接略过</strong>。</p>
</li>
<li><p>如果是第一次用到这个类且 <code>initialize</code> 参数为 <code>YES</code>（<code>initialize &amp;&amp; !cls-&gt;isInitialized()</code>），需要进行初始化工作，也就是开辟一个用于读写数据的空间。先对 <code>runtimeLock</code> 加锁，然后调用 <code>cls</code> 的 <code>initialize</code> 方法，并将<code>cls-&gt;isInitialized()</code>置为true。</p>
</li>
</ol>
<p>然后，会继续在类的继承体系中查找：</p>
<p>考虑到运行时类中的方法可能会增加，需要先加锁，使得方法查找和缓存填充成为原子操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtimeLock.assertLocked();</span><br></pre></td></tr></table></figure>

<p>之后的逻辑如下：</p>
<ol>
<li><p>查找当前类中的缓存，跟之前一样，使用 <code>cache_getImp</code> 汇编程序入口。如果命中缓存获取到了 IMP，则直接跳到第 6 步；否则执行下一步。</p>
</li>
<li><p>在当前类的方法列表（method list）中进行查找，也就是根据 selector 查找到 Method 后，获取 Method 中的 IMP（也就是 <code>method_imp</code> 属性），并填充到缓存中。查找过程如下：</p>
<p>首先调用 <code>getMethodNoSuper_nolock()</code>方法，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">method_t</span> *</span><br><span class="line">getMethodNoSuper_nolock(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    <span class="comment">// fixme nil cls? </span></span><br><span class="line">    <span class="comment">// fixme nil sel?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> mlists = cls-&gt;data()-&gt;methods.beginLists(), </span><br><span class="line">              <span class="built_in">end</span> = cls-&gt;data()-&gt;methods.endLists(); </span><br><span class="line">         mlists != <span class="built_in">end</span>;</span><br><span class="line">         ++mlists)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">method_t</span> *m = search_method_list(*mlists, sel);</span><br><span class="line">        <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在getMethodNoSuper_nolock方法中，会遍历methodList。遍历过程中会调用search_method_list函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* getMethodNoSuper_nolock</span></span><br><span class="line"><span class="comment">* fixme</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be read- or write-locked by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">method_t</span> *<span class="title">search_method_list</span><span class="params">(<span class="keyword">const</span> <span class="keyword">method_list_t</span> *mlist, SEL sel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> methodListIsFixedUp = mlist-&gt;isFixedUp();</span><br><span class="line">    <span class="keyword">int</span> methodListHasExpectedSize = mlist-&gt;entsize() == <span class="keyword">sizeof</span>(<span class="keyword">method_t</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMethodInSortedMethodList(sel, mlist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Linear search of unsorted method list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// sanity-check negative results</span></span><br><span class="line">    <span class="keyword">if</span> (mlist-&gt;isFixedUp()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"linear search worked when binary search did not"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在search_method_list函数中，会去判断当前methodList是否有序，如果有序，会调用findMethodInSortedMethodList方法，这个方法里面的实现是一个二分搜索。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">method_t</span> *<span class="title">findMethodInSortedMethodList</span><span class="params">(SEL key, <span class="keyword">const</span> <span class="keyword">method_list_t</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_t</span> * <span class="keyword">const</span> first = &amp;<span class="built_in">list</span>-&gt;first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_t</span> *base = first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_t</span> *probe;</span><br><span class="line">    <span class="keyword">uintptr_t</span> keyValue = (<span class="keyword">uintptr_t</span>)key;</span><br><span class="line">    <span class="keyword">uint32_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  base相当于low，count是max，probe是middle</span></span><br><span class="line">    <span class="keyword">for</span> (count = <span class="built_in">list</span>-&gt;count; count != <span class="number">0</span>; count &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//  probe = 从首地址 + count/2</span></span><br><span class="line">        probe = base + (count &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">uintptr_t</span> probeValue = (<span class="keyword">uintptr_t</span>)probe-&gt;name;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  如果查找的sel == 中间位置（probe）的probeValue</span></span><br><span class="line">        <span class="keyword">if</span> (keyValue == probeValue) &#123;</span><br><span class="line">            <span class="comment">// `probe` is a match.</span></span><br><span class="line">            <span class="comment">// Rewind looking for the *first* occurrence of this value.</span></span><br><span class="line">            <span class="comment">// This is required for correct category overrides.</span></span><br><span class="line">            <span class="comment">// -- while 平移 -- 排除分类重名方法</span></span><br><span class="line">            <span class="comment">//  循环在methodlist中查找第一个满足(keyValue == probeValue)的元素。因为在methodlist中分类方法会插入在本类方法之前</span></span><br><span class="line">            <span class="keyword">while</span> (probe &gt; first &amp;&amp; keyValue == (<span class="keyword">uintptr_t</span>)probe[<span class="number">-1</span>].name) &#123;</span><br><span class="line">                probe--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">method_t</span> *)probe;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  如果keyValue 大于 probeValue，就往probe即中间位置的右边查找</span></span><br><span class="line">        <span class="keyword">if</span> (keyValue &gt; probeValue) &#123;</span><br><span class="line">            base = probe + <span class="number">1</span>;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果成功查找到 Method 对象，则调用log_and_fill_cache()，将获取到的 Method 中的 IMP（也就是 <code>method_imp</code> 属性），填充到缓存中，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* log_and_fill_cache</span></span><br><span class="line"><span class="comment">* Log this method call. If the logger permits it, fill the method cache.</span></span><br><span class="line"><span class="comment">* cls is the method whose cache should be filled. </span></span><br><span class="line"><span class="comment">* implementer is the class that owns the implementation in question.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">log_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_MESSAGE_LOGGING</span></span><br><span class="line">    <span class="keyword">if</span> (objcMsgLogEnabled) &#123;</span><br><span class="line">        <span class="keyword">bool</span> cacheIt = logMessageSend(implementer-&gt;isMetaClass(), </span><br><span class="line">                                      cls-&gt;nameForLogging(),</span><br><span class="line">                                      implementer-&gt;nameForLogging(), </span><br><span class="line">                                      sel);</span><br><span class="line">        <span class="keyword">if</span> (!cacheIt) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    cache_fill (cls, sel, imp, receiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>忽略debug的log逻辑，方法仅仅是调用cache_fill。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_fill</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DEBUG_TASK_THREADS</span></span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(cacheUpdateLock)</span></span>;</span><br><span class="line">    cache_fill_nolock(cls, sel, imp, receiver);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _collecting_in_critical();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cache_fill</code>又会来到<code>cache_fill_nolock</code>，这个函数的作用是将方法的<code>SEL</code>和<code>IMP</code>写入<code>_buckets</code>，同时更新<code>_mask</code>和<code>_occupied</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cache_fill_nolock</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果类未初始化，直接return</span></span><br><span class="line">    <span class="comment">// Never cache before +initialize is done</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isInitialized()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the entry wasn't added to the cache by some other thread </span></span><br><span class="line">    <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">    <span class="comment">//  在获取cacheUpdateLock之前，确保其他线程没有将该方法写入缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache_getImp(cls, sel)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取 cls 的 cache_t指针</span></span><br><span class="line">    <span class="keyword">cache_t</span> *cache = getCache(cls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the cache as-is if it is less than 3/4 full</span></span><br><span class="line">    <span class="comment">//  newOccupied为新的方法缓存数，等于 当前方法缓存数+1</span></span><br><span class="line">    <span class="keyword">mask_t</span> newOccupied = cache-&gt;occupied() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//  获取当前cache_t的总容量，为 mask+1</span></span><br><span class="line">    <span class="keyword">mask_t</span> capacity = cache-&gt;capacity();</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        <span class="comment">//  当第一次调用类的实例方法时（如`init`）</span></span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">//  新的方法缓存数 不大于 总容量的3/4，按原样使用，无需扩容</span></span><br><span class="line">        <span class="comment">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Cache is too full. Expand it.</span></span><br><span class="line">        <span class="comment">//  新的方法缓存数 大于 总容量的3/4，需要扩容</span></span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot because the </span></span><br><span class="line">    <span class="comment">// minimum size is 4 and we resized at 3/4 full.</span></span><br><span class="line">    <span class="comment">//  根据sel获取bucket，此bucket的sel一般为0（说明这个位置还没缓存方法），</span></span><br><span class="line">    <span class="comment">//  也可能与实参sel相等（hash冲突，可能性很低）</span></span><br><span class="line">    <span class="keyword">bucket_t</span> *bucket = cache-&gt;<span class="built_in">find</span>(sel, receiver);</span><br><span class="line">    <span class="comment">//  当且仅当bucket的sel为0时，执行_occupied++</span></span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;sel() == <span class="number">0</span>) cache-&gt;incrementOccupied();</span><br><span class="line">    <span class="comment">//  更新bucket的sel和imp</span></span><br><span class="line">    bucket-&gt;<span class="built_in">set</span>&lt;Atomic&gt;(sel, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码不难看出，<code>cache_fill_nolock</code>主要是<code>cache_t</code>缓存方法的调度中心，在这里会：</p>
<ol>
<li>决定执行<code>_buckets</code>的哪一种缓存策略（初始化后缓存、直接缓存、扩容后缓存，三者取一）；</li>
<li>然后通过方法的<code>sel</code>找到一个<code>bucket</code>，并更新这个<code>bucket</code>的<code>sel</code>和<code>imp</code>。（如果这个<code>bucket</code>的<code>sel</code>为0，说明是个空桶，正好可以缓存方法，于是执行<code>_occupied++</code>）。</li>
</ol>
<p>缓存填充完成，然后就直接跳到第 6 步；否则如果当前类的method list没有找到method，则执行下一步。</p>
</li>
<li><p>在继承层级中递归向父类中查找，情况跟上一步类似，也是先查找缓存，缓存没中就查找方法列表。这里跟上一步不同的地方在于缓存策略，有个 <code>_objc_msgForward_impcache</code> 汇编程序入口作为缓存中消息转发的标记。也就是说如果在缓存中找到了 IMP，但如果发现其内容是 <code>_objc_msgForward_impcache</code>，那就终止在类的继承层级中递归查找，进入下一步；否则跳到第 7 步。</p>
</li>
<li><p>当传入 <code>lookUpImpOrForward</code> 的参数 <code>resolver</code> 为 <code>YES</code> 并且是第一次进入第 5 步时，时进入动态方法解析；否则进入下一步。这步消息转发前的最后一次机会。此时释放读入锁（<code>runtimeLock.unlock()</code>），接着调用<code>resolveMethod()</code>进行动态方法解析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* resolveMethod</span></span><br><span class="line"><span class="comment">* Call +resolveClassMethod or +resolveInstanceMethod.</span></span><br><span class="line"><span class="comment">* Returns nothing; any result would be potentially out-of-date already.</span></span><br><span class="line"><span class="comment">* Does not check if the method already exists.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveMethod</span><span class="params">(Class cls, SEL sel, id inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中会判断，如果 <code>cls</code> 是元类则会发送 <code>+resolveClassMethod</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* resolveClassMethod</span></span><br><span class="line"><span class="comment">* Call +resolveClassMethod, looking for a method to be added to class cls.</span></span><br><span class="line"><span class="comment">* cls should be a metaclass.</span></span><br><span class="line"><span class="comment">* Does not check if the method already exists.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveClassMethod</span><span class="params">(Class cls, SEL sel, id inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class nonmeta;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst);</span><br><span class="line">        <span class="comment">// +initialize path should have realized nonmeta already</span></span><br><span class="line">        <span class="keyword">if</span> (!nonmeta-&gt;isRealized()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"nonmeta class %s (%p) unexpectedly not realized"</span>,</span><br><span class="line">                        nonmeta-&gt;nameForLogging(), nonmeta);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(nonmeta, SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveClassMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据 <code>lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)</code> 函数的结果来判断是否发送 <code>+resolveInstanceMethod</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* resolveInstanceMethod</span></span><br><span class="line"><span class="comment">* Call +resolveInstanceMethod, looking for a method to be added to class cls.</span></span><br><span class="line"><span class="comment">* cls may be a metaclass or a non-meta class.</span></span><br><span class="line"><span class="comment">* Does not check if the method already exists.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveInstanceMethod</span><span class="params">(Class cls, SEL sel, id inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是元类，则只需要发送 <code>+resolveInstanceMethod</code> 消息。这里调用 <code>+resolveInstanceMethod</code> 或 <code>+resolveClassMethod</code> 时再次用到了 <code>objc_msgSend</code>，而且第三个参数正是传入 <code>lookUpImpOrForward</code> 的那个 <code>sel</code>。在发送方法解析消息之后还会调用 <code>lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)</code> 来判断是否已经添加上 <code>sel</code> 对应的 IMP 了，打印出结果。</p>
<p><code>lookUpImpOrNil</code> 跟 <code>lookUpImpOrForward</code> 的功能很相似，只是将 <code>lookUpImpOrForward</code> 实现中的 <code>_objc_msgForward_impcache</code> 替换成了 <code>nil</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* lookUpImpOrNil.</span></span><br><span class="line"><span class="comment">* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">IMP <span class="title">lookUpImpOrNil</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);</span><br><span class="line">    <span class="keyword">if</span> (imp == _objc_msgForward_impcache) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时不仅没查找到 IMP，动态方法解析也不奏效，只能将 <code>_objc_msgForward_impcache</code> 当做 IMP 并写入缓存。这也就是之前第 3 步中为何查找到 <code>_objc_msgForward_impcache</code> 就表明了要进入消息转发了。</p>
</li>
<li><p>解锁 <code>runtimeLock.unlock()</code>，并将之前找到的 IMP 返回。。</p>
</li>
</ol>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>前面说到如果没有找到方法，会将 <code>_objc_msgForward_impcache</code> 当成imp写入缓存。<code>_objc_msgForward_impcache</code> 只是个内部的函数指针，只存储于类的方法缓存中，需要被转化为 <code>_objc_msgForward</code> 和 <code>_objc_msgForward_stret</code> 才能被外部调用。转换的方式也很简单，就是增加个静态入口 <code>__objc_msgForward_impcache</code>。 <code>_objc_msgForward_impcache</code> 在objc-msg-arm64.s中汇编的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; No stret specialization.</span><br><span class="line">b	__objc_msgForward</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward_impcache</span><br></pre></td></tr></table></figure>

<p> <code>_objc_msgForward_impcache</code>只是入口。实际的实现函数是 <code>objc_msgForward</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">adrp	x17, __objc_forward_handler@PAGE</span><br><span class="line">ldr	p17, [x17, __objc_forward_handler@PAGEOFF]</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward</span><br></pre></td></tr></table></figure>

<p> <code>objc_msgForward</code> 函数中会调用__objc_forward_handler函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default forward handler halts the process.</span></span><br><span class="line">__attribute__((noreturn)) <span class="keyword">void</span> </span><br><span class="line">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(<span class="string">"%c[%s %s]: unrecognized selector sent to instance %p "</span></span><br><span class="line">                <span class="string">"(no message forward handler is installed)"</span>, </span><br><span class="line">                class_isMetaClass(object_getClass(self)) ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> *_objc_forward_handler = (<span class="keyword">void</span>*)objc_defaultForwardHandler;</span><br></pre></td></tr></table></figure>

<p>在Objc2.0中会有一个objc_defaultForwardHandler，看源码实现我们可以看到熟悉的语句。当我们给一个对象发送一个没有实现的方法的时候，如果其父类也没有这个方法，则会崩溃，报错信息类似于这样：unrecognized selector sent to instance，然后接着会跳出一些堆栈信息。这些信息就是从这里而来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_setForwardHandler</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Default forward handler (nil) goes to forward:: dispatch.</span></span><br><span class="line"><span class="keyword">void</span> *_objc_forward_handler = nil;</span><br><span class="line"><span class="keyword">void</span> *_objc_forward_stret_handler = nil;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Default forward handler halts the process.</span></span><br><span class="line">__attribute__((noreturn)) <span class="keyword">void</span> </span><br><span class="line">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(<span class="string">"%c[%s %s]: unrecognized selector sent to instance %p "</span></span><br><span class="line">                <span class="string">"(no message forward handler is installed)"</span>, </span><br><span class="line">                class_isMetaClass(object_getClass(self)) ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> *_objc_forward_handler = (<span class="keyword">void</span>*)objc_defaultForwardHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_STRET</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stret</span> &#123;</span> <span class="keyword">int</span> i[<span class="number">100</span>]; &#125;;</span><br><span class="line">__attribute__((noreturn)) <span class="class"><span class="keyword">struct</span> <span class="title">stret</span> </span></span><br><span class="line"><span class="class"><span class="title">objc_defaultForwardStretHandler</span>(<span class="title">id</span> <span class="title">self</span>, <span class="title">SEL</span> <span class="title">sel</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    objc_defaultForwardHandler(self, sel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> *_objc_forward_stret_handler = (<span class="keyword">void</span>*)objc_defaultForwardStretHandler;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setForwardHandler</span><span class="params">(<span class="keyword">void</span> *fwd, <span class="keyword">void</span> *fwd_stret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _objc_forward_handler = fwd;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_STRET</span></span><br><span class="line">    _objc_forward_stret_handler = fwd_stret;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要设置转发只要重写_objc_forward_handler方法即可。在objc_setForwardHandler方法中，可以设置ForwardHandler。</p>
<p>当你想要弄清objc_setForwardHandler的调用，以及之后的消息转发调用栈的时候，会发现在objc4-756.2找不到源码。这是因为objc_setForwardHandler的实现是在 Core Foundation（CoreFoundation.framework）中。虽然 CF 是开源的，但是苹果在这里做了点手脚。关于objc_setForwardHandler的调用，以及之后的消息转发调用栈的问题，需要用到逆向的知识。推荐大家看这篇文章就会明白其中的原理。</p>
<p><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="noopener">Objective-C 消息发送与转发机制原理</a><br>iOS会在 CF runtime 连接到进程时初始化调用<code>__CFInitialize()</code> 函数，把 <code>__CF_forwarding_prep_0</code> 和 <code>___forwarding_prep_1___</code> 作为参数调用 <code>objc_setForwardHandler</code> 方法。</p>
<p>从函数调用栈可以看出 <code>__CF_forwarding_prep_0</code> 和 <code>___forwarding_prep_1___</code> 这两个 Forward Handler 做了啥：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-09-05 21:05:39.018585+0800 Test[46006:16033328] -[Person eat]: unrecognized selector sent to instance 0x600000db8100</span><br><span class="line">2021-09-05 21:05:39.023782+0800 Test[46006:16033328] *** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[Person eat]: unrecognized selector sent to instance 0x600000db8100&#39;*** First throw call stack:(	0   CoreFoundation                      0x00007fff23c7127e __exceptionPreprocess + 350	1   libobjc.A.dylib                     0x00007fff513fbb20 objc_exception_throw + 48	2   CoreFoundation                      0x00007fff23c91fd4 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132	3   CoreFoundation                      0x00007fff23c75c4c ___forwarding___ + 1436	4   CoreFoundation                      0x00007fff23c77f78 _CF_forwarding_prep_0 + 120	5   Test                                0x000000010ba3e226 main + 54	6   libdyld.dylib                       0x00007fff5227ec25 start + 1)libc++abi.dylib: terminating with uncaught exception of type NSException</span><br></pre></td></tr></table></figure>

<p>这个日志场景熟悉得不能再熟悉了，可以看出 <code>_CF_forwarding_prep_0</code> 函数调用了 <code>___forwarding___</code> 函数，接着又调用了 <code>doesNotRecognizeSelector</code> 方法，最后抛出异常。</p>
<p><code>__CF_forwarding_prep_0</code> 和 <code>___forwarding_prep_1___</code> 函数都调用了 <code>___forwarding___</code>，只是传入参数不同。</p>
<p>消息转发的逻辑几乎都写在 <code>___forwarding___</code> 函数中了，实现比较复杂，反编译出的伪代码也不是很直观。<a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="noopener">Objective-C 消息发送与转发机制原理</a> 的结果如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __forwarding__(<span class="keyword">void</span> *frameStackPointer, <span class="keyword">int</span> isStret) &#123;</span><br><span class="line">  id receiver = *(id *)frameStackPointer;</span><br><span class="line">  SEL sel = *(SEL *)(frameStackPointer + <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *selName = sel_getName(sel);</span><br><span class="line">  Class receiverClass = object_getClass(receiver);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 forwardingTargetForSelector:</span></span><br><span class="line">  <span class="keyword">if</span> (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123;</span><br><span class="line">    id forwardingTarget = [receiver forwardingTargetForSelector:sel];</span><br><span class="line">    <span class="keyword">if</span> (forwardingTarget &amp;&amp; forwarding != receiver) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (isStret == <span class="number">1</span>) &#123;</span><br><span class="line">    		<span class="keyword">int</span> ret;</span><br><span class="line">    		objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...);</span><br><span class="line">    		<span class="keyword">return</span> ret;</span><br><span class="line">    	&#125;</span><br><span class="line">      <span class="keyword">return</span> objc_msgSend(forwardingTarget, sel, ...);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 僵尸对象</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *className = class_getName(receiverClass);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *zombiePrefix = <span class="string">"_NSZombie_"</span>;</span><br><span class="line">  <span class="keyword">size_t</span> prefixLen = <span class="built_in">strlen</span>(zombiePrefix); <span class="comment">// 0xa</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strncmp</span>(className, zombiePrefix, prefixLen) == <span class="number">0</span>) &#123;</span><br><span class="line">    CFLog(kCFLogLevelError,</span><br><span class="line">          @<span class="string">"*** -[%s %s]: message sent to deallocated instance %p"</span>,</span><br><span class="line">          className + prefixLen,</span><br><span class="line">          selName,</span><br><span class="line">          receiver);</span><br><span class="line">    &lt;breakpoint-interrupt&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span></span><br><span class="line">  <span class="keyword">if</span> (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123;</span><br><span class="line">    NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];</span><br><span class="line">    <span class="keyword">if</span> (methodSignature) &#123;</span><br><span class="line">      BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct;</span><br><span class="line">      <span class="keyword">if</span> (signatureIsStret != isStret) &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @<span class="string">"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s."</span>,</span><br><span class="line">              selName,</span><br><span class="line">              signatureIsStret ? <span class="string">""</span> : <span class="keyword">not</span>,</span><br><span class="line">              isStret ? <span class="string">""</span> : <span class="keyword">not</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123;</span><br><span class="line">        NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</span><br><span class="line"></span><br><span class="line">        [receiver forwardInvocation:invocation];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> *returnValue = <span class="literal">NULL</span>;</span><br><span class="line">        [invocation getReturnValue:&amp;value];</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CFLog(kCFLogLevelWarning ,</span><br><span class="line">              @<span class="string">"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message"</span>,</span><br><span class="line">              receiver,</span><br><span class="line">              className);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SEL *registeredSel = sel_getUid(selName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// selector 是否已经在 Runtime 注册过</span></span><br><span class="line">  <span class="keyword">if</span> (sel != registeredSel) &#123;</span><br><span class="line">    CFLog(kCFLogLevelWarning ,</span><br><span class="line">          @<span class="string">"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort"</span>,</span><br><span class="line">          sel,</span><br><span class="line">          selName,</span><br><span class="line">          registeredSel);</span><br><span class="line">  &#125; <span class="comment">// doesNotRecognizeSelector</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123;</span><br><span class="line">    [receiver doesNotRecognizeSelector:sel];</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    CFLog(kCFLogLevelWarning ,</span><br><span class="line">          @<span class="string">"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort"</span>,</span><br><span class="line">          receiver,</span><br><span class="line">          className);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The point of no return.</span></span><br><span class="line">  kill(getpid(), <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么一大坨代码就是整个消息转发路径的逻辑，概括如下：</p>
<ol>
<li>先调用 <code>forwardingTargetForSelector</code> 方法获取新的 target 作为 receiver 重新执行 selector，如果返回的内容不合法（为 <code>nil</code> 或者跟旧 receiver 一样），那就进入第二步。</li>
<li>调用 <code>methodSignatureForSelector</code> 获取方法签名后，判断返回类型信息是否正确，再调用 <code>forwardInvocation</code> 执行 <code>NSInvocation</code> 对象，并将结果返回。如果对象没实现 <code>methodSignatureForSelector</code> 方法，进入第三步。</li>
<li>调用 <code>doesNotRecognizeSelector</code> 方法。</li>
</ol>
<p><code>doesNotRecognizeSelector</code> 之前其实还有个判断 selector 在 Runtime 中是否注册过的逻辑，但在我们正常发消息的时候不会出此问题。但如果手动创建一个 <code>NSInvocation</code> 对象并调用 <code>invoke</code>，并将第二个参数设置成一个不存在的 selector，那就会导致这个问题，并输入日志 “does not match selector known to Objective C runtime”。较真儿的读者可能会有疑问：何这段逻辑判断干脆用不到却还存在着？难道除了 <code>__CF_forwarding_prep_0</code> 和 <code>___forwarding_prep_1___</code> 函数还有其他函数也调用 <code>___forwarding___</code> 么？莫非消息转发还有其他路径？其实并不是！原因是 <code>___forwarding___</code> 调用了 <code>___invoking___</code> 函数，所以上面的伪代码直接把 <code>___invoking___</code> 函数的逻辑也『翻译』过来了。除了 <code>___forwarding___</code> 函数，以下方法也会调用<code>___invoking___</code> 函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[NSInvocation invoke]</span><br><span class="line">-[NSInvocation invokeUsingIMP:]</span><br><span class="line">-[NSInvocation invokeSuper]</span><br></pre></td></tr></table></figure>

<p><code>doesNotRecognizeSelector</code> 方法其实在 libobj.A.dylib 中已经废弃了，而是在 CF 框架中实现，而且也不是开源的。从函数调用栈可以发现 <code>doesNotRecognizeSelector</code> 之后会抛出异常，而 Runtime 中废弃的实现只是打日志后直接杀掉进程（<code>__builtin_trap()</code>）。下面是 CF 中实现的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> -[NSObject doesNotRecognizeSelector:](<span class="keyword">void</span> * self, <span class="keyword">void</span> * _cmd, <span class="keyword">void</span> * arg2) &#123;</span><br><span class="line">    r14 = ___CFFullMethodName([self class], self, arg2);</span><br><span class="line">    _CFLog(<span class="number">0x3</span>, @<span class="string">"%@: unrecognized selector sent to instance %p"</span>, r14, self, r8, r9, <span class="built_in">stack</span>[<span class="number">2048</span>]);</span><br><span class="line">    rbx = _CFMakeCollectable(_CFStringCreateWithFormat(___kCFAllocatorSystemDefault, <span class="number">0x0</span>, @<span class="string">"%@: unrecognized selector sent to instance %p"</span>));</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int8_t</span> *)___CFOASafe != <span class="number">0x0</span>) &#123;</span><br><span class="line">            ___CFRecordAllocationEvent();</span><br><span class="line">    &#125;</span><br><span class="line">    rax = _objc_rootAutorelease(rbx);</span><br><span class="line">    rax = [NSException exceptionWithName:@<span class="string">"NSInvalidArgumentException"</span> reason:rax userInfo:<span class="number">0x0</span>];</span><br><span class="line">    objc_exception_throw(rax);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> +[NSObject doesNotRecognizeSelector:](<span class="keyword">void</span> * self, <span class="keyword">void</span> * _cmd, <span class="keyword">void</span> * arg2) &#123;</span><br><span class="line">    r14 = ___CFFullMethodName([self class], self, arg2);</span><br><span class="line">    _CFLog(<span class="number">0x3</span>, @<span class="string">"%@: unrecognized selector sent to class %p"</span>, r14, self, r8, r9, <span class="built_in">stack</span>[<span class="number">2048</span>]);</span><br><span class="line">    rbx = _CFMakeCollectable(_CFStringCreateWithFormat(___kCFAllocatorSystemDefault, <span class="number">0x0</span>, @<span class="string">"%@: unrecognized selector sent to class %p"</span>));</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int8_t</span> *)___CFOASafe != <span class="number">0x0</span>) &#123;</span><br><span class="line">            ___CFRecordAllocationEvent();</span><br><span class="line">    &#125;</span><br><span class="line">    rax = _objc_rootAutorelease(rbx);</span><br><span class="line">    rax = [NSException exceptionWithName:@<span class="string">"NSInvalidArgumentException"</span> reason:rax userInfo:<span class="number">0x0</span>];</span><br><span class="line">    objc_exception_throw(rax);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说我们可以 override <code>doesNotRecognizeSelector</code> 或者捕获其抛出的异常。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>过滤了部分不会进入的分支路径和跟主题无关的细节，整体流程如下：</p>
<img src="/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/runtime%E4%B9%8B%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B.png" class title="runtime之消息转发和发送流程">



<p>参考：</p>
<p>iOS-底层原理 12：消息流程分析之快速查找（<a href="https://blog.51cto.com/u_12801393/2955213）" target="_blank" rel="noopener">https://blog.51cto.com/u_12801393/2955213）</a></p>
<p>Objc-msg-arm64源码深入分析（<a href="https://www.jianshu.com/p/835ae53372ba）" target="_blank" rel="noopener">https://www.jianshu.com/p/835ae53372ba）</a></p>
<p>OC底层原理11-objc_msgSend源码分析(方法查找快流程)（<a href="https://www.jianshu.com/p/62ecc3f31467）" target="_blank" rel="noopener">https://www.jianshu.com/p/62ecc3f31467）</a></p>
<p>OC底层原理12-lookUpImpOrForward源码分析(方法查找慢流程)（<a href="https://www.jianshu.com/p/740ee19690c3）" target="_blank" rel="noopener">https://www.jianshu.com/p/740ee19690c3）</a></p>
<p>objc_msgSend 源码跟踪（<a href="https://www.jianshu.com/p/c8aedd333f2d）" target="_blank" rel="noopener">https://www.jianshu.com/p/c8aedd333f2d）</a></p>
<p>深入解构objc_msgSend函数的实现（<a href="http://www.cocoachina.com/articles/24536）" target="_blank" rel="noopener">http://www.cocoachina.com/articles/24536）</a></p>
<p><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="noopener">Objective-C 消息发送与转发机制原理</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/12/04/%E3%80%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8B%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/" rel="prev" title="「性能优化」之启动优化">
      <i class="fa fa-chevron-left"></i> 「性能优化」之启动优化
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E4%B9%8B-Runtime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/" rel="next" title="「刨根问底」之Objective-C 2.0 中类与对象的定义">
      「刨根问底」之Objective-C 2.0 中类与对象的定义 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#objc-msgSend"><span class="nav-number">1.</span> <span class="nav-text">objc_msgSend</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数简介"><span class="nav-number">1.1.</span> <span class="nav-text">函数简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码解析"><span class="nav-number">1.2.</span> <span class="nav-text">源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-msgSend源码分析"><span class="nav-number">1.2.1.</span> <span class="nav-text">_objc_msgSend源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CacheLookup源码分析"><span class="nav-number">1.2.2.</span> <span class="nav-text">CacheLookup源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-msgSend-uncached源码分析"><span class="nav-number">1.2.3.</span> <span class="nav-text">__objc_msgSend_uncached源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息转发"><span class="nav-number">1.2.4.</span> <span class="nav-text">消息转发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">2.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">和僧</p>
  <div class="site-description" itemprop="description">技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">和僧</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
