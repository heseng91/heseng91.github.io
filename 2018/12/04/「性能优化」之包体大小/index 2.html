<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heseng91.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="安装包大小是 App 重要的基础体验指标之一，与新用户转化直接相关。本文内容包括苹果的对包大小的限制等背景介绍、安装包分析和一些优化措施等。阅读本文之后，你将对安装包优化有一个整体的认知。">
<meta property="og:type" content="article">
<meta property="og:title" content="「性能优化」之包体大小">
<meta property="og:url" content="http://heseng91.github.io/2018/12/04/%E3%80%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8B%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F/index.html">
<meta property="og:site_name" content="和僧">
<meta property="og:description" content="安装包大小是 App 重要的基础体验指标之一，与新用户转化直接相关。本文内容包括苹果的对包大小的限制等背景介绍、安装包分析和一些优化措施等。阅读本文之后，你将对安装包优化有一个整体的认知。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nos.netease.com/cloud-website-bucket/201809181451521907e647-871e-44e4-8b7d-1b5539d4682e.jpg">
<meta property="og:image" content="https://nos.netease.com/cloud-website-bucket/20180918145314d34dd07d-f152-40a7-ac7b-a1081a441c34.jpg">
<meta property="og:image" content="https://nos.netease.com/cloud-website-bucket/201809181452418e5bac54-bed6-4a3d-a3cb-48af54e2daf2.jpg">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e5eba61ac4741be8d465a63e651ac35~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3d3d5debbb34a81aec16861e52046ff~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8832b403c76745e9bb6c2a2df354a3ed~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b748ca6fba6462287a7fae857fcd1fd~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://nos.netease.com/cloud-website-bucket/20180918145633f82a98cf-fc75-44a3-830d-553f837991d2.jpg">
<meta property="og:image" content="https://nos.netease.com/cloud-website-bucket/201809181456458ffc259f-3338-4408-82c6-503bdc0e1a21.jpg">
<meta property="article:published_time" content="2018-12-04T08:30:33.000Z">
<meta property="article:modified_time" content="2022-07-25T19:30:01.474Z">
<meta property="article:author" content="和僧">
<meta property="article:tag" content="和僧-技术博客，技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nos.netease.com/cloud-website-bucket/201809181451521907e647-871e-44e4-8b7d-1b5539d4682e.jpg">

<link rel="canonical" href="http://heseng91.github.io/2018/12/04/%E3%80%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8B%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>「性能优化」之包体大小 | 和僧</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">和僧</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://heseng91.github.io/2018/12/04/%E3%80%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8B%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="和僧">
      <meta itemprop="description" content="技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和僧">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          「性能优化」之包体大小
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-04 16:30:33" itemprop="dateCreated datePublished" datetime="2018-12-04T16:30:33+08:00">2018-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-26 03:30:01" itemprop="dateModified" datetime="2022-07-26T03:30:01+08:00">2022-07-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>安装包大小是 App 重要的基础体验指标之一，与新用户转化直接相关。本文内容包括苹果的对包大小的限制等背景介绍、安装包分析和一些优化措施等。阅读本文之后，你将对安装包优化有一个整体的认知。</p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="下载大小限制"><a href="#下载大小限制" class="headerlink" title="下载大小限制"></a>下载大小限制</h3><p>App 大小有下载大小和安装大小的概念。</p>
<p>下载大小是指 App 压缩包（也就是 .ipa 文件）所占的空间，用户在下载 App 时，下载的是压缩包，这样做可以节省流量；当压缩包下载完成后，就会自动解压，解压过程也就是通常所说的安装过程；安装大小就是指压缩包解压后所占用的空间。</p>
<p>安装大小在 App Store 上就可以看见 ，通常它会影响用户的下载意愿。而下载大小只有研发人员在 App Store Connect 后台才可以看，用户看不见，它影响的是下载消耗的流量和时长。若<strong>下载大小</strong>超过限制，将无法使用蜂窝网络下载 App（ iOS 13 之前），会收到文件容量太大的提示，需通过 Wi-Fi 网络下载。如下，为苹果历年来对 App 下载大小限制的变化情况：</p>
<ul>
<li><p>2008 年 7 月，搭载了 App Store 的 iPhone 3G 正式发售，下载限制仅为 10 MB</p>
</li>
<li><p>2010 年 2 月，苹果将 iPhone 3G 的下载限制从 10 MB 提升到 20 MB</p>
</li>
<li><p>2012 年 3 月，iOS 5.1 正式版后，下载限制从 20 MB 提升到 50 MB</p>
</li>
<li><p>2013 年 9 月，iOS 7 正式版后，下载限制从 50 MB 提升至 100 MB</p>
</li>
<li><p>2017 年 9 月，iOS 11 正式版后，下载限制从 100 MB 提升至 150 MB</p>
</li>
<li><p>2019 年 5 月，下载限制从 150 MB 提升至 200 MB</p>
</li>
<li><p>2019 年 9 月，iOS 13 正式版后，若下载大小超过 200 MB，用户可选择是否使用蜂窝网络下载</p>
</li>
</ul>
<p>如今，App 下载大小超出 200 MB 时 ，会出现两种情况：</p>
<ul>
<li>iOS 13 以下的用户，无法通过蜂窝数据下载 App</li>
<li>iOS 13 及以上的用户，需要手动设置才可以使用蜂窝网络下载 App</li>
</ul>
<p>可见下载大小若超出 200 MB，就会对用户新增会有一定影响，因此下载大小 200 MB 是包大小的一根红线。</p>
<h3 id="可执行文件大小限制"><a href="#可执行文件大小限制" class="headerlink" title="可执行文件大小限制"></a>可执行文件大小限制</h3><p>根据<a href="https://help.apple.com/app-store-connect/#/dev611e0a21f" target="_blank" rel="noopener">最大构建版本文件大小</a>描述，苹果对可执行文件大小亦有明确限制，超过该限制会导致 App 审核被拒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: ERROR ITMS-90122: &quot;Invalid ExecutaBe Size. The size of your app&#39;s executaBe file &#39;News.app&#x2F;News&#39; is 68534272 bytes for architecture &#39;arm64&#39;, which exceeds the maximum allowed size of 60 MB.&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>具体限制如下：</p>
<ul>
<li><p>iOS 7 之前，二进制文件中所有的 <code>__TEXT</code>段总和不得超过 80 MB</p>
</li>
<li><p>iOS 7.X 至 iOS 8.X ，二进制文件中，每个特定架构中的 <code>__TEXT</code>段不得超过 60 MB</p>
</li>
<li><p>iOS 9.0 之后，二进制文件中所有的 <code>__TEXT</code>段总和不得超过 500 MB</p>
</li>
</ul>
<h2 id="安装包分析"><a href="#安装包分析" class="headerlink" title="安装包分析"></a>安装包分析</h2><p>本文探讨的是优化，说到优化最重要的是要做到白盒优化，知道安装包的构成，才能针对性的进行优化。</p>
<h3 id="安装包构成"><a href="#安装包构成" class="headerlink" title="安装包构成"></a>安装包构成</h3><p>对通过 Archieve 打包的安装包 unzip 解压之后，就能看到 payload 中 app 文件的数据，整理归类后其大致如下：</p>
<ul>
<li><p>Exectutable: 可执行文件</p>
</li>
<li><p>Resources：资源文件</p>
</li>
<li><ul>
<li>图片资源：Assets.car/bundle/png/jpg 等</li>
<li>视频/音频资源：mp4/mp3 等</li>
<li>静态网页资源：html/css/js 等</li>
<li>视图资源：xib/storyboard 等</li>
<li>其他：文本/字体/证书 等</li>
</ul>
</li>
<li><p>Framework：项目中使用的动态库</p>
</li>
<li><ul>
<li>SwiftSupport: libSwiftxxx 等一系列 Swift 库</li>
<li>其他依赖库：Embeded Framework</li>
</ul>
</li>
<li><p>Pulgins：Application Extensions</p>
</li>
<li><ul>
<li>appex：其组成大致与 ipa 包组成一致</li>
</ul>
</li>
</ul>
<p>从以上结构中可以看出一个 ipa 包大致由 Executable, Resources, Framework,Plugins 四大模块组成，接下来我们就从这四个方向来探讨 App 瘦身的具体方案。</p>
<h3 id="安装包分析-1"><a href="#安装包分析-1" class="headerlink" title="安装包分析"></a>安装包分析</h3><p>通过分析安装包，了解安装包中可执行文件占用大小、资源占用大小，了解安装包的现状。才能明确从哪里入手可以获得 ROI 最高的优化手段。</p>
<p>而在做包大小分析过程中比较难的是，怎么样通过线下的安装包衡量对下载大小的影响。</p>
<h4 id="App-Slicing"><a href="#App-Slicing" class="headerlink" title="App Slicing"></a>App Slicing</h4><p>鉴于早期网络的不普及和比较高的流量费用，苹果对下载大小和可执行文件大小有着上文所述的限制。于此同时，为了提升用户体验和节省用户流量，苹果也为 App安装包大小提供了很多优化方式。</p>
<p>iOS 9 中引入的 <a href="https://www.taoxtao.cn/go?_=f3573ab79daHR0cHM6Ly9oZWxwLmFwcGxlLmNvbS94Y29kZS9tYWMvY3VycmVudC8jL2RldmJiZGM1Y2U0Zg==" target="_blank" rel="noopener">App Thinning</a> 中提到过 Slicing 的技术，当我们把一个完整的安装包提交给 AppStore Connect后，Apple 会为不同的设备准备不同的变体（Variant），设备的在下载 App 的时候它能根据设备的处理器架构（arm64, armv7）、屏幕分辨率（2x, 3x）、iOS 系统版本等信息，帮助我们自动选择合适的 Variant 进行下载。</p>
<p>可执行文件的 Slicing 技术就是对不同架构进行裁剪，只剩下单架构可执行文件。同样资源文件也是支持 Slicing 的。比如 iPhone 6 下载的安装包中就只会包含 2x 图，iPhone 6 Plus 下载的安装包就只会包含 3x 图，但是只有使用 asset catelogs(也就是 XCAssets) 管理的资源才支持 Slicing，所以尽量还是使用 XCAsset 来管理资源图片。同时 XCAsset 也支持 PDFs 矢量图，在上传到 AppStore Connect之后，会根据矢量图自动生成 1x, 2x, 3x 图，然后进行 Slicing。</p>
<h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>除了上述调整之外，安装包被提交到 AppStore Connect后，出于安全考虑，苹果还会对安装包的二进制部分TEXT 段通过 FirePlay 进行加密，加密会导致 TEXT 段的压缩比为 1（ iOS 13+ 以上设备下载变体中苹果移除了这个加密 ）。</p>
<p>这些调整也导致了线下安装包的变化无法对应到真正的下载大小变化的变更，很难用线下构建的安装包来量化最终对下载大小的影响。想要查看不同机型的安装包下载大小，只能打包上传AppStore Connect后查看。</p>
<h2 id="可执行文件瘦身"><a href="#可执行文件瘦身" class="headerlink" title="可执行文件瘦身"></a>可执行文件瘦身</h2><p>安装包中的可执行文件，占了安装包中很大一部分空间，而这部分不光和代码有关还和编译、链接过程中添加的参数，编译的机器环境、Xcode 版本等等都有关系。</p>
<h3 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h3><h4 id="编译期优化参数"><a href="#编译期优化参数" class="headerlink" title="编译期优化参数"></a>编译期优化参数</h4><p>Xcode 支持编译器层面的一些优化选项，可以让我们介于更快的编译速度和更小的二进制大小并且更快的执行速度之间自由选择想要进行的优化粒度。</p>
<p>我们都知道 Xcode 是使用 <a href="http://clang.llvm.org/" target="_blank" rel="noopener">Clang</a> 来编译 Objective-C 语言的，Clang 的优化选项在其文档 <a href="https://clang.llvm.org/docs/CommandGuide/clang.html" target="_blank" rel="noopener">clang - Code Generation Options</a> 中可以查阅得到。我们Xcode 目前提供给我们 7 个等级的编译选项，在 Xcode -&gt; Build Setting -&gt; Apple clang - Code Generation -&gt; Optimization Level 中进行设置，每个等级的说明，可以参考<a href="http://help.apple.com/xcode/mac/current/#/itcaec37c2a6" target="_blank" rel="noopener">官方文档</a>：</p>
<ul>
<li>None[-O0]: 编译器不会优化代码，意味着更快的编译速度和更多的调试信息，默认在 Debug 模式下开启。</li>
<li>Fast[-O,O1]: 编译器会优化代码性能并且最小限度影响编译时间，此选项在编译时会占用更多的内存。</li>
<li>Faster[-O2]：编译器会开启不依赖<a href="https://simple.wikipedia.org/wiki/Space-time_tradeoff" target="_blank" rel="noopener">空间/时间折衷</a>所有优化选项。在此，编译器不会展开循环或者函数内联。此选项会增加编译时间并且提高代码执行效率。</li>
<li>Fastest[-O3]：编译器会开启所有的优化选项来提升代码执行效率。此模式编译器会执行函数内联使得生成的可执行文件变得更大。一般不推荐使用此模式。</li>
<li>Fastest Smallest[-Os]：编译器会开启除了会明显增加包大小以外的所有优化选项。默认在 Release 模式下开启。</li>
<li>Fastest, Aggressive Optimization[-Ofast]：启动 -O3 中的所有优化，可能会开启一些违反语言标准的一些优化选项。一般不推荐使用此模式。</li>
<li>Smallest, Aggressive Optimization[-Oz]：编译器会对单个编译单元中跨函数的相同代码序列外联成函数进行复用，和“内联函数”的原理正好相反。每个原始代码序列都被替换为调用该 Outlined 函数。会减小相同代码存在多份问题。开启此模式，能减小二进制的大小，但同时也会使得的函数调用存在更深的调用栈，理论上会带来执行效率的额外消耗，对性能（CPU）敏感的代码使用需要评估。<a href="https://developer.apple.com/videos/play/wwdc2019/409/" target="_blank" rel="noopener">WWDC 2019 《What’s New in Clang and LLVM》</a> 中对 Oz 有过介绍。</li>
</ul>
<p>Fastest Smallest[-Os] 极小限度会影响到包大小，而且也保证了代码的执行效率，是最佳的发布选项。一般 Xcode 会在 Release 下默认选择 Fastest Smallest[-Os] 选项，较老的项目可能没有自动勾选。</p>
<p>XCode 中设置的选项最终会反应在 Clang 命令上面，打开 build log 可以看到此选项最终的表现形式：</p>
<p><img src="https://nos.netease.com/cloud-website-bucket/201809181451521907e647-871e-44e4-8b7d-1b5539d4682e.jpg" alt="img"> </p>
<blockquote>
<p>如果你还需要 clang 的其他选项来编译你的项目，可以在 Other C Flag 中直接添加其参数。举例来说，在 Optimization Level 中设置 Fastest Smallest[-Os] 和在 Other C Flags 中添加 -Os 效果是一样的。</p>
</blockquote>
<p>对执行效率、堆栈解析、稳定性和编译速度进行综合评估后，如果可以接受，可以对部分源代码开启Oz 编译，以最大程度优化安装包效果。</p>
<p>需要注意的是在 ARC 场景 <code>objc_retainAutoreleaseReturnValue</code> 被外联之后会导致一个本来不需要被放入 autoreleasepool 中的对象被放入了 autoreleasepool。这将导致一些有问题的写法出现更坏的结果比如出现延迟释放导致 BAD_ACCESS 或者被 <code>@autoreleasepool</code>包裹的对象延时释放导致的内存暴涨，所以在开启的时候需要进行测试。</p>
<h4 id="链接期优化参数"><a href="#链接期优化参数" class="headerlink" title="链接期优化参数"></a>链接期优化参数</h4><p>除了编译期优化，Xcode 还支持链接器层面的一些优化选项，可以在 Xcode -&gt; Build Setting -&gt; Apple clang - Code Generation -&gt; Link-Time Optimization 中进行设置。目前Xcode提供了以下选项：</p>
<ul>
<li><strong>No：</strong>不开启链接期优化；</li>
<li><strong>Monolithic：</strong>生成单个 LTO 文件，每次链接重新生成，无缓存高内存消耗，参数 LLVM_LTO=YES；</li>
<li><strong>Incremental：</strong>生成多个 LTO 文件，增量生成，低内存消耗，参数 LLVM_LTO=YES_THIN；</li>
</ul>
<p>本地调试和对时间敏感的构建流程不建议开启 LTO。会增加很多的构建时间。</p>
<p>需要注意的是 LTO 虽然是链接期优化，但是仍然需要编译期参与，加入了 LTO 的编译出来的 .a 本质是 LLVM 的 BitCode，如果使用未开启 LTO 构建出来的的 .a 直接是机器码了。直接链接是无法完成 LTO 优化的。</p>
<p>开启 LTO 之后跨编译单元的重复代码会被链接器单独生成以 <code>.lto.o</code>为后缀的目标文件进行链接。尤其是对于 Objc Runtime 需要的一些结构 比如方法签名的 literal string， protocol 的结构等有比较大的优化。同时开启 Oz 和 LTO 可以让外联函数都只存在一份能够最大限度的优化安装包体积。如果你的项目中大量的使用了 Protocol 建议还是开启这个选项。</p>
<h5 id="BitCode"><a href="#BitCode" class="headerlink" title="BitCode"></a>BitCode</h5><p>BitCode 是 iOS 9 引入的新特性，官方文档解释 BitCode 是一种程序中间码，其实就是 LLVM IR 的一种编码形式 - <a href="https://llvm.org/docs/BitCodeFormat.html" target="_blank" rel="noopener">BitCodeFormart</a>。</p>
<p><img src="https://nos.netease.com/cloud-website-bucket/20180918145314d34dd07d-f152-40a7-ac7b-a1081a441c34.jpg" alt="img"> </p>
<p>上图表示了 IR 和 BitCode 在编译器架构中所在的位置，需要说明的是 BitCode 是以 section 形式保存在可执行文件中。上文中提到的可执行文件的 Slicing 技术就是基于BitCode。当我们把携带 BitCode 的 App 提交到 AppStore 后，苹果会提取出可执行文件中的 BitCode 段，然后针对不同的 CPU 架构编译和链接成不同的可执行文件变体(Variant)，不同 CPU 架构的设备会自动选择合适的架构的变体进行下载。而在 BitCode 之前，我们都是把所有需要的 CPU 架构集合打包成一个 <a href="https://en.wikipedia.org/wiki/Fat_binary" target="_blank" rel="noopener">Fat Binary</a>，结果就是用户最终下载的安装包之中有很多冗余的 CPU 架构支持代码。</p>
<p>从以上编译器架构中我们也可以得出一个结论：开启 BitCode 之后编译器后端(Backend)的工作都由 Apple 接管了。所以假如以后苹果推出了新的 CPU 架构或者以后 LLVM 推出了一系列优化，我们也不再需要为其发布新的安装包了。</p>
<p>需要注意的是，工程开启 BitCode 之后必须要求所有打进 Bundle 的 Binary 都需要支持 BitCode，也就是说我们依赖的静态库和动态库都是含有 BitCode 的，不然就会打包失败。</p>
<h3 id="符号表的裁剪"><a href="#符号表的裁剪" class="headerlink" title="符号表的裁剪"></a>符号表的裁剪</h3><p>可执行文件中的<a href="https://en.wikipedia.org/wiki/Symbol_(programming)" target="_blank" rel="noopener">符号</a>是指程序中的所有的变量、类、函数、枚举、变量和地址映射关系，以及一些在调试的时候使用到的用于定位代码在源码中的位置的调试符号，符号和断点定位以及堆栈符号化有很重要的关系。</p>
<h4 id="Strip-Style"><a href="#Strip-Style" class="headerlink" title="Strip Style"></a>Strip Style</h4><p>Strip Style 表示的是我们需要去除的符号的类型的选项，其分为三个选择项：</p>
<ul>
<li>All Symbols: 去除所有符号，一般是在主工程中开启。</li>
<li>Non-Global Symbols: 去除一些非全局的 Symbol（保留全局符号，Debug Symbols 同样会被去除），链接时会被重定向的那些符号不会被去除，此选项是静态库/动态库的建议选项。</li>
<li>Debug Symbols: 去除调试符号，去除之后将无法断点调试。</li>
</ul>
<p>对于 App 的主二进制而言，对外是不需要暴露符号信息的。而对外暴露的符号名称对 App 整体安全来讲也存在一些风险。通常通过设置 <code>STRIP_STYLE= all</code>来裁剪所有符号。对于自己构建的动态库。只需要保留未定义的符号以及全局的符号其他的都可以去除。通常设置：<code>STRIP_STYLE=non-global</code>。</p>
<h4 id="调试符号（symbols）"><a href="#调试符号（symbols）" class="headerlink" title="调试符号（symbols）"></a>调试符号（symbols）</h4><p>iOS 的调试符号是 DWARF 格式的，相关概念如下：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Mach-O" target="_blank" rel="noopener">Mach-O</a>: 可执行文件，源文件编译链接的结果。包含映射调试信息(对象文件)具体存储位置的 Debug Map。</li>
<li><a href="https://en.wikipedia.org/wiki/DWARF" target="_blank" rel="noopener">DWARF</a>：一种通用的调试文件格式，支持源码级别的调试，调试信息存在于 <a href="https://en.wikipedia.org/wiki/Object_file" target="_blank" rel="noopener">Object_file</a> 中，一般都比较大。Xcode 调试模式下一般都是使用 DWARF 来进行符号化的。</li>
<li>dSYM：独立的符号表文件，主要用来做发布产品的崩溃符号化。dSYM 是一个压缩包，里面包含了 DWARF 文件。</li>
</ul>
<p><img src="https://nos.netease.com/cloud-website-bucket/201809181452418e5bac54-bed6-4a3d-a3cb-48af54e2daf2.jpg" alt="img"> </p>
<p>使用 Xcode 编译打包的时候会先通过可执行文件的 Debug Map 获取到所有对象文件的位置，然后使用 <a href="https://llvm.org/docs/CommandGuide/dsymutil.html" target="_blank" rel="noopener">dsymutil</a> 来将对象文件中的 DWARF 提取出来生成 dSYM 文件。</p>
<h4 id="Strip-Linked-Product"><a href="#Strip-Linked-Product" class="headerlink" title="Strip Linked Product"></a>Strip Linked Product</h4><blockquote>
<p>If enabled, the linked product of the build will be stripped of symbols when performing deployment postprocessing.</p>
</blockquote>
<p>并不是所有的符号都是必须的，比如 Debug Map，所以 Xcode 提供给我们 Strip Linked Product 来去除不需要的符号信息(Strip Style 中选择的选项相应的符号)，去除了符号信息之后我们就只能使用 dSYM 来进行符号化了，所以需要将 Debug Information Format 修改为 DWARF with dSYM file。</p>
<p>那么没有 DWARF 调试信息之后 Xcode 是靠什么来生成 dSYM 的呢？答案其实还是 DWARF，因为 Xcode 编译实际的操作步骤是：生成带有 DWARF 调试信息的可执行文件 -&gt; 提取可执行文件中的调试信息打包成 dSYM -&gt; 去除符号化信息。去除符号是单独的步骤，使用的是 strip 命令。</p>
<p>另外一个问题是，去除符号化信息之后我们只能使用 dSYM 来进行符号化，那我们使用 Xcode 来进行调试的时候会不会太麻烦了？其实我们完全不用担心这个问题：Strip Linked Product 选项在 Deployment Postprocessing 设置为 YES 的时候才生效，而在 Archive 的时候 Xcode 总是会把 Deployment Postprocessing 设置为 YES 。所以我们可以打开 Strip Linked Product 并且把 Deployment Postprocessing 设置为 NO，而不用担心调试的时候会影响断点和符号化，同时打包的时候又会自动去除符号信息。这个选项也是默认打开的，较老的项目可以选择手动开启。</p>
<h4 id="Strip-Debug-Symbols-During-Copy"><a href="#Strip-Debug-Symbols-During-Copy" class="headerlink" title="Strip Debug Symbols During Copy"></a>Strip Debug Symbols During Copy</h4><blockquote>
<p>Specifies whether binary files that are copied during the build, such as in a Copy Bundle Resources or Copy Files build phase, should be stripped of debugging symbols. It does not cause the linked product of a target to be stripped—use Strip Linked Product (STRIP_INSTALLED_PRODUCT) for that.</p>
</blockquote>
<p>与 Strip Linked Product 类似，但是这个是将那些拷贝进项目包的三方库、资源或者 Extension 的  Debug Symbol 去除掉，同样也是使用的 strip 命令。这个选项没有前置条件，所以我们只需要在 Release 模式下开启，不然就不能对三方库进行断点调试和符号化了。</p>
<p>如果依赖的 Target 是独立签名的（比如 App Extension），strip 操作就会失效，并伴随着 Warning：warning: skipping copy phase strip, binary is code signed: xxxx。此情况将依赖的 Target 中的 Strip Linked Product 修改为 YES，保证依赖的 Target 是已经去除了符号即可，Waning 忽略掉就可以了。</p>
<blockquote>
<p>Cocoapods 管理的动态库(use_framework!)的情况就相对要特殊一点，因为 Cocoapods 中的的动态库是使用自己实现的脚本 Pods-xxx-frameworks.sh 来实现拷贝的，所以并不会走 Xcode 的流程，当然也就不受 Strip Debug Symbols During Copy 的影响。当然 Cocoapods 是源码管理的，所以只需要将源码 Target 中的 Strip Linked Product 设置为 YES 即可。</p>
</blockquote>
<h4 id="Strip-Swift-Symbols"><a href="#Strip-Swift-Symbols" class="headerlink" title="Strip Swift Symbols"></a>Strip Swift Symbols</h4><blockquote>
<p>Adjust the level of symbol stripping specified by the STRIP_STYLE setting so that when the linked product of the build is stripped, all Swift symbols will be removed.</p>
</blockquote>
<p>开启 Strip Swift Symbols 能帮助我们移除相应 Target 中的所有的 Swift 符号，这个选项也是默认打开的。</p>
<p>补充一点：Swift ABI 稳定之前，Swift 标准库是会打进目标文件的，想要同时移除 Swift 标准库里面的符号的话需要在<a href="http://help.apple.com/xcode/mac/current/#/devde46df08a" target="_blank" rel="noopener">发布选项</a>中勾选 Strip Swift symbols。</p>
<h3 id="修正-Exported-Symbols-配置"><a href="#修正-Exported-Symbols-配置" class="headerlink" title="修正 Exported Symbols 配置"></a>修正 Exported Symbols 配置</h3><p>上面说到可以通过设置 <code>STRIP_STYLE= all</code>来裁剪所有符号。但通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -exports-trie &#x2F;path&#x2F;to&#x2F;MyApp.app&#x2F;MyApp</span><br></pre></td></tr></table></figure>

<p>还能获取到可执行文件中的符号，这部分可以通过设置 <code>EXPORTED_SYMBOLS_FILE</code>为一个空文件解决 <code>EXPORTED_SYMBOLS_FILE=/path/to/emptyfile.txt</code>。</p>
<p>Xcode Build Settings 中的 <code>EXPORTED_SYMBOLS_FILE</code>配置，控制着 Mach-O 中 <code>__LINKEDIT</code>段中 Export Info 的信息。动态链接器 dyld 在做符号绑定时，会读取被绑定的动态库或可执行文件的 Export Info 信息，得到一个符号对应的实际调用地址。如果正在被绑定的符号，在目标动态库的 Export Info 中缺失，dyld 则会抛出异常，表现为 App 崩溃。</p>
<p>虽然从原理上看，Export Info 中的信息不可或缺。但是，对于一个 Mach-O 文件来说，并非所有的符号都是需要暴露给其他动态库或可执行文件的。理想情况下，私有的符号应该在编码时就应该以 <code>__attribute__((visibility(hidden)))</code>修饰。但在历史代码难以逐个添加修饰符的情况下，Exported Symbols 配置给了工程一个维护公有符号白名单的机会。如果填写了有效的 <code>EXPORTED_SYMBOLS_FILE</code>配置，动态库或者可执行文件会在静态链接时去掉白名单以外的符号，起到缩减包大小、增加逆向难度的作用。</p>
<h3 id="死代码裁剪"><a href="#死代码裁剪" class="headerlink" title="死代码裁剪"></a>死代码裁剪</h3><p>在构建完成之后如果是 C、C++ 等静态的语言的代码、一些常量定义，如果发现没有被使用到将会被标记为 Dead code。开启 <code>DEAD_CODE_STRIP = YES</code>这些 Dead code 将不会被打包到安装包中。在 LinkMap 这些符号也会被标记为 <code>&lt;&lt;dead&gt;&gt;</code>。</p>
<h3 id="清理无用代码"><a href="#清理无用代码" class="headerlink" title="清理无用代码"></a>清理无用代码</h3><p>扫描无用代码方式可以分为动态和静态两种方式。静态的方式主要是通过代码扫描、参与编译构建过程或者分析最终产物来确认哪些代码没有被用到。而动态的方式主要是靠插桩或者运行时信息来获取哪些代码没有执行。由于 Objc 强大的动态特性，我们在样本量足够大的场景使用动态方式会比静态方式准确率高很多。</p>
<p><strong>静态筛查筛查方案：</strong></p>
<p>最简单的静态扫描是基于 AppCode，但是项目大了之后 AppCode 的索引速度非常慢。另一种方式是基于 Mach-O 的的一种静态扫描方式，在 otool dump 最终产物中的 objc_class_list &amp; objc_class_refs 做差集找到未使用的 Objc 类。</p>
<p>上面提到，如果代码采用 C 、C++ 等静态语言编写代码时，编译期已经确定了基本的代码逻辑，编译器会帮助我们将没有使用到的代码标记为 Dead code 并裁剪，最终不会打包到安装包中。但 Objc 是典型的动态语言，很多逻辑都是在运行时决议的，我们通过静态扫描的方式扫描出来的误差会比较大。</p>
<p>Objc 动态特性引入的的主要的问题包括：</p>
<ul>
<li><p>实际用到了但被扫描成无用类：</p>
<ul>
<li>一个类确实没有被其他地方使用， 但是本身逻辑依赖 <code>+load</code>、<code>+initialize</code>、<code>__attribute__((constructor))</code>在启动时调用</li>
<li>通过 string 动态调用</li>
<li>抽象基类、基类等会被认为是无用类</li>
<li>通过运行时动态生成的代码引用了某个类</li>
<li>一个类专门作为通知处理类</li>
<li>MTLModel 等，通过运行时消息机制 assign value 的无法通过 classref 统计</li>
<li>典型的 DI 场景。如果一个类声明遵循了某个 Protocol，外部使用的时候使用了这个 Protocol 进行方法调用</li>
</ul>
</li>
<li><p>实际没用到但被认为有用到：</p>
<ul>
<li>某个对象被另外一个对象引用，但是另外一个对象本身未被使用到。这时候会遗漏掉这个对象所属 Class 的检查</li>
</ul>
</li>
</ul>
<p><strong>动态筛查方案：</strong></p>
<ul>
<li><p>基于插桩的行级别代码覆盖率</p>
<p>基于 GCOV 或者 LLVM Profile 二进制的插桩方案可以实现在运行时收集插桩数据来指导无用代码的删除。但插桩方案局限性也显而易见，插桩会劣化二进制本身的大小和性能，同时原生的插桩方案是无法过审上线。数据收集只能局限于线下。</p>
</li>
<li><p>基于 Runtime 的轻量级运行时「类覆盖率」方案</p>
<p>Objc 的类首次调用类初始化时，<code>+initialize</code>被执行，系统会自动标记已被调用，在 metaClass 中 data 的 flags 字段第 29 位就存着这个这个状态。可以使用 <code>flags &amp; RW_INITIALIZED</code>获取。iOS14 之后这个值的获取方式有变化。具体参考：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2020%2F10163%2F">WWDC：Advancements in the Objective-C runtime</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define RW_INITIALIZED (1&lt;&lt;29)</span><br><span class="line">bool isInitialized() &#123;</span><br><span class="line">   return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上报的数据可以让我们了解我们线上真实的 Class 使用情况，对得到的数据不仅可以用来删减未使用的代码。还可以分辨使用率低的场景，如果是低频且必须的场景可以考虑使用跨端技术这种对原生包大小影响比较小的方案实现。而如果这些场景是某个渗透率很低的需求可以考虑直接下线为其他需求做置换。</p>
</li>
</ul>
<h3 id="重构重复代码"><a href="#重构重复代码" class="headerlink" title="重构重复代码"></a>重构重复代码</h3><p>重复代码堆积太多，不仅意味着 <a href="https://en.wikipedia.org/wiki/Code_smell" target="_blank" rel="noopener">Bad Code Smell</a>，我们的包大小也会受到影响。如果没有开启-Oz编译选项，我们可以使用 <a href="https://pmd.github.io/" target="_blank" rel="noopener">PMD</a> 来检查项目中的重复代码然后做选择性的重构。</p>
<h3 id="属性动态化"><a href="#属性动态化" class="headerlink" title="属性动态化"></a>属性动态化</h3><p>属性是 OC 中最常见的概念之一。然而，一个属性并没有我们想象的这么小。通过分析 Mach-O 文件，我们发现，一个属性可以分为三个部分：</p>
<p>（1）成员变量部分：成员变量本质是一个大小 32B 的结构体，结构体中三个指针（Offset、Name、Type）指向的内容的大小分别为 8B、10B、10B，其中 Name、Type 指针指向的内容的大小和成员变量的类型、名字长度相关。总大小大约 60B。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">presentViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">UIButton</span> *button;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e5eba61ac4741be8d465a63e651ac35~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>（2）自动生成的 set/get 方法部分：set/get 方法本质是一个大小 24B 的结构体，结构体包含三个指针 Name、Type、Implementation，指向的内容大小大概为 10B、10B、20B。一个方法大小大概是64B，set、get 两个方法就是 128B。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3d3d5debbb34a81aec16861e52046ff~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>（3）property 部分：property 的本质仍然是个结构体，大小是 16B，结构体中两个指针指向内容的大小分别大概是 10B、10B，和属性的名字和类型相关。总大小大概 36B。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8832b403c76745e9bb6c2a2df354a3ed~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>即一个属性占用的包大小大约为 224B。</p>
<p>如果我们用 <code>@dynamic</code>修饰一个属性，不生成成员变量、get/set 方法，则一个属性可以由 224B 减少到 36B，即仅包含 property 部分的大小。</p>
<p>同时，代码中存在大量通过脚本自动生成的 <code>JSONModel</code>子类，这些子类往往拥有大量属性。这里也就存在着包大小优化空间。</p>
<p>于是我们通过修改生成 <code>JSONModel</code>子类的脚本，实现了：</p>
<p>1、属性全部使用 <code>@dynamic</code>修饰，基础变量额外生成 IVAR</p>
<p>2、所有 <code>JSONModel</code>的子类继承自新的父类，新的父类实现 <code>resolveInstanceMethod</code>，在该方法中用 <code>class_addMethod</code>统一为属性添加 get/set 方法。对象类型的属性使用关联对象的方式存取，基础类型的属性使用额外生成的 IVAR 存取。</p>
<h3 id="TEXT-段迁移"><a href="#TEXT-段迁移" class="headerlink" title="__TEXT 段迁移"></a>__TEXT 段迁移</h3><p>安装包经过压缩后的 Download Size 若超过 200 MB，在蜂窝网络下载 App 就会受到限制，这对新增会有较大影响。在 2020 年下半年，我们探索实践了 <strong>TEXT 段迁移技术：在链接阶段使用 <code>-rename_section</code>选项将 `</strong>TEXT,<strong>text<code>迁移到</code></strong>BD_TEXT<code>,</code>__text`，减少苹果对可执行文件的加密范围，提升可执行文件的压缩效率，从而减少 Download Size。</p>
<p>使用该方案我们最终减少了 60 MB 的 Download Size 以及 2 MB 的 Install Size。详细的原理可以参考：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI1MzYzMjE0MQ%3D%3D%26mid%3D2247487459%26idx%3D1%26sn%3D3dd9276f5af78ca5a377adec37e3e916%26chksm%3De9d0c401dea74d17e9f1bdd5ea764cc0cd7e845c6ebadde752d36608306b09e762a1681c7252%26token%3D2034623783%26lang%3Dzh_CN%23rd">《今日头条优化实践： iOS 包大小二进制优化，一行代码减少 60 MB 下载大小》</a></p>
<h3 id="二进制段压缩"><a href="#二进制段压缩" class="headerlink" title="二进制段压缩"></a>二进制段压缩</h3><p>Mach-O 文件占据了 Install Size 中很大一部分比例，但并不是文件中的每个段/节在程序启动的第一时间都要被用到。可以在构建过程中将 Mach-O 文件中的这部分段/节压缩，然后只要在这些段被使用到之前将其解压到内存中，就能达到了减少包大小的效果，同时也能保证程序正常运行。由于苹果的一些限制，推荐只压缩了 <code>__TEXT,__gcc_except_tab</code>与 <code>__TEXT,__objc_methtype</code>两个节，然后在 <code>_dyld_register_func_for_add_image</code>的回调中对它进行解压。 </p>
<h2 id="资源文件瘦身"><a href="#资源文件瘦身" class="headerlink" title="资源文件瘦身"></a>资源文件瘦身</h2><h3 id="无用资源的移除"><a href="#无用资源的移除" class="headerlink" title="无用资源的移除"></a>无用资源的移除</h3><p>未使用的资源可以使用脚本来进行删除。强烈推荐使用 <a href="https://github.com/onevcat/FengNiao" target="_blank" rel="noopener">FengNiao</a> 来自动删除图片，因为其相对比较新，是 2017 年开始开发的，并且是使用 swift 语言开发的，方便进行二次开发。FengNiao 的基本原理是查找出项目中所有使用到的字符串和项目中所有的资源文件。两者进行匹配（完全匹配和模式匹配，模式匹配支持带数字资源的前缀/中缀/后缀匹配），计算差集就为未使用的资源。</p>
<p>相比于之前流行的 <a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">LSUnusedResources</a>，FengNiao 支持模式匹配会更加强大：比如我们导入 image_01 image_02 image_03 这样的图片资源作为帧动画素材，使用的时候是 image_%d 或者 image_(index) 方式，FengNiao 会把这些图片资源作为使用中的资源，不会出现误删的情况。当然如果你还是用了其他 Pattern，可以考虑扩展 FengNiao。</p>
<p>除了这些之外，FengNiao 是命令行工具，我们可以给 Xcode 添加 Run Script，在每次构建的时候自动检测/清理未使用的资源。</p>
<blockquote>
<p>由于基于源码的扫描工具结果不是百分百准确的，所以建议最好的做法是在项目编译的时候提供出显式的 Warning，然后再次确认之后再去删除。同时也可以配合资源命名规范来优化工具，如果你们的命名规范和工具的检测规范能够保持一致的话，搜索的结果无疑是最为准确的。</p>
<p>之所以要使用自动化工具来检测重复资源的原因是因为资源是弱类型，我们在项目迭代过程中手动去维护是相当麻烦的一个过程。转换一下思维，如果资源变成强类型了，那我们维护起来就相当容易了。目前就有这样一个工具-<a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener">R.swift</a>，类似于 Android 开发中的 R 文件，有兴趣的可以去尝试。</p>
</blockquote>
<h3 id="去除重复资源"><a href="#去除重复资源" class="headerlink" title="去除重复资源"></a>去除重复资源</h3><p>这里所说的重复资源是资源内容相同但是命名不相同的一些资源，对于此类资源，我们可以使用 <a href="https://github.com/adrianlopezroche/fdupes" target="_blank" rel="noopener">fdupes</a> 来进行扫描并去除，fdupes 的原理是对比不同文件的签名，签名相同的文件就会判定为重复资源。</p>
<p>然后我们就可以在 Xcode 中添加 Run Script，对于扫描到的相同的资源，我们可以显式的报出 Warning，然后我们在开发阶段解决资源重复的问题。</p>
<h3 id="资源文件动态化"><a href="#资源文件动态化" class="headerlink" title="资源文件动态化"></a>资源文件动态化</h3><p>可以将一些低频场景下的资源放到云端，在进入 app 安装之后再去云端按需获取。</p>
<h3 id="ODR-的资源获取方案"><a href="#ODR-的资源获取方案" class="headerlink" title="ODR 的资源获取方案"></a>ODR 的资源获取方案</h3><p>Apple 提供了按需资源（On-Demand Resource）的方式来帮助减小安装包首次下载的大小, 当有一些由于审核原因必须要内置在安装包中，但又可以走下发的情况可以尝试以下这种解决方案。当然 ODR 中的资源也需要符合 App Store 的审核标准，否则也会存在拒审风险。</p>
<h3 id="资源压缩"><a href="#资源压缩" class="headerlink" title="资源压缩"></a>资源压缩</h3><p>当我们一定要在安装包内置某个资源的话，应该在可接受的范畴之内，尽可能的小。比如我们安装包中内置的视频、音频资源可以采用降低清晰度、码率等等方式进行压缩。iOS 原生的多语言方案比较消耗空间，可以考虑自研更加紧凑的方案。</p>
<h3 id="使用-RGB-with-palette-压缩图片"><a href="#使用-RGB-with-palette-压缩图片" class="headerlink" title="使用 RGB with palette 压缩图片"></a>使用 RGB with palette 压缩图片</h3><p>做过包体优化的话，你可能会发现，如果对 Asset Catalog 中的 png 图片做无损压缩，虽然放入 Asset Catalog 的图片大小有了明显减小，但是构建的产物的大小却几乎没有变化。这是因为，Xcode 中，构建 Asset Catalog 的工具 actool 会首先对 Asset Catalog 中的 png 图片进行解码，得到 Bitmap 数据，然后再运用 actool 的编码压缩算法进行编码压缩处理。无损压缩通过变换图片的编码压缩算法减少大小，但是不会改变 Bitmap 数据。对于 actool 来说，它接收的输入没有改变，所以无损压缩无法优化 Assets.car 的大小。所以要优化 Assets.car 的大小，做合适的有损压缩是一个思路。</p>
<p>有损压缩可以尝试 <a href="https://manifold.net/doc/mfd9/palette_images.htm" target="_blank" rel="noopener">RGB with palette 编码方式</a>。RGB with palette 编码的得到的字节流首先维护了一个颜色数组。颜色数组每个成员用 RGBA 四个分量维护一个颜色。图像中的每个像素点则存储颜色数组的下标代表该点的颜色。颜色数组维护的颜色种类和数量由图片决定，同时可以人为的限制颜色数组维护颜色的种类的上限，默认为最大值 256 种。这种编码方式正如它的名字：palette（调色板）。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b748ca6fba6462287a7fae857fcd1fd~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>App 中大部分图片虽然使用了很多种类的颜色，但这些颜色中大多数都非常接近，从视觉上很难分辨，比如大量扁平风格的 icon。这种类型的图片非常适合用 palette 编码且减少颜色数组大小的方式来进行有损压缩，既能减少颜色数量实现有损压缩，也能保证保留的颜色贴近原始图片，使得经过有损压缩后的也看起来质量无损。</p>
<p>在具体执行中，我们使用了 ImageOptim 工具改变图片的编码方式为 RGB with palette ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageoptim -Q <span class="comment">--no-imageoptim --imagealpha --number-of-colors 16 --quality 40-80 ./1.png</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>--number-of-colors</code>控制颜色数组维护颜色的数量；<code>--quality</code>控制图片的质量变为原来的百分比。我们的经验表明，当 <code>--number-of-colors</code>从 16 开始向上调整，<code>--quality</code>维持 40-80，能够在显著减少包大小的同时维持肉眼看不到的质量变化。经过 UI 同学的像素眼审查，确认优化前后的图片看起来无差别。</p>
<h3 id="Asset-car-中图片的优化"><a href="#Asset-car-中图片的优化" class="headerlink" title="Asset.car 中图片的优化"></a>Asset.car 中图片的优化</h3><p>Assets.car 编译过程中有时会选择一些图片，拼凑成一张大图（ZZZZPackedAsset）来提高图片的加载效率。被放进这张大图的小图会变为通过偏移量的引用。</p>
<p>建议使用频率高且小的图片放到 Asset.car 中，Asset.car 能保证其加载和渲染的速度最优。而大的图片比如背景图之类的，长宽尺寸就有上千个像素，而这种放到 Asset.car 中会大大的增加安装包的大小。建议实践中比如页面背景图，或者其他 png 格式超过 100KB 大小的图片都使用 WebP 的方式引入。相较于 PNG 格式，WebP 具有更加优秀的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量。</p>
<p>当我们在构建过程中，Xcode 会通过自己的压缩算法重新对图片进行处理。这也是为什么我们通过对图片无损压缩来优化包大小没有效果的原因。对于放入 Asset.car 中的图片如果图片没有半透明效果，使用 70% 的有损压缩是一个不错的方式，既能保证图片清晰度的同时获得更小的大小。如果对于有半透明效果的图片，采用 70% 的有损压缩会导致半透明的地方出现噪点，所以压缩过后的图片最好找设计师同学再确认一次。</p>
<p>我们通过对 Asset.car 进行了逆向研究，同一张图片，在不同设备、iOS 系统上 Xcode 采用了不同的压缩算法这也导致了下载时候不同的设备针对图片出现大小的区别。</p>
<p>截止目前 Xcode 会使用的压缩算法有 <code>lzfse</code>、<code>palette_img</code>、<code>deepmap2</code>、<code>deepmap_lzfse</code>、<code>zip</code>。</p>
<p>以 iPhoneX 为例子：</p>
<p>iOS 11.x 版本：对应的压缩算法为 <code>lzfse</code>、<code>zip</code>；</p>
<p>iOS 12.0.x - iOS 12.4.x: 对应的压缩算法为 <code>deepmap_lzfse</code>、<code>palette_img</code>；</p>
<p>iOS 13.x: 对应的压缩算法为<code>deepmap2</code>； 按照压缩比来讲 <code>lzfse</code>&lt; <code>palette_img</code>~= <code>deepmap_lzfse</code>&lt; <code>deepmap2</code>。</p>
<p>我们可以使用 <code>xcrun assetutil --info Assets.car</code> 命令检查 Assets.car 中每张图片使用的编码压缩算法。在 BuildSetting 中如果设置了 <code>ASSETCATALOG_COMPILER_OPTIMIZATION=space</code>那么低版本的使用 <code>lzfse</code>压缩算法的图片会变成 <code>zip</code>的算法可减少 iOS11.x 及以下的 iOS 设备图片的占用大小。其他 iOS 版本的压缩算法不受这个配置的影响。</p>
<h1 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h1><p>Framework 文件夹存放的是 <a href="https://developer.apple.com/library/content/technotes/tn2435/_index.html" target="_blank" rel="noopener">Embedded Framework</a>，它在打包的时候最终会被拷贝进 Target App Bundle 中的 Framework 文件夹中，在 App 启动的时候才会被链接和加载。Embedded Framework 主要分类两类：</p>
<ul>
<li>SwiftSupport：Framework 文件夹中前缀是 libSwift 的一些 framework。之前版本，由于 <a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md" target="_blank" rel="noopener">Swift ABI</a> 还未稳定，我们发布应用的时候还需要带上一份自己应用中使用到的 Swift 标准库代码，这部分占用最终 ipa 的大小可能在 10M 左右。</li>
<li>其他依赖库：使用 Cocoapods 管理依赖并且设置了 user_framework! 时三方库源码都会打包成 framework，然后导入到工程当中。</li>
</ul>
<h3 id="Framework-中的资源"><a href="#Framework-中的资源" class="headerlink" title="Framework 中的资源"></a>Framework 中的资源</h3><blockquote>
<p>这里所说的 Framework 表示的是: 静态库(.a) Framework(Static Library)</p>
</blockquote>
<p>目前绝大部分的 Framework 的做法是直接将资源放进 bundle 中进行管理的，在主工程打包的时候，Xcode 会将这部分资源直接拷贝进 App Target Bundle 中，这样做就存在2个问题：</p>
<ul>
<li>使用 bundle 管理的资源是不会被 Xcode 优化的(图片压缩等)</li>
<li>使用 bundle 管理的资源不享受 App Thinning/Slicing。</li>
</ul>
<p>所以尽量还是选择 XCAsset 进行 Framework 的资源管理，静态库和动态库的管理方式有所不同：</p>
<ul>
<li>静态库(.a)/Framework(Static Library): 静态库的目标文件(.a/.framework) 中是不能包含资源文件的，所以这部分只能使用 bundle 来管理。但是由于 bundle 直拷贝的特性，我们需要把 xib/storyboard/asset catalog 编译后的产物(nib/storyboardc/Asset.car)放进 bundle 里。比较普遍的一个做法是借助 Bundle Target 来编译我们的资源文件。</li>
<li>动态库: 动态库相对来说要简单一点，因为动态库本身就是一个 bundle。所以我们直接把资源文件放在目标文件(.framework)中就可以了。</li>
</ul>
<blockquote>
<p>如果你是使用 <a href="https://cocoapods.org/" target="_blank" rel="noopener">Cocoapods</a> 管理你的源码，也可以使用 XCAsset 来管理资源，参考 <a href="https://stackoverflow.com/questions/32577227/how-to-use-images-asset-catalog-in-cocoapod-library-for-ios" target="_blank" rel="noopener">在 Cocoapods 中使用 XCAsset</a>。</p>
</blockquote>
<h3 id="Framework-中的可执行文件"><a href="#Framework-中的可执行文件" class="headerlink" title="Framework 中的可执行文件"></a>Framework 中的可执行文件</h3><p>这部分可以参考以上的可执行文件瘦身。</p>
<h1 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h1><p>Plugin 内部主要存放的就是 <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html" target="_blank" rel="noopener">App Extension</a>，App Extension 是独立打包签名，然后再拷贝进 Target App Bundle 的。</p>
<h3 id="Plugin-中的静态库"><a href="#Plugin-中的静态库" class="headerlink" title="Plugin 中的静态库"></a>Plugin 中的静态库</h3><p>静态库最终会打包进可执行文件内部，所以如果 App Extension 依赖了三方静态库，同时主工程也引用了相同的静态库的话，最终 App 包中可能会包含两份三方静态库的体积。</p>
<h3 id="Plugin-中的动态库"><a href="#Plugin-中的动态库" class="headerlink" title="Plugin 中的动态库"></a>Plugin 中的动态库</h3><p>动态库是在运行的时候才进行加载链接的，所以 Plugin 的动态库是可以和主工程共享的，把动态库的加载路径 Runpath Search Paths 修改为跟主工程一致就可以共享主工程引入的动态库。<img src="https://nos.netease.com/cloud-website-bucket/20180918145633f82a98cf-fc75-44a3-830d-553f837991d2.jpg" alt="img"></p>
<h3 id="Plugin-中的-Swift-Standard-Library"><a href="#Plugin-中的-Swift-Standard-Library" class="headerlink" title="Plugin 中的 Swift Standard Library"></a>Plugin 中的 Swift Standard Library</h3><p>在 Swift ABI 稳定之前，Swift 标准库会被拷贝进 App 当中。Swift 标准库是动态链接库，也是可以在主工程和其他的 App Extensions 之间共享的，前提当然是所有 Target 使用的 Swift 版本是一致的，否则就会出现意料之外的 bug。 设置共享分为两步：</p>
<ul>
<li>设置 Extension 中的 Always Embed Swift Standard Libraries 为 NO，让编译器不再为 Extension 生成 Swift 标准库<img src="https://nos.netease.com/cloud-website-bucket/201809181456458ffc259f-3338-4408-82c6-503bdc0e1a21.jpg" alt="img"></li>
<li>设置 Extension 中的动态库的查找路径为主工程的 Framework 文件夹</li>
</ul>
<h2 id="防劣化的建设"><a href="#防劣化的建设" class="headerlink" title="防劣化的建设"></a>防劣化的建设</h2><p>在优化之后，一定要做好防劣化的建设，尤其是业务迭代迅速的团队，否则很有可能优化的速度赶不上劣化。</p>
<h3 id="各业务线对包大小占用的展示和监控"><a href="#各业务线对包大小占用的展示和监控" class="headerlink" title="各业务线对包大小占用的展示和监控"></a>各业务线对包大小占用的展示和监控</h3><p>一般大型项目都是分多个业务线，对各业务线代码占用状况进行摸底和监控，有助于从全局的角度了解头条的代码状况，找到“性价比”较低的模块。</p>
<p>进行“摸底和监控”的第一步，是需要展示出各业务线代码所占的安装包大小，即获得这些业务方向的代码，分别占用了多少安装包大小。</p>
<p>要统计代码对包大小的贡献，基本的方法是查看link map。网络上流行着一些分析link map的工具，可以查看每个类、每个静态库所占的大小。然而，如果app业务庞大，类众多（几千个），且主要功能都在主工程而非静态库中的话，展示每个类所占的二进制文件大小依然可读性较差，无法从中看出每个业务占用的大小。</p>
<p>那么如何将一个类归类到某个业务线呢？一种可行的方式，就是利用现成的数据：工程的目录结构。</p>
<p>通常项目中各个group的命名都能表明这个group属于哪个业务线。所以结合工程的目录结构，应该可以较方便的将一个类归类到某个业务线中去。通过编写脚本，可以按照工程目录的树形结构输出各个类、各个group的大小占用。脚本可以借助开源的ruby工具Xcodeproj读取工程目录，使用开源的python脚本linkmap.py读取link map，获得类和静态库的大小，最后进行整合，输出link map分析报表。</p>
<p>虽然工程中的类有几千个，但group的数目显然是非常有限的。人工的对一些group进行合计，我们可以轻松的获得各个业务线占用的二进制文件大小。</p>
<p>这些数据也可以成为了我们推动各业务线“删除冗余代码、下线废弃业务、为包大小优化作贡献”的依据。对于安装包大小占用特别大的业务，我们会优先进行包大小优化推动。</p>
<p>另外，通过观察link map分析报表，可以发现一些收益较低但代码颇多的业务并推动加速这类代码的下线。</p>
<p>在业务方对自身业务进行优化时，link map分析报表也具有指导性意义。业务方可以查看自己业务中哪些子方向相关的代码占用最多从而优先进行优化。</p>
<p>对各业务线所占包大小进行盘点后，也方便推动各业务线对无用的业务和代码进行了下线。</p>
<p>为了便于及时的产出报告，这一脚本可以集成到工程的Run Script中去，这样在需要时只用build一下，在构建的最后一步便会执行脚本，产出分析报告。</p>
<h4 id="版本差异监控"><a href="#版本差异监控" class="headerlink" title="版本差异监控"></a>版本差异监控</h4><p>在安装包大小的优化中，不仅需要优化当前的安装包大小，更需要控制包大小的增长。否则，就可能会出现业务增长造成的包大小增长快过包大小优化量的尴尬局面。</p>
<p>可以在自动打包平台增加了一些用于监控版本差异的脚本，用于对比各个版本间包大小的增长量。如果发现当前版本的包大小较上一版本有较大增长，则会以报警的方式通知给开发人员。</p>
<p>这时我们就需要排查这两个版本间包大小的增长点。为此我们编写了一个脚本辅助我们快速排查版本间的差异。</p>
<p>这个脚本执行的工作有：</p>
<p>1、从打包平台上抓去特定两个版本的安装包和linkmap文件。</p>
<p>2、解压两个安装包，对比安装包中的每个文件，输出每个文件的差量值</p>
<p>3、解压两个asset.car文件，对比安装包中的图片的差量，输出增加/减少的图片的top x</p>
<p>4、处理和对比两个linkmap文件，输出增长/减小的类的top x</p>
<p>最后它可以输出报表，帮助开发人员快速定位版本间的增长点。</p>
<p>TODO: </p>
<p>按照group展示.o大小的脚本</p>
<p>检查图片大小的脚本</p>
<p>未初始化的类的代码</p>
<p>linkmap统计未使用的方法</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://sq.sf.163.com/blog/article/200385709022117888" target="_blank" rel="noopener">iOS 安装包瘦身 （上篇）</a></p>
<p><a href="https://sq.sf.163.com/blog/article/200384401846304768" target="_blank" rel="noopener">iOS 安装包瘦身（下篇）</a></p>
<p><a href="https://juejin.cn/post/6924107853141655565" target="_blank" rel="noopener">今日头条 iOS 安装包大小优化 - 新阶段、新实践</a></p>
<p><a href="https://sq.sf.163.com/blog/article/200384401846304768" target="_blank" rel="noopener">抖音品质建设 - iOS 安装包大小优化实践篇</a></p>
<p><a href="https://www.toutiao.com/i6504526811181892110/?group_id=6504526811181892110?group_id=6504526811181892110" target="_blank" rel="noopener">干货｜今日头条iOS端安装包大小优化—思路与实践</a></p>
<p><a href="https://juejin.cn/post/6911121493573402638" target="_blank" rel="noopener">今日头条优化实践： iOS 包大小二进制优化，一行代码减少 60 MB 下载大小</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/12/04/%E3%80%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8BWebview%E9%A6%96%E5%B1%8F/" rel="prev" title="「性能优化」之Webview首屏">
      <i class="fa fa-chevron-left"></i> 「性能优化」之Webview首屏
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/" rel="next" title="刨根问底」之Runtime消息发送和转发">
      刨根问底」之Runtime消息发送和转发 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#背景"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#下载大小限制"><span class="nav-number">1.1.</span> <span class="nav-text">下载大小限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可执行文件大小限制"><span class="nav-number">1.2.</span> <span class="nav-text">可执行文件大小限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装包分析"><span class="nav-number">2.</span> <span class="nav-text">安装包分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装包构成"><span class="nav-number">2.1.</span> <span class="nav-text">安装包构成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装包分析-1"><span class="nav-number">2.2.</span> <span class="nav-text">安装包分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#App-Slicing"><span class="nav-number">2.2.1.</span> <span class="nav-text">App Slicing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加密"><span class="nav-number">2.2.2.</span> <span class="nav-text">加密</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可执行文件瘦身"><span class="nav-number">3.</span> <span class="nav-text">可执行文件瘦身</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编译选项"><span class="nav-number">3.1.</span> <span class="nav-text">编译选项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编译期优化参数"><span class="nav-number">3.1.1.</span> <span class="nav-text">编译期优化参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链接期优化参数"><span class="nav-number">3.1.2.</span> <span class="nav-text">链接期优化参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BitCode"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">BitCode</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#符号表的裁剪"><span class="nav-number">3.2.</span> <span class="nav-text">符号表的裁剪</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Strip-Style"><span class="nav-number">3.2.1.</span> <span class="nav-text">Strip Style</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调试符号（symbols）"><span class="nav-number">3.2.2.</span> <span class="nav-text">调试符号（symbols）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Strip-Linked-Product"><span class="nav-number">3.2.3.</span> <span class="nav-text">Strip Linked Product</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Strip-Debug-Symbols-During-Copy"><span class="nav-number">3.2.4.</span> <span class="nav-text">Strip Debug Symbols During Copy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Strip-Swift-Symbols"><span class="nav-number">3.2.5.</span> <span class="nav-text">Strip Swift Symbols</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修正-Exported-Symbols-配置"><span class="nav-number">3.3.</span> <span class="nav-text">修正 Exported Symbols 配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死代码裁剪"><span class="nav-number">3.4.</span> <span class="nav-text">死代码裁剪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清理无用代码"><span class="nav-number">3.5.</span> <span class="nav-text">清理无用代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重构重复代码"><span class="nav-number">3.6.</span> <span class="nav-text">重构重复代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性动态化"><span class="nav-number">3.7.</span> <span class="nav-text">属性动态化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TEXT-段迁移"><span class="nav-number">3.8.</span> <span class="nav-text">__TEXT 段迁移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制段压缩"><span class="nav-number">3.9.</span> <span class="nav-text">二进制段压缩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源文件瘦身"><span class="nav-number">4.</span> <span class="nav-text">资源文件瘦身</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无用资源的移除"><span class="nav-number">4.1.</span> <span class="nav-text">无用资源的移除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#去除重复资源"><span class="nav-number">4.2.</span> <span class="nav-text">去除重复资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源文件动态化"><span class="nav-number">4.3.</span> <span class="nav-text">资源文件动态化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ODR-的资源获取方案"><span class="nav-number">4.4.</span> <span class="nav-text">ODR 的资源获取方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源压缩"><span class="nav-number">4.5.</span> <span class="nav-text">资源压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-RGB-with-palette-压缩图片"><span class="nav-number">4.6.</span> <span class="nav-text">使用 RGB with palette 压缩图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Asset-car-中图片的优化"><span class="nav-number">4.7.</span> <span class="nav-text">Asset.car 中图片的优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Framework"><span class="nav-number"></span> <span class="nav-text">Framework</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Framework-中的资源"><span class="nav-number">0.1.</span> <span class="nav-text">Framework 中的资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Framework-中的可执行文件"><span class="nav-number">0.2.</span> <span class="nav-text">Framework 中的可执行文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Plugins"><span class="nav-number"></span> <span class="nav-text">Plugins</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Plugin-中的静态库"><span class="nav-number">0.1.</span> <span class="nav-text">Plugin 中的静态库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Plugin-中的动态库"><span class="nav-number">0.2.</span> <span class="nav-text">Plugin 中的动态库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Plugin-中的-Swift-Standard-Library"><span class="nav-number">0.3.</span> <span class="nav-text">Plugin 中的 Swift Standard Library</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#防劣化的建设"><span class="nav-number">1.</span> <span class="nav-text">防劣化的建设</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#各业务线对包大小占用的展示和监控"><span class="nav-number">1.1.</span> <span class="nav-text">各业务线对包大小占用的展示和监控</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#版本差异监控"><span class="nav-number">1.1.1.</span> <span class="nav-text">版本差异监控</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考："><span class="nav-number">1.2.</span> <span class="nav-text">参考：</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">和僧</p>
  <div class="site-description" itemprop="description">技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">和僧</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
