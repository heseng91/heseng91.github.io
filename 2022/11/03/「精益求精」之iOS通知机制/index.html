<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"heseng91.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="作为一个iOS开发，想必对通知应该都不陌生。本文主要是针对iOS通知机制的全面解析，从接口到原理面面俱到。 由于苹果没有对相关源码开放，所以以GNUStep源码为基础进行研究，GNUStep虽然不是苹果官方的源码，但彼此之间都在努力的保持一致，因此很具有参考意义，根据实现原理来猜测和实践，更重要的还可以学习观察者模式的架构设计。">
<meta property="og:type" content="article">
<meta property="og:title" content="「精益求精」之iOS通知机制">
<meta property="og:url" content="http://heseng91.github.io/2022/11/03/%E3%80%8C%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%E3%80%8D%E4%B9%8BiOS%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="和僧">
<meta property="og:description" content="作为一个iOS开发，想必对通知应该都不陌生。本文主要是针对iOS通知机制的全面解析，从接口到原理面面俱到。 由于苹果没有对相关源码开放，所以以GNUStep源码为基础进行研究，GNUStep虽然不是苹果官方的源码，但彼此之间都在努力的保持一致，因此很具有参考意义，根据实现原理来猜测和实践，更重要的还可以学习观察者模式的架构设计。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://heseng91.github.io/2022/11/03/%E3%80%8C%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%E3%80%8D%E4%B9%8BiOS%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/%E5%AD%98%E5%9C%A8name%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png">
<meta property="og:image" content="http://heseng91.github.io/2022/11/03/%E3%80%8C%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%E3%80%8D%E4%B9%8BiOS%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/%E5%8F%AA%E5%AD%98%E5%9C%A8object%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png">
<meta property="article:published_time" content="2022-11-02T17:35:39.000Z">
<meta property="article:modified_time" content="2023-02-04T19:33:24.750Z">
<meta property="article:author" content="和僧">
<meta property="article:tag" content="和僧-技术博客，技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://heseng91.github.io/2022/11/03/%E3%80%8C%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%E3%80%8D%E4%B9%8BiOS%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/%E5%AD%98%E5%9C%A8name%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png">

<link rel="canonical" href="http://heseng91.github.io/2022/11/03/%E3%80%8C%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%E3%80%8D%E4%B9%8BiOS%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>「精益求精」之iOS通知机制 | 和僧</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">和僧</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://heseng91.github.io/2022/11/03/%E3%80%8C%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%E3%80%8D%E4%B9%8BiOS%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="和僧">
      <meta itemprop="description" content="技术博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="和僧">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          「精益求精」之iOS通知机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-03 01:35:39" itemprop="dateCreated datePublished" datetime="2022-11-03T01:35:39+08:00">2022-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-05 03:33:24" itemprop="dateModified" datetime="2023-02-05T03:33:24+08:00">2023-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE/" itemprop="url" rel="index"><span itemprop="name">精益求精</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>作为一个iOS开发，想必对通知应该都不陌生。本文主要是针对<code>iOS通知机制</code>的全面解析，从接口到原理面面俱到。</p>
<p>由于苹果没有对相关源码开放，所以以<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgnustep%2Flibs-base">GNUStep</a>源码为基础进行研究，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgnustep%2Flibs-base">GNUStep</a>虽然不是苹果官方的源码，但彼此之间都在努力的保持一致，因此很具有参考意义，根据实现原理来猜测和实践，更重要的还可以学习观察者模式的架构设计。</p>
<a id="more"></a>

<h2 id="关键类结构"><a href="#关键类结构" class="headerlink" title="关键类结构"></a>关键类结构</h2><p>首先介绍接口部分，这里将介绍首先一起来了解一下通知相关的关键类，也为后面介绍原理做铺垫。</p>
<h3 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h3><p>用于描述通知的类，一个<code>NSNotification</code>对象就包含了一条通知的信息，所以当创建一个通知时通常包含如下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;</span><br><span class="line">...</span><br><span class="line">&#x2F;* Querying a Notification Object *&#x2F;</span><br><span class="line"></span><br><span class="line">- (NSString*) name; &#x2F;&#x2F; 通知的name</span><br><span class="line">- (id) object; &#x2F;&#x2F; 携带的对象</span><br><span class="line">- (NSDictionary*) userInfo; &#x2F;&#x2F; 配置信息</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>一般用于发送通知时使用，常用api如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)postNotification:(NSNotification *)notification;</span><br></pre></td></tr></table></figure>

<h3 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h3><p>这是个单例类，负责管理通知的创建和发送，属于最核心的类了。而<code>NSNotificationCenter</code>类主要负责三件事</p>
<ol>
<li>添加通知</li>
<li>发送通知</li>
<li>移除通知</li>
</ol>
<p>核心<code>API</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加通知</span><br><span class="line">- (void) addObserver: (id)observer selector: (SEL)selector name: (NSString*)name object: (id)object;</span><br><span class="line">- (id) addObserverForName: (NSString *)name object: (id)object queue: (NSOperationQueue *)queue usingBlock: (GSNotificationBlock)block;</span><br><span class="line">&#x2F;&#x2F; 发送通知</span><br><span class="line">- (void)postNotification:(NSNotification *)notification;</span><br><span class="line">- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;</span><br><span class="line">- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;</span><br><span class="line">&#x2F;&#x2F; 删除通知</span><br><span class="line">- (void)removeObserver:(id)observer;</span><br></pre></td></tr></table></figure>

<h3 id="NSNotificationQueue"><a href="#NSNotificationQueue" class="headerlink" title="NSNotificationQueue"></a>NSNotificationQueue</h3><h4 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h4><p>通知队列，用于异步发送消息，这个异步并不是开启线程，而是把通知存到双向链表实现的队列里面，等待某个时机触发时调用<code>NSNotificationCenter</code>的发送接口进行发送通知，这么看<code>NSNotificationQueue</code>最终还是调用<code>NSNotificationCenter</code>进行消息的分发</p>
<p>另外<code>NSNotificationQueue</code>是依赖<code>runloop</code>的，所以如果线程的<code>runloop</code>未开启则无效，至于为什么依赖<code>runloop</code>下面会解释</p>
<p><code>NSNotificationQueue</code>主要做了两件事：</p>
<ol>
<li>添加通知到队列</li>
<li>删除通知</li>
</ol>
<p>核心<code>API</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 把通知添加到队列中，NSPostingStyle是个枚举，下面会介绍</span><br><span class="line">- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;</span><br><span class="line">&#x2F;&#x2F; 删除通知，把满足合并条件的通知从队列中删除</span><br><span class="line">- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask;</span><br></pre></td></tr></table></figure>

<h4 id="队列的合并策略和发送时机"><a href="#队列的合并策略和发送时机" class="headerlink" title="队列的合并策略和发送时机"></a>队列的合并策略和发送时机</h4><p>把通知添加到队列等待发送，同时提供了一些附加条件供开发者选择，如：什么时候发送通知、如何合并通知等，系统给了如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 表示通知的发送时机</span><br><span class="line">typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123;</span><br><span class="line">    NSPostWhenIdle &#x3D; 1, &#x2F;&#x2F; runloop空闲时发送通知</span><br><span class="line">    NSPostASAP &#x3D; 2, &#x2F;&#x2F; 尽快发送，这种情况稍微复杂，这种时机是穿插在每次事件完成期间来做的</span><br><span class="line">    NSPostNow &#x3D; 3 &#x2F;&#x2F; 立刻发送或者合并通知完成之后发送</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 通知合并的策略，有些时候同名通知只想存在一个，这时候就可以用到它了</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, NSNotificationCoalescing) &#123;</span><br><span class="line">    NSNotificationNoCoalescing &#x3D; 0, &#x2F;&#x2F; 默认不合并</span><br><span class="line">    NSNotificationCoalescingOnName &#x3D; 1, &#x2F;&#x2F; 只要name相同，就认为是相同通知</span><br><span class="line">    NSNotificationCoalescingOnSender &#x3D; 2  &#x2F;&#x2F; object相同</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="GSNotificationObserver"><a href="#GSNotificationObserver" class="headerlink" title="GSNotificationObserver"></a>GSNotificationObserver</h3><p>这个类是<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgnustep%2Flibs-base">GNUStep</a>源码中定义的，它的作用是代理观察者，主要用来实现接口：<code>addObserverForName：object: queue: usingBlock:</code>时用到，即要实现在指定队列回调block，那么<code>GSNotificationObserver</code>对象保存了<code>queue</code>和<code>block</code>信息，并且作为观察者注册到通知中心，等到接收通知时触发了响应方法，并在响应方法中把<code>block</code>抛到指定<code>queue</code>中执行，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@implementation GSNotificationObserver</span><br><span class="line">&#123;</span><br><span class="line">	NSOperationQueue *_queue; &#x2F;&#x2F; 保存传入的队列</span><br><span class="line">	GSNotificationBlock _block; &#x2F;&#x2F; 保存传入的block</span><br><span class="line">&#125;</span><br><span class="line">- (id) initWithQueue: (NSOperationQueue *)queue </span><br><span class="line">               block: (GSNotificationBlock)block</span><br><span class="line">&#123;</span><br><span class="line">......初始化操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) dealloc</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 响应接收通知的方法，并在指定队列中执行block</span><br><span class="line">- (void) didReceiveNotification: (NSNotification *)notif</span><br><span class="line">&#123;</span><br><span class="line">	if (_queue !&#x3D; nil)</span><br><span class="line">	&#123;</span><br><span class="line">		GSNotificationBlockOperation *op &#x3D; [[GSNotificationBlockOperation alloc] </span><br><span class="line">			initWithNotification: notif block: _block];</span><br><span class="line"></span><br><span class="line">		[_queue addOperation: op];</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		CALL_BLOCK(_block, notif);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h3 id="存储容器"><a href="#存储容器" class="headerlink" title="存储容器"></a>存储容器</h3><p>上面介绍了一些类的功能，但是要想实现通知中心的逻辑必须设计一套合理的存储结构，对于通知的存储基本上围绕下面几个结构体来做（大致了解下，后面章节会用到），后面会详细介绍具体逻辑的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 根容器，NSNotificationCenter持有</span><br><span class="line">typedef struct NCTbl &#123;</span><br><span class="line">  Observation		*wildcard;	&#x2F;* 链表结构，保存既没有name也没有object的通知 *&#x2F;</span><br><span class="line">  GSIMapTable		nameless;	&#x2F;* 存储没有name但是有object的通知	*&#x2F;</span><br><span class="line">  GSIMapTable		named;		&#x2F;* 存储带有name的通知，不管有没有object	*&#x2F;</span><br><span class="line">    ...</span><br><span class="line">&#125; NCTable;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Observation 存储观察者和响应结构体，基本的存储单元</span><br><span class="line">typedef	struct	Obs &#123;</span><br><span class="line">  id		observer;	&#x2F;* 观察者，接收通知的对象	*&#x2F;</span><br><span class="line">  SEL		selector;	&#x2F;* 响应方法		*&#x2F;</span><br><span class="line">  struct Obs	*next;		&#x2F;* Next item in linked list.	*&#x2F;</span><br><span class="line">  ...</span><br><span class="line">&#125; Observation;</span><br></pre></td></tr></table></figure>

<h2 id="源码探究"><a href="#源码探究" class="headerlink" title="源码探究"></a>源码探究</h2><p>介绍完通知关键类，下面我们就开始一起通过阅读源码来深入探究一下通知原理。</p>
<h3 id="添加监听"><a href="#添加监听" class="headerlink" title="添加监听"></a>添加监听</h3><p>首先开始“添加监听”的深入研究，目前只介绍<code>NSNotificationCenter</code>的添加监听，<code>NSNotificationQueue</code>的方式在下面章节单独拎出来解释。<code>NSNotificationCenter</code>有两个添加监听的API。下面我们逐一介绍。</p>
<h4 id="接口1"><a href="#接口1" class="headerlink" title="接口1"></a>接口1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Adding new observers. *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * &lt;p&gt;Registers observer to receive notifications with the name</span><br><span class="line"> * notificationName and&#x2F;or containing object (one or both of these two must be</span><br><span class="line"> * non-nil; nil acts like a wildcard).  When a notification of name name</span><br><span class="line"> * containing object is posted, observer receives a selector message with this</span><br><span class="line"> * notification as the argument.  The notification center waits for the</span><br><span class="line"> * observer to finish processing the message, then informs the next registree</span><br><span class="line"> * matching the notification, and after all of this is done, control returns</span><br><span class="line"> * to the poster of the notification.  Therefore the processing in the</span><br><span class="line"> * selector implementation should be short.&lt;&#x2F;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The notification center does not retain observer or object. Therefore,</span><br><span class="line"> * you should always send removeObserver: or removeObserver:name:object: to</span><br><span class="line"> * the notification center before releasing these objects.&lt;br &#x2F;&gt;</span><br><span class="line"> * &lt;&#x2F;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;NB. For MacOS-X compatibility, adding an observer multiple times will</span><br><span class="line"> * register it to receive multiple copies of any matching notification, however</span><br><span class="line"> * removing an observer will remove &lt;em&gt;all&lt;&#x2F;em&gt; of the multiple registrations.</span><br><span class="line"> * &lt;&#x2F;p&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void) addObserver: (id)observer</span><br><span class="line">	    selector: (SEL)selector</span><br><span class="line">                name: (NSString*)name</span><br><span class="line">	      object: (id)object</span><br><span class="line">&#123;</span><br><span class="line">  Observation	*list;</span><br><span class="line">  Observation	*o;</span><br><span class="line">  GSIMapTable	m;</span><br><span class="line">  GSIMapNode	n;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 前置条件判断</span><br><span class="line">  if (observer &#x3D;&#x3D; nil)</span><br><span class="line">    [NSException raise: NSInvalidArgumentException</span><br><span class="line">		format: @&quot;Nil observer passed to addObserver ...&quot;];</span><br><span class="line"></span><br><span class="line">  if (selector &#x3D;&#x3D; 0)</span><br><span class="line">    [NSException raise: NSInvalidArgumentException</span><br><span class="line">		format: @&quot;Null selector passed to addObserver ...&quot;];</span><br><span class="line"></span><br><span class="line">  if ([observer respondsToSelector: selector] &#x3D;&#x3D; NO)</span><br><span class="line">    &#123;</span><br><span class="line">      [NSException raise: NSInvalidArgumentException</span><br><span class="line">        format: @&quot;[%@-%@] Observer &#39;%@&#39; does not respond to selector &#39;%@&#39;&quot;,</span><br><span class="line">        NSStringFromClass([self class]), NSStringFromSelector(_cmd),</span><br><span class="line">        observer, NSStringFromSelector(selector)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  lockNCTable(TABLE);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建一个observation对象，持有观察者和SEL，下面进行的所有逻辑就是为了存储它</span><br><span class="line">  o &#x3D; obsNew(TABLE, selector, observer);</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">   * Record the Observation in one of the linked lists.</span><br><span class="line">   *</span><br><span class="line">   * NB. It is possible to register an observer for a notification more than</span><br><span class="line">   * once - in which case, the observer will receive multiple messages when</span><br><span class="line">   * the notification is posted... odd, but the MacOS-X docs specify this.</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; case1： 如果name存在 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;</span><br><span class="line">  if (name) &#123;</span><br><span class="line">      &#x2F;*</span><br><span class="line">       * Locate the map table for this name - create it if not present.</span><br><span class="line">       *&#x2F;</span><br><span class="line">      &#x2F;&#x2F;-------- NAMED是个宏，表示名为named字典。以name为key，从named表中获取对应的mapTable</span><br><span class="line">      n &#x3D; GSIMapNodeForKey(NAMED, (GSIMapKey)(id)name);</span><br><span class="line">      if (n &#x3D;&#x3D; 0)	&#123; &#x2F;&#x2F; 不存在，则创建 </span><br><span class="line">	  	    m &#x3D; mapNew(TABLE);&#x2F;&#x2F; 先取缓存，如果缓存没有则新建一个map</span><br><span class="line">          &#x2F;*</span><br><span class="line">           * As this is the first observation for the given name, we take a</span><br><span class="line">           * copy of the name so it cannot be mutated while in the map.</span><br><span class="line">           *&#x2F;</span><br><span class="line">          name &#x3D; [name copyWithZone: NSDefaultMallocZone()];</span><br><span class="line">          GSIMapAddPair(NAMED, (GSIMapKey)(id)name, (GSIMapVal)(void*)m);</span><br><span class="line">          GS_CONSUMED(name)</span><br><span class="line">			&#125; else &#123; &#x2F;&#x2F; 存在则把值取出来 赋值给m</span><br><span class="line">	  			m &#x3D; (GSIMapTable)n-&gt;value.ptr;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;*</span><br><span class="line">       * Add the observation to the list for the correct object.</span><br><span class="line">       *&#x2F;</span><br><span class="line">    	&#x2F;&#x2F;-------- 以object为key，从字典m中取出对应的value，其实value被MapNode的结构包装了一层，这里不追究细节</span><br><span class="line">      n &#x3D; GSIMapNodeForSimpleKey(m, (GSIMapKey)object);</span><br><span class="line">      if (n &#x3D;&#x3D; 0)	&#123;&#x2F;&#x2F; 不存在，则创建</span><br><span class="line">          o-&gt;next &#x3D; ENDOBS;</span><br><span class="line">          GSIMapAddPair(m, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          list &#x3D; (Observation*)n-&gt;value.ptr;</span><br><span class="line">          o-&gt;next &#x3D; list-&gt;next;</span><br><span class="line">          list-&gt;next &#x3D; o;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; else if (object) &#123;&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; case2：如果name为空，但object不为空 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;</span><br><span class="line">    	&#x2F;&#x2F; 以object为key，从nameless字典中取出对应的value，value是个链表结构</span><br><span class="line">      n &#x3D; GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object);</span><br><span class="line">      if (n &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; 不存在则新建链表，并存到map中</span><br><span class="line">          o-&gt;next &#x3D; ENDOBS;</span><br><span class="line">          GSIMapAddPair(NAMELESS, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">      &#125; else &#123;&#x2F;&#x2F; 存在 则把值接到链表的节点上</span><br><span class="line">          list &#x3D; (Observation*)n-&gt;value.ptr;</span><br><span class="line">          o-&gt;next &#x3D; list-&gt;next;</span><br><span class="line">          list-&gt;next &#x3D; o;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; else &#123;&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; case3：name 和 object 都为空 则存储到wildcard链表中 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;</span><br><span class="line">      o-&gt;next &#x3D; WILDCARD;</span><br><span class="line">      WILDCARD &#x3D; o;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  unlockNCTable(TABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上面介绍的<a href="#dpptO">存储容器</a>中我们了解到<code>NCTable</code>结构体中核心的三个变量以及功能：<code>wildcard</code>、<code>named</code>、<code>nameless</code>，在源码中直接用宏定义表示了：<code>WILDCARD</code>、<code>NAMELESS</code>、<code>NAMED</code>，下面逻辑会用到。</p>
</blockquote>
<p>建议如果看文字说明觉得复杂不好理解，就看看下节介绍的存储关系图。</p>
<h5 id="case1-存在name（无论object是否存在）"><a href="#case1-存在name（无论object是否存在）" class="headerlink" title="case1: 存在name（无论object是否存在）"></a>case1: 存在<code>name</code>（无论object是否存在）</h5><ol>
<li>注册通知，如果通知的<code>name</code>存在，则以<code>name</code>为key从<code>named</code>字典中取出值<code>n</code>(这个<code>n</code>其实被<code>MapNode</code>包装了一层，便于理解这里直接认为没有包装)，这个<code>n</code>还是个字典，各种判空新建逻辑不讨论；</li>
<li>然后以<code>object</code>为key，从字典<code>n</code>中取出对应的值，这个值就是<code>Observation</code>类型(后面简称<code>obs</code>)的链表，然后把刚开始创建的<code>obs</code>对象<code>o</code>存储进去；</li>
</ol>
<p>数据结构关系图如下：</p>
<img src="/2022/11/03/%E3%80%8C%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%E3%80%8D%E4%B9%8BiOS%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/%E5%AD%98%E5%9C%A8name%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png" class title="存在name数据结构关系图">

<p>如果注册通知时传入<code>name</code>，那么会是一个双层的存储结构</p>
<ol>
<li>找到<code>NCTable</code>中的<code>named</code>表，这个表存储了还有<code>name</code>的通知；</li>
<li>以<code>name</code>作为key，找到<code>value</code>，这个<code>value</code>依然是一个<code>map</code>；</li>
<li><code>map</code>的结构是以<code>object</code>作为key，<code>obs</code>对象为value，这个<code>obs</code>对象的结构上面已经解释，主要存储了<code>observer &amp; SEL</code>；</li>
</ol>
<h5 id="case2-只存在object"><a href="#case2-只存在object" class="headerlink" title="case2: 只存在object"></a>case2: 只存在object</h5><ol>
<li>以<code>object</code>为key，从<code>nameless</code>字典中取出value，此value是个<code>obs</code>类型的链表；</li>
<li>把创建的<code>obs</code>类型的对象<code>o</code>存储到链表中；</li>
</ol>
<p>数据结构关系图如下：</p>
<img src="/2022/11/03/%E3%80%8C%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%E3%80%8D%E4%B9%8BiOS%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/%E5%8F%AA%E5%AD%98%E5%9C%A8object%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png" class title="只存在object数据结构关系图">

<p>只存在<code>object</code>时存储只有一层，那就是<code>object</code>和<code>obs</code>对象之间的映射。</p>
<h5 id="case3-没有name和object"><a href="#case3-没有name和object" class="headerlink" title="case3: 没有name和object"></a>case3: 没有name和object</h5><p>这种情况直接把<code>obs</code>对象存放在了<code>Observation  *wildcard</code> 链表结构中。</p>
<h4 id="接口2"><a href="#接口2" class="headerlink" title="接口2"></a>接口2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * &lt;p&gt;Returns a new observer added to the notification center, in order to </span><br><span class="line"> * observe the given notification name posted by an object or any object (if </span><br><span class="line"> * the object argument is nil).&lt;&#x2F;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;For the name and object arguments, the constraints and behavior described </span><br><span class="line"> * in -addObserver:name:selector:object: remain valid.&lt;&#x2F;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;For each notification received by the center, the observer will execute </span><br><span class="line"> * the notification block. If the queue is not nil, the notification block is </span><br><span class="line"> * wrapped in a NSOperation and scheduled in the queue, otherwise the block is </span><br><span class="line"> * executed immediately in the posting thread.&lt;&#x2F;p&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (id) addObserverForName: (NSString *)name </span><br><span class="line">                   object: (id)object </span><br><span class="line">                    queue: (NSOperationQueue *)queue </span><br><span class="line">               usingBlock: (GSNotificationBlock)block</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 创建一个临时观察者</span><br><span class="line">	GSNotificationObserver *observer &#x3D; </span><br><span class="line">		[[GSNotificationObserver alloc] initWithQueue: queue block: block];</span><br><span class="line">	&#x2F;&#x2F; 调用了接口1的注册方法</span><br><span class="line">	[self addObserver: observer </span><br><span class="line">	         selector: @selector(didReceiveNotification:) </span><br><span class="line">	             name: name </span><br><span class="line">	           object: object];</span><br><span class="line"></span><br><span class="line">	return observer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="逻辑说明"><a href="#逻辑说明" class="headerlink" title="逻辑说明"></a>逻辑说明</h5><p>这个接口依赖于<code>接口1</code>，只是多了一层代理观察者<code>GSNotificationObserver</code>，在<a href="#MtztL">关键类结构</a>中已经介绍了它，设计思路值得学习</p>
<ol>
<li>创建一个<code>GSNotificationObserver</code>类型的对象<code>observer</code>，并把<code>queue</code>和<code>block</code>保存下来;</li>
<li>调用接口1进行通知的注册;</li>
<li>接收到通知时会响应<code>observer</code>的<code>didReceiveNotification:</code>方法，然后在<code>didReceiveNotification:</code>中把<code>block</code>抛给指定的<code>queue</code>去执行;</li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li>从上述介绍可以总结，存储是以<code>name</code>和<code>object</code>为维度的，即判定是不是同一个通知要从<code>name</code>和<code>object</code>区分，如果他们都相同则认为是同一个通知，后面包括查找逻辑、删除逻辑都是以这两个为维度的；</li>
<li>理解数据结构的设计是整个通知机制的核心，其他功能只是在此基础上扩展了一些逻辑；</li>
<li>存储过程并没有做去重操作，这也解释了为什么同一个通知注册多次则响应多次。</li>
</ol>
<h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h3><p>发送通知相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Posts notification to all the observers that match its NAME and OBJECT.&lt;br &#x2F;&gt;</span><br><span class="line"> * The GNUstep implementation calls -postNotificationName:object:userInfo: to</span><br><span class="line"> * perform the actual posting.</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void) postNotification: (NSNotification*)notification</span><br><span class="line">&#123;</span><br><span class="line">  if (notification &#x3D;&#x3D; nil)</span><br><span class="line">    &#123;</span><br><span class="line">      [NSException raise: NSInvalidArgumentException</span><br><span class="line">		  format: @&quot;Tried to post a nil notification.&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">  [self _postAndRelease: RETAIN(notification)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Creates and posts a notification using the</span><br><span class="line"> * -postNotificationName:object:userInfo: passing a nil user info argument.</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void) postNotificationName: (NSString*)name</span><br><span class="line">		       object: (id)object</span><br><span class="line">&#123;</span><br><span class="line">  [self postNotificationName: name object: object userInfo: nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The preferred method for posting a notification.</span><br><span class="line"> * &lt;br &#x2F;&gt;</span><br><span class="line"> * For performance reasons, we don&#39;t wrap an exception handler round every</span><br><span class="line"> * message sent to an observer.  This means that, if one observer raises</span><br><span class="line"> * an exception, later observers in the lists will not get the notification.</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void) postNotificationName: (NSString*)name</span><br><span class="line">		       object: (id)object</span><br><span class="line">		     userInfo: (NSDictionary*)info</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 构造一个GSNotification对象， GSNotification继承了NSNotification</span><br><span class="line">  GSNotification	*notification;</span><br><span class="line"></span><br><span class="line">  notification &#x3D; (id)NSAllocateObject(concrete, 0, NSDefaultMallocZone());</span><br><span class="line">  notification-&gt;_name &#x3D; [name copyWithZone: [self zone]];</span><br><span class="line">  notification-&gt;_object &#x3D; [object retain];</span><br><span class="line">  notification-&gt;_info &#x3D; [info retain];</span><br><span class="line">  &#x2F;&#x2F; 进行发送操作</span><br><span class="line">  [self _postAndRelease: notification];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见发送通知实际都调用了<code>_postAndRelease:</code>方法来完成世纪的发送操作，该函数源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Private method to perform the actual posting of a notification.</span><br><span class="line"> * Release the notification before returning, or before we raise</span><br><span class="line"> * any exception ... to avoid leaks.</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void) _postAndRelease: (NSNotification*)notification</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F;step1: 从named、nameless、wildcard表中查找对应的通知</span><br><span class="line">  Observation	*o;</span><br><span class="line">  unsigned	count;</span><br><span class="line">  NSString	*name &#x3D; [notification name];</span><br><span class="line">  id		object;</span><br><span class="line">  GSIMapNode	n;</span><br><span class="line">  GSIMapTable	m;</span><br><span class="line">  GSIArrayItem	i[64];</span><br><span class="line">  GSIArray_t	b;</span><br><span class="line">  GSIArray	a &#x3D; &amp;b;</span><br><span class="line"></span><br><span class="line">  if (name &#x3D;&#x3D; nil)</span><br><span class="line">    &#123;</span><br><span class="line">      RELEASE(notification);</span><br><span class="line">      [NSException raise: NSInvalidArgumentException</span><br><span class="line">		  format: @&quot;Tried to post a notification with no name.&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">  object &#x3D; [notification object];</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">   * Lock the table of observations while we traverse it.</span><br><span class="line">   *</span><br><span class="line">   * The table of observations contains weak pointers which are zeroed when</span><br><span class="line">   * the observers get destroyed.  So to avoid consistency problems</span><br><span class="line">   * we use scanned memory in the array in the case where there are more</span><br><span class="line">   * than the 64 observers we allowed room for on the stack.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  GSIArrayInitWithZoneAndStaticCapacity(a, _zone, 64, i);</span><br><span class="line">  lockNCTable(TABLE);</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">   * Find all the observers that specified neither NAME nor OBJECT.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  for (o &#x3D; WILDCARD &#x3D; purgeCollected(WILDCARD); o !&#x3D; ENDOBS; o &#x3D; o-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">      GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">   * Find the observers that specified OBJECT, but didn&#39;t specify NAME.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  if (object)</span><br><span class="line">    &#123;</span><br><span class="line">      n &#x3D; GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object);</span><br><span class="line">      if (n !&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	  o &#x3D; purgeCollectedFromMapNode(NAMELESS, n);</span><br><span class="line">	  while (o !&#x3D; ENDOBS)</span><br><span class="line">	    &#123;</span><br><span class="line">	      GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">	      o &#x3D; o-&gt;next;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">   * Find the observers of NAME, except those observers with a non-nil OBJECT</span><br><span class="line">   * that doesn&#39;t match the notification&#39;s OBJECT).</span><br><span class="line">   *&#x2F;</span><br><span class="line">  if (name)</span><br><span class="line">    &#123;</span><br><span class="line">      n &#x3D; GSIMapNodeForKey(NAMED, (GSIMapKey)((id)name));</span><br><span class="line">      if (n)</span><br><span class="line">	&#123;</span><br><span class="line">	  m &#x3D; (GSIMapTable)n-&gt;value.ptr;</span><br><span class="line">	&#125;</span><br><span class="line">      else</span><br><span class="line">	&#123;</span><br><span class="line">	  m &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">      if (m !&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	  &#x2F;*</span><br><span class="line">	   * First, observers with a matching object.</span><br><span class="line">	   *&#x2F;</span><br><span class="line">	  n &#x3D; GSIMapNodeForSimpleKey(m, (GSIMapKey)object);</span><br><span class="line">	  if (n !&#x3D; 0)</span><br><span class="line">	    &#123;</span><br><span class="line">	      o &#x3D; purgeCollectedFromMapNode(m, n);</span><br><span class="line">	      while (o !&#x3D; ENDOBS)</span><br><span class="line">		&#123;</span><br><span class="line">		  GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">		  o &#x3D; o-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  if (object !&#x3D; nil)</span><br><span class="line">	    &#123;</span><br><span class="line">	      &#x2F;*</span><br><span class="line">	       * Now observers with a nil object.</span><br><span class="line">	       *&#x2F;</span><br><span class="line">	      n &#x3D; GSIMapNodeForSimpleKey(m, (GSIMapKey)(id)nil);</span><br><span class="line">	      if (n !&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">	          o &#x3D; purgeCollectedFromMapNode(m, n);</span><br><span class="line">		  while (o !&#x3D; ENDOBS)</span><br><span class="line">		    &#123;</span><br><span class="line">		      GSIArrayAddItem(a, (GSIArrayItem)o);</span><br><span class="line">		      o &#x3D; o-&gt;next;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Finished with the table ... we can unlock it,</span><br><span class="line">   *&#x2F;</span><br><span class="line">  unlockNCTable(TABLE);</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">   * Now send all the notifications.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;&#x2F;step2：执行发送，即调用performSelector执行响应方法，从这里可以看出是同步的</span><br><span class="line">  count &#x3D; GSIArrayCount(a);</span><br><span class="line">  while (count-- &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      o &#x3D; GSIArrayItemAtIndex(a, count).ext;</span><br><span class="line">      if (o-&gt;next !&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">          NS_DURING</span><br><span class="line">            &#123;</span><br><span class="line">              [o-&gt;observer performSelector: o-&gt;selector</span><br><span class="line">                                withObject: notification];</span><br><span class="line">            &#125;</span><br><span class="line">          NS_HANDLER</span><br><span class="line">            &#123;</span><br><span class="line">	      BOOL	logged;</span><br><span class="line"></span><br><span class="line">	      &#x2F;* Try to report the notification along with the exception,</span><br><span class="line">	       * but if there&#39;s a problem with the notification itself,</span><br><span class="line">	       * we just log the exception.</span><br><span class="line">	       *&#x2F;</span><br><span class="line">	      NS_DURING</span><br><span class="line">		NSLog(@&quot;Problem posting %@: %@&quot;, notification, localException);</span><br><span class="line">		logged &#x3D; YES;</span><br><span class="line">	      NS_HANDLER</span><br><span class="line">		logged &#x3D; NO;</span><br><span class="line">	      NS_ENDHANDLER</span><br><span class="line">  	      if (NO &#x3D;&#x3D; logged)</span><br><span class="line">		&#123; </span><br><span class="line">		  NSLog(@&quot;Problem posting notification: %@&quot;, localException);</span><br><span class="line">		&#125;  </span><br><span class="line">            &#125;</span><br><span class="line">          NS_ENDHANDLER</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  lockNCTable(TABLE);</span><br><span class="line">  GSIArrayEmpty(a);</span><br><span class="line">  unlockNCTable(TABLE);</span><br><span class="line"></span><br><span class="line">  RELEASE(notification);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="逻辑说明-1"><a href="#逻辑说明-1" class="headerlink" title="逻辑说明"></a>逻辑说明</h4><p>其实上述代码注释说的很清晰了，主要做了三件事</p>
<ol>
<li>通过<code>name &amp; object</code>查找到所有的<code>obs</code>对象(保存了<code>observer</code>和<code>sel</code>)，放到数组中；</li>
<li>通过<code>performSelector：</code>逐一调用<code>sel</code>，这是个同步操作；</li>
<li>释放<code>notification</code>对象。</li>
</ol>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>从源码逻辑可以看出发送过程的概述：从三个存储容器中：<code>named</code>、<code>nameless</code>、<code>wildcard</code>去查找对应的<code>obs</code>对象，然后通过<code>performSelector：</code>逐一调用响应方法，这就完成了发送流程。</p>
<p><strong>核心点：</strong></p>
<ol>
<li>同步发送</li>
<li>遍历所有列表，即注册多次通知就会响应多次</li>
</ol>
<h3 id="删除通知"><a href="#删除通知" class="headerlink" title="删除通知"></a>删除通知</h3><p>这里源码太长而且基本上都是查找删除逻辑，不一一列举，感兴趣的去下载<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgnustep%2Flibs-base">源码</a>看下吧<br><strong>要注意的点：</strong></p>
<ol>
<li>查找时仍然以<code>name</code>和<code>object</code>为维度的，再加上<code>observer</code>做区分</li>
<li>因为查找时做了这个链表的遍历，所以删除时会把重复的通知全都删除掉</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除已经注册的通知</span></span><br><span class="line">- (<span class="keyword">void</span>) removeObserver: (<span class="keyword">id</span>)observer</span><br><span class="line">		   name: (<span class="built_in">NSString</span>*)name</span><br><span class="line">                 object: (<span class="keyword">id</span>)object &#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="literal">nil</span> &amp;&amp; object == <span class="literal">nil</span> &amp;&amp; observer == <span class="literal">nil</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) removeObserver: (<span class="keyword">id</span>)observer</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (observer == <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> removeObserver: observer name: <span class="literal">nil</span> object: <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步通知"><a href="#异步通知" class="headerlink" title="异步通知"></a>异步通知</h3><p>上面介绍的<code>NSNotificationCenter</code>都是同步发送的，而这里介绍关于<code>NSNotificationQueue</code>的异步发送，从线程的角度看并不是真正的异步发送，或可称为延时发送，它是利用了<code>runloop</code>的时机来触发的。</p>
<h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><p>相关源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  Sets notification to be posted to notification center at time dependent on</span><br><span class="line"> *  postingStyle, which may be either &lt;code&gt;NSPostNow&lt;&#x2F;code&gt; (synchronous post),</span><br><span class="line"> *  &lt;code&gt;NSPostASAP&lt;&#x2F;code&gt; (post soon), or &lt;code&gt;NSPostWhenIdle&lt;&#x2F;code&gt; (post</span><br><span class="line"> *  when runloop is idle).</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void) enqueueNotification: (NSNotification*)notification</span><br><span class="line">		postingStyle: (NSPostingStyle)postingStyle	</span><br><span class="line">&#123;</span><br><span class="line">  [self enqueueNotification: notification</span><br><span class="line">	       postingStyle: postingStyle</span><br><span class="line">	       coalesceMask: NSNotificationCoalescingOnName</span><br><span class="line">			      + NSNotificationCoalescingOnSender</span><br><span class="line">		   forModes: nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  Sets notification to be posted to notification center at time dependent on</span><br><span class="line"> *  postingStyle, which may be either &lt;code&gt;NSPostNow&lt;&#x2F;code&gt; (synchronous</span><br><span class="line"> *  post), &lt;code&gt;NSPostASAP&lt;&#x2F;code&gt; (post soon), or &lt;code&gt;NSPostWhenIdle&lt;&#x2F;code&gt;</span><br><span class="line"> *  (post when runloop is idle).  coalesceMask determines whether this</span><br><span class="line"> *  notification should be considered same as other ones already on the queue,</span><br><span class="line"> *  in which case they are removed through a call to</span><br><span class="line"> *  -dequeueNotificationsMatching:coalesceMask: .  The modes argument</span><br><span class="line"> *  determines which [NSRunLoop] mode notification may be posted in (nil means</span><br><span class="line"> *  NSDefaultRunLoopMode).</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 把要发送的通知添加到队列，等待发送</span><br><span class="line"> * NSPostingStyle 和 coalesceMask在上面的类结构中有介绍</span><br><span class="line"> * modes这个就和runloop有关了，指的是runloop的mode</span><br><span class="line"> *&#x2F; </span><br><span class="line">- (void) enqueueNotification: (NSNotification*)notification</span><br><span class="line">		postingStyle: (NSPostingStyle)postingStyle</span><br><span class="line">		coalesceMask: (NSUInteger)coalesceMask</span><br><span class="line">		    forModes: (NSArray*)modes</span><br><span class="line">&#123;</span><br><span class="line">  if (modes &#x3D;&#x3D; nil)</span><br><span class="line">    &#123;</span><br><span class="line">      modes &#x3D; defaultMode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F; 判断是否需要合并通知</span><br><span class="line">  if (coalesceMask !&#x3D; NSNotificationNoCoalescing)</span><br><span class="line">    &#123;</span><br><span class="line">      [self dequeueNotificationsMatching: notification</span><br><span class="line">			    coalesceMask: coalesceMask];</span><br><span class="line">    &#125;</span><br><span class="line">  switch (postingStyle)</span><br><span class="line">    &#123;</span><br><span class="line">      case NSPostNow:</span><br><span class="line">        &#123;</span><br><span class="line">          NSString	*mode;</span><br><span class="line"></span><br><span class="line">          mode &#x3D; [[NSRunLoop currentRunLoop] currentMode];</span><br><span class="line">          if (mode &#x3D;&#x3D; nil || [modes indexOfObject: mode] !&#x3D; NSNotFound)</span><br><span class="line">            &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用NSNotificationCenter进行发送</span><br><span class="line">              [_center postNotification: notification];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      case NSPostASAP:</span><br><span class="line">      	&#x2F;&#x2F; 添加到_asapQueue队列，等待发送</span><br><span class="line">				add_to_queue(_asapQueue, notification, modes, _zone);</span><br><span class="line">				break;</span><br><span class="line"></span><br><span class="line">      case NSPostWhenIdle:</span><br><span class="line">      	&#x2F;&#x2F; 添加到_idleQueue队列，等待发送</span><br><span class="line">        add_to_queue(_idleQueue, notification, modes, _zone);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看源码的注释，基本上能明白大致逻辑：</p>
<ol>
<li>根据<code>coalesceMask</code>参数判断是否合并通知；</li>
<li>接着根据<code>postingStyle</code>参数，判断通知发送的时机，如果不是立即发送则把通知加入到队列中：<code>_asapQueue</code>、<code>_idleQueue</code>。</li>
</ol>
<p>核心点：</p>
<ol>
<li>队列是双向链表实现；</li>
<li>当postingStyle值是立即发送时，调用的是<code>NSNotificationCenter</code>进行发送的，所以<code>NSNotificationQueue</code>还是依赖<code>NSNotificationCenter</code>进行发送。</li>
</ol>
<h4 id="发送通知-1"><a href="#发送通知-1" class="headerlink" title="发送通知"></a>发送通知</h4><p><code>NSPostNow</code>枚举的发送前面的代码已经有所体现。这里主要介绍<code>NSPostASAP</code> 和 <code>NSPostWhenIdle</code> 两种枚举的通知发送。<code>NSPostASAP</code> 和 <code>NSPostWhenIdle</code> 会分别调用<code>GSPrivateNotifyASAP()</code>和<code>GSPrivateNotifyIdle()</code>方法来发送通知，方法的调用主要是通过RunLoop，调用的时机参见<a href="https://github.com/gnustep/libs-base/blob/0b1a2d4d668b605a5f29e377888ce4b3be484604/Source/NSRunLoop.m" target="_blank" rel="noopener">GNUStep的NSRunLoop</a>。</p>
<p>异步发送通知的相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">notify(NSNotificationCenter *center, NSNotificationQueueList *list,</span><br><span class="line">  NSString *mode, NSZone *zone)</span><br><span class="line">&#123;</span><br><span class="line">  BOOL					allocated &#x3D; NO;</span><br><span class="line">  void					*buf[100];</span><br><span class="line">  void					**ptr &#x3D; buf;</span><br><span class="line">  unsigned				len &#x3D; sizeof(buf) &#x2F; sizeof(*buf);</span><br><span class="line">  unsigned				pos &#x3D; 0;</span><br><span class="line">  NSNotificationQueueRegistration	*item &#x3D; list-&gt;head;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Gather matching items into a buffer.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  while (item !&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      if (mode &#x3D;&#x3D; nil || [item-&gt;modes indexOfObject: mode] !&#x3D; NSNotFound)</span><br><span class="line">        &#123;</span><br><span class="line">          if (pos &#x3D;&#x3D; len)</span><br><span class="line">            &#123;</span><br><span class="line">              unsigned	want;</span><br><span class="line"></span><br><span class="line">              want &#x3D; (len &#x3D;&#x3D; 0) ? 2 : len * 2;</span><br><span class="line">              if (NO &#x3D;&#x3D; allocated)</span><br><span class="line">                &#123;</span><br><span class="line">                  void		*tmp;</span><br><span class="line"></span><br><span class="line">                  tmp &#x3D; NSZoneMalloc(NSDefaultMallocZone(),</span><br><span class="line">                    want * sizeof(void*));</span><br><span class="line">                  memcpy(tmp, (void*)ptr, len * sizeof(void*));</span><br><span class="line">                  ptr &#x3D; tmp;</span><br><span class="line">                  allocated &#x3D; YES;</span><br><span class="line">                &#125;</span><br><span class="line">              else</span><br><span class="line">                &#123;</span><br><span class="line">                  ptr &#x3D; NSZoneRealloc(NSDefaultMallocZone(),</span><br><span class="line">                    ptr, want * sizeof(void*));</span><br><span class="line">                &#125;</span><br><span class="line">              len &#x3D; want;</span><br><span class="line">            &#125;</span><br><span class="line">          ptr[pos++] &#x3D; item;</span><br><span class="line">        &#125;</span><br><span class="line">      item &#x3D; item-&gt;next;	&#x2F;&#x2F; head --&gt; tail uses next link</span><br><span class="line">    &#125;</span><br><span class="line">  len &#x3D; pos;	&#x2F;&#x2F; Number of items found</span><br><span class="line"></span><br><span class="line">  &#x2F;* Posting a notification catches exceptions, so it&#39;s OK to use</span><br><span class="line">   * retain&#x2F;release of objects here as we won&#39;t get an exception</span><br><span class="line">   * causing a leak.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  if (len &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;* First, we make a note of each notification while removing the</span><br><span class="line">       * corresponding list item from the queue ... so that when we get</span><br><span class="line">       * round to posting the notifications we will not get problems</span><br><span class="line">       * with another notif() trying to use the same items.</span><br><span class="line">       *&#x2F;</span><br><span class="line">      for (pos &#x3D; 0; pos &lt; len; pos++)</span><br><span class="line">        &#123;</span><br><span class="line">          item &#x3D; ptr[pos];</span><br><span class="line">          ptr[pos] &#x3D; RETAIN(item-&gt;notification);</span><br><span class="line">          remove_from_queue(list, item, zone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;* Now that we no longer need to worry about r-entrancy,</span><br><span class="line">       * we step through our notifications, posting each one in turn.</span><br><span class="line">       *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 循环遍历发送通知</span><br><span class="line">      for (pos &#x3D; 0; pos &lt; len; pos++)</span><br><span class="line">        &#123;</span><br><span class="line">          NSNotification	*n &#x3D; (NSNotification*)ptr[pos];</span><br><span class="line"></span><br><span class="line">          [center postNotification: n];</span><br><span class="line">          RELEASE(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      if (allocated)</span><br><span class="line">        &#123;</span><br><span class="line">          NSZoneFree(NSDefaultMallocZone(), ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> *	The following code handles sending of queued notifications by</span><br><span class="line"> *	NSRunLoop.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 发送_asapQueue中的通知</span><br><span class="line">void</span><br><span class="line">GSPrivateNotifyASAP(NSString *mode)</span><br><span class="line">&#123;</span><br><span class="line">  NotificationQueueList	*item;</span><br><span class="line"></span><br><span class="line">  GSPrivateCheckTasks();</span><br><span class="line"></span><br><span class="line">  for (item &#x3D; currentList(); item; item &#x3D; item-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">      if (item-&gt;queue)</span><br><span class="line">	&#123;</span><br><span class="line">	  notify(item-&gt;queue-&gt;_center,</span><br><span class="line">	    item-&gt;queue-&gt;_asapQueue,</span><br><span class="line">	    mode,</span><br><span class="line">	    item-&gt;queue-&gt;_zone);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 发送_idleQueue中的通知</span><br><span class="line">void</span><br><span class="line">GSPrivateNotifyIdle(NSString *mode)</span><br><span class="line">&#123;</span><br><span class="line">  NotificationQueueList	*item;</span><br><span class="line"></span><br><span class="line">  for (item &#x3D; currentList(); item; item &#x3D; item-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">      if (item-&gt;queue)</span><br><span class="line">	&#123;</span><br><span class="line">	  notify(item-&gt;queue-&gt;_center,</span><br><span class="line">	    item-&gt;queue-&gt;_idleQueue,</span><br><span class="line">	    mode,</span><br><span class="line">	    item-&gt;queue-&gt;_zone);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="逻辑说明-2"><a href="#逻辑说明-2" class="headerlink" title="逻辑说明"></a>逻辑说明</h5><ol>
<li><code>runloop</code>触发某个时机，调用<code>GSPrivateNotifyASAP()</code>和<code>GSPrivateNotifyIdle()</code>方法，这两个方法最终都调用了<code>notify()</code>方法；</li>
<li><code>notify()</code>所做的事情就是调用<code>NSNotificationCenter</code>的<code>postNotification:</code>进行发送通知；</li>
</ol>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>对于<code>NSNotificationQueue</code>总结如下</p>
<ol>
<li>依赖<code>runloop</code>，所以如果在其他子线程使用<code>NSNotificationQueue</code>，需要开启runloop；</li>
<li>最终还是通过<code>NSNotificationCenter</code>进行发送通知，所以这个角度讲它还是同步的；</li>
<li>所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程；</li>
</ol>
<h3 id="主线程响应通知"><a href="#主线程响应通知" class="headerlink" title="主线程响应通知"></a>主线程响应通知</h3><p>异步线程发送通知则响应函数也是在异步线程，如果执行UI刷新相关的话就会出问题，那么如何保证在主线程响应通知呢？</p>
<p>其实也是比较常见的问题了，基本上解决方式如下几种：</p>
<ol>
<li>使用<code>addObserverForName: object: queue: usingBlock</code>方法注册通知，指定在<code>mainqueue</code>上响应<code>block</code>；</li>
<li>在主线程注册一个<code>machPort</code>，它是用来做线程通信的，当在异步线程收到通知，然后给<code>machPort</code>发送消息，这样肯定是在主线程处理的，具体用法去网上资料很多，苹果官网也有。</li>
</ol>
<p>参考：</p>
<p><a href="https://juejin.cn/post/6844904082516213768" target="_blank" rel="noopener">轻松过面：一文全解iOS通知机制(经典收藏)</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/03/%E3%80%8C%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%E3%80%8D%E4%B9%8BiOS-APP%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/" rel="prev" title="「精益求精」之iOS APP签名机制">
      <i class="fa fa-chevron-left"></i> 「精益求精」之iOS APP签名机制
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/05/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8Bblock/" rel="next" title="「刨根问底」之block">
      「刨根问底」之block <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#关键类结构"><span class="nav-number">1.</span> <span class="nav-text">关键类结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NSNotification"><span class="nav-number">1.1.</span> <span class="nav-text">NSNotification</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSNotificationCenter"><span class="nav-number">1.2.</span> <span class="nav-text">NSNotificationCenter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSNotificationQueue"><span class="nav-number">1.3.</span> <span class="nav-text">NSNotificationQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#功能介绍"><span class="nav-number">1.3.1.</span> <span class="nav-text">功能介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列的合并策略和发送时机"><span class="nav-number">1.3.2.</span> <span class="nav-text">队列的合并策略和发送时机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GSNotificationObserver"><span class="nav-number">1.4.</span> <span class="nav-text">GSNotificationObserver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储容器"><span class="nav-number">1.5.</span> <span class="nav-text">存储容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码探究"><span class="nav-number">2.</span> <span class="nav-text">源码探究</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加监听"><span class="nav-number">2.1.</span> <span class="nav-text">添加监听</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口1"><span class="nav-number">2.1.1.</span> <span class="nav-text">接口1</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#case1-存在name（无论object是否存在）"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">case1: 存在name（无论object是否存在）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#case2-只存在object"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">case2: 只存在object</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#case3-没有name和object"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">case3: 没有name和object</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口2"><span class="nav-number">2.1.2.</span> <span class="nav-text">接口2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#逻辑说明"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">逻辑说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">2.1.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送通知"><span class="nav-number">2.2.</span> <span class="nav-text">发送通知</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑说明-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">逻辑说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除通知"><span class="nav-number">2.3.</span> <span class="nav-text">删除通知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步通知"><span class="nav-number">2.4.</span> <span class="nav-text">异步通知</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#入队"><span class="nav-number">2.4.1.</span> <span class="nav-text">入队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发送通知-1"><span class="nav-number">2.4.2.</span> <span class="nav-text">发送通知</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#逻辑说明-2"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">逻辑说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-2"><span class="nav-number">2.4.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主线程响应通知"><span class="nav-number">2.5.</span> <span class="nav-text">主线程响应通知</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">和僧</p>
  <div class="site-description" itemprop="description">技术博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">和僧</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
