{"meta":{"title":"和僧","subtitle":"","description":"技术博客","author":"和僧","url":"http://heseng91.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-07-25T18:29:43.000Z","updated":"2022-07-25T18:37:04.171Z","comments":true,"path":"categories/index.html","permalink":"http://heseng91.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World!","slug":"hello-world","date":"2018-12-04T08:32:24.000Z","updated":"2022-07-31T18:43:22.684Z","comments":true,"path":"2018/12/04/hello-world/","link":"","permalink":"http://heseng91.github.io/2018/12/04/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"「App优化」之稳定性优化","slug":"「App优化」之稳定性优化","date":"2018-12-04T08:32:24.000Z","updated":"2022-10-19T17:47:43.466Z","comments":true,"path":"2018/12/04/「App优化」之稳定性优化/","link":"","permalink":"http://heseng91.github.io/2018/12/04/%E3%80%8CApp%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8B%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/","excerpt":"本文主要转载至如何系统性治理 iOS 稳定性问题，文章比较详细阐述了稳定性优化相关优化思路，其中有些优化本人目前在实际项目中还没有实践，有待进一步探索。","text":"本文主要转载至如何系统性治理 iOS 稳定性问题，文章比较详细阐述了稳定性优化相关优化思路，其中有些优化本人目前在实际项目中还没有实践，有待进一步探索。 本文主要分为四大章节，分别是：1.稳定性问题分类；2.稳定性问题治理方法论；3.疑难问题归因；4.总结回顾。其中第三章节「疑难问题归因」是本次分享的重点，大概会占到60%的篇幅。 一、稳定性问题分类在讲分类之前，我们先了解一下背景：大家都知道对于移动端应用而言，闪退是用户能遇到的最严重的 bug，因为在闪退之后用户无法继续使用产品，那么后续的用户留存以及产品本身的商业价值都无从谈起。 这里有一些数据想和大家分享：有 20% 的用户在使用移动端产品的时候，最无法忍受的问题就是闪退，这个比例仅次于不合时宜的广告；在因为体验问题流失的用户中，有 1/3 的用户会转而使用竞品，由此可见闪退问题是非常糟糕和严重的。 字节跳动作为拥有像抖音、头条等超大量级 App 的公司，对稳定性问题是非常重视的。过去几年，我们在这方面投入了非常多的人力和资源，同时也取得了不错的治理成果。过去两年抖音、头条、飞书等 App 的异常崩溃率都有 30% 以上的优化，个别产品的部分指标甚至有 80% 以上的优化。 通过上图中右侧的饼状图可以看出：我们以 iOS 平台为例，根据稳定性问题不同的原因，将已知稳定性问题分成了这五大类，通过占比从高到低排序：第一大类是 OOM ，就是内存占用过大导致的崩溃，这个比例能占到 50% 以上；其次是 Watchdog，也就是卡死，类比于安卓中的 ANR；再次是普通的 Crash；最后是磁盘 IO 异常和 CPU 异常。 看到这里大家心里可能会有一个疑问：字节跳动究竟做了什么，才取得了这样的成果？接下来我会将我们在稳定性治理方面沉淀的方法论分享给大家。 二、稳定性问题治理的方法论 首先我们认为在稳定性问题治理方面，从监控平台侧视角出发，最重要的就是要有完整的能力覆盖，比如针对上一章节中提到所有类型的稳定性问题，监控平台都应该能及时准确的发现。 另外是从业务研发同学的视角出发：稳定性问题治理这个课题，需要贯穿到软件研发的完整生命周期，包括需求研发、测试、集成、灰度、上线等，在上述每个阶段，研发同学都应该重视稳定性问题的发现和治理。 上图中右侧是我们总结的两条比较重要的治理原则： 第一条是控制新增，治理存量。一般来说新增的稳定性问题可能是一些容易爆发的问题，影响比较严重。存量问题相对来说疑难的问题居多，修复周期较长。 第二条比较容易理解：先急后缓，先易后难。我们应该优先修复那些爆发的问题以及相对容易解决的问题。 如果我们将软件研发周期聚焦在稳定性问题治理这个方向上，又可以抽象出以下几个环节： 首先第一个环节是问题发现：当用户在线上遇到任何类型的闪退，监控平台都应该能及时发现并上报。同时可以通过报警以及问题的自动分发，将这些问题第一时间通知给开发者，确保这些问题能够被及时的修复。 第二个阶段是归因：当开发者拿到一个稳定性问题之后，要做的第一件事情应该是排查这个问题的原因。根据一些不同的场景，我们又可以把归因分为单点归因、共性归因以及爆发问题归因。 当排查到问题的原因之后，下一步就是把这个问题修复掉，也就是问题的治理。在这里我们有一些问题治理的手段：如果是在线上阶段，我们首先可以做一些问题防护，比如网易几年前一篇文章提到的基于 OC Runtime 的线上 Crash 自动修复的方案大白，基于这种方案我们可以直接在线上做 Crash 防护；另外由于后端服务上线导致的稳定性问题爆发，我们可以通过服务的回滚来做到动态止损。除了这两种手段之外，更多的场景还是需要研发在线下修复 native 代码，再通过发版做彻底的修复。 如果我们想把稳定性问题治理做好的话，需要所有研发同学关注上述每一个环节，才能达到最终的目标。可是这么多环节我们的重点究竟在哪里呢？从字节跳动的问题治理经验来看，我们认为最重要的环节是第二个——线上的问题的归因。因为通过内部的统计数据发现：线上之所以存在长期没有结论，没有办法修复的问题，主要还是因为研发并没有定位到这些问题的根本原因。所以下一章节也是本次分享的重点：疑难问题归因。 三、疑难问题归因我们根据开发者对这些问题的熟悉程度做了一下排序，分别是：Crash、Watchdog、OOM 和 CPU&amp;Disk I/O。每一类疑难问题我都会分享这类问题的背景和对应的解决方案，并且会结合实战案例演示各种归因工具究竟是如何解决这些疑难问题的。 3.1 第一类疑难问题 —— Crash 上图中左侧这张饼状图是我们根据 Crash 不同的原因，把它细分成四大类：包括 Mach 异常、 Unix Signal 异常、OC 和 C++ 语言层面上的异常。其中比例最高的还是 Mach 异常，其次是 Signal 异常，OC 和 C++ 的异常相对比较少。 为什么是这个比例呢？ 大家可以看到右上角有两个数据。第一个数据是微软发布的一篇文章，称其发布的 70% 以上的安全补丁都是内存相关的错误，对应到 iOS 平台上就是 Mach 异常中的非法地址访问，也就是 EXC_BAD_ACCESS。内部统计数据表明，字节跳动线上 Crash 有 80% 是长期没有结论的，在这部分 Crash 当中，90% 以上都是 Mach 异常或者 Signal 异常。 看到这里，大家肯定心里又有疑问了，为什么有这么多 Crash 解决不了？究竟难在哪里？我们总结了几点这些问题归因的难点： 首先不同于 OC 和 C++ 的异常，可能开发者拿到的崩溃调用栈是一个纯系统调用栈，这类问题显然修复难度是非常大的； 另外可能有一部分Crash是偶发而不是必现的问题，研发同学想在线下复现问题是非常困难的，因为无法复现，也就很难通过 IDE 调试去排查和定位这些问题； 另外对于非法地址访问这类问题，崩溃的调用栈可能并不是第一现场。这里举一个很简单的例子：A业务的内存分配溢出，踩到了B业务的内存，这个时候我们认为 A 业务应该是导致这个问题的主要原因，但是有可能B业务在之后的某一个时机用到了这块内存，发生了崩溃。显然这种问题实际上是 A 业务导致的，最终却崩在了 B 业务的调用栈里，这就会给开发者排查和解决这个问题带来非常大的干扰。 看到这里大家可能心里又有问题：既然这类问题如此难解，是不是就完全没有办法了呢？其实也并不是，下面我会分享字节内部两个解决这类疑难问题非常好用的归因工具。 3.1.1 Zombie 检测 首先第一个是 Zombie 检测，大家如果用过 Xcode 的 Zombie 监控，应该对这个功能比较熟悉。如果我们在调试之前打开了 Zombie Objects 这个开关，在运行的时候如果遇到了 OC 对象野指针造成的崩溃，Xcode 控制台中会打印出一行日志，它会告诉开发者哪个对象在调用什么消息的时候崩溃了。 这里我们再解释一下 Zombie 的定义，其实非常简单，指的是已经释放的 OC 对象。 Zombie 监控的归因优势是什么呢？首先它可以直接定位到问题发生的类，而不是一些随机的崩溃调用栈；另外它可以提高偶现问题的复现概率，因为大部分偶现问题可能跟多线程的运行环境有关，如果我们能把一个偶现问题变成必现问题的话，那么开发者就可以借助 IDE 和调试器非常方便地排查问题。但是这个方案也有自己的适用范围，因为它的底层原理基于 OC 的 runtime 机制，所以它仅仅适用于 OC 对象野指针导致的内存问题。 这里再和大家一起回顾一下 Zombie 监控的原理：首先我们会 hook 基类 NSObject 的 dealloc 方法，当任意 OC 对象被释放的时候，hook 之后的那个 dealloc 方法并不会真正的释放这块内存，同时将这个对象的 ISA 指针指向一个特殊的僵尸类，因为这个特殊的僵尸类没有实现任何方法，所以这个僵尸对象在之后接收到任何消息都会 Crash，与此同时我们会将崩溃现场这个僵尸对象的类名以及当时调用的方法名上报到后台分析。 这里是字节的一个真实案例：这个问题是飞书在某个版本线上 Top 1 的 Crash，当时持续了两个月没有被解决。首先大家可以看到这个崩溃调用栈是一个纯系统调用栈，它的崩溃类型是非法地址访问，发生在视图导航控制器的一次转场动画，可能开发者一开始看到这个崩溃调用栈是毫无思路的。 那么我们再看 Zombie 功能开启之后的崩溃调用栈：这个时候报错信息会更加丰富，可以直接定位到野指针对象的类型，是 MainTabbarController 对象在调用 retain 方法的时候发生了 Crash。 看到这里大家肯定有疑问了，MainTabbarController 一般而言都是首页的根视图控制器，理论上在整个生命周期内不应该被释放。为什么它变成了一个野指针对象呢？可见这样一个简单的报错信息，有时候还并不足以让开发者定位到问题的根本原因。所以这里我们更进一步，扩展了一个功能：将 Zombie 对象释放时的调用栈信息同时上报上来。 大家看倒数第二行，实际上是一段飞书的业务代码，是视图导航控制器手势识别的代理方法，这个方法在调用的时候释放了 MainTabbarController。因为通过这个调用栈找到了业务代码的调用点，所以我们只需要对照源码去分析为什么会释放 TabbarController，就可以定位到这个问题的原因。 上图中右侧是简化之后的源码（因为涉及到代码隐私问题，所以通过一段注释代替）。历史上为了解决手势滑动返回的冲突问题，在飞书视图导航控制器的手势识别代理方法中写了一段 trick 代码，正是这个 trick 方案导致了首页视图导航控制器被意外释放。 排查到这里，我们就找到了问题的根本原因，修复的方案也就非常简单了：只要下掉这个 trick 方案，并且依赖导航控制器的原生实现来决定这个手势是否触发就解决了这个问题。 3.1.2 Coredump刚才也提到：Zombie 监控方案是有一些局限的，它仅适用于 OC 对象的野指针问题。大家可能又会有疑问：C 和 C++ 代码同样可能会出现野指针问题，在 Mach 异常和 Signal 异常中，除了内存问题之外，还有很多其他类型的异常比如 EXC_BAD_INSTRUCTION和SIGABRT。那么其他的疑难问题我们又该怎么解决呢？这里我们给出了另外一个解决方案 —— Coredump。 这个先解释一下什么是 Coredump：Coredump 是由 lldb 定义的一种特殊的文件格式，Coredump 文件可以还原 App 在运行到某一时刻的完整运行状态（这里的运行状态主要指的是内存状态）。大家可以简单的理解为：Coredump文件相当于在崩溃的现场打了一个断点，并且获取到当时所有线程的寄存器信息，栈内存以及完整的堆内存。 Coredump 方案它的归因优势是什么呢？首先因为它是 lldb 定义的文件格式，所以它天然支持 lldb 的指令调试，也就是说开发者无需复现问题，就可以实现线上疑难问题的事后调试。另外因为它有崩溃时现场的所有内存信息，这就为开发者提供了海量的问题分析素材。 这个方案的适用范围比较广，可以适用于任意 Mach 异常或者 Signal 异常问题的分析。 下面也带来一个线上真实案例的分析：当时这个问题出现在字节的所有产品中，而且在很多产品中的量级非常大，排名Top 1 或者 Top 2，这个问题在之前两年的时间内都没有被解决。 大家可以看到这个崩溃调用栈也全是系统库方法，最终崩溃在 libdispatch 库中的一个方法，异常类型是命中系统库断言。 我们将这次崩溃的 Coredump 文件上报之后，用前面提到的 lldb 调试指令去分析，因为拥有崩溃时的完整内存状态，所以我们可以分析所有线程的寄存器和栈内存等信息。 这里最终我们分析出：崩溃线程的 0 号栈帧(第一行调用栈)，它的 x0 寄程器实际上就是 libdispatch 中定义的队列结构体信息。在它起始地址偏移 0x48 字节的地方，也就是这个队列的 label 属性（可以简单理解为队列的名字）。这个队列的名字对我们来说是至关重要的，因为要修复这个问题，首先应该知道究竟是哪个队列出现了问题。通过 memory read 指令我们直接读取这块内存的信息，最终发现它是一个 C 的字符串，名字叫 com.apple.CFFileDescriptor，这个信息非常关键。我们在源码中全局搜索这个关键字，最终发现这个队列是在字节底层的网络库中创建的，这也就能解释为什么字节所有产品都有这个崩溃了。 最终我们和网络库的同学一起排查，同时结合 libdispatch 的源码，定位到这个问题的原因是 GCD 队列的外部引用计数小于0，存在过度释放的问题，最终命中系统库断言导致崩溃。 排查到问题之后，解决方案就比较简单了：我们只需要在这个队列创建的时候，使用 dispatch_source_create 的方式去增加队列的外部引用计数，就能解决这个问题。和维护网络库的同学沟通后，确认这个队列在整个 App 的生命周期内不应该被释放。这个问题最终解决的收益是直接让字节所有产品的 Crash 率降低了8%。 3.2 第二类疑难问题 —— Watchdog我们进入疑难问题中的第二类问题 —— Watchdog 也就是卡死。 上图中左侧是我在微博上截的两张图，是用户在遇到卡死问题之后的抱怨。可见卡死问题对用户体验的伤害还是比较大的。那么卡死问题它的危害有哪些呢？ 首先卡死问题通常发生于用户打开 App 的冷启动阶段，用户可能等待了10 秒什么都没有做，这个 App 就崩溃了，这对用户体验的伤害是非常大的。另外我们线上监控发现，如果没有对卡死问题做任何治理的话，它的量级可能是普通 Crash 的 2-3 倍。另外现在业界普遍监控 OOM 崩溃的做法是排除法，如果没有排除卡死崩溃的话，相应的就会增加 OOM 崩溃误判的概率。 卡死类问题的归因难点有哪些呢？首先基于传统的方案——卡顿监控：认为主线程无响应时间超过3秒～5秒之后就是一次卡死，这种传统的方案非常容易误报，至于为什么误报，我们下一页中会讲到。另外卡死的成因可能非常复杂，它不一定是单一的问题：主线程的死锁、锁等待、主线程 IO 等原因都有可能造成卡死。第三点是死锁问题是一类常见的导致卡死问题的原因。传统方案对于死锁问题的分析门槛是比较高的，因为它强依赖开发者的经验，开发者必须依靠人工的经验去分析主线程到底跟哪个或者哪些线程互相等待造成死锁，以及为什么发生死锁。 大家可以看到这是基于传统的卡顿方案来监控卡死，容易发生误报。为什么呢？图中绿色和红色的部分是主线程的不同耗时阶段。假如主线程现在卡顿的时间已经超过了卡死阈值，刚好发生在图中的第5个耗时阶段，我们在此时去抓取主线程调用栈，显然它并不是这次耗时的最主要的原因，问题其实主要发生在第4个耗时阶段，但是此时第4个耗时阶段已经过去了，所以会发生一次误报，这可能让开发者错过真正的问题。 针对以上提到的痛点，我们给出了两个解决方案：首先在卡死监控的时候可以多次抓取主线程调用栈，并且记录每次不同时刻主线程的线程状态，关于线程状态包括哪些信息，下一页中会提到。 另外我们可以自动识别出死锁导致的卡死问题，将这类问题标识出来，并且可以帮助开发者自动还原出各个线程之间的锁等待关系。 首先是第一个归因工具——线程状态，这张图是主线程在不同时刻调用栈的信息，在每个线程名字后面都有三个 tag ，分别指的是三种线程的状态，包括当时的线程 CPU 占用、线程运行状态和线程标志。 上图中右侧是线程的运行状态和线程标志的解释。当看到线程状态的时候，我们主要的分析思路有两种：第一种，如果看到主线程的 CPU 占用为 0，当前处于等待的状态，已经被换出，那我们就有理由怀疑当前这次卡死可能是因为死锁导致的；另外一种，特征有所区别，主线程的 CPU 占用一直很高 ，处于运行的状态，那么就应该怀疑主线程是否存在一些死循环等 CPU 密集型的任务。 第二个归因工具是死锁线程分析，这个功能比较新颖，所以首先带领大家了解一下它的原理。基于上一页提到的线程状态，我们可以在卡死时获取到所有线程的状态并且筛选出所有处于等待状态的线程，再获取每个线程当前的 PC 地址，也就是正在执行的方法，并通过符号化判断它是否是一个锁等待的方法。 上图中列举了目前我们覆盖到的一些锁等待方法，包括互斥锁、读写锁、自旋锁、 GCD 锁等等。每个锁等待的方法都会定义一个参数，传入当前锁等待的信息。我们可以从寄存器中读取到这些锁等待信息，强转为对应的结构体，每一个结构体中都会定义一个线程id的属性，表示当前这个线程正在等待哪个线程释放锁。对每一个处于等待状态的线程完成这样一系列操作之后，我们就能够完整获得所有线程的锁等待关系，并构建出锁等待关系图。 通过上述方案，我们可以自动识别出死锁线程。假如我们能判断 0 号线程在等待 3 号线程释放锁， 同时3 号线程在等待0号线程释放锁，那么显然就是两个互相等待最终造成死锁的线程。 大家可以看到这里主线程我们标记为死锁，它的 CPU 占用为 0，状态是等待状态，而且已经被换出了，和我们之前分析线程状态的方法论是吻合的。 通过这样的分析之后，我们就能够构建出一个完整的锁等待关系图，而且无论是两个线程还是更多线程互相等待造成的死锁问题，都可以自动识别和分析。 这是上图中死锁问题的一段示意的源码。它的问题就是主线程持有互斥锁，子线程持有 GCD 锁，两个线程之间互相等待造成了死锁。这里给出的解决方案是：如果子线程中可能存在耗时操作，尽量不要和主线程有锁竞争关系；另外如果在串行队列中同步执行 block 的话，一定要慎重。 上图是通过字节内部线上的监控和归因工具，总结出最常见触发卡死问题的原因，分别是死锁、锁竞争、主线程IO、跨进程通信。 3.3 第三类疑难问题 —— OOMOOM 就是 Out Of Memory，指的是应用占用的内存过高，最终被系统强杀导致的崩溃。 OOM 崩溃的危害有哪些呢？首先我们认为用户使用 App 的时间越长，就越容易发生 OOM 崩溃，所以说 OOM 崩溃对重度用户的体验伤害是比较大的；统计数据显示，如果 OOM 问题没有经过系统性的治理，它的量级一般是普通 Crash 的 3-5 倍。最后是内存问题不同于 Crash 和卡死，相对隐蔽，在快速迭代的过程中非常容易劣化。 那么 OOM 问题的归因难点有哪些呢？首先是内存的构成是非常复杂的事情，并没有非常明确的异常调用栈信息。另外我们在线下有一些排查内存问题的工具，比如 Xcode MemoryGraph 和 Instruments Allocations，但是这些线下工具并不适用于线上场景。同样是因为这个原因，如果开发者想在线下模拟和复现线上 OOM 问题是非常困难的。 这里我们给出解决线上 OOM 疑难问题的归因工具是MemoryGraph。这里的 MemoryGraph 主要指的是在线上环境中可以使用的 MemoryGraph。跟 Xcode MemoryGraph 有一些类似，但是也有不小的区别。最大的区别当然是它能在线上环境中使用，其次它可以对分散的内存节点进行统计和聚合，方便开发者定位头部的内存占用。 这里带领大家再回顾一下线上 MemoryGraph 的基本原理：首先我们会定时的去检测 App 的物理内存占用，当它超过危险阈值的时候，就会触发内存 dump，此时 SDK 会记录每个内存节点符号化之后的信息，以及他们彼此之间的引用关系，如果能判定出是强引用还是弱引用，也会把这个强弱引用关系同时上报上来，最终这些信息整体上报到后台之后，就可以辅助开发者去分析当时的大内存占用和内存泄露等异常问题。 这里我们还是用一个实战案例带领大家看一下 MemoryGraph 到底是如何解决 OOM 问题的。 分析 MemoryGraph 文件的思路一般是抽丝剥茧，逐步找到根本原因。 上图是 MemoryGraph 文件分析的一个例子，这里的红框标注了不同的区域：左上角是类列表，会把同一类型对象的数量以及它们占用的内存大小做一个汇总；右侧是这个类所有实例的地址列表，右下角区域开发者可以手动回溯对象的引用关系（当前对象被哪些其他对象引用、它引用了哪些其他对象），中间比较宽的区域是引用关系图。 因为不方便播放视频，所以这边就跟大家分享一些比较关键的结论：首先看到类列表，我们不难发现 ImageIO 类型的对象有 47 个，但是这 47 个对象居然占了 500 多 MB 内存，显然这并不是一个合理的内存占用。我们点开 ImageIO 的类列表，以第一个对象为例，回溯它的引用关系。当时我们发现这个对象只有一个引用，就是 VM Stack: Rust Client Callback ，它实际上是飞书底层的 Rust 网络库线程。 排查到这里，大家肯定会好奇：这 47 个对象是不是都存在相同的引用关系呢？这里我们就可以用到右下角路径回溯当中的 add tag 功能，自动筛选这 47 个对象是否都存在相同的引用关系。大家可以看到上图中右上角区域，通过筛选之后，我们确认这 47 个对象 100% 都有相同的引用关系。 我们再去分析 VM Stack: Rust Client Callback这个对象。发现它引用的对象中有两个名字非常敏感，一个是 ImageRequest，另外一个是 ImageDecoder ，从这两个名字我们可以很容易地推断出：应该是图片请求和图片解码的对象。 我们再用这两个关键字到类列表中搜索，可以发现 ImageRequest 对象有 48 个，ImageDecoder 对象有 47 个。如果大家还有印象的话，上一页中占用内存最大的对象 ImageIO 也是 47 个。这显然并不是一个巧合，我们再去排查这两类对象的引用关系，发现这两类对象也同样是 100% 被 VM Stack: Rust Client Callback 对象所引用。 最终我们和飞书图片库的同学一起定位到这个问题的原因：在同一时刻并发请求 47 张图片并解码，这不是一个合理的设计。问题的根本原因是飞书图片库的下载器依赖了 NSOperationQueue 做任务管理和调度，但是却没有配置最大并发数，在极端场景下就有可能造成内存占用过高的问题。与之相对应的解决方案就是对图片下载器设置最大并发数，并且根据待加载图片是否在可视区域内调整优先级。 上图是通过字节内部的线上监控和归因工具，总结出来最常见的几类触发 OOM 问题的原因，分别是：内存泄露，这个较为常见；第二个是内存堆积，主要指的是 AutoreleasePool 没有及时清理；第三是资源异常，比如加载一张超大图或者一个超大的 PDF 文件；最后一个是内存使用不当，比如内存缓存没有设计淘汰清理的机制。 3.4 第四类疑难问题 —— CPU 异常和磁盘 I/O 异常这里之所以把这两类问题合并在一起，是因为这两类问题是高度相似的：首先它们都属于资源的异常占用；另外它们也都不同于闪退，导致崩溃的原因并不是发生在一瞬间，而都是持续一段时间的资源异常占用。 异常 CPU 占用和磁盘 I/O 占用危害有哪些呢？首先我们认为，这两类问题即使最终没有导致 App 崩溃，也特别容易引发卡顿或者设备发烫等性能问题。其次这两类问题的量级也是不可以被忽视的。另外相比之前几类稳定性问题而言，开发者对这类问题比较陌生，重视程度不够，非常容易劣化。 这类问题的归因难点有哪些呢？首先是刚刚提到它的持续时间非常长，所以原因也可能并不是单一的；同样因为用户的使用环境和操作路径都比较复杂，开发者也很难在线下复现这类问题；另外如果 App 想在用户态去监控和归因这类问题的话，可能需要在一段时间内高频的采样调用栈信息，然而这种监控手段显然性能损耗是非常高的。 上图中左侧是我们从 iOS 设备中导出的一段 CPU 异常占用的崩溃日志，截取了关键部分。这部分信息的意思是：当前 App 在 3 分钟之内的 CPU 时间占用已经超过80%，也就是超过了 144 秒，最终触发了这次崩溃。 上图中右侧是我截取苹果 WWDC2020 一个 session 中的截图，苹果官方对于这类问题，给出了一些归因方案的建议：首先是 Xcode Organizer，它是苹果官方提供的问题监控后台。然后是建议开发者也可以接入 MetricKit ，新版本有关于 CPU 异常的诊断信息。 上图中左侧是磁盘异常写入的崩溃日志，也是从 iOS 设备中导出，依然只截取了关键部分：在 24 小时之内，App 的磁盘写入量已经超过了 1073 MB，最终触发了这次崩溃。 上图中右侧是苹果官方的文档，也给出了对于这类问题的归因建议。同样是两个建议：一个是依赖 Xcode Organizer，另一个是依赖 MetricKit。我们选型的时候最终确定采用 MetricKit 方案，主要考虑还是想把数据源掌握在自己手中。因为 Xcode Organizer 毕竟是一个苹果的黑盒后台，我们无法与集团内部的后台打通，更不方便建设报警、问题自动分配、issue状态管理等后续流程。 MetricKit是苹果提供的官方性能分析以及稳定性问题诊断的框架，因为是系统库，所以它的性能损耗很小。在 iOS 14 系统以上，基于Metrickit，我们可以很方便地获取 CPU 和磁盘 I/O 异常的诊断信息。它的集成也非常方便。我们只需要导入系统库的头文件，设置一个监听者，在对应的回调中把 CPU 和磁盘写入异常的诊断信息上报到后台分析就好了。 其实这两类异常的诊断信息格式也是高度类似的，都是记录一段时间内所有方法的调用以及每个方法的耗时。上报到后台之后，我们可以把这些数据可视化为非常直观的火焰图。通过这样直观的形式，可以辅助开发者轻松地定位到问题。对于上图中右侧的火焰图，我们可以简单的理解为：矩形块越长，占用的 CPU 时间就越长。那么我们只需要找到矩形块最长的 App 调用栈，就能定位到问题。图中高亮的红框，其中有一个方法的关键字是 animateForNext，看这个名字大概能猜到这是动画在做调度。 最终我们和飞书的同学一起定位到这个问题的原因：飞书的小程序业务有一个动画在隐藏的时候并没有暂停播放，造成了 CPU 占用持续比较高。解决方案也非常简单，只要在动画隐藏的时候把它暂停掉就可以了。 四、总结回顾 在第二章节稳定性问题治理方法论中，我提到“如果想把稳定性问题治理好，就需要将这件事情贯穿到软件研发周期中的每一个环节，包括问题的发现、归因、治理以及防劣化。”同时我们认为线上问题——特别是线上疑难问题的归因，是整个链路中的重中之重。针对每一类疑难问题，本次分享均给出了一些好用的归因工具：Crash 有 Zombie 监控和 Coredump；Watchdog 有线程状态和死锁线程分析；OOM 有 MemoryGraph；CPU 和磁盘 I/O 异常有 MetricKit。 本次分享提到的所有疑难问题的归因方案，除了MetricKit 之外，其余均为字节跳动自行研发，开源社区尚未有完整解决方案。这些工具和平台后续都将通过字节火山引擎应用开发套件MARS下的 APM Plus 平台提供一站式的企业解决方案。本次分享提到的所有能力均已在字节内部各大产品中验证和打磨多年，其自身的稳定性以及接入后所带来的业务效果都是有目共睹的，欢迎大家持续保持关注。","categories":[{"name":"App优化","slug":"App优化","permalink":"http://heseng91.github.io/categories/App%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"「刨根问底」之RunLoop","slug":"「刨根问底」之Runloop","date":"2018-12-04T08:30:33.000Z","updated":"2022-07-31T18:42:50.784Z","comments":true,"path":"2018/12/04/「刨根问底」之Runloop/","link":"","permalink":"http://heseng91.github.io/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRunloop/","excerpt":"RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，与自动释放池、延迟回调、触摸事件、屏幕刷新等功能的实现密切相关。理解RunLoop可以帮助开发者了解很多技术的实现细节，加深理解，并在实际工作中加以灵活运用以解决特定场景的问题。","text":"RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，与自动释放池、延迟回调、触摸事件、屏幕刷新等功能的实现密切相关。理解RunLoop可以帮助开发者了解很多技术的实现细节，加深理解，并在实际工作中加以灵活运用以解决特定场景的问题。 本文将从RunLoop源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。最后介绍RunLoop的一些实际应用。前两部分网上相关文章已经很多了，珠玉在前，因此本文就基于深入理解RunLoop适当补充一些当时拜读文章时疑惑的点，来做个介绍。 RunLoop 的概念以及底层实现原理RunLoop 的概念一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的： 1234567function loop() &#123; initialize(); do &#123; var message &#x3D; get_next_message(); process_message(message); &#125; while (message !&#x3D; quit);&#125; 这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 CFRunLoopRef 的代码是开源的，你可以在这里 http://opensource.apple.com/tarballs/CF/ 下载到整个 CoreFoundation 的源码来查看。 (Update: Swift 开源后，苹果又维护了一个跨平台的 CoreFoundation 版本：https://github.com/apple/swift-corelibs-foundation/，这个版本的源码可能和现有 iOS 系统中的实现略不一样，但更容易编译，而且已经适配了 Linux/Windows。) CFRunLoopRefCFRunLoopRef 其实是 __CFRunLoop 结构体的别名，可在 CFRunLoop.h 找到如下代码： 1typedef struct __CFRunLoop * CFRunLoopRef; __CFRunLoop 结构体在 CFRunLoop.c 中定义如下： 123456789101112131415161718struct __CFRunLoop &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* locked for accessing mode list */ __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData; // reset for runs of the run loop pthread_t _pthread; // RunLoop对应的线程 uint32_t _winthread; CFMutableSetRef _commonModes; // set CFMutableSetRef _commonModeItems; // set CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFAbsoluteTime _runTime; CFAbsoluteTime _sleepTime; CFTypeRef _counterpart;&#125;; 结构体中包含一个pthread_mutex_t类型的锁，来保证获取 RunLoop mode list时的线程安全，所以说 CFRunLoopRef API是线程安全的。 除此之外结构体还包含一个 pthread_t 类型变量，那么RunLoop 与线程是什么关系呢？另外结构体的_commonModes、_commonModeItems、 _currentMode 和 _modes 分别代表什么含义呢？带着这些问题，我们来逐步解答。 RunLoop 与线程的关系首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份[文档](http://www.fenestrated.net/~macman/mirrors/Apple Technotes (As of 2002)/tn/tn2028.html)标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。 苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样: 123456789101112131415161718192021222324252627282930313233343536373839/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock; /// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) &#123; /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125; CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125; CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; 从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 RunLoop 对外的接口在RunLoop结构体中包含了一个CFRunLoopModeRef 类型的变量 。CFRunLoopModeRef 在 CFRunLoop.c 文件中的定义如下： 1234567891011121314151617181920212223242526272829303132typedef struct __CFRunLoopMode *CFRunLoopModeRef;struct __CFRunLoopMode &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* must have the run loop locked before locking this */ CFStringRef _name; // Mode Name, 例如 @\"kCFRunLoopDefaultMode\" Boolean _stopped; char _padding[3]; CFMutableSetRef _sources0; // set CFMutableSetRef _sources1; // set CFMutableArrayRef _observers; // array CFMutableArrayRef _timers; // array CFMutableDictionaryRef _portToV1SourceMap; __CFPortSet _portSet; CFIndex _observerMask;#if USE_DISPATCH_SOURCE_FOR_TIMERS dispatch_source_t _timerSource; dispatch_queue_t _queue; Boolean _timerFired; // set to true by the source when a timer has fired Boolean _dispatchTimerArmed;#endif#if USE_MK_TIMER_TOO mach_port_t _timerPort; Boolean _mkTimerArmed;#endif#if DEPLOYMENT_TARGET_WINDOWS DWORD _msgQMask; void (*_msgPump)(void);#endif uint64_t _timerSoftDeadline; /* TSR */ uint64_t _timerHardDeadline; /* TSR */&#125;; CFRunLoopSourceRef： 结构体中 _sources0 和 _sources1 变量的元素类型是 CFRunLoopSourceRef。CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 CFRunLoopTimerRef： 结构体中 _timers 变量的元素类型是 CFRunLoopTimerRef。CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef： 结构体中 _observers 变量的元素类型是CFRunLoopObserverRef。 CFRunLoopObserverRef是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 这里提到的CFRunLoopModeRef、CFRunLoopSourceRef、CFRunLoopTimerRef 和 CFRunLoopObserverRef 四个类和前面说的 CFRunLoopRef 共同构成了CoreFoundation 里面关于 RunLoop 有5个类。其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下: 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 Source/Timer/Observer 被统称为 mode item，即 CFRunLoopRef 结构体中的 commonModeItems变量中存放的元素。一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop 的 Mode上文中 CFRunLoopRef 结构体中有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。 CFRunLoop对外暴露的管理 Mode 接口只有下面2个: 12CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);CFRunLoopRunInMode(CFStringRef modeName, ...); Mode 暴露的管理 mode item 的接口有下面几个： 123456CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 RunLoop的退出方式启动一个runloop有以下三种方法： 12345- (void)run; - (void)runUntilDate:(NSDate *)limitDate；- (void)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate; 第一种方式，runloop会一直运行下去，在此期间会处理来自输入源的数据，并且会在NSDefaultRunLoopMode模式下重复调用runMode:beforeDate:方法； 第二种方式，可以设置超时时间，在超时时间到达之前，runloop会一直运行，在此期间runloop会处理来自输入源的数据，并且也会在NSDefaultRunLoopMode模式下重复调用runMode:beforeDate:方法； 第三种方式，runloop会运行一次，超时时间到达或者第一个input source被处理，则runloop就会退出。 前两种启动方式会重复调用runMode:beforeDate:方法。 与之对应的退出方式分别为： 第一种启动方式的退出方法：如果想退出runloop，不应该使用第一种启动方式来启动runloop。如果runloop没有input sources或者附加的timer，runloop就会退出。 虽然这样可以将runloop退出，但是苹果并不建议我们这么做，因为系统内部有可能会在当前线程的runloop中添加一些输入源，所以通过手动移除input source或者timer这种方式，并不能保证runloop一定会退出。 第二种启动方式的退出方法：可以通过设置超时时间来退出runloop。 **第三种启动方式的退出方法：通过这种方式启动，runloop会运行一次，当超时时间到达或者第一个输入源被处理，runloop就会退出。如果我们想控制runloop的退出时机，而不是在处理完一个输入源事件之后就退出，那么就要重复调用runMode:beforeDate:，具体可以参考苹果文档给出的方案，如下： 12345678 NSRunLoop *myLoop = [NSRunLoop currentRunLoop]; myPort = (NSMachPort *)[NSMachPort port]; [myLoop addPort:_port forMode:NSDefaultRunLoopMode];BOOL isLoopRunning = YES; // globalwhile (isLoopRunning &amp;&amp; [myLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]); 123456//关闭runloop的地方- (void)quitLoop &#123; isLoopRunning = NO; CFRunLoopStop(CFRunLoopGetCurrent());&#125; 总之： 如果不想退出runloop可以使用第一种方式启动runloop；使用第二种方式启动runloop，可以通过设置超时时间来退出；使用第三种方式启动runloop，可以通过设置超时时间或者使用CFRunLoopStop方法来退出。 RunLoop 的内部逻辑根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下: 第七步按照官方文档的描述，会有4种情况唤醒RunLoop：An event arrives for a port-based input source.A timer fires.The timeout value set for the run loop expires.The run loop is explicitly woken up. 其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/// 用DefaultMode启动void CFRunLoopRun(void) &#123; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125; /// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123; return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125; /// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123; /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; /// 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); /// 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123; Boolean sourceHandledThisLoop = NO; int retVal = 0; do &#123; /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 4. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; &#125; /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); &#125; /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 /// • 一个基于 port 的Source 的事件。 /// • 一个 Timer 到时间了 /// • RunLoop 自身的超时时间到了 /// • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg &#125; /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); /// 收到消息，处理消息。 handle_msg: /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) &#125; /// 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123; mach_msg(reply, MACH_SEND_MSG, reply); &#125; &#125; /// 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout) &#123; /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(runloop)) &#123; /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123; /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; &#125; /// 如果没超时，mode里没空，loop也没被停止，那继续loop。 &#125; while (retVal == 0); &#125; /// 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop 的底层实现从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。 苹果官方将整个系统大致划分为上述4个层次：应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。应用框架层即开发人员接触到的 Cocoa 等框架。核心框架层包括各种核心框架、OpenGL 等内容。Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 opensource.apple.com 里找到。 我们在深入看一下 Darwin 这个核心的架构： 其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。 Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。 Mach 的消息定义是在 &lt;mach/message.h&gt; 头文件的，很简单： 12345678910111213typedef struct &#123; mach_msg_header_t header; mach_msg_body_t body;&#125; mach_msg_base_t; typedef struct &#123; mach_msg_bits_t msgh_bits; mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; mach_port_t msgh_local_port; mach_port_name_t msgh_voucher_port; mach_msg_id_t msgh_id;&#125; mach_msg_header_t; 一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向： 12345678mach_msg_return_t mach_msg( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify); 为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图： 这些概念可以参考维基百科: System_call、Trap_(computing)。 RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。 关于具体的如何利用 mach port 发送信息，可以看看 NSHipster 这一篇文章，或者这里的中文翻译 。 关于Mach的历史可以看看这篇很有趣的文章：Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian。 苹果用 RunLoop 实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CFRunLoop &#123; current mode = kCFRunLoopDefaultMode common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0 (manual) CFRunLoopSource &#123;order =-1, &#123; callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventSignalCallback &#125;&#125; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach port) CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1b03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125; CFRunLoopSource &#123;order = 1, &#123;port = 1903, callout = __IOMIGMachPortPortCallback&#125;&#125; // Ovserver CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver&#125; CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // Timer CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125; &#125;, modes ＝ &#123; CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, sources1 = (null), observers = &#123; CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; )&#125;, timers = (null), &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;, sources1 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventCallback&#125;&#125; &#125;, observers = (null), timers = (null), &#125;, CFRunLoopMode &#123; sources0 = (null), sources1 = (null), observers = (null), timers = (null), &#125; &#125;&#125; kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。 你可以在这里看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。 当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; /// 1. 通知Observers，即将进入RunLoop /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry); do &#123; /// 2. 通知 Observers: 即将触发 Timer 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers); /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 4. 触发 Source0 (非基于port的) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 6. 通知Observers，即将进入休眠 /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting); /// 7. sleep to wait msg. mach_msg() -&gt; mach_msg_trap(); /// 8. 通知Observers，线程被唤醒 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting); /// 9. 如果是被Timer唤醒的，回调Timer __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer); /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block); /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1); &#125; while (...); /// 10. 通知Observers，即将退出RunLoop /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);&#125; AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。接着会在UIWindow为根节点的整颗视图树上通过hitTest:withEvent:和pointInside:withEvent:这两个方法递归查找到合适响应这个触摸事件的视图。找到合适的子节点视图后，调用touches方法，判断是否实现touches方法，没有实现默认会将事件传递给上一个响应者。如果最终找到上一个响应者则调用，否则方法作废。响应链的整体流程如下： 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： 1234567891011_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD实际上 RunLoop 底层也会用到 GCD 的东西，但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 关于网络请求iOS 中，关于网络请求的接口自下至上有如下几层: 1234CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire • CFSocket 是最底层的接口，只负责 socket 通信。• CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。• NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。• NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。 下面主要介绍下 NSURLConnection 的工作过程。 通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 RunLoop 的实际应用AFNetworkingAFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop &#x3D; [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125; + (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread &#x3D; nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread &#x3D; [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start &#123; [self.lock lock]; if ([self isCancelled]) &#123; [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; else if ([self isReady]) &#123; self.state &#x3D; AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; [self.lock unlock];&#125; 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 AsyncDisplayKitAsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下： UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。 排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。 为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。具体的代码可以看这里：_ASAsyncTransactionGroup。 FDTemplateLayoutCellFDTemplateLayoutCell 的高度预缓存是一个优化功能，它只会在页面处于空闲状态时才执行计算，当用户正在滑动列表时显然不应该执行计算任务影响滑动体验。前面提到了当用户正在滑动 UIScrollView 时，RunLoop 将切换到 UITrackingRunLoopMode 接受滑动手势和处理滑动事件（包括减速和弹簧效果），而此时其它Mode（除了具有 “Common” 标记的Mode外）下的事件将全部暂停执行，来保证滑动事件的优先处理。当 UI 没在滑动时，默认的 Mode 是 kCFRunLoopDefaultMode，同时也是 CF 中定义的 “空闲状态 Mode”。 高度预缓存的实现思路就是将未展示或者缓存的高度，分解成多个RunLoop Source任务，在RunLoop 处于“空闲”状态 Mode下分散到多个RunLoop 迭代中执行，避免计算任务在同一个 RunLoop 迭代中同步执行造成的卡顿。 为此，FDTemplateLayoutCell 获取当前RunLoop并在kCFRunLoopDefaultMode mod下添加一个Observer，监听kCFRunLoopBeforeWaiting状态的时候，执行一次预计算，待所有任务执行完成的时候，移除监听者，核心代码如下： 123456789101112131415161718CFRunLoopRef runLoop = CFRunLoopGetCurrent();CFStringRef runLoopMode = kCFRunLoopDefaultMode;NSMutableArray *mutableIndexPathsToBePrecached = self.fd_allIndexPathsToBePrecached.mutableCopy;CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) &#123; if (mutableIndexPathsToBePrecached.count == 0) &#123; CFRunLoopRemoveObserver(runLoop, observer, runLoopMode); CFRelease(observer); // 注意释放，否则会造成内存泄露 return; &#125; NSIndexPath *indexPath = mutableIndexPathsToBePrecached.firstObject; [mutableIndexPathsToBePrecached removeObject:indexPath]; [self performSelector:@selector(fd_precacheIndexPathIfNeeded:) onThread:[NSThread mainThread] withObject:indexPath waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];&#125;);CFRunLoopAddObserver(runLoop, observer, runLoopMode); 此思路也可用于其它场景的优化。 RunLoop 监控 app 卡顿上文介绍了，Runloop的六个状态，Runloop 真正处理事务的状态区间是：kCFRunloopBeforeSources-&gt;kCFRunLoopBeforeWaitingkCFRunLoopAfterWaiting-&gt; kCFRunLoopBeforeTimers 要监控app 卡顿的思路如下： 创建一个 CFRunLoopObserverContext 观察者， 将创建好的观察者 runLoopObserver 添加到主线程 RunLoop 的 common mode下监听 kCFRunLoopBeforeWaiting 和 kCFRunLoopBeforeWaiting 状态 创建一个Dispatch Semaphore来监控主线程的 RunLoop 状态并设置等待时间 过等待时间内子线程还没有被唤醒，则认为发生了卡顿 核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738dispatchSemaphore = dispatch_semaphore_create(0); //Dispatch Semaphore保证同步 //创建一个观察者 CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;; runLoopObserver = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); //将观察者添加到主线程runloop的common模式下的观察中 CFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes); //创建子线程监控 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; //子线程开启一个持续的loop用来进行监控 while (YES) &#123; long semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC)); // semaphoreWait 的值不为 0， 说明线程被堵塞 if (semaphoreWait != 0) &#123; if (!runLoopObserver) &#123; timeoutCount = 0; dispatchSemaphore = 0; runLoopActivity = 0; return; &#125; // BeforeSources和 AfterWaiting 这两个 runloop 状态的区间时间能够检测到是否卡顿 if (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) &#123; // 将堆栈信息上报服务器的代码放到这里 if (++ timeoutCount &lt; 5) &#123; //连续5次就是250毫秒 continue; &#125; else &#123; NSLog(@\"卡顿了\"); &#125; &#125; //end activity &#125;// end semaphore wait timeoutCount = 0; &#125;// end while &#125;); runLoopObserverCallBack 回调实现如下： 1234567static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; SMLagMonitor *lagMonitor = (__bridge SMLagMonitor*)info; lagMonitor-&gt;runLoopActivity = activity; dispatch_semaphore_t semaphore = lagMonitor-&gt;dispatchSemaphore; dispatch_semaphore_signal(semaphore);&#125; 使用runloop阻塞线程前文中说到，runloop其实就是一个while循环，所以可以使用runloop来阻塞线程。 1234567891011121314151617181920212223242526272829@implementation ViewController&#123; BOOL end;&#125;– (void)viewDidLoad&#123; [super viewDidLoad]; NSLog(@”start new thread …”); [NSThread detachNewThreadSelector:@selector(runOnNewThread) toTarget:self withObject:nil]; while (!end) &#123; NSLog(@”runloop…”); [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; NSLog(@”runloop end.”); &#125; NSLog(@”ok”);&#125;-(void)runOnNewThread&#123; NSLog(@”run for new thread …”); sleep(1); [self performSelectorOnMainThread:@selector(setEnd) withObject:nil waitUntilDone:NO]; NSLog(@”end.”);&#125;-(void)setEnd&#123; end=YES;&#125; 参考： 深入理解RunLoop 优化UITableViewCell高度计算的那些事 如何利用 RunLoop 监控 app 卡顿 使用runloop阻塞线程的正确写法 RunLoop的退出方式","categories":[{"name":"刨根问底","slug":"刨根问底","permalink":"http://heseng91.github.io/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}],"tags":[]},{"title":"刨根问底」之Runtime消息发送和转发","slug":"「刨根问底」之Runtime消息发送和转发","date":"2018-12-04T08:30:33.000Z","updated":"2022-07-25T19:29:06.791Z","comments":true,"path":"2018/12/04/「刨根问底」之Runtime消息发送和转发/","link":"","permalink":"http://heseng91.github.io/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/","excerpt":"上篇文章Runtime类和对象的定义 中提到了源代码到可执行文件需要需要经过编译和链接。其中编译通常会先预处理，再编译。iOS中预编译是使用Clang完成的。","text":"上篇文章Runtime类和对象的定义 中提到了源代码到可执行文件需要需要经过编译和链接。其中编译通常会先预处理，再编译。iOS中预编译是使用Clang完成的。 下面新建一个工程并修改一下main.m文件如下： 12345678910#import &lt;UIKit&#x2F;UIKit.h&gt;#import &quot;AppDelegate.h&quot;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; UIViewController *vc &#x3D; [[UIViewController alloc] init]; [vc viewDidLoad]; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 打开终端，cd到工程目录，然后执行如下命令，对源文件进行clang rewrite， 1xcrun -sdk iphonesimulator13.2 clang -rewrite-objc -F &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneOS13.2.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneOS.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks SecondViewController.m iphonesimulator13.2中 13.2 为当前xcode SDK版本号（指令xcodebuild -showsdks即可查看），在得到的main.cpp文件末尾，可以找到源代码clang后的代码： 1234567int main(int argc, char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; UIViewController *vc = ((UIViewController *(*)(id, SEL))(void *)objc_msgSend)((id)((UIViewController *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"UIViewController\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")); ((void (*)(id, SEL))(void *)objc_msgSend)((id)vc, sel_registerName(\"viewDidLoad\")); return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AppDelegate\"), sel_registerName(\"class\")))); &#125;&#125; 从中可以得知: [receiver message] 其实会被编译器转化为： 1objc_msgSend(receiver, selector) 本篇就来详细分析一下Objective-C消息发送和转发机制。 消息发送和转发流程可以概括为： 消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现； 消息转发（Message Forwarding）是在查找 IMP 失败后执行一系列转发流程的慢速通道，如果不作转发处理，则会打日志和抛出异常。 本文将从源码角度分析消息发送和转发的原理。能够很好地阅读本文的前提是你对 Objective-C Runtime 已经有一定的了解，关于什么是消息，Class 的结构，selector、IMP、元类等概念将不再赘述。本文用到的源码为 objc4-756.2，汇编语言架构为 arm64。 objc_msgSend函数简介此函数是消息发送必经之路。objc_msgSend函数究竟会干什么事情呢？从这篇「objc_msgSend() Tour」文章里面可以得到一个比较详细的结论。 1234567891. Check for ignored selectors (GC) and short-circuit.2. Check for nil target. If nil &amp; nil receiver handler configured, jump to handler If nil &amp; no handler (default), cleanup and return.3. Search the class’s method cache for the method IMP(use hash to find&amp;store method in cache) -1. If found, jump to it. -2. Not found: lookup the method IMP in the class itself corresponding its hierarchy chain. If found, load it into cache and jump to it. If not found, jump to forwarding mechanism. 总结一下objc_msgSend会做以下几件事情： 检测这个 selector是不是要忽略的。 检查target是不是为nil。 如果这里有相应的nil的处理函数，就跳转到相应的函数中。如果没有处理nil的函数，就自动清理现场并返回。这一点就是为何在OC中给nil发送消息不会崩溃的原因。 确定不是给nil发消息之后，在该class的缓存中查找方法对应的IMP实现。 如果找到，就跳转进去执行。如果没有找到，就在方法分发表里面继续查找，一直找到NSObject为止。 如果还没有找到，那就需要开始消息转发阶段了。至此，发送消息Messaging阶段完成。这一阶段主要完成的是通过selecter快速查找IMP的过程。 源码解析在这篇文章Obj-C Optimization: The faster objc_msgSend中看到了这样一段C版本的objc_msgSend的源码。 Objective-C 123456789101112131415161718192021222324252627282930313233#include &lt;objc/objc-runtime.h&gt;id c_objc_msgSend( struct objc_class /* ahem */ *self, SEL _cmd, ...)&#123; struct objc_class *cls; struct objc_cache *cache; unsigned int hash; struct objc_method *method; unsigned int index; if( self) &#123; cls = self-&gt;isa; cache = cls-&gt;cache; hash = cache-&gt;mask; index = (unsigned int) _cmd &amp; hash; do &#123; method = cache-&gt;buckets[ index]; if( ! method) goto recache; index = (index + 1) &amp; cache-&gt;mask; &#125; while( method-&gt;method_name != _cmd); return( (*method-&gt;method_imp)( (id) self, _cmd)); &#125; return( (id) self);recache: /* ... */ return( 0);&#125; 该源码中有一个do-while循环，这个循环就是前面提到的在方法分发表里面查找method的过程。 _objc_msgSend源码分析不过在 objc4-756.2里面objc_msgSend 是用汇编语言写的，针对不同架构有不同的实现。objc-msg-arm64.s文件中实现是如下一段汇编代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&#x2F;&#x2F; objc_msgSend 汇编入口 ENTRY _objc_msgSend &#x2F;&#x2F; 无窗口 UNWIND _objc_msgSend, NoFrame&#x2F;&#x2F; p0：objc_msgSend的第一个参数，即消息接受者&#x2F;&#x2F; cmp: 比较&#x2F;&#x2F; #0：nil&#x2F;&#x2F; 判断p0是否为空 cmp p0, #0 &#x2F;&#x2F; nil check and tagged pointer check&#x2F;&#x2F; 支持taggedpointer的流程#if SUPPORT_TAGGED_POINTERS&#x2F;&#x2F; b.le: 执行标号，判断上面cmp值是小于等于，如果receiver为nil或taggedpointer，则执行LNilOrTagged b.le LNilOrTagged &#x2F;&#x2F; (MSB tagged pointer looks negative)#else&#x2F;&#x2F; b.eq: 执行标号，判断上面cmp值是等于，如果receiver为nil，则执行LReturnZero&#x2F;&#x2F; p0为空，返回空 b.eq LReturnZero#endif&#x2F;&#x2F; p0不为空，即receiver 存在的流程&#x2F;&#x2F; ldr 把数据从内存中某处读取到寄存器&#x2F;&#x2F; p13 &#x3D; x0栈内存中的值，从x0寄存器指向的地址中取出 isa，并把isa赋值给p13 ldr p13, [x0] &#x2F;&#x2F; p13 &#x3D; isa&#x2F;&#x2F; 在64位架构下通过 p16 &#x3D; isa（p13） &amp; ISA_MASK，获取shiftcls，从而得到class信息 GetClassFromIsa_p16 p13 &#x2F;&#x2F; p16 &#x3D; classLGetIsaDone:&#x2F;&#x2F; 如果isa存在，调用CacheLookup，开始cache查找流程(快速查找流程sel-&gt;imp)&#x2F;&#x2F; 找到就返回imp，没找到就返回objc_msgSend_uncached CacheLookup NORMAL &#x2F;&#x2F; calls imp or objc_msgSend_uncached&#x2F;&#x2F; 支持taggedpointer#if SUPPORT_TAGGED_POINTERS&#x2F;&#x2F; LNilOrTagged条件判断逻辑LNilOrTagged:&#x2F;&#x2F; 等于空，返回空 b.eq LReturnZero &#x2F;&#x2F; nil check &#x2F;&#x2F; tagged &#x2F;&#x2F; adrp 计算指定的数据地址到当前pc寄存器值相对偏移 &#x2F;&#x2F; 得到包含_objc_debug_taggedpointer_classes地址的page的基址，arm64架构中page大小为16kb。 &#x2F;&#x2F; 并将该page的基址存到寄存器X10中； adrp x10, _objc_debug_taggedpointer_classes@PAGE &#x2F;&#x2F; add 加 &#x2F;&#x2F; x10 &#x3D; x10 + _objc_debug_taggedpointer_classes@PAGEOFF（偏移量） &#x2F;&#x2F; 即计算出_objc_debug_taggedpointer_classes的地址，并存到寄存器X10中 add x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF &#x2F;&#x2F; ubfx 无符号位段提取（ubfx Xd, Xn, #lsb, #width。表示从Wn寄存器的第lsb位开始，提取width位到Wd寄存器，剩余高位用0填充） &#x2F;&#x2F; 从x0寄存器的第60位开始，提取4位到x11寄存器，剩余高位用0填充，即提取指针的最后四位（标记tagged pointer的位）存到x11寄存器 ubfx x11, x0, #60, #4 &#x2F;&#x2F; ldr 加载字到寄存器 &#x2F;&#x2F; lsl 逻辑或算术左移 &#x2F;&#x2F; x16 &#x3D; x10 + (x11&lt;&lt;3)， 获取taggedpointer标识位，并存到x16寄存器 ldr x16, [x10, x11, LSL #3] adrp x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE add x10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF cmp x10, x16 &#x2F;&#x2F; b.ne 判断上面cmp的值是不等于 执行标号，否则直接往下走 b.ne LGetIsaDone &#x2F;&#x2F; ext tagged adrp x10, _objc_debug_taggedpointer_ext_classes@PAGE add x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF ubfx x11, x0, #52, #8 ldr x16, [x10, x11, LSL #3] b LGetIsaDone&#x2F;&#x2F; SUPPORT_TAGGED_POINTERS#endifLReturnZero: &#x2F;&#x2F; x0 is already zero &#x2F;&#x2F; 1、首先先把 x1 清空，x0 这里是 self，已经是0，所以不需要清空 mov x1, #0 &#x2F;&#x2F; 2、清空 v 寄存器 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 ret END_ENTRY _objc_msgSend 主要有以下几步 【第一步】判断objc_msgSend方法的第一个参数receiver是否为空 判断receiver如果为空，则直接返回空，即LReturnZero； 如果支持tagged pointer对象，判断如果为tagged pointer对象，跳转至【第二步】 否则，如果receiver不为tagged pointer对象且不为空，从receiver中取出isa存入p13寄存器， 通过 GetClassFromIsa_p16中，arm64架构下通过 isa &amp; ISA_MASK 获取shiftcls位域的类信息，即class，GetClassFromIsa_p16的汇编实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&#x2F;&#x2F; .macro 汇编宏定义.macro GetClassFromIsa_p16 &#x2F;* src *&#x2F;#if SUPPORT_INDEXED_ISA&#x2F;&#x2F; mov指令是数据传送指令，用于将一个数据从源地址传送到目标地址，其特点是不破坏源地址单元的内容。&#x2F;&#x2F; 把传入的值src赋值给p16寄存器，p16 &#x3D; class &#x2F;&#x2F; Indexed isa mov p16, $0 &#x2F;&#x2F; optimistically set dst &#x3D; src&#x2F;&#x2F; # define ISA_INDEX_IS_NPI_BIT 0&#x2F;&#x2F; tbz 条件执行&#x2F;&#x2F; 判断p16寄存器中存储的class指针最后一位如果不为0，即如果是tagged pointer，则直接跳转到1，直接结束 tbz p16, #ISA_INDEX_IS_NPI_BIT, 1f &#x2F;&#x2F; done if not non-pointer isa&#x2F;&#x2F; adrp 计算指定的数据地址到当前pc寄存器值相对偏移 &#x2F;&#x2F; 得到包含_objc_indexed_classes地址的page的基址，arm64架构中page大小为16kb。 &#x2F;&#x2F; 并将该page的基址存到寄存器X10中； &#x2F;&#x2F; isa in p16 is indexed adrp x10, _objc_indexed_classes@PAGE&#x2F;&#x2F; x10 &#x3D; x10 + _objc_indexed_classes@PAGEOFF（_objc_indexed_classes在page中的偏移量），即计算出_objc_debug_taggedpointer_classes的地址，并存到寄存器X10中 add x10, x10, _objc_indexed_classes@PAGEOFF&#x2F;&#x2F; ubfx:有符号和无符号位域提取。 将一个寄存器中相邻的位复制到另一个寄存器的最低有效位，并用符号或零扩展到 32 位。&#x2F;&#x2F; 从p16的第ISA_INDEX_SHIFT位开始，提取 ISA_INDEX_BITS 位 到 p16寄存器，剩余的高位用0补充&#x2F;&#x2F; # define ISA_INDEX_SHIFT 2&#x2F;&#x2F; # define ISA_INDEX_BITS 15&#x2F;&#x2F; 从p16寄存器的第2位开始，提取15位到p16寄存器，剩余高位用0填充 ubfx p16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS &#x2F;&#x2F; extract index&#x2F;&#x2F; #define PTRSHIFT 3 &#x2F;&#x2F; 1&lt;&lt;PTRSHIFT &#x3D;&#x3D; PTRSIZE&#x2F;&#x2F; #define UXTP UXTX ldr p16, [x10, p16, UXTP #PTRSHIFT] &#x2F;&#x2F; load class from array1:&#x2F;&#x2F; 如果是64位#elif __LP64__ &#x2F;&#x2F; 64-bit packed isa&#x2F;&#x2F; p16 &#x3D; class &#x3D; isa &amp; ISA_MASK(位运算 &amp; 即获取isa中的shiftcls信息) and p16, $0, #ISA_MASK#else &#x2F;&#x2F; 32-bit raw isa mov p16, $0#endif&#x2F;&#x2F; 宏定义结束.endmacro 然后走到【第二步】 【第二步】获取isa完毕，调用CacheLookup NORMAL在缓存中查找方法。 CacheLookup源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&#x2F;&#x2F; 定义CacheLookup宏.macro CacheLookup &#x2F;&#x2F; ldp:从栈取&#x2F;存数据 &#x2F;&#x2F; #define CACHE (2 * __SIZEOF_POINTER__)，其中 __SIZEOF_POINTER__表示pointer的大小 ，即 2*8 &#x3D; 16 &#x2F;&#x2F; p11 &#x3D; mask|buckets，从x16（即isa）中平移16字节，获取cache地址。isa距离cache 正好16字节：isa（8字节）+ superClass（8字节） &#x2F;&#x2F; 从cache中分别取出 buckets 和 occupied|mask 存入 p10（存储buckets） 和 p11（存储occupied|mask） &#x2F;&#x2F; p1 &#x3D; SEL, p16 &#x3D; isa ldp p10, p11, [x16, #CACHE] &#x2F;&#x2F; p10 &#x3D; buckets, p11 &#x3D; occupied|mask#if !__LP64__ and w11, w11, 0xffff &#x2F;&#x2F; p11 &#x3D; mask#endif &#x2F;&#x2F; and 按位“与”操作，key &amp; mask得到cache_hash and w12, w1, w11 &#x2F;&#x2F; x12 &#x3D; _cmd &amp; mask add p12, p10, p12, LSL #(1+PTRSHIFT) &#x2F;&#x2F; p12 &#x3D; buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT)) &#x2F;&#x2F; 从x12（即p12）中取出 bucket 分别将imp和sel 存入 p17（存储imp） 和 p9（存储sel） ldp p17, p9, [x12] &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket&#x2F;&#x2F; 比较 sel 与 p1（传入的参数cmd）1: cmp p9, p1 &#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd) &#x2F;&#x2F; 如果不相等，即没有找到，跳转至 2f b.ne 2f &#x2F;&#x2F; scan more &#x2F;&#x2F; 如果相等，即缓存命中，执行cacheHit直接调用或返回imp CacheHit $0 &#x2F;&#x2F; call or return imp 2: &#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket &#x2F;&#x2F; 如果一直都找不到，因为是normal，跳转至__objc_msgSend_uncached CheckMiss $0 &#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0 &#x2F;&#x2F; 判断p12（当前的bucket）是否 是 p10（buckets数组第一个元素，） cmp p12, p10 &#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets &#x2F;&#x2F; 如果想等，跳转至 3f b.eq 3f &#x2F;&#x2F; 从x12（即p12 buckets首地址）- 实际需要平移的内存大小BUCKET_SIZE，得到得到第二个bucket元素，imp-sel分别存入p17-p9，即向前查找 ldp p17, p9, [x12, #-BUCKET_SIZE]! &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket &#x2F;&#x2F; 跳转至第1步，继续对比 sel 与 cmd b 1b &#x2F;&#x2F; loop3: &#x2F;&#x2F; wrap: p12 &#x3D; first bucket, w11 &#x3D; mask &#x2F;&#x2F; mask左移4位，直接定位到buckets的最后一个元素，缓存查找顺序是向前查找 add p12, p12, w11, UXTW #(1+PTRSHIFT) &#x2F;&#x2F; p12 &#x3D; buckets + (mask &lt;&lt; 1+PTRSHIFT) &#x2F;&#x2F; Clone scanning loop to miss instead of hang when cache is corrupt. &#x2F;&#x2F; The slow path may detect any corruption and halt later. ldp p17, p9, [x12] &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket1: cmp p9, p1 &#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd) b.ne 2f &#x2F;&#x2F; scan more CacheHit $0 &#x2F;&#x2F; call or return imp 2: &#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket &#x2F;&#x2F; 判断p12（当前遍历到的bucket）是否等于 p10（buckets数组第一个元素）即前面已经没有了 CheckMiss $0 &#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0 cmp p12, p10 &#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets b.eq 3f &#x2F;&#x2F; 偏移获取前一个bucket，并取出imp和sel分别存入p17、p9，即向前查找 ldp p17, p9, [x12, #-BUCKET_SIZE]! &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket &#x2F;&#x2F; 跳转至第1步，继续对比 sel 与 cmd b 1b &#x2F;&#x2F; loop3: &#x2F;&#x2F; double wrap &#x2F;&#x2F; 跳转至JumpMiss 因为是normal ，跳转至__objc_msgSend_uncached JumpMiss $0 .endmacro 主要分为以下几步 【第一步】通过isa首地址平移16字节（因为在objc_class中，首地址距离cache正好16字节，即isa首地址 占8字节，superClass占8字节），获取cahce，并将cache中的buckets存放到p10寄存器中，将cache中的occupied|mask存放到p11寄存器中 【第二步】由mask根据哈希算法计算出下标 将objc_msgSend的参数p1（即第二个参数_cmd）和p11中存放的msak进行&amp;运算，得到需要查找存储sel-imp的bucket下标index，即p12 = index = _cmd &amp; mask。 【第三步】根据所得的哈希下标index 和 buckets首地址，取出哈希下标对应的bucket，并存放到p12寄存器中p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT)) 其中PTRSHIFT等于3，左移4位（即2^4 = 16字节）即是一个bucket实际占用的大小,结构体bucket_t中sel占8字节，imp占8字节 根据计算的哈希下标index 乘以单个bucket占用的内存大小，得到bucket相当于buckets首地址的偏移量 通过首地址 + 实际偏移量，获取哈希下标index对应的bucket 【第四步】根据获取的bucket，取出其中的imp和sel分别存入p17和p9寄存器 【第五步】遍历buckets查找缓存的方法 比较sel和传入的参数cmd是否相等，如果不相等，即没找到，执行下一步，否则如果相等，即缓存命中，执行CacheHit函数返回imp 123456789101112131415161718&#x2F;&#x2F; CacheHit: x17 &#x3D; cached IMP, x12 &#x3D; address of cached IMP, x1 &#x3D; SEL.macro CacheHit.if $0 &#x3D;&#x3D; NORMAL TailCallCachedImp x17, x12, x1 &#x2F;&#x2F; authenticate and call imp.elseif $0 &#x3D;&#x3D; GETIMP mov p0, p17 cbz p0, 9f &#x2F;&#x2F; don&#39;t ptrauth a nil imp AuthAndResignAsIMP x0, x12, x1 &#x2F;&#x2F; authenticate imp and re-sign as IMP9: ret &#x2F;&#x2F; return IMP.elseif $0 &#x3D;&#x3D; LOOKUP &#x2F;&#x2F; No nil check for ptrauth: the caller would crash anyway when they &#x2F;&#x2F; jump to a nil IMP. We don&#39;t care if that jump also fails ptrauth. AuthAndResignAsIMP x17, x12, x1 &#x2F;&#x2F; authenticate imp and re-sign as IMP ret &#x2F;&#x2F; return imp via x17.else.abort oops.endif.endmacro 这里传入的$0是normal会调用TailCallCachedImp执行imp 12345.macro TailCallCachedImp &#x2F;&#x2F; $0 &#x3D; cached imp, $1 &#x3D; address of cached imp, $2 &#x3D; SEL eor $1, $1, $2 &#x2F;&#x2F; mix SEL into ptrauth modifier brab $0, $1.endmacro 调用CheckMiss，判断是否一直找不到（bucket-&gt;sel == 0），即遇到空通，说明cache中没有该method。因此可见cache解决hash冲突的方式为开放寻址法（线性探测）。 123456789101112.macro CheckMiss &#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0.if $0 &#x3D;&#x3D; GETIMP cbz p9, LGetImpMiss.elseif $0 &#x3D;&#x3D; NORMAL cbz p9, __objc_msgSend_uncached.elseif $0 &#x3D;&#x3D; LOOKUP cbz p9, __objc_msgLookup_uncached.else.abort oops.endif.endmacro 因为$0是normal，如果一直都找不到，会跳转至__objc_msgSend_uncached，即进入慢速查找流程。否则执行下一步 如果根据index获取的bucket 等于 buckets的第一个元素，则将当前bucket设置为buckets的最后一个元素（通过buckets首地址+mask*16（等同于左移4位）直接定位到buckets的最后一个元素），并读取bucket的imp和sel`分别存入p17和p9寄存器，然后执行【第六步】；否则执行下一步 通过地址偏移，得到前一个bucket元素，并读取bucket的imp和sel`分别存入p17和p9寄存器，然后重复1 【第六步】第二次遍历查找：重复【第五步】的操作，与【第五步】中唯一区别是，如果当前的bucket还是等于 buckets的第一个元素，则直接跳转至JumpMiss， 1234567891011.macro JumpMiss.if $0 &#x3D;&#x3D; GETIMP b LGetImpMiss.elseif $0 &#x3D;&#x3D; NORMAL b __objc_msgSend_uncached.elseif $0 &#x3D;&#x3D; LOOKUP b __objc_msgLookup_uncached.else.abort oops.endif.endmacro 此时的$0是normal，也是直接跳转至__objc_msgSend_uncached，即进入慢速查找流程。 __objc_msgSend_uncached源码分析__objc_msgSend_uncached源码实现如下 12345678910STATIC_ENTRY __objc_msgSend_uncachedUNWIND __objc_msgSend_uncached, FrameWithNoSaves&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION&#x2F;&#x2F; Out-of-band p16 is the class to searchMethodTableLookupTailCallFunctionPointer x17END_ENTRY __objc_msgSend_uncached 该方法中主要调用了MethodTableLookup方法。 123456789101112131415161718192021222324252627282930313233343536373839404142.macro MethodTableLookup &#x2F;&#x2F; push frame SignLR stp fp, lr, [sp, #-16]! mov fp, sp &#x2F;&#x2F; save parameter registers: x0..x8, q0..q7 sub sp, sp, #(10*8 + 8*16) stp q0, q1, [sp, #(0*16)] stp q2, q3, [sp, #(2*16)] stp q4, q5, [sp, #(4*16)] stp q6, q7, [sp, #(6*16)] stp x0, x1, [sp, #(8*16+0*8)] stp x2, x3, [sp, #(8*16+2*8)] stp x4, x5, [sp, #(8*16+4*8)] stp x6, x7, [sp, #(8*16+6*8)] str x8, [sp, #(8*16+8*8)] &#x2F;&#x2F; receiver and selector already in x0 and x1 mov x2, x16 bl __class_lookupMethodAndLoadCache3 &#x2F;&#x2F; IMP in x0 mov x17, x0 &#x2F;&#x2F; restore registers and return ldp q0, q1, [sp, #(0*16)] ldp q2, q3, [sp, #(2*16)] ldp q4, q5, [sp, #(4*16)] ldp q6, q7, [sp, #(6*16)] ldp x0, x1, [sp, #(8*16+0*8)] ldp x2, x3, [sp, #(8*16+2*8)] ldp x4, x5, [sp, #(8*16+4*8)] ldp x6, x7, [sp, #(8*16+6*8)] ldr x8, [sp, #(8*16+8*8)] mov sp, fp ldp fp, lr, [sp], #16 AuthenticateLR.endmacro MethodTableLookup 可以算是个接口层宏，主要用于保存环境与准备参数，来调用 __class_lookupMethodAndLoadCache3函数（在objc-class-new.mm中）。 1234567891011/************************************************************************ _class_lookupMethodAndLoadCache.* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().* This lookup avoids optimistic cache scan because the dispatcher * already tried that.**********************************************************************/IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)&#123; return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/);&#125; __class_lookupMethodAndLoadCache3函数也是个接口层（C编写），此函数提供相应参数配置，实际功能在lookUpImpOrForward函数中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154/************************************************************************ lookUpImpOrForward.* The standard IMP lookup. * initialize==NO tries to avoid +initialize (but sometimes fails)* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)* Most callers should use initialize==YES and cache==YES.* inst is an instance of cls or a subclass thereof, or nil if none is known. * If cls is an un-initialized metaclass then a non-nil inst is faster.* May return _objc_msgForward_impcache. IMPs destined for external use * must be converted to _objc_msgForward or _objc_msgForward_stret.* If you don't want forwarding at all, use lookUpImpOrNil() instead.**********************************************************************/IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = nil; bool triedResolver = NO; // runtimeLock 本质上是对 Darwin 提供的线程读写锁 pthread_rwlock_t 的一层封装，提供了一些便捷的方法。 runtimeLock.assertUnlocked(); // Optimistic cache lookup // 如果使用缓存（cache 参数为 YES），那就调用 cache_getImp 方法从缓存查找 IMP。cache_getImp 是用汇编语言写的，也可以在 objc-msg-arm64.s 找到，其依然用了前文中说过的 CacheLookup 宏。因为 _class_lookupMethodAndLoadCache3 调用 lookUpImpOrForward 时 cache 参数为 NO，这步直接略过。 if (cache) &#123; imp = cache_getImp(cls, sel); if (imp) return imp; &#125; // runtimeLock is held during isRealized and isInitialized checking // to prevent races against concurrent realization. // runtimeLock is held during method search to make // method-lookup + cache-fill atomic with respect to method addition. // Otherwise, a category could be added but ignored indefinitely because // the cache was re-filled with the old value after the cache flush on // behalf of the category. runtimeLock.lock(); // 判断是否是一个已知的类：判断当前类是否是已经被认可的类，即已经加载的类。 checkIsKnownClass(cls); // 判断类是否已经Realized，如果没有，需要先Realized if (!cls-&gt;isRealized()) &#123; cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock); // runtimeLock may have been dropped but is now locked again &#125; // 判断如果入参传入的initialize为true，且类未实例化，需要先实例化 if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; cls = initializeAndLeaveLocked(cls, inst, runtimeLock); // runtimeLock may have been dropped but is now locked again // If sel == initialize, class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won't happen. 2778172 &#125; retry: // runtimeLock 上锁 runtimeLock.assertLocked(); // Try this class's cache. // 调用 cache_getImp 方法从缓存查找 IMP。 imp = cache_getImp(cls, sel); // 如果找到直接返回imp。 if (imp) goto done; // Try this class's method lists. &#123; // 在当前类中的方法列表（method list）中进行查找，也就是根据 selector 查找 Method Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123; // 如果在当前类的方法列表成功找到了Method// 获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。 log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); // 将找到的IMP直接返回imp imp = meth-&gt;imp; goto done; &#125; &#125; // 如果在当前类中的方法列表（method list）中没有找到Method，尝试在逐级在父类的缓存和方法列表中查找 // Try superclass caches and method lists. &#123; unsigned attempts = unreasonableClassCount(); // 在继承层级中递归向父类中查找，和上一步类似，也是先查找缓存，缓存没中就查找方法列表 for (Class curClass = cls-&gt;superclass; curClass != nil; curClass = curClass-&gt;superclass) &#123; // Halt if there is a cycle in the superclass chain. if (--attempts == 0) &#123; _objc_fatal(\"Memory corruption in class list.\"); &#125; // Superclass cache. // 调用 cache_getImp 方法从父类的缓存查找 IMP。 imp = cache_getImp(curClass, sel); if (imp) &#123; // 如果找到的imp不是_objc_msgForward_impcache if (imp != (IMP)_objc_msgForward_impcache) &#123; // Found the method in a superclass. Cache it in this class. // 将父类链中查找到的imp并填充到当前类的缓存中。 log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; &#125; else &#123; // 如果找到的imp是_objc_msgForward_impcache，退出循环 // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; &#125; &#125; // 在当前父类中的方法列表（method list）中进行查找，也就是根据 selector 查找到 Method 后，获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。 // Superclass method list. Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done; &#125; &#125; &#125; // No implementation found. Try method resolver once. // 参数 resolver 为 YES且是第一次执行到这里的时侯，进行动态方法解析 if (resolver &amp;&amp; !triedResolver) &#123; // 释放锁 runtimeLock.unlock(); // 间接地发送 +resolveInstanceMethod 或 +resolveClassMethod 消息。函数中实现了方法解析逻辑。如果 cls 是元类则会发送 +resolveClassMethod，然后根据 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 函数的结果来判断是否发送 +resolveInstanceMethod；如果不是元类，则只需要发送 +resolveInstanceMethod 消息。这里调用 +resolveInstanceMethod 或 +resolveClassMethod 时再次用到了 objc_msgSend，而且第三个参数正是传入 lookUpImpOrForward 的那个 sel。在发送方法解析消息之后还会调用 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 来判断是否已经添加上 sel 对应的 IMP 了，打印出结果。 resolveMethod(cls, sel, inst); // 读入锁加锁 runtimeLock.lock(); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; &#125; // No implementation found, and method resolver didn't help. // Use forwarding. // 将 _objc_msgForward_impcache 当做 IMP 并写入缓存 imp = (IMP)_objc_msgForward_impcache; cache_fill(cls, sel, imp, inst); done: runtimeLock.unlock(); return imp;&#125; 首先了lookUpImpOrForward方法，对 assert 进行 unlock： 1runtimeLock.assertUnlocked(); runtimeLock 本质上是对 Darwin 提供的线程读写锁 pthread_rwlock_t 的一层封装，提供了一些便捷的方法。 接着，lookUpImpOrForward做了如下两件事： 如果使用缓存（cache 参数为 YES），那就调用 cache_getImp 方法从缓存查找 IMP。cache_getImp 是用汇编语言写的，实现如下 12345678910STATIC_ENTRY _cache_getImp GetClassFromIsa_p16 p0 CacheLookup GETIMPLGetImpMiss: mov p0, #0 ret END_ENTRY _cache_getImp 其依然用了之前说过的 CacheLookup 宏。因为 _class_lookupMethodAndLoadCache3 调用 lookUpImpOrForward 时 cache 参数为 NO，这步直接略过。 如果是第一次用到这个类且 initialize 参数为 YES（initialize &amp;&amp; !cls-&gt;isInitialized()），需要进行初始化工作，也就是开辟一个用于读写数据的空间。先对 runtimeLock 加锁，然后调用 cls 的 initialize 方法，并将cls-&gt;isInitialized()置为true。 然后，会继续在类的继承体系中查找： 考虑到运行时类中的方法可能会增加，需要先加锁，使得方法查找和缓存填充成为原子操作。 1runtimeLock.assertLocked(); 之后的逻辑如下： 查找当前类中的缓存，跟之前一样，使用 cache_getImp 汇编程序入口。如果命中缓存获取到了 IMP，则直接跳到第 6 步；否则执行下一步。 在当前类的方法列表（method list）中进行查找，也就是根据 selector 查找到 Method 后，获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。查找过程如下： 首先调用 getMethodNoSuper_nolock()方法， 1234567891011121314151617181920static method_t *getMethodNoSuper_nolock(Class cls, SEL sel)&#123; runtimeLock.assertLocked(); assert(cls-&gt;isRealized()); // fixme nil cls? // fixme nil sel? for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(), end = cls-&gt;data()-&gt;methods.endLists(); mlists != end; ++mlists) &#123; method_t *m = search_method_list(*mlists, sel); if (m) return m; &#125; return nil;&#125; 在getMethodNoSuper_nolock方法中，会遍历methodList。遍历过程中会调用search_method_list函数。 1234567891011121314151617181920212223242526272829303132/************************************************************************ getMethodNoSuper_nolock* fixme* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static method_t *search_method_list(const method_list_t *mlist, SEL sel)&#123; int methodListIsFixedUp = mlist-&gt;isFixedUp(); int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t); if (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, 1)) &#123; return findMethodInSortedMethodList(sel, mlist); &#125; else &#123; // Linear search of unsorted method list for (auto&amp; meth : *mlist) &#123; if (meth.name == sel) return &amp;meth; &#125; &#125;#if DEBUG // sanity-check negative results if (mlist-&gt;isFixedUp()) &#123; for (auto&amp; meth : *mlist) &#123; if (meth.name == sel) &#123; _objc_fatal(\"linear search worked when binary search did not\"); &#125; &#125; &#125;#endif return nil;&#125; 在search_method_list函数中，会去判断当前methodList是否有序，如果有序，会调用findMethodInSortedMethodList方法，这个方法里面的实现是一个二分搜索。 123456789101112131415161718192021222324252627282930313233343536373839static method_t *findMethodInSortedMethodList(SEL key, const method_list_t *list)&#123; assert(list); const method_t * const first = &amp;list-&gt;first; const method_t *base = first; const method_t *probe; uintptr_t keyValue = (uintptr_t)key; uint32_t count; // base相当于low，count是max，probe是middle for (count = list-&gt;count; count != 0; count &gt;&gt;= 1) &#123; // probe = 从首地址 + count/2 probe = base + (count &gt;&gt; 1); uintptr_t probeValue = (uintptr_t)probe-&gt;name; // 如果查找的sel == 中间位置（probe）的probeValue if (keyValue == probeValue) &#123; // `probe` is a match. // Rewind looking for the *first* occurrence of this value. // This is required for correct category overrides. // -- while 平移 -- 排除分类重名方法 // 循环在methodlist中查找第一个满足(keyValue == probeValue)的元素。因为在methodlist中分类方法会插入在本类方法之前 while (probe &gt; first &amp;&amp; keyValue == (uintptr_t)probe[-1].name) &#123; probe--; &#125; return (method_t *)probe; &#125; // 如果keyValue 大于 probeValue，就往probe即中间位置的右边查找 if (keyValue &gt; probeValue) &#123; base = probe + 1; count--; &#125; &#125; return nil;&#125; 如果成功查找到 Method 对象，则调用log_and_fill_cache()，将获取到的 Method 中的 IMP（也就是 method_imp 属性），填充到缓存中， 1234567891011121314151617181920/************************************************************************ log_and_fill_cache* Log this method call. If the logger permits it, fill the method cache.* cls is the method whose cache should be filled. * implementer is the class that owns the implementation in question.**********************************************************************/static voidlog_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)&#123;#if SUPPORT_MESSAGE_LOGGING if (objcMsgLogEnabled) &#123; bool cacheIt = logMessageSend(implementer-&gt;isMetaClass(), cls-&gt;nameForLogging(), implementer-&gt;nameForLogging(), sel); if (!cacheIt) return; &#125;#endif cache_fill (cls, sel, imp, receiver);&#125; 忽略debug的log逻辑，方法仅仅是调用cache_fill。 12345678910void cache_fill(Class cls, SEL sel, IMP imp, id receiver)&#123;#if !DEBUG_TASK_THREADS mutex_locker_t lock(cacheUpdateLock); cache_fill_nolock(cls, sel, imp, receiver);#else _collecting_in_critical(); return;#endif&#125; cache_fill又会来到cache_fill_nolock，这个函数的作用是将方法的SEL和IMP写入_buckets，同时更新_mask和_occupied。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)&#123; cacheUpdateLock.assertLocked(); // 如果类未初始化，直接return // Never cache before +initialize is done if (!cls-&gt;isInitialized()) return; // Make sure the entry wasn't added to the cache by some other thread // before we grabbed the cacheUpdateLock. // 在获取cacheUpdateLock之前，确保其他线程没有将该方法写入缓存 if (cache_getImp(cls, sel)) return; // 获取 cls 的 cache_t指针 cache_t *cache = getCache(cls); // Use the cache as-is if it is less than 3/4 full // newOccupied为新的方法缓存数，等于 当前方法缓存数+1 mask_t newOccupied = cache-&gt;occupied() + 1; // 获取当前cache_t的总容量，为 mask+1 mask_t capacity = cache-&gt;capacity(); if (cache-&gt;isConstantEmptyCache()) &#123; // 当第一次调用类的实例方法时（如`init`） // Cache is read-only. Replace it. cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE); &#125; else if (newOccupied &lt;= capacity / 4 * 3) &#123; // 新的方法缓存数 不大于 总容量的3/4，按原样使用，无需扩容 // Cache is less than 3/4 full. Use it as-is. &#125; else &#123; // Cache is too full. Expand it. // 新的方法缓存数 大于 总容量的3/4，需要扩容 cache-&gt;expand(); &#125; // Scan for the first unused slot and insert there. // There is guaranteed to be an empty slot because the // minimum size is 4 and we resized at 3/4 full. // 根据sel获取bucket，此bucket的sel一般为0（说明这个位置还没缓存方法）， // 也可能与实参sel相等（hash冲突，可能性很低） bucket_t *bucket = cache-&gt;find(sel, receiver); // 当且仅当bucket的sel为0时，执行_occupied++ if (bucket-&gt;sel() == 0) cache-&gt;incrementOccupied(); // 更新bucket的sel和imp bucket-&gt;set&lt;Atomic&gt;(sel, imp);&#125; 从上面的源码不难看出，cache_fill_nolock主要是cache_t缓存方法的调度中心，在这里会： 决定执行_buckets的哪一种缓存策略（初始化后缓存、直接缓存、扩容后缓存，三者取一）； 然后通过方法的sel找到一个bucket，并更新这个bucket的sel和imp。（如果这个bucket的sel为0，说明是个空桶，正好可以缓存方法，于是执行_occupied++）。 缓存填充完成，然后就直接跳到第 6 步；否则如果当前类的method list没有找到method，则执行下一步。 在继承层级中递归向父类中查找，情况跟上一步类似，也是先查找缓存，缓存没中就查找方法列表。这里跟上一步不同的地方在于缓存策略，有个 _objc_msgForward_impcache 汇编程序入口作为缓存中消息转发的标记。也就是说如果在缓存中找到了 IMP，但如果发现其内容是 _objc_msgForward_impcache，那就终止在类的继承层级中递归查找，进入下一步；否则跳到第 7 步。 当传入 lookUpImpOrForward 的参数 resolver 为 YES 并且是第一次进入第 5 步时，时进入动态方法解析；否则进入下一步。这步消息转发前的最后一次机会。此时释放读入锁（runtimeLock.unlock()），接着调用resolveMethod()进行动态方法解析 1234567891011121314151617181920212223242526/************************************************************************ resolveMethod* Call +resolveClassMethod or +resolveInstanceMethod.* Returns nothing; any result would be potentially out-of-date already.* Does not check if the method already exists.**********************************************************************/static void resolveMethod(Class cls, SEL sel, id inst)&#123; runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); if (! cls-&gt;isMetaClass()) &#123; // try [cls resolveInstanceMethod:sel] resolveInstanceMethod(cls, sel, inst); &#125; else &#123; // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; resolveInstanceMethod(cls, sel, inst); &#125; &#125;&#125; 该方法中会判断，如果 cls 是元类则会发送 +resolveClassMethod。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/************************************************************************ resolveClassMethod* Call +resolveClassMethod, looking for a method to be added to class cls.* cls should be a metaclass.* Does not check if the method already exists.**********************************************************************/static void resolveClassMethod(Class cls, SEL sel, id inst)&#123; runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); assert(cls-&gt;isMetaClass()); if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; // Resolver not implemented. return; &#125; Class nonmeta; &#123; mutex_locker_t lock(runtimeLock); nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst); // +initialize path should have realized nonmeta already if (!nonmeta-&gt;isRealized()) &#123; _objc_fatal(\"nonmeta class %s (%p) unexpectedly not realized\", nonmeta-&gt;nameForLogging(), nonmeta); &#125; &#125; BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(nonmeta, SEL_resolveClassMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); if (resolved &amp;&amp; PrintResolving) &#123; if (imp) &#123; _objc_inform(\"RESOLVE: method %c[%s %s] \" \"dynamically resolved to %p\", cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); &#125; else &#123; // Method resolver didn't add anything? _objc_inform(\"RESOLVE: +[%s resolveClassMethod:%s] returned YES\" \", but no new implementation of %c[%s %s] was found\", cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); &#125; &#125;&#125; 然后根据 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 函数的结果来判断是否发送 +resolveInstanceMethod 12345678910111213141516171819202122232425262728293031323334353637383940414243/************************************************************************ resolveInstanceMethod* Call +resolveInstanceMethod, looking for a method to be added to class cls.* cls may be a metaclass or a non-meta class.* Does not check if the method already exists.**********************************************************************/static void resolveInstanceMethod(Class cls, SEL sel, id inst)&#123; runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; // Resolver not implemented. return; &#125; BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(cls, SEL_resolveInstanceMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveInstanceMethod adds to self a.k.a. cls IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); if (resolved &amp;&amp; PrintResolving) &#123; if (imp) &#123; _objc_inform(\"RESOLVE: method %c[%s %s] \" \"dynamically resolved to %p\", cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); &#125; else &#123; // Method resolver didn't add anything? _objc_inform(\"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES\" \", but no new implementation of %c[%s %s] was found\", cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); &#125; &#125;&#125; 如果不是元类，则只需要发送 +resolveInstanceMethod 消息。这里调用 +resolveInstanceMethod 或 +resolveClassMethod 时再次用到了 objc_msgSend，而且第三个参数正是传入 lookUpImpOrForward 的那个 sel。在发送方法解析消息之后还会调用 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 来判断是否已经添加上 sel 对应的 IMP 了，打印出结果。 lookUpImpOrNil 跟 lookUpImpOrForward 的功能很相似，只是将 lookUpImpOrForward 实现中的 _objc_msgForward_impcache 替换成了 nil: 1234567891011/************************************************************************ lookUpImpOrNil.* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache**********************************************************************/IMP lookUpImpOrNil(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver); if (imp == _objc_msgForward_impcache) return nil; else return imp;&#125; 此时不仅没查找到 IMP，动态方法解析也不奏效，只能将 _objc_msgForward_impcache 当做 IMP 并写入缓存。这也就是之前第 3 步中为何查找到 _objc_msgForward_impcache 就表明了要进入消息转发了。 解锁 runtimeLock.unlock()，并将之前找到的 IMP 返回。。 消息转发前面说到如果没有找到方法，会将 _objc_msgForward_impcache 当成imp写入缓存。_objc_msgForward_impcache 只是个内部的函数指针，只存储于类的方法缓存中，需要被转化为 _objc_msgForward 和 _objc_msgForward_stret 才能被外部调用。转换的方式也很简单，就是增加个静态入口 __objc_msgForward_impcache。 _objc_msgForward_impcache 在objc-msg-arm64.s中汇编的实现如下： 123456STATIC_ENTRY __objc_msgForward_impcache&#x2F;&#x2F; No stret specialization.b __objc_msgForwardEND_ENTRY __objc_msgForward_impcache _objc_msgForward_impcache只是入口。实际的实现函数是 objc_msgForward 1234567ENTRY __objc_msgForwardadrp x17, __objc_forward_handler@PAGEldr p17, [x17, __objc_forward_handler@PAGEOFF]TailCallFunctionPointer x17END_ENTRY __objc_msgForward objc_msgForward 函数中会调用__objc_forward_handler函数。 12345678910// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel)&#123; _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \" \"(no message forward handler is installed)\", class_isMetaClass(object_getClass(self)) ? '+' : '-', object_getClassName(self), sel_getName(sel), self);&#125;void *_objc_forward_handler = (void*)objc_defaultForwardHandler; 在Objc2.0中会有一个objc_defaultForwardHandler，看源码实现我们可以看到熟悉的语句。当我们给一个对象发送一个没有实现的方法的时候，如果其父类也没有这个方法，则会崩溃，报错信息类似于这样：unrecognized selector sent to instance，然后接着会跳出一些堆栈信息。这些信息就是从这里而来。 123456789101112131415161718192021222324252627282930313233343536373839404142/************************************************************************ objc_setForwardHandler**********************************************************************/#if !__OBJC2__// Default forward handler (nil) goes to forward:: dispatch.void *_objc_forward_handler = nil;void *_objc_forward_stret_handler = nil;#else// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel)&#123; _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \" \"(no message forward handler is installed)\", class_isMetaClass(object_getClass(self)) ? '+' : '-', object_getClassName(self), sel_getName(sel), self);&#125;void *_objc_forward_handler = (void*)objc_defaultForwardHandler;#if SUPPORT_STRETstruct stret &#123; int i[100]; &#125;;__attribute__((noreturn)) struct stret objc_defaultForwardStretHandler(id self, SEL sel)&#123; objc_defaultForwardHandler(self, sel);&#125;void *_objc_forward_stret_handler = (void*)objc_defaultForwardStretHandler;#endif#endifvoid objc_setForwardHandler(void *fwd, void *fwd_stret)&#123; _objc_forward_handler = fwd;#if SUPPORT_STRET _objc_forward_stret_handler = fwd_stret;#endif&#125; 要设置转发只要重写_objc_forward_handler方法即可。在objc_setForwardHandler方法中，可以设置ForwardHandler。 当你想要弄清objc_setForwardHandler的调用，以及之后的消息转发调用栈的时候，会发现在objc4-756.2找不到源码。这是因为objc_setForwardHandler的实现是在 Core Foundation（CoreFoundation.framework）中。虽然 CF 是开源的，但是苹果在这里做了点手脚。关于objc_setForwardHandler的调用，以及之后的消息转发调用栈的问题，需要用到逆向的知识。推荐大家看这篇文章就会明白其中的原理。 Objective-C 消息发送与转发机制原理iOS会在 CF runtime 连接到进程时初始化调用__CFInitialize() 函数，把 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 作为参数调用 objc_setForwardHandler 方法。 从函数调用栈可以看出 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 这两个 Forward Handler 做了啥： 122021-09-05 21:05:39.018585+0800 Test[46006:16033328] -[Person eat]: unrecognized selector sent to instance 0x600000db81002021-09-05 21:05:39.023782+0800 Test[46006:16033328] *** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[Person eat]: unrecognized selector sent to instance 0x600000db8100&#39;*** First throw call stack:( 0 CoreFoundation 0x00007fff23c7127e __exceptionPreprocess + 350 1 libobjc.A.dylib 0x00007fff513fbb20 objc_exception_throw + 48 2 CoreFoundation 0x00007fff23c91fd4 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132 3 CoreFoundation 0x00007fff23c75c4c ___forwarding___ + 1436 4 CoreFoundation 0x00007fff23c77f78 _CF_forwarding_prep_0 + 120 5 Test 0x000000010ba3e226 main + 54 6 libdyld.dylib 0x00007fff5227ec25 start + 1)libc++abi.dylib: terminating with uncaught exception of type NSException 这个日志场景熟悉得不能再熟悉了，可以看出 _CF_forwarding_prep_0 函数调用了 ___forwarding___ 函数，接着又调用了 doesNotRecognizeSelector 方法，最后抛出异常。 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 函数都调用了 ___forwarding___，只是传入参数不同。 消息转发的逻辑几乎都写在 ___forwarding___ 函数中了，实现比较复杂，反编译出的伪代码也不是很直观。Objective-C 消息发送与转发机制原理 的结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485int __forwarding__(void *frameStackPointer, int isStret) &#123; id receiver = *(id *)frameStackPointer; SEL sel = *(SEL *)(frameStackPointer + 8); const char *selName = sel_getName(sel); Class receiverClass = object_getClass(receiver); // 调用 forwardingTargetForSelector: if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123; id forwardingTarget = [receiver forwardingTargetForSelector:sel]; if (forwardingTarget &amp;&amp; forwarding != receiver) &#123; if (isStret == 1) &#123; int ret; objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...); return ret; &#125; return objc_msgSend(forwardingTarget, sel, ...); &#125; &#125; // 僵尸对象 const char *className = class_getName(receiverClass); const char *zombiePrefix = \"_NSZombie_\"; size_t prefixLen = strlen(zombiePrefix); // 0xa if (strncmp(className, zombiePrefix, prefixLen) == 0) &#123; CFLog(kCFLogLevelError, @\"*** -[%s %s]: message sent to deallocated instance %p\", className + prefixLen, selName, receiver); &lt;breakpoint-interrupt&gt; &#125; // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123; NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel]; if (methodSignature) &#123; BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct; if (signatureIsStret != isStret) &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'. Signature thinks it does%s return a struct, and compiler thinks it does%s.\", selName, signatureIsStret ? \"\" : not, isStret ? \"\" : not); &#125; if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123; NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer]; [receiver forwardInvocation:invocation]; void *returnValue = NULL; [invocation getReturnValue:&amp;value]; return returnValue; &#125; else &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message\", receiver, className); return 0; &#125; &#125; &#125; SEL *registeredSel = sel_getUid(selName); // selector 是否已经在 Runtime 注册过 if (sel != registeredSel) &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort\", sel, selName, registeredSel); &#125; // doesNotRecognizeSelector else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123; [receiver doesNotRecognizeSelector:sel]; &#125; else &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort\", receiver, className); &#125; // The point of no return. kill(getpid(), 9);&#125; 这么一大坨代码就是整个消息转发路径的逻辑，概括如下： 先调用 forwardingTargetForSelector 方法获取新的 target 作为 receiver 重新执行 selector，如果返回的内容不合法（为 nil 或者跟旧 receiver 一样），那就进入第二步。 调用 methodSignatureForSelector 获取方法签名后，判断返回类型信息是否正确，再调用 forwardInvocation 执行 NSInvocation 对象，并将结果返回。如果对象没实现 methodSignatureForSelector 方法，进入第三步。 调用 doesNotRecognizeSelector 方法。 doesNotRecognizeSelector 之前其实还有个判断 selector 在 Runtime 中是否注册过的逻辑，但在我们正常发消息的时候不会出此问题。但如果手动创建一个 NSInvocation 对象并调用 invoke，并将第二个参数设置成一个不存在的 selector，那就会导致这个问题，并输入日志 “does not match selector known to Objective C runtime”。较真儿的读者可能会有疑问：何这段逻辑判断干脆用不到却还存在着？难道除了 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 函数还有其他函数也调用 ___forwarding___ 么？莫非消息转发还有其他路径？其实并不是！原因是 ___forwarding___ 调用了 ___invoking___ 函数，所以上面的伪代码直接把 ___invoking___ 函数的逻辑也『翻译』过来了。除了 ___forwarding___ 函数，以下方法也会调用___invoking___ 函数: 123-[NSInvocation invoke]-[NSInvocation invokeUsingIMP:]-[NSInvocation invokeSuper] doesNotRecognizeSelector 方法其实在 libobj.A.dylib 中已经废弃了，而是在 CF 框架中实现，而且也不是开源的。从函数调用栈可以发现 doesNotRecognizeSelector 之后会抛出异常，而 Runtime 中废弃的实现只是打日志后直接杀掉进程（__builtin_trap()）。下面是 CF 中实现的伪代码： 123456789101112131415161718192021222324void -[NSObject doesNotRecognizeSelector:](void * self, void * _cmd, void * arg2) &#123; r14 = ___CFFullMethodName([self class], self, arg2); _CFLog(0x3, @\"%@: unrecognized selector sent to instance %p\", r14, self, r8, r9, stack[2048]); rbx = _CFMakeCollectable(_CFStringCreateWithFormat(___kCFAllocatorSystemDefault, 0x0, @\"%@: unrecognized selector sent to instance %p\")); if (*(int8_t *)___CFOASafe != 0x0) &#123; ___CFRecordAllocationEvent(); &#125; rax = _objc_rootAutorelease(rbx); rax = [NSException exceptionWithName:@\"NSInvalidArgumentException\" reason:rax userInfo:0x0]; objc_exception_throw(rax); return;&#125;void +[NSObject doesNotRecognizeSelector:](void * self, void * _cmd, void * arg2) &#123; r14 = ___CFFullMethodName([self class], self, arg2); _CFLog(0x3, @\"%@: unrecognized selector sent to class %p\", r14, self, r8, r9, stack[2048]); rbx = _CFMakeCollectable(_CFStringCreateWithFormat(___kCFAllocatorSystemDefault, 0x0, @\"%@: unrecognized selector sent to class %p\")); if (*(int8_t *)___CFOASafe != 0x0) &#123; ___CFRecordAllocationEvent(); &#125; rax = _objc_rootAutorelease(rbx); rax = [NSException exceptionWithName:@\"NSInvalidArgumentException\" reason:rax userInfo:0x0]; objc_exception_throw(rax); return;&#125; 也就是说我们可以 override doesNotRecognizeSelector 或者捕获其抛出的异常。 总结过滤了部分不会进入的分支路径和跟主题无关的细节，整体流程如下： 参考： iOS-底层原理 12：消息流程分析之快速查找（https://blog.51cto.com/u_12801393/2955213） Objc-msg-arm64源码深入分析（https://www.jianshu.com/p/835ae53372ba） OC底层原理11-objc_msgSend源码分析(方法查找快流程)（https://www.jianshu.com/p/62ecc3f31467） OC底层原理12-lookUpImpOrForward源码分析(方法查找慢流程)（https://www.jianshu.com/p/740ee19690c3） objc_msgSend 源码跟踪（https://www.jianshu.com/p/c8aedd333f2d） 深入解构objc_msgSend函数的实现（http://www.cocoachina.com/articles/24536） Objective-C 消息发送与转发机制原理","categories":[{"name":"刨根问底","slug":"刨根问底","permalink":"http://heseng91.github.io/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}],"tags":[]},{"title":"「刨根问底」之Objective-C 2.0 中类与对象的定义","slug":"「刨根问底之-Runtime类和对象的定义","date":"2018-12-04T08:30:33.000Z","updated":"2022-07-25T19:29:33.521Z","comments":true,"path":"2018/12/04/「刨根问底之-Runtime类和对象的定义/","link":"","permalink":"http://heseng91.github.io/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E4%B9%8B-Runtime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/","excerpt":"runtime简介依照苹果文档的说法，runtime是： 12The Objective-C language defers as many decisions as it can from compile time and link time to runtime. （尽量将决定放到运行的时候，而不是在编译和链接过程） 如何理解这段话呢，我们首先要知道，一段代码从写完到最终执行的过程中发生了什么。","text":"runtime简介依照苹果文档的说法，runtime是： 12The Objective-C language defers as many decisions as it can from compile time and link time to runtime. （尽量将决定放到运行的时候，而不是在编译和链接过程） 如何理解这段话呢，我们首先要知道，一段代码从写完到最终执行的过程中发生了什么。 从代码到可执行文件的过程具体过程见下图： 主要过程可以简化成三个： 123- 编译- 链接- 运行 编译：将代码转换成底层可执行的语言（如汇编），简单来讲，就是把你能看懂的语言，转换成系统底层可以看懂的东西，这中间通常会有优化，先预处理，再编译。 链接：在编译的过程中，如果有调用其他的类的方法等，是不会检查或者报警的，编译的时候会默认你已经实现了。而链接就是去检查调用的方法或者类等是否确实存在。 运行：执行最终的可执行文件 如果是普通的C语言代码，我们使用的是传统的编译运行，那么一个函数的执行内容，在编译阶段其实就确定了，执行的时候只要去执行对应的内存地址的程序就好。 因为Objc是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个 Objc 运行框架的一块基石。 Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 maxOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime之发送消息（objc_msgSend）还记得刚学 Objective-C 时把 [receiver message] 当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。其实 [receiver message] 会被编译器转化为： 1objc_msgSend(receiver, selector) 如果消息含有参数，则为： 1objc_msgSend(receiver, selector, arg1, arg2, ...) 如果消息的接收者能够找到对应的 selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个 selector 对应的实现内容，要么就干脆玩完崩溃掉。 消息发送等下章详细表述。本文基于源码为 objc4-756.2，先来介绍一下 Objective-C 2.0 中类与对象的相关定义，仅作为参考，暂不做深入的分析。 Runtime 基础数据结构前面提到的objc_msgSend:的真身是这样的： 1id objc_msgSend ( id self, SEL op, ... ); 下面将会逐渐展开介绍一些术语，其实它们都对应着数据结构。 SELobjc_msgSend函数第二个参数类型为SEL，它是selector在Objc中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL: 1typedef struct objc_selector *SEL; 其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获得一个 SEL 类型的方法选择器。 不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(参见：NSNumber 一堆抽象工厂方法)，Cocoa 中也有好多长长的方法。 idobjc_msgSend 第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针： 1typedef struct objc_object *id; 那objc_object又是啥呢，参考 objc-private.h 文件部分源码： 12345678910111213struct objc_object &#123;private: isa_t isa;public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // getIsa() allows this to be a tagged pointer object Class getIsa(); ... 此处省略其他方法声明&#125; objc_object 结构体包含一个 isa 指针，类型为 isa_t 联合体。根据 isa 就可以顺藤摸瓜找到对象所属的类。 PS: isa 指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用 class 方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见官方文档 isa_tobjc_object 中的 isa 是一个 isa_t 类型的共用体（union），在objc-private.h 文件中定义如下： 123456789101112union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 其中 ISA_BITFIELD在 isa.h文件中定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#if SUPPORT_PACKED_ISA // extra_rc must be the MSB-most field (so it matches carry/overflow flags) // nonpointer must be the LSB (fixme or get rid of it) // shiftcls must occupy the same bits that a real class pointer would // bits + RC_ONE is equivalent to extra_rc + 1 // RC_HALF is the high bit of extra_rc (i.e. half of its range) // future expansion: // uintptr_t fast_rr : 1; // no r/r overrides // uintptr_t lock : 2; // lock for atomic property, @synch // uintptr_t extraBytes : 1; // allocated with extra bytes# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18)# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 8# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7)# else# error unknown architecture for packed isa# endif SUPPORT_PACKED_ISA 用于标记是否支持优化的 isa 指针，其字面含义意思是 isa 的内容不再是类的指针了，而是包含了更多信息，比如引用计数，析构状态，被其他 weak 变量引用情况。判断方法也是根据设备类型： 12345678// Define SUPPORT_PACKED_ISA=1 on platforms that store the class in the isa // field as a maskable pointer with other data around it.#if (!__LP64__ || TARGET_OS_WIN32 || \\ (TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_IOSMAC))# define SUPPORT_PACKED_ISA 0#else# define SUPPORT_PACKED_ISA 1#endif 综合看来目前只有 arm64 架构的设备支持，下面列出了 isa 指针中变量对应的含义： 变量名 含义 nonpointer 0 表示普通的 isa 指针，1 表示使用优化，存储引用计数 has_assoc 表示该对象是否包含 associated object，如果没有，则析构时会更快 has_cxx_dtor 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls 类的指针 magic 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。 weakly_referenced 表示该对象是否有被弱引用指向过，如果没有，则析构时更快 deallocating 表示该对象是否正在析构 has_sidetable_rc 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_rc 存储引用计数值减一后的结果 ClassClass 其实是一个指向 objc_class 结构体的指针： 1typedef struct objc_class *Class; 而 objc_class 包含很多方法，主要都为围绕它的几个成员做文章： 123456789101112struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125; ...// 省略其他方法&#125; objc_class 继承于 objc_object，也就是说一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似 [NSObject alloc] 的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 [NSObject alloc] 这条消息发给类对象的时候，objc_msgSend() 会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。 上图实线是 superclass 指针，虚线是isa指针。 有趣的是根元类的超类是 NSObject，而 isa 指向了自己，而 NSObject的超类为 nil，也就是它没有超类。 cache_t1234567struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;... //省略其他方法&#125; 其中，bucket_t *_buckets 是一个散列表，用来存储 Method 方法列表，而 bucket_t 结构体定义如下，包含了一个 unsigned long 类型的 _key 和一个 IMP 类型的 _imp，存储了指针与 IMP 的键值对。IMP 是一个函数指针，指向了一个方法的具体实现。 1234567891011121314struct bucket_t &#123;private: // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64.#if __arm64__ uintptr_t _imp; SEL _sel;#else SEL _sel; uintptr_t _imp;#endif... 省略其他方法&#125;; cache_t 中另外两个变量 _mask 和 _occupied，它们的类型为 mask_t，定义如下，其实是一个 unsigned int。 12345#if __LP64__typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t;#endif _mask 和 _occupied 对应于 vtable： _mask：分配用来缓存 bucket 的总数。 _occupied：表明目前实际占用的缓存 bucket 的个数。 cache 的作用主要是对方法调用的性能进行优化。通俗地讲，每当实例对象接收到一个消息时，它不会直接在其 isa 指向的类（或类的 isa 指向的父类）的方法列表中遍历查找能够响应消息的方法实现，因为这样效率太低了，而是优先在 cache 中查找。Runtime 系统会把被调用过的方法存到该类对象的 cache 中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。 有关缓存的实现细节，可以查看 objc-cache.mm 文件。 class_data_bits_tobjc_class 中最复杂的是 bits，class_data_bits_t 结构体所包含的信息太多了，主要包含 class_rw_t, retain/release/autorelease/retainCount 和 alloc 等信息，很多存取方法也是围绕它展开。查看 objc-runtime-new.h 源码如下： 123456789101112131415161718struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;private: bool getBit(uintptr_t bit) &#123; return bits &amp; bit; &#125;...public: class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;...省略其他方法&#125; 注意 objc_class 的 data 方法直接将 class_data_bits_t 的data 方法返回，最终是返回 class_rw_t，保了好几层。 可以看到 class_data_bits_t 里又包了一个 bits，这个指针跟不同的 FAST_ 前缀的 flag 掩码做按位与操作，就可以获取不同的数据。bits 在内存中每个位的含义有三种排列顺序： 32 位： 0 1 2 - 31 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_DATA_MASK 64 位兼容版： 0 1 2 3 - 46 47 - 63 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_HAS_DEFAULT_RR FAST_DATA_MASK 空闲 64 位不兼容版： 0 1 2 3 - 46 47 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_ALLOC FAST_DATA_MASK FAST_HAS_CXX_CTOR 48 49 50 51 52 - 63 FAST_HAS_DEFAULT_AWZ FAST_HAS_DEFAULT_RR FAST_REQUIRES_RAW_ISA FAST_HAS_CXX_DTOR 空闲 其中 64 位不兼容版每个宏对应的含义如下： 1234567891011121314151617181920212223242526// class is a Swift class from the pre-stable Swift ABI#define FAST_IS_SWIFT_LEGACY (1UL&lt;&lt;0)// class is a Swift class from the stable Swift ABI#define FAST_IS_SWIFT_STABLE (1UL&lt;&lt;1)// summary bit for fast alloc path: !hasCxxCtor and // !instancesRequireRawIsa and instanceSize fits into shiftedSize#define FAST_ALLOC (1UL&lt;&lt;2)// data pointer#define FAST_DATA_MASK 0x00007ffffffffff8UL// class or superclass has .cxx_construct implementation#define FAST_HAS_CXX_CTOR (1UL&lt;&lt;47)// class or superclass has default alloc/allocWithZone: implementation// Note this is is stored in the metaclass.#define FAST_HAS_DEFAULT_AWZ (1UL&lt;&lt;48)// class or superclass has default retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference#define FAST_HAS_DEFAULT_RR (1UL&lt;&lt;49)// class's instances requires raw isa// This bit is aligned with isa_t-&gt;hasCxxDtor to save an instruction.#define FAST_REQUIRES_RAW_ISA (1UL&lt;&lt;50)// class or superclass has .cxx_destruct implementation#define FAST_HAS_CXX_DTOR (1UL&lt;&lt;51)// instance size in units of 16 bytes// or 0 if the instance size is too big in this field// This field must be LAST#define FAST_SHIFTED_SIZE_SHIFT 52 这里面除了 FAST_DATA_MASK 是用一段空间存储数据外，其他宏都是只用 1 bit 存储 bool 值。class_data_bits_t 提供了三个方法用于位操作：getBit, setBits 和 clearBits，对应到存储 bool 值的掩码也有封装函数，比如： 123456bool hasCxxCtor() &#123; return getBit(FAST_HAS_CXX_CTOR);&#125;void setHasCxxCtor() &#123; setBits(FAST_HAS_CXX_CTOR);&#125; 重头戏在于最大的那块存储区域FAST_DATA_MASK，它其实就存储了指向 class_rw_t 的指针： 123class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK);&#125; 对这片内存读写处于并发环境，但并不需要加锁，因为会通过对一些状态（realization or construction）判断来决定是否可读写。 class_data_bits_t 甚至还包含了一些对 class_rw_t 中 flags 成员存取的封装函数。 class_rw_tobjc_class 包含了 class_data_bits_t，class_data_bits_t 存储了 class_rw_t 的指针。 1234567891011121314151617181920212223struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;#if SUPPORT_INDEXED_ISA uint32_t index;#endif...省略操作 flags 的相关方法&#125; class_rw_t 中使用的 method_array_t, property_array_t, protocol_array_t 都继承自 list_array_tt&lt;Element, List&gt;, 它可以不断扩张，因为它可以存储 list 指针，内容有三种： 空 一个 entsize_list_tt 指针 entsize_list_tt 指针数组 class_rw_t 的内容是可以在运行时被动态修改的，可以说运行时对类的拓展大都是存储在这里的。 class_rw_t-&gt;flags 存储的值并不是编辑器设置的，其中有些值可能将来会作为 ABI 的一部分。下面这些 RW_ 前缀的宏标记了 flags 一些位置的含义。这些 bool 值标记了类的一些状态，涉及到声明周期和内存管理。有些位目前甚至还空着。 12345678910111213141516171819202122232425262728293031// Values for class_rw_t-&gt;flags// These are not emitted by the compiler and are never used in class_ro_t. // Their presence should be considered in future ABI versions.// class_t-&gt;data is class_rw_t, not class_ro_t#define RW_REALIZED (1&lt;&lt;31)// class is unresolved future class#define RW_FUTURE (1&lt;&lt;30)// class is initialized#define RW_INITIALIZED (1&lt;&lt;29)// class is initializing#define RW_INITIALIZING (1&lt;&lt;28)// class_rw_t-&gt;ro is heap copy of class_ro_t#define RW_COPIED_RO (1&lt;&lt;27)// class allocated but not yet registered#define RW_CONSTRUCTING (1&lt;&lt;26)// class allocated and registered#define RW_CONSTRUCTED (1&lt;&lt;25)// available for use; was RW_FINALIZE_ON_MAIN_THREAD// #define RW_24 (1&lt;&lt;24)// class +load has been called#define RW_LOADED (1&lt;&lt;23)#if !SUPPORT_NONPOINTER_ISA// class instances may have associative references#define RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS (1&lt;&lt;22)#endif// class has instance-specific GC layout#define RW_HAS_INSTANCE_SPECIFIC_LAYOUT (1 &lt;&lt; 21)// class does not allow associated objects on its instances#define RW_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;20)// class has started realizing but not yet completed it#define RW_REALIZING (1&lt;&lt;19) demangledName 是计算机语言用于解决实体名称唯一性的一种方法，做法是向名称中添加一些类型信息，用于从编译器中向链接器传递更多语义信息。 class_ro_tclass_rw_t 提供了运行时对类拓展的能力，而 class_ro_t 存储的大多是类在编译时就已经确定的信息。二者都存有类的方法、属性（成员变量）、协议等信息，不过存储它们的列表实现方式不同。 class_ro_t 中的 method_list_t, ivar_list_t, property_list_t 结构体都继承自 entsize_list_tt&lt;Element, List, FlagMask&gt;。结构为 xxx_list_t 的列表元素结构为 xxx_t，命名很工整。protocol_list_t 与前三个不同，它存储的是 protocol_t * 指针列表，实现比较简单。 entsize_list_tt 实现了 non-fragile 特性的数组结构。假如苹果在新版本的 SDK 中向 NSObject 类增加了一些内容，NSObject 的占据的内存区域会扩大，开发者以前编译出的二进制中的子类就会与新的 NSObject 内存有重叠部分。于是在编译期会给 instanceStart 和 instanceSize 赋值，确定好编译时每个类的所占内存区域起始偏移量和大小，这样只需将子类与基类的这两个变量作对比即可知道子类是否与基类有重叠，如果有，也可知道子类需要挪多少偏移量。更多细节可以参考后面的章节 Non Fragile ivars。 123456789101112131415161718192021222324struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; // This field exists only when RO_HAS_SWIFT_INITIALIZER is set. _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0];...省略其他方法&#125;; class_ro_t-&gt;flags 存储了很多在编译时期就确定的类的信息，也是 ABI 的一部分。下面这些 RO_ 前缀的宏标记了 flags 一些位置的含义。其中后三个并不需要被编译器赋值，是预留给运行时加载和初始化类的标志位，涉及到与 class_rw_t 的类型强转。运行时会用到它做判断，后面会讲解。 1234567891011121314151617181920212223242526272829303132333435// class_data_bits_t is the class_t-&gt;data field (class_rw_t pointer plus flags)// The extra bits are optimized for the retain/release and alloc/dealloc paths.// Values for class_ro_t-&gt;flags// These are emitted by the compiler and are part of the ABI.// Note: See CGObjCNonFragileABIMac::BuildClassRoTInitializer in clang// class is a metaclass#define RO_META (1&lt;&lt;0)// class is a root class#define RO_ROOT (1&lt;&lt;1)// class has .cxx_construct/destruct implementations#define RO_HAS_CXX_STRUCTORS (1&lt;&lt;2)// class has +load implementation// #define RO_HAS_LOAD_METHOD (1&lt;&lt;3)// class has visibility=hidden set#define RO_HIDDEN (1&lt;&lt;4)// class has attribute(objc_exception): OBJC_EHTYPE_$_ThisClass is non-weak#define RO_EXCEPTION (1&lt;&lt;5)// class has ro field for Swift metadata initializer callback#define RO_HAS_SWIFT_INITIALIZER (1&lt;&lt;6)// class compiled with ARC#define RO_IS_ARC (1&lt;&lt;7)// class has .cxx_destruct but no .cxx_construct (with RO_HAS_CXX_STRUCTORS)#define RO_HAS_CXX_DTOR_ONLY (1&lt;&lt;8)// class is not ARC but has ARC-style weak ivar layout #define RO_HAS_WEAK_WITHOUT_ARC (1&lt;&lt;9)// class does not allow associated objects on instances#define RO_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;10)// class is in an unloadable bundle - must never be set by compiler#define RO_FROM_BUNDLE (1&lt;&lt;29)// class is unrealized future class - must never be set by compiler#define RO_FUTURE (1&lt;&lt;30)// class is realized - must never be set by compiler#define RO_REALIZED (1&lt;&lt;31) realizeClass在某个类初始化之前，objc_class-&gt;data() 返回的指针指向的其实是个 class_ro_t 结构体。等到 static Class realizeClass(Class cls) 静态方法在类第一次初始化时被调用，它会: 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针 初始化一个 class_rw_t 结构体 设置结构体 ro 的值以及 flag 最后设置正确的 data。 将 class_ro_t 指针赋值给 class_rw_t-&gt;ro。这种偷天换日的行为是靠 RO_FUTURE 标志位来记录的： 123456789101112131415161718192021222324252627/************************************************************************ realizeClassWithoutSwift* Performs first-time initialization on class cls, * including allocating its read-write data.* Does not perform any Swift-side initialization.* Returns the real class structure for the class. * Locking: runtimeLock must be write-locked by the caller**********************************************************************/static Class realizeClassWithoutSwift(Class cls)&#123;... ro = (const class_ro_t *)cls-&gt;data(); if (ro-&gt;flags &amp; RO_FUTURE) &#123; // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro; cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE); &#125; else &#123; // Normal class. Allocate writeable class data. rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); rw-&gt;ro = ro; rw-&gt;flags = RW_REALIZED|RW_REALIZING; cls-&gt;setData(rw); &#125;...省略逻辑实现&#125; 注意之前 RO 和 RW flags 宏标记的一个细节： 12345#define RO_FUTURE (1&lt;&lt;30)#define RO_REALIZED (1&lt;&lt;31)#define RW_REALIZED (1&lt;&lt;31)#define RW_FUTURE (1&lt;&lt;30) 也就是说 ro = (const class_ro_t *)cls-&gt;data(); 这种强转对于接下来的 ro-&gt;flags &amp; RO_FUTURE 操作完全是 OK 的，两种结构体第一个成员都是 flags，RO_FUTURE 与 RW_FUTURE 值一样的。 经过 realizeClass 函数处理的类才是『真正的』类，调用它时不能对类做写操作。 Ivar在 objc-private.h 中，Ivar 被定义为一个指向 ivar_t 结构体的指针： 1#if __OBJC2__typedef struct ivar_t *Ivar; ivar_t 结构体在 objc-runtime-new.h 中定义： 123456789101112131415161718192021struct ivar_t &#123;#if __x86_64__ // *offset was originally 64-bit on some x86_64 platforms. // We read and write only 32 bits of it. // Some metadata provides all 64 bits. This is harmless for unsigned // little-endian values. // Some code uses all 64 bits. class_addIvar() over-allocates the // offset for their benefit.#endif int32_t *offset; const char *name; const char *type; // alignment is sometimes -1; use alignment() instead uint32_t alignment_raw; uint32_t size; uint32_t alignment() const &#123; if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT; return 1 &lt;&lt; alignment_raw; &#125;&#125;; Ivar 用于表示类中实例变量（成员变量）的类型，ivar_t 中定义了实例变量的名字和类型。而ivar 的修饰信息存放在了 Class 的 Ivar Layout 中。ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型。 举个例子说明，若类定义为： 123456@interface Foo : NSObject &#123; __strong id ivar0; __weak id ivar1; __weak id ivar2;&#125;@end 则储存 strong ivar 的 ivarLayout 的值为 0x012000 储存 weak ivar 的 weakIvarLayout 的值为 0x1200 一个 uint8_t 在 16 进制下是两位，所以编码的值每两位一对儿，以上面的 ivarLayout 为例： 前两位 01 表示有 0 个非 strong 对象和 1 个 strong 对象 之后两位 20 表示有 2 个非 strong 对象和 0 个 strong 对象 最后两位 00 为结束符，就像 cstring 的 \\0 一样 同理，上面的 weakIvarLayout： 前两位 12 表示有 1 个非 weak 对象和接下来连续 2 个 weak 对象 00 结束符 这样，用两个 layout 编码值就可以排查出一个 ivar 是属于 strong 还是 weak 的，若都没有找到，就说明这个对象是 unsafe_unretained. Property我们知道，@property 用于声明类中的属性，在 Runtime 系统中，objc_property_t 是一个指向objc_property 结构体的指针，在 objc-private.h 中定义： 1#if __OBJC2__typedef struct property_t *objc_property_t; property_t 结构体在 objc-runtime-new.h 中定义： 1234struct property_t &#123; const char *name; const char *attributes;&#125;; MethodMethod是一种代表类中的某个方法的类型。 1#if __OBJC2__typedef struct method_t *Method; 而 objc_method 在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现： 1234567891011121314struct method_t &#123; SEL name; const char *types; MethodListIMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;; 方法名类型为 SEL，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。 方法类型 types 是个char指针，其实存储着方法的参数类型和返回值类型。 imp 指向了方法的实现，本质上是一个函数指针，后面会详细讲到。 CategoryCategory 为现有的类提供了拓展性，它是 category_t 结构体的指针。 1#if __OBJC2__typedef struct category_t *Category; category_t 存储了类别中可以拓展的实例方法、类方法、协议、实例属性和类属性。类属性是 Objective-C 2016 年新增的特性，沾 Swift 的光。所以 category_t 中有些成员变量是为了兼容 Swift 的特性，Objective-C 暂没提供接口，仅做了底层数据结构上的兼容。 1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; 在 App 启动加载镜像文件时，会在 _read_images 函数间接调用到 attachCategories 函数，完成向类中添加 Category 的工作。原理就是向 class_rw_t 中的 method_array_t, property_array_t, protocol_array_t 数组中分别添加 method_list_t, property_list_t, protocol_list_t 指针。之前讲过 xxx_array_t 可以存储对应 xxx_list_t 的指针数组。 在调用 attachCategories 函数之前，会先使用 unattachedCategoriesForClass 函数获取类中还未添加的类别列表。这个列表类型为 locstamped_category_list_t，它封装了 category_t 以及对应的 header_info。header_info 存储了实体在镜像中的加载和初始化状态，以及一些偏移量，在加载 Mach-O 文件相关函数中经常用到。 123456789101112struct locstamped_category_t &#123; category_t *cat; struct header_info *hi;&#125;;struct locstamped_category_list_t &#123; uint32_t count;#if __LP64__ uint32_t reserved;#endif locstamped_category_t list[0];&#125;; 所以更具体来说 attachCategories 做的就是将 locstamped_category_list_t.list 列表中每个 locstamped_category_t.cat 中的那方法、协议和属性分别添加到类的 class_rw_t 对应列表中。header_info 中的信息决定了是否是元类，从而选择应该是添加实例方法还是类方法、实例属性还是类属性等。源码在 objc-runtime-new.mm 文件中，很好理解。 protocol_t虽然 Objective-C 的 Category 和 protocol 拓展能力有限，但也得为了将就 Swift 的感受，充个胖子。 flags 32 位指针最后两位是给加载 Mach-O 的 fix-up 阶段使用的，前 16 位预留给 Swift 用的。 protocol 主要内容其实是（可选）方法，其次就是继承其他 protocol。Swift 还支持 protocol 多继承，所以需要 protocols 数组来做兼容。 123456789101112131415161718192021222324struct protocol_t : objc_object &#123; const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; const char *demangledName(); const char *nameForLogging() &#123; return demangledName(); &#125;... 省略一些封装的便捷 get 方法&#125;; IMPIMP在objc.h中的定义是： 1typedef void (*IMP)(void /* id, SEL, ... */ ); 它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。既然得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面会提到。 你会发现 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址；反之亦然。 总结我们可以用如下这张图来分别表示 Objective-C 2.0 版本中类和对象的定义，及相关数据结构的关系： 拓展Tagged Pointerisa 这里还涉及到 Tagged Pointer 等概念。因为 isa_t 使用 union 实现，所以可能表示多种形态，既可以当成是指针，也可以存储标志位。 Tagged Pointer：一种特殊标记的对象，Tagged Pointer 通过在其最后一个 bit 位设置为特殊标记位，并且把数据直接保存在指针本身中。Tagged Pointer 是一个”伪”对象，使用 Tagged Pointer 有 3 倍的访问速度提升，100 倍的创建、销毁速度提升。 Tips：Advances in Objective-C 在我们查看对象指针时，在 64 位系统中，我们会看到 16 进制地址如0x00000001003041e0，我们把它转换为二进制表示如下图 在 64 位系统中，我们有 64 位可以表示一个对象指针，但是我们通常没有真正使用到所有这些位。由于内存对齐要求的存在，低位始终为0，对象必须始终位于指针大小倍数的地址中。由于地址空间有限，所以高位也始终为0。所以实际上我们只在一个真正的对象指针中使用了中间的这些位，而不会用到用到2^64，这些高位和低位总是0。 苹果从这些始终为0的位中选择了低位并把它设置为1。以标识这不是一个真正的对象指针，然后就可以给其他位赋予一些其他的意义，苹果称这种指针为tagged pointer。 例如：NSNumber指针，苹果在其它位中塞入的是一个数值。（PS：这些值实际上是通过与进程启动时初始化的随机值相结合而被混淆的）。 在设置为 1 表示为 Tagged Pointer 对象之后，在最低位之后的 3 位，苹果给他赋予类型意义，由于只有 3 位，所以它可以表示 7 种数据类型 12345678OBJC_TAG_NSAtom = 0, OBJC_TAG_1 = 1, OBJC_TAG_NSString = 2, OBJC_TAG_NSNumber = 3, OBJC_TAG_NSIndexPath = 4, OBJC_TAG_NSManagedObjectID = 5, OBJC_TAG_NSDate = 6, OBJC_TAG_7 = 7 在剩余的字段中，我们可以赋予他所包含的数据。在 Intel 中，我们 Tagged Pointer 对象的表示如下 OBJC_TAG_7类型的 Tagged Pointer 是个例外，它可以将接下来后 8 位作为它的扩展类型字段，基于此我们可以多支持 256 中类型的 Tagged Pointer，如 UIColors 或 NSIndexSets 之类的对象。 OC对象占用的大小初始OC对象占用内存OC中对象大部分继承至NSObject。NSObject类的定义如下： 123456789OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ROOT_CLASSOBJC_EXPORT@interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125; 上文中提到Class其实就是一个指向 struct objc_class 结构体类型的指针.。那么也就是说 NSObject 对象对应的结构体只包含一个 isa 指针变量 ，一个指针变量在 64 位的机器上大小是 8 个字节。 那是不是说一个 NSObject 对象就占用8个字节大小的内存呢？实际上不是的. 答案其实是: 所有的OC对象至少为16字节. 我们先来验证一下。 12345678910#import &lt;Foundation&#x2F;Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; &#x2F;&#x2F; insert code here... NSObject *obj &#x3D; [[NSObject alloc] init]; NSLog(@&quot;Hello, World! %@&quot;,obj); &#125; return 0;&#125; 打印语句加个断点。 lldb中打印得出：对象实际占用的内存大小为8，实际分配的内存大小为16。 lldb查看布情况，可以看出创建的对象后面几个字节全部为 00。 我们可以通过阅读 objc4 的源码来找到答案。通过查看跟踪 obj4 中 alloc 和 allocWithZone 两个函数的实现，会发现这个连个函数都会调用一个 instanceSize 的函数： 123456size_t instanceSize(size_t extraBytes) &#123; size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16bytes. if (size &lt; 16) size = 16; return size; &#125; 上面源码中我们看出了答案, 最少会开辟16个字节. 那么为什么非要用 16 个字节来存储 8 个字节的内容呢? 这里简单解释一下 . 其实这里主要是涉及到硬件问题, 因为不同厂商之间需要一套标准化方案来解决不同厂商之间规则不同导致内存读取使用出现不统一的情况.为了解决这种问题而产生的 字节对齐. 讲到这里,我还想继续看下 当这个对象包含多个属性时使用内存情况. 以便我们彻底搞明白 OC 对象使用内存情况. 包含其他属性占用内存情况创建一个 Person 类,继承与 NSObject , 其包含三个 int 属性。修改main.m 文件如下： 12345678910111213141516171819202122#import &lt;Foundation&#x2F;Foundation.h&gt;@interface Person : NSObject@property (nonatomic, assign) int age;@property (nonatomic, assign) int height;@property (nonatomic, assign) int row;@end@implementation Person@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *obj &#x3D; [[Person alloc] init]; obj.age &#x3D; 4; obj.height &#x3D; 5; obj.row &#x3D; 6; NSLog(@&quot;Hello, World! %@&quot;,obj); &#125; return 0;&#125; lldb打印对象内存情况如下 ![屏幕快照 2021-08-22 下午11.50.02](/Users/ethenfarben/Desktop/屏幕快照 2021-08-22 下午11.50.02.png) 对象实际占用内存大小为24，实际分配的内存大小为32。 ![屏幕快照 2021-08-22 下午11.41.12](/Users/ethenfarben/Desktop/屏幕快照 2021-08-22 下午11.41.12.png) 这里就出现一个比较奇怪的现象 , 实际需要内存大小 24, 为什么呢 ? 其实这里就是 结构体内存分配的原理了. 结构体每个成员相对于结构体首地址的偏移量都是这个成员大小的整数倍，如果有需要，编译器会在成员之间加上填充字节 结构体的总大小为结构体最宽成员大小的整数倍。 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。 对于结构体成员属性中包含结构体变量的复合型结构体，在确定最宽基本类型成员时，应当包括复合类型成员的子成员。但在确定复合类型成员的偏移位置时则是将复合类型作为整体看待。 由于原本结构体 isa指针占用8个 , age属性占用4个, height占用 4个, row属性再占用4个 , 这中间由于满足整除并没有自动偏移补充. 而由于 : 结构体的总大小为结构体最宽成员大小的整数倍 , 而且对线开辟满足 16 字节对齐原则 ( 可以在 libmaclloc 源码查找到 ) , 因此实际总占用内存为24. 而实际开辟则满足对齐标准开辟为 32. 在 libmaclloc 源码 , nano_malloc.c 中 1234567891011121314static MALLOC_INLINE size_tsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)&#123; size_t k, slot_bytes; if (0 == size) &#123; size = NANO_REGIME_QUANTA_SIZE; // Historical behavior &#125; k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // round up and shift for number of quanta slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; // multiply by power of two quanta size *pKey = k - 1; // Zero-based! return slot_bytes;&#125; 其中NANO_REGIME_QUANTA_SIZE 和 SHIFT_NANO_QUANTUM在nano_zone_common.h中定义如下： 12#define SHIFT_NANO_QUANTUM 4#define NANO_REGIME_QUANTA_SIZE (1 &lt;&lt; SHIFT_NANO_QUANTUM) // 16 所以16字节对齐算法为：size + (2^4 - 1) &gt;&gt; 4 &lt;&lt; 4。 总结 (只考虑64位): OC对象 最少占用 16个字节内存 . 当对象中包含属性, 会按属性占用内存开辟空间. 在结构体内存分配原则下自动偏移和补齐 . 对象最终满足 16字节对齐标准 . 属性最终满足 8字节对齐标准 . 可以通过 #pragma pack() 自定义对齐方式 . 更新在2020年WWDC中，Runtime又有了一些更新。详见：2020 – Advancements in the Objective-C runtime主要更新内容如下: 数据结构的变化在介绍更新之前，先了解一下二进制类在磁盘中的表示。 ![屏幕快照 2021-08-21 下午9.40.03](/Users/ethenfarben/Desktop/屏幕快照 2021-08-21 下午9.40.03.png) 首先是类对象本身，包含最常访问的信息：指向元类，超类和方法缓存的指针，在类结构之中有指向包含更多数据的结构体class_ro_t的指针，包含了类的名称，方法，协议，实例变量等等编译期确定的信息。 当类被 Runtime 加载之后，类的结构会发生一些变化，在了解这些变化之前，我们需要知道2个概念： Clean Memory：加载后不会发生更改的内存块，class_ro_t属于Clean Memory，因为它是只读的。 Dirty Memory：运行时会进行更改的内存块，类一旦被加载，就会变成Dirty Memory，例如，我们可以在 Runtime 给类动态的添加方法。 这里要明确，Dirty Memory比Clean Memory要昂贵得多。因为它需要更多的内存信息，并且只要进程正在运行，就必须保留它。对于我们来说，越多的Clean Memory显然是更好的，因为它可以节约更多的内存。我们可以通过分离出永不更改的数据部分，将大多数类数据保留为Clean Memory，如何怎么做的呢？ 在介绍优化方法之前，我们先来看一下，在类加载之后，类的结构会变成如何呢？ ![屏幕快照 2021-08-21 下午9.44.24](/Users/ethenfarben/Desktop/屏幕快照 2021-08-21 下午9.44.24.png) 在类加载到 Runtime 中后会被分配用于读取/写入数据的结构体class_rw_t。 Tips：class_ro_t是只读的，存放的是编译期间就确定的字段信息；而class_rw_t是在 runtime 时才创建的，它会先将class_ro_t的内容拷贝一份，再将类的分类的属性、方法、协议等信息添加进去，之所以要这么设计是因为 Objective-C 是动态语言，你可以在运行时更改它们方法，属性等，并且分类可以在不改变类设计的前提下，将新方法添加到类中。 事实证明，class_rw_t会占用比class_ro_t占用更多的内存，在 iPhone 中，我们在系统测量了大约 30MB 的这些class_rw_t结构。应该如何优化这些内存呢？通过测量实际设备上的使用情况，我们发现大约 10％ 的类实际会存在动态的更改行为，如动态添加方法，使用 Category 方法等。因此，我们能可以把这部分动态的部分提取出来，我们称之为class_rw_ext_t，所以，结构会变成这个样子。 ![屏幕快照 2021-08-21 下午10.05.15](/Users/ethenfarben/Desktop/屏幕快照 2021-08-21 下午10.05.15.png) 经过拆分，可以把 90% 的类优化为Clean Memory，在系统层面，取得效果是节省了大约 14MB 的内存，使内存可用于更有效的用途。 Tips：head xxxxx | egrep &#39;class_rw|COUNT’ 你可以使用此命令来查看 class_rw_t 消耗的内存。xxxx可以替换为需要测量的 App 名称。如：head Mail | egrep &#39;class_rw|COUNT’\\&#39;查看 Mail 应用的使用情况。 Tagged pointer格式的变化相比于之前的Tagged pointer，在 ARM64 中格式有些变化。 ![屏幕快照 2021-08-22 上午5.33.02](/Users/ethenfarben/Desktop/屏幕快照 2021-08-22 上午5.33.02.png) 不同于以往，苹果使用最高位代表 Tagged Pointer 标识位，低位 3 位标识 Tagged Pointer 的类型，接下去的位来表示包含的数据（可能包含扩展类型字段），为什么我们使用高位指示 ARM上 的 Tagged Pointer，而不是像 Intel 一样使用低位标记？ 它实际是对 objc_msgSend 的微小优化。我们希望 msgSend 中最常用的路径尽可能快。最常用的路径表示普通对象指针。我们有两种不常见的情况：Tagged Pointer 指针和 nil。事实证明，当我们使用最高位时，可以通过一次比较来检查两者。与分别检查 nil 和 Tagged Pointer 指针相比，这会为 msgSend 中的节省了条件分支。 应用判断类有没有初始化很多技术博客里都提到了，ObjC类的meta class里，自带了一个标记自己有没有初始化过的flag，即class_rw_t–&gt;flags里的RW_INITIALIZED。objc_class类中有提供了封装的函数供外部快速获取该flag值。调用相关代码如下： 12345678910111213141516171819202122// objc_class 代码片段struct objc_class : objc_object &#123;... class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125;... bool isInitialized() &#123; return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED; &#125; void setInitialized();... // NOT identical to this-&gt;ISA when this is a metaclass Class getMeta() &#123; if (isMetaClass()) return (Class)this; else return this-&gt;ISA(); &#125;...&#125; 123456789101112struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;...public: class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;...&#125; 12345struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags;...&#125; 可惜的是，这些方法对我们app来说，是不可见的，没办法直接调用。所以如果想要在运行过程中获取类的初始化状态，只能另想办法。从方法的调用情况看到方法的过程大概分为4步： 我们要先找到类的meta class。 获取objc_class的成员变量bits（class_data_bits_t结构体） 调用class_data_bits_t结构体的data()方法，对结构体的bits属性进行位运算，获取class_rw_t结构体 最后获取class_rw_t结构体的成员变量flags并进行位运算 因为runtime源代码是用C++来写的，所以我们可以通过偏移地址获取到用到的变量，直接用指针来搞定问题。 针对第一步，获取类的meta class，是个runtime里可见的方法，直接调用objc_getMetaClass()方法就能拿到。 第二步获取objc_class的成员变量bits。回到objc_class的头部几行： 1234567891011struct objc_class : objc_object &#123; objc_class(const objc_class&amp;) = delete;// 0 bytes objc_class(objc_class&amp;&amp;) = delete;// 0 bytes void operator=(const objc_class&amp;) = delete;// 0 bytes void operator=(objc_class&amp;&amp;) = delete;// 0 bytes // Class ISA; Class superclass; // 8 bytes cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags...&#125; 首先objc_class 继承至 objc_object，对于子结构体来说，是需要继承父结构体的成员变量的。runtime源代码是用C++来写的，函数都不会占用类meta信息（或者说实例）的内存地址，只有成员变量会占用地址。objc_object父结构如前表述，仅包含isa这个成员变量，占用类实例的头8个bytes，也就是64位CPU的一个指针的长度；而下面的一堆方法，在实例里面一点内存都不占用。然后看完整个结构体，只有这么一个成员变量，所以总长度也就8个bytes。 objc_class内前面几行那几个函数禁用语句，不会产生内存地址的偏移，先不管它们。 superclass作为一个指针（对，Class类型实际上是一个指向结构体的指针），长度为8 bytes。 接下来是cache_t类型的变量cache，它占用了多少bytes我们就要展开看看了。 123456789101112131415161718192021#if __LP64__typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t;#endif...struct cache_t &#123;private: explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;// 8 bytes union &#123; struct &#123; explicit_atomic&lt;mask_t&gt; _maybeMask;//4 bytes#if __LP64__ uint16_t _flags;//2 bytes#endif uint16_t _occupied;//2 bytes &#125;; explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;// 8 bytes &#125;;...&#125; 首先说一下explicit_atomic&lt;T&gt;，它只是负责把模板里的类型包成atomic的，不会对变量占用的内存长度产生影响。 然后要说一下union，C++的老朋友了，联合体内部的成员取最长的一个内存长度，就是联合体的内存长度，这里就是8 bytes。 mask_t的定义在文件头就能找到，其实在64位CPU下就是一个uint32_t而已。 基于上面的介绍，可以推断出整个cache_t结构体的长度就是8 bytes + 8 bytes = 16 bytes。 综上，bits 偏移量为：父结构体objc_object的isa成员变量（8 bytes）+ objc_class结构体的superclass成员变量（8 bytes）+ objc_class结构体的cache成员变量（16 bytes） = 32 bytes。 第三步、第四步，很凑巧的是bits和flags都是两个结构体里的第一个成员变量，那么我们就不需要继续计算偏移了，只需要关注data()函数的具体取值方法即可。 最终我们从一个Class类型，取到它有没有被初始化过的代码大致如下： 1234567Class metaCls &#x3D; objc_getMetaClass(class_getName(cls));if (metaCls) &#123; uint64_t *bits &#x3D; (__bridge void *)metaCls + 32; &#x2F;&#x2F; 在 metaClass 基地址上加上 32 bits 的偏移 uint32_t *data &#x3D; (uint32_t *)(*bits &amp; FAST_DATA_MASK); &#x2F;&#x2F; 模拟 data() 函数取值 return (*data &amp; RW_INITIALIZED); &#x2F;&#x2F; 模拟 isInitialized() 函数最后一步与操作&#125;return NO;","categories":[{"name":"刨根问底","slug":"刨根问底","permalink":"http://heseng91.github.io/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}],"tags":[]},{"title":"「性能优化」之Webview首屏","slug":"「性能优化」之Webview首屏","date":"2018-12-04T08:30:33.000Z","updated":"2022-10-19T16:46:46.803Z","comments":true,"path":"2018/12/04/「性能优化」之Webview首屏/","link":"","permalink":"http://heseng91.github.io/2018/12/04/%E3%80%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8BWebview%E9%A6%96%E5%B1%8F/","excerpt":"在App开发中，当遇到需要跨平台复用、动态更新、无限扩展、较小体积的场景时，内嵌H5可能是较低成本的一种实现方式。作为主流的hybrid方式，H5 + native基本在所有的App中都有使用。然而虽然内嵌H5有很多优点，但如果没针对性地做一些优化，体验会比较不好，主要体现在WebView启动白屏时间和响应流畅度两方面。","text":"在App开发中，当遇到需要跨平台复用、动态更新、无限扩展、较小体积的场景时，内嵌H5可能是较低成本的一种实现方式。作为主流的hybrid方式，H5 + native基本在所有的App中都有使用。然而虽然内嵌H5有很多优点，但如果没针对性地做一些优化，体验会比较不好，主要体现在WebView启动白屏时间和响应流畅度两方面。 WebView启动白屏时间：打开一个 H5 页面需要做一系列处理，会有一段白屏时间，体验糟糕。 响应流畅度：由于 webkit 的渲染机制，单线程，历史包袱等原因，页面刷新/交互的性能体验不如原生。 第二点的体验提升，主要依赖移动设备性能不断增强以及浏览器内核的不断优化。因此针对第二点，本文先不作讨论，仅讨论第一点，怎样减少页面启动白屏时间。对 APP 里的一些使用 H5 实现的功能模块，页面的启动速度是给人最直观感受的体验。本文将首先介绍H5页面加载过程，接着介绍针对加载各阶段要如何优化。 H5页面加载过程对于一个普通用户来讲，打开一个WebView通常会经历以下几个阶段： 交互无反馈 到达新的页面，页面白屏 页面基本框架出现，但是没有数据；页面处于loading状态 出现所需的数据 如果从程序上观察，WebView启动过程大概分为以下几个阶段： 如何缩短这些过程的时间，就成了优化WebView性能的关键。 接下来我们逐一分析各个阶段的耗时情况，以及需要注意的优化点。 无反馈当App首次打开时，默认是并不初始化浏览器内核的；只有当创建WebView实例的时候，才会创建WebView的基础框架。所以与浏览器不同，App中打开WebView的第一步并不是建立连接，而是启动浏览器内核。因此相比浏览器以网络连接开始为起点计算加载时长，App中加载H5页面的时间会更长。针对这段时间的耗时，可以通过预加载 webview来优化，主要有以下几种预加载方案： 全局WebView在一个进程内首次初始化 webview 与第二次初始化不同，首次会比第二次慢很多。原因预计是 webview 首次初始化后，即使 webview 已经释放，但一些多 webview 共用的全局服务或资源对象仍没有释放，第二次初始化时不需要再生成这些对象从而变快。因此我们可以在客户端刚启动时，就初始化一个全局的WebView待用，并隐藏，当用户访问了WebView时，直接使用这个WebView加载对应网页，并展示。 这种方法可以比较有效的减少WebView在App中的首次打开时间。当用户访问页面时，不需要初始化WebView的时间。 当然这也带来了一些问题，包括： 额外的内存消耗。 页面间跳转需要清空上一个页面的痕迹，更容易内存泄露。 【参考东软专利 - 加载网页的方法及装置 CN106250434A】 webview 池另一种方案是可以用两个或多个 webview 重复使用，而不是每次打开 H5 都新建 webview。不过这种方式要解决页面跳转时清空上一个页面，另外若一个 H5 页面上 JS 出现内存泄漏，就影响到其他页面，在 APP 运行期间都无法释放了。 白屏WebView加载完成之后，就会进入白屏阶段，此时WebView会建立连接请求页面，并页面在解析到足够多的节点，且所有CSS都加载完成后进行首屏渲染。在此之前，页面保持白屏。 建立连接/服务器处理在页面请求的数据返回之前，主要有以下过程耗费时间。 DNS connection 服务器处理 针对DNS的耗时，可以通过H5采用和客户端API相同的域名或者预解析DNS等方式来优化。DNS会在系统级别进行缓存，对于WebView的地址，如果使用的域名与native的API相同，则可以直接使用缓存的DNS而不用再进行DNS解析。静态资源同理，最好与客户端的资源域名保持一致。 除此之外，同步渲染时如果后端请求时间过长，可以考虑采用chunk编码，将数据放在最后，并优先将静态内容flush。对于传统的后端渲染页面，往往都是使用的【浏览器】–&gt; 【Web API】 –&gt; 【业务 API】的加载模式，其中后端时间就指的是Web API的处理时间了。在这里Web API一般有两个作用： 确定静态资源的版本。 根据用户的请求，去业务API获取数据。 而一般确定静态资源的版本往往是直接读取代码版本，基本无耗时；而主要的后端时间都花费在了业务API请求上面。 针对业务API请求的耗时，在HTTP协议中，我们可以在header中设置 transfer-encoding:chunked 使得页面可以分块输出。如果合理设计页面，让head部分都是确定的静态资源版本相关内容，而body部分是业务数据相关内容，那么我们可以在用户请求的时候，首先将Web API可以确定的部分先输出给浏览器，然后等API完全获取后，再将API数据传输给浏览器。 下图可以直观的看出分chunk输出和一起输出的区别： 如果采用普通方式输出页面，则页面会在服务器请求完所有API并处理完成后开始传输。浏览器要在后端所有API都加载完成后才能开始解析。 如果采用chunk-encoding: chunked，并优先将页面的静态部分输出；然后处理API请求，并最终返回页面，可以让后端的API请求和前端的资源加载同时进行。 两者的总共后端时间并没有区别，但是可以提升首字节速度，从而让前端加载资源和后端加载API不互相阻塞。 页面框架渲染前面提到页面在解析到足够多的节点，且所有CSS都加载完成后就会进行首屏渲染。一般来说HTML在开始接收到返回数据的时候就开始解析HTML并构建DOM树。但是如果页面的header部分有这样的代码： 1234567891011.....&lt;link href=\"//ms0.meituan.net/css/eve.9d9eee71.css\" rel=\"stylesheet\" onload=\"MT.pageData.eveTime=Date.now()\"/&gt;&lt;script&gt;window.fk = function (callback) &#123;require(['util/native/risk.js'], function (risk) &#123; risk.getFk(callback);&#125;);&#125;&lt;/script&gt;&lt;/head&gt;.... 上面代码的link部分和script部分如果单独出现，都不会阻塞页面的解析： CSS不会阻止页面继续向下继续。 内联的JS很快执行完成，然后继续解析文档。 然而，当这两部分同时出现的时候，CSS后面有JS，则会阻塞JS的执行直到CSS加载完成（即便JS是内联的脚本），从而间接阻塞HTML的解析。 在页面框架加载这一部分，能够优化的点参照雅虎14条就够了；但注意不要犯错，一个小小的内联JS放错位置也会让性能下降很多。 CSS的加载会在HTML解析到CSS的标签时开始，所以CSS的标签要尽量靠前。 但是，CSS链接下面不能有任何的JS标签（包括很简单的内联JS），否则会阻塞HTML的解析。 如果必须要在头部增加内联脚本，一定要放在CSS标签之前。 loading在页面完全下载并解析完成之前，页面处于不完整展示状态。该阶段主要是业务数据的加载，主要有以下两个优化方向： 降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。 加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。 这里就不详细展开了。 优化HTTP 缓存协议在WebView加载过程中，对首屏启动速度影响最大的就是网络请求，所以优化的重点就是缓存，这里着重说一下前端对请求的缓存策略。我们再细分一下，分成 HTML 的缓存，JS/CSS/image 资源的缓存，以及 json 数据的缓存。 HTML 和 JS/CSS/image 资源都属于静态文件，HTTP 本身提供了缓存协议，浏览器实现了这些协议，可以做到静态文件的缓存，具体可以参考这里，总的来说，就是两种缓存： 询问是否有更新：根据 If-Modified-Since / ETag 等协议向后端请求询问是否有更新，没有更新返回304，浏览器使用本地缓存。 直接使用本地缓存：根据协议里的 Cache-Control / Expires 字段去确定多长时间内可以不去发请求询问更新，直接使用本地缓存。 前端能做的最大限度的缓存策略是：HTML 文件每次都向服务器询问是否有更新，JS/CSS/Image资源文件则不请求更新，直接使用本地缓存。那 JS/CSS 资源文件如何更新？常见做法是在在构建过程中给每个资源文件一个版本号或hash值，若资源文件有更新，版本号和 hash 值变化，这个资源请求的 URL 就变化了，同时对应的 HTML 页面更新，变成请求新的资源URL，资源也就更新了。 json 数据的缓存可以用 localStorage 缓存请求下来的数据，可以在首次显示时先用本地数据，再请求更新，这都由前端 JS 控制。 这些缓存策略可以实现 JS/CSS 等资源文件以及用户数据的缓存的全缓存，可以做到每次都直接使用本地缓存数据，不用等待网络请求。但 HTML 文件的缓存做不到，对于 HTML 文件，如果把 Expires / max-age 时间设长了，长时间只使用本地缓存，那更新就不及时，如果设短了，每次打开页面都要发网络请求询问是否有更新，再确定是否使用本地资源，一般前端在这里的策略是每次都请求，这在弱网情况下用户感受到的白屏时间仍然会很长。所以 HTML 文件的“缓存”和跟“更新”间存在矛盾。 HTML 缓存桌面时代受限于浏览器，H5 页面无法做更多的优化，现在 H5 页面是内嵌在客户端 APP 上，客户端有更多的权限，于是客户端上可以超出浏览器的范围，做更多的优化。在缓存方面，在客户端也有更自由的缓存策略，客户端可以拦截 H5 页面的所有请求，由自己管理缓存，针对上述 HTML 文件的“缓存”和“更新”之间的矛盾，我们可以用这样的策略解决： 在客户端拦截请求，首次请求 HTML 文件后缓存数据，第二次不发请求，直接使用缓存数据。 什么时候去请求更新？这个更新请求可以客户端自由控制策略，可以在使用本地缓存打开本地页面后再在后台发起请求询问更新缓存，下次打开时生效；也可以在 APP 启动时或某个时机在后台去发起请求预更新，提升用户访问最新代码的几率。 这样看起来已经比较完美了，HTML 文件在用客户端的策略缓存，其余资源和数据沿用上述前端的缓存方式，这样一个 H5 页面第二次访问从 HTML 到 JS/CSS/Image 资源，再到数据，都可以直接从本地读取，无需等待网络请求，同时又能保持尽可能的实时更新，解决了缓存问题，大大提升 H5 页面首屏启动速度。 上述方案似乎已完整解决缓存问题，但实际上还有很多问题： 没有预加载：第一次打开的体验很差，所有数据都要从网络请求。 缓存不可控：缓存的存取由系统 webview 控制，无法控制它的缓存逻辑，带来的问题包括： i. 清理逻辑不可控，缓存空间有限，可能缓存几张大图片后，重要的 HTML/JS/CSS 缓存就被清除了。 ii.磁盘 IO 无法控制，无法从磁盘预加载数据到内存。 更新体验差：后台 HTML/JS/CSS 更新时全量下载，数据量大，弱网下载耗时长。 无法防劫持：若 HTML 页面被运营商或其他第三方劫持，将长时间缓存劫持的页面。 这些问题在客户端上都是可以被解决的，只不过有点麻烦，简单描述下： 可以配置一个预加载列表，在APP启动或某些时机时提前去请求，这个预加载列表需要包含所需 H5 模块的页面和资源，还需要考虑到一个H5模块有多个页面的情况，这个列表可能会很大，也需要工具生成和管理这个预加载列表。 客户端可以接管所有请求的缓存，不走 webview 默认缓存逻辑，自行实现缓存机制，可以分缓存优先级以及缓存预加载。 可以针对每个 HTML 和资源文件做增量更新，只是实现和管理起来比较麻烦。 在客户端使用 httpdns + https 防劫持。 上面的解决方案实现起来十分繁琐，原因就是各个 HTML 和资源文件很多很分散，管理困难，有个较好的方案可以解决这些问题，就是离线包。 离线包既然很多问题都是文件分散管理困难引起，而我们这里的使用场景是使用 H5 开发功能模块，那很容易想到把一个个功能模块的所有相关页面和资源打包下发，这个压缩包可以称为功能模块的离线包。使用离线包的方案，可以相对较简单地解决上述几个问题： 可以预先下载整个离线包，只需要按业务模块配置，不需要按文件配置，离线包包含业务模块相关的所有页面，可以一次性预加载。 离线包核心文件和页面动态的图片资源文件缓存分离，可以更方便地管理缓存，离线包也可以整体提前加载进内存，减少磁盘 IO 耗时。 离线包可以很方便地根据版本做增量更新。 离线包以压缩包的方式下发，同时会经过加密和校验，运营商和第三方无法对其劫持篡改。 到这里，对于使用 H5 开发功能模块，离线包是一个挺不错的方案了，简单复述一下离线包的方案： 后端使用构建工具把同一个业务模块相关的页面和资源打包成一个文件，同时对文件加密/签名。 客户端根据配置表，在自定义时机去把离线包拉下来，做解压/解密/校验等工作。 根据配置表，打开某个业务时转接到打开离线包的入口页面。 拦截网络请求，对于离线包已经有的文件，直接读取离线包数据返回，否则走 HTTP 协议缓存逻辑。 离线包更新时，根据版本号后台下发两个版本间的 diff 数据，客户端合并，增量更新。 更多优化离线包方案在缓存上已经做得差不多了，还可以再配上一些细节优化： 公共资源包每个包都会使用相同的 JS 框架和 CSS 全局样式，这些资源重复在每一个离线包出现太浪费，可以做一个公共资源包提供这些全局文件。 预加载数据理想情况下离线包的方案第一次打开时所有 HTML/JS/CSS 都使用本地缓存，无需等待网络请求，但页面上的用户数据还是需要实时拉，这里可以做个优化，在 webview 初始化的同时并行去请求数据，webview 初始化是需要一些时间的，这段时间没有任何网络请求，在这个时机并行请求可以节省不少时间。 具体实现上，首先可以在配置表注明某个离线包需要预加载的 URL，客户端在 webview 初始化同时发起请求，请求由一个管理器管理，请求完成时缓存结果，然后 webview 在初始化完毕后开始请求刚才预加载的 URL，客户端拦截到请求，转接到刚才提到的请求管理器，若预加载已完成就直接返回内容，若未完成则等待。 Fallback如果用户访问某个离线包模块时，这个离线包还没有下载，或配置表检测到已有新版本但本地是旧版本的情况如何处理？几种方案： 简单的方案是如果本地离线包没有或不是最新，就同步阻塞等待下载最新离线包。这种用户打开的体验更差了，因为离线包体积相对较大。 也可以是如果本地有旧包，用户本次就直接使用旧包，如果没有再同步阻塞等待，这种会导致更新不及时，无法确保用户使用最新版本。 还可以对离线包做一个线上版本，离线包里的文件在服务端有一一对应的访问地址，在本地没有离线包时，直接访问对应的线上地址，跟传统打开一个在线页面一样，这种体验相对等待下载整个离线包较好，也能保证用户访问到最新。 第三种 Fallback 的方式还带来兜底的好处，在一些意外情况离线包出错的时候可以直接访问线上版本，功能不受影响，此外像公共资源包更新不及时导致版本没有对应上时也可以直接访问线上版本，是个不错的兜底方案。 上述几种方案策略也可以混着使用，看业务需求。 使用客户端接口网路和存储接口如果使用 webkit 的 ajax 和 localStorage 会有不少限制，难以优化，可以在客户端提供这些接口给 JS，客户端可以在网络请求上做像 DNS 预解析/IP直连/长连接/并行请求等更细致的优化，存储也使用客户端接口也能做读写并发/用户隔离等针对性优化。 服务端渲染早期 web 页面里，JS 只是负责交互，所有内容都是直接在 HTML 里，到现代 H5 页面，很多内容已经依赖 JS 逻辑去决定渲染什么，例如等待 JS 请求 JSON 数据，再拼接成 HTML 生成 DOM 渲染到页面上，于是页面的渲染展现就要等待这一整个过程，这里有一个耗时，减少这里的耗时也是白屏优化的范围之内。 优化方法可以是人为减少 JS 渲染逻辑，也可以是更彻底地，回归到原始，所有内容都由服务端返回的 HTML 决定，无需等待 JS 逻辑，称之为服务端渲染。是否做这种优化视业务情况而定，毕竟这种会带来开发模式变化/流量增大/服务端开销增大这些负面影响。手Q的部分页面就是使用服务端渲染的方式，称为动态直出，见文章。 参考： WebView性能、体验分析与优化 移动 H5 首屏秒开优化方案探讨 70%以上业务由H5开发，手机QQ Hybrid 的架构如何优化演进？","categories":[{"name":"性能优化","slug":"性能优化","permalink":"http://heseng91.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"「性能优化」之包体大小","slug":"「性能优化」之包体大小","date":"2018-12-04T08:30:33.000Z","updated":"2022-07-25T19:30:01.474Z","comments":true,"path":"2018/12/04/「性能优化」之包体大小/","link":"","permalink":"http://heseng91.github.io/2018/12/04/%E3%80%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8B%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F/","excerpt":"安装包大小是 App 重要的基础体验指标之一，与新用户转化直接相关。本文内容包括苹果的对包大小的限制等背景介绍、安装包分析和一些优化措施等。阅读本文之后，你将对安装包优化有一个整体的认知。","text":"安装包大小是 App 重要的基础体验指标之一，与新用户转化直接相关。本文内容包括苹果的对包大小的限制等背景介绍、安装包分析和一些优化措施等。阅读本文之后，你将对安装包优化有一个整体的认知。 背景下载大小限制App 大小有下载大小和安装大小的概念。 下载大小是指 App 压缩包（也就是 .ipa 文件）所占的空间，用户在下载 App 时，下载的是压缩包，这样做可以节省流量；当压缩包下载完成后，就会自动解压，解压过程也就是通常所说的安装过程；安装大小就是指压缩包解压后所占用的空间。 安装大小在 App Store 上就可以看见 ，通常它会影响用户的下载意愿。而下载大小只有研发人员在 App Store Connect 后台才可以看，用户看不见，它影响的是下载消耗的流量和时长。若下载大小超过限制，将无法使用蜂窝网络下载 App（ iOS 13 之前），会收到文件容量太大的提示，需通过 Wi-Fi 网络下载。如下，为苹果历年来对 App 下载大小限制的变化情况： 2008 年 7 月，搭载了 App Store 的 iPhone 3G 正式发售，下载限制仅为 10 MB 2010 年 2 月，苹果将 iPhone 3G 的下载限制从 10 MB 提升到 20 MB 2012 年 3 月，iOS 5.1 正式版后，下载限制从 20 MB 提升到 50 MB 2013 年 9 月，iOS 7 正式版后，下载限制从 50 MB 提升至 100 MB 2017 年 9 月，iOS 11 正式版后，下载限制从 100 MB 提升至 150 MB 2019 年 5 月，下载限制从 150 MB 提升至 200 MB 2019 年 9 月，iOS 13 正式版后，若下载大小超过 200 MB，用户可选择是否使用蜂窝网络下载 如今，App 下载大小超出 200 MB 时 ，会出现两种情况： iOS 13 以下的用户，无法通过蜂窝数据下载 App iOS 13 及以上的用户，需要手动设置才可以使用蜂窝网络下载 App 可见下载大小若超出 200 MB，就会对用户新增会有一定影响，因此下载大小 200 MB 是包大小的一根红线。 可执行文件大小限制根据最大构建版本文件大小描述，苹果对可执行文件大小亦有明确限制，超过该限制会导致 App 审核被拒： 12ERROR: ERROR ITMS-90122: &quot;Invalid ExecutaBe Size. The size of your app&#39;s executaBe file &#39;News.app&#x2F;News&#39; is 68534272 bytes for architecture &#39;arm64&#39;, which exceeds the maximum allowed size of 60 MB.&quot;复制代码 具体限制如下： iOS 7 之前，二进制文件中所有的 __TEXT段总和不得超过 80 MB iOS 7.X 至 iOS 8.X ，二进制文件中，每个特定架构中的 __TEXT段不得超过 60 MB iOS 9.0 之后，二进制文件中所有的 __TEXT段总和不得超过 500 MB 安装包分析本文探讨的是优化，说到优化最重要的是要做到白盒优化，知道安装包的构成，才能针对性的进行优化。 安装包构成对通过 Archieve 打包的安装包 unzip 解压之后，就能看到 payload 中 app 文件的数据，\b整理归类后其大致如下： Exectutable: 可执行文件 Resources：资源文件 图片资源：Assets.car/bundle/png/jpg 等 视频/音频资源：mp4/mp3 等 静态网页资源：html/css/js 等 视图资源：xib/storyboard 等 其他：文本/字体/证书 等 Framework：项目中使用的动态库 SwiftSupport: libSwiftxxx 等一系列 Swift 库 其他依赖库：Embeded Framework Pulgins：Application Extensions appex：其组成大致与 ipa 包组成一致 从以上结构中可以看出一个 ipa 包\b大致由 Executable, Resources, Framework,Plugins 四大模块组成，\b接下来我们就从这四个方向来探讨 App 瘦身的\b具体方案。 安装包分析通过分析安装包，了解安装包中可执行文件占用大小、资源占用大小，了解安装包的现状。才能明确从哪里入手可以获得 ROI 最高的优化手段。 而在做包大小分析过程中比较难的是，怎么样通过线下的安装包衡量对下载大小的影响。 App Slicing鉴于早期网络的不普及和比较高的流量费用，苹果对下载大小和可执行文件大小有着上文所述的限制。于此同时，为了提升用户体验和节省用户流量，苹果也为 App安装包大小提供了很多优化方式。 iOS 9 中引入的 App Thinning 中提到过 Slicing 的技术，当我们把一个完整的安装包提交给 AppStore Connect后，Apple 会为不同的设备准备不同的变体（Variant），设备的在下载 App 的时候它能根据设备的处理器架构（arm64, armv7）、屏幕分辨率（2x, 3x）、iOS 系统版本等信息，帮助我们自动选择合适的 Variant 进行下载。 可执行文件的 Slicing 技术就是对不同架构进行裁剪，只剩下单架构可执行文件。同样资源文件也是支持 Slicing 的。比如 iPhone 6 下载的安装包中就只会包含 2x 图，iPhone 6 Plus 下载的安装包就只会包含 3x 图，但是只有使用 asset catelogs(也就是 XCAssets) 管理的资源才支持 Slicing，所以尽量还是使用 XCAsset 来管理资源图片。同时 XCAsset 也支持 PDFs 矢量图，在上传到 AppStore Connect之后，会根据矢量图自动生成 1x, 2x, 3x 图，然后进行 Slicing。 加密除了上述调整之外，安装包被提交到 AppStore Connect后，出于安全考虑，苹果还会对安装包的二进制部分TEXT 段通过 FirePlay 进行加密，加密会导致 TEXT 段的压缩比为 1（ iOS 13+ 以上设备下载变体中苹果移除了这个加密 ）。 这些调整也导致了线下安装包的变化无法对应到真正的下载大小变化的变更，很难用线下构建的安装包来量化最终对下载大小的影响。想要查看不同机型的安装包下载大小，只能打包上传AppStore Connect后查看。 可执行文件瘦身安装包中的可执行文件，占了安装包中很大一部分空间，而这部分不光和代码有关还和编译、链接过程中添加的参数，编译的机器环境、Xcode 版本等等都有关系。 编译选项编译期优化参数Xcode 支持编译器层面的一些优化选项，可以让我们介于更快的编译速度和更小的二进制大小并且更快的执行速度之间自由选择想要进行的\b优化粒度。 我们都知道 Xcode 是使用 Clang 来编译 Objective-C 语言的，\bClang 的优化选项在其文档 clang - Code Generation Options 中可以查阅得到。我们Xcode 目前提供给我们 7 个等级的编译选项，在 Xcode -&gt; Build Setting -&gt; Apple clang - Code Generation -&gt; Optimization Level 中进行设置\b，每个等级的说明，可以参考\b官方文档： None[-O0]: 编译器不会优化代码，\b意味着更快的编译速度和更多的调试信息，默认在 Debug 模式下开启。 Fast[-O,O1]: 编译器会优化代码性能并且最小限度影响编译时间，此选项在编译时会\b占用更多的内存。 Faster[-O2]：编译器会开启不依赖空间/时间折衷所有优化选项。在此，编译器不会展开循环或者函数内联。此选项会增加编译时间并且提高代码执行效率。 Fastest[-O3]：编译器会开启所有的\b优化选项来提升代码执行效率。此模式\b编译器会执行函数内联使得生成的可执行文件变得更大。一般不推荐使用此模式。 Fastest Smallest[-Os]：编译器会开启除了会明显增加包大小以外的所有优化选项。默认在 Release 模式下开启。 Fastest, Aggressive Optimization[-Ofast]：启动 -O3 中的所有优化\b，可能会开启一些违反语言标准的一些优化选项。一般不推荐使用此模式。 Smallest, Aggressive Optimization[-Oz]：编译器会对单个编译单元中跨函数的相同代码序列外联成函数进行复用，和“内联函数”的原理正好相反。每个原始代码序列都被替换为调用该 Outlined 函数。会减小相同代码存在多份问题。开启此模式\b，能减小二进制的大小，但同时也会使得的函数调用存在更深的调用栈，理论上会带来执行效率的额外消耗，对性能（CPU）敏感的代码使用需要评估。WWDC 2019 《What’s New in Clang and LLVM》 中对 Oz 有过介绍。 Fastest Smallest[-Os] 极小\b限度会影响到包大小，而且也保证了\b代码的执行效率，是最佳的发布选项。一般 Xcode 会在 Release 下默认选择 Fastest Smallest[-Os] 选项，较老的项目可能没有自动勾选。 XCode 中设置的选项最终会反应在 Clang 命令上面，打开 build log 可以看到此选项最终的表现形式： 如果你还需要 clang 的其他选项来编译你的项目，可以在 Other C Flag 中直接添加其参数。\b举例来说，在 Optimization Level 中设置 Fastest Smallest[-Os] 和在 Other C Flags 中添加 -Os 效果是一样的。 对执行效率、堆栈解析、稳定性和编译速度进行综合评估后，如果可以接受，可以对部分源代码开启Oz 编译，以最大程度优化安装包效果。 需要注意的是在 ARC 场景 objc_retainAutoreleaseReturnValue 被外联之后会导致一个本来不需要被放入 autoreleasepool 中的对象被放入了 autoreleasepool。这将导致一些有问题的写法出现更坏的结果比如出现延迟释放导致 BAD_ACCESS 或者被 @autoreleasepool包裹的对象延时释放导致的内存暴涨，所以在开启的时候需要进行测试。 链接期优化参数除了编译期优化，Xcode 还支持链接器层面的一些优化选项，可以在 Xcode -&gt; Build Setting -&gt; Apple clang - Code Generation -&gt; Link-Time Optimization 中进行设置。目前Xcode提供了以下选项： No：不开启链接期优化； Monolithic：生成单个 LTO 文件，每次链接重新生成，无缓存高内存消耗，参数 LLVM_LTO=YES； Incremental：生成多个 LTO 文件，增量生成，低内存消耗，参数 LLVM_LTO=YES_THIN； 本地调试和对时间敏感的构建流程不建议开启 LTO。会增加很多的构建时间。 需要注意的是 LTO 虽然是链接期优化，但是仍然需要编译期参与，加入了 LTO 的编译出来的 .a 本质是 LLVM 的 BitCode，如果使用未开启 LTO 构建出来的的 .a 直接是机器码了。直接链接是无法完成 LTO 优化的。 开启 LTO 之后跨编译单元的重复代码会被链接器单独生成以 .lto.o为后缀的目标文件进行链接。尤其是对于 Objc Runtime 需要的一些结构 比如方法签名的 literal string， protocol 的结构等有比较大的优化。同时开启 Oz 和 LTO 可以让外联函数都只存在一份能够最大限度的优化安装包体积。如果你的项目中大量的使用了 Protocol 建议还是开启这个选项。 BitCodeBitCode 是 iOS 9 引入的新特性，官方文档解释 BitCode 是一种程序中间码，其实就是 LLVM IR 的一种编码形式 - BitCodeFormart。 上图\b表示了 IR 和 BitCode 在编译器架构中所在的位置，需要说明的是 BitCode 是以 section 形式保存在可执行文件中。上文中提到的可执行文件的 Slicing 技术就是基于BitCode。当我们把携带 BitCode 的 App 提交到 AppStore 后，苹果会提取出可执行文件中的 BitCode 段，然后针对不同的 CPU 架构编译\b和链接成不同的可执行文件变体(Variant)，不同\b CPU 架构的设备会自动选择合适的架构的变体进行下载。而在 BitCode 之前，我们都是把所有需要的 CPU 架构集合打包成一个 Fat Binary，结果就是用户最终下载的安装包之中有很多冗余的\b CPU 架构支持\b代码。 从以上\b编译器\b架构中我们也可以得出一个结论：开启 BitCode 之后编译器后端(Backend)的工作都由 Apple 接管了。所以\b假如以后苹果推出了新的 CPU 架构或者以后 LLVM 推出了一系列优化，我们也不再需要为其发布\b新的安装包了。 需要注意的是，工程开启 BitCode 之后必须要求所有打进 Bundle 的 Binary 都需要支持 BitCode，也就是说我们\b依赖的静态库\b和动态库都是含有 BitCode 的，不然就会打包失败。 符号表的裁剪可执行文件中的符号是指程序中的所有的\b变量、类、函数、枚举、变量\b和地址映射关系，以及一些在调试的时候使用到的用于定位代码在源码中的位置的调试符号，符号和断点定位以及\b堆栈符号化有很重要的关系\b。 Strip StyleStrip Style 表示的是我们需要去除的符号的类型的选项，其分为三个选择项： All Symbols: 去除所有符号，一般是在主工程中开启。 Non-Global Symbols: 去除一些非全局的 Sy\bmbol（保留全局符号，Debug Symbols 同样会被去除），链接时会被重定向的那些符号不会被去除，此选项是静态库/动态库的建议选项。 Debug Symbols: 去除调试符号，去除之后将无法断点调试。 对于 App 的主二进制而言，对外是不需要暴露符号信息的。而对外暴露的符号名称对 App 整体安全来讲也存在一些风险。通常通过设置 STRIP_STYLE= all来裁剪所有符号。对于自己构建的动态库。只需要保留未定义的符号以及全局的符号其他的都可以去除。通常设置：STRIP_STYLE=non-global。 调试\b符号（symbols）iOS 的调试\b符号是 DWARF 格式的，相关概念如下： Mach-O: 可执行文件，源文件编译链接的结果。包含映射调试信息(对象文件)具体存储位置的 Debug Map。 DWARF：一种通用的调试文件格式，支持源码级别的调试，调试信息存在于 Object_file 中，一般都比较大。Xcode 调试模式下一般都是使用 DWARF 来\b进行符号化的。 dSYM：独立的\b符号表文件，主要用来做发布产品的崩溃符号化。dSYM 是一个压缩包，里面包含了 DWARF 文件。 使用 Xcode 编译打包的时候会先通过可执行文件的 Debug Map 获取到所有对象文件的位置，然后使用 dsymutil 来将对象文件中的 DWARF 提取出来生\b成 dSYM 文件。 Strip Linked Product If enabled, the linked product of the build will be stripped of symbols when performing deployment postprocessing. 并不是所有的符号都是必须的，比如 Debug \bMap，所以 Xcode 提供给我们 Strip Linked Product 来去除不需要的符号信息(Strip Style 中选择的选项相应的符号)，去除了符号信息之后我们就只能使用 dSYM 来进行符号化了，\b所以需要\b将 Debug Information Format 修改为 DWARF with dSYM file。 那么没有 DWARF 调试信息之后 Xcode 是靠什么来生成 dSYM 的呢？答案其实还是 DWARF，\b因为 Xcode \b编译实际的操作步骤是：生成带有 DWARF 调试信息的可执行文件 -&gt; 提取可执行文件中的调试信息\b打包成 dSYM -&gt; 去除符号化信息。去除符号是单独的步骤，使用的是 strip 命令。 另外一个问题是，去除符号化信息之后我们只能使用 dSYM 来进行符号化，那我们使用 Xcode 来进行调试的时候会不会太麻烦\b了？其实我们完全不用担心这个问题：Strip Linked Product 选项在 Deployment Postprocessing \b设置为 YES 的时候才生效，而\b在 Archive 的时候 Xcode 总是会把 Deployment Postprocessing 设置为 YES 。所以我们可以打开 Strip Linked Product 并且\b把 Deployment Postprocessing 设置为 NO\b，而不用担心调试的时候会影响断点和符号化，同时打包的时候又会自动去除符号信息。这个选项也是默认打开的，较老的项目可以选择手动开启。 Strip Debug Symbols During Copy Specifies whether binary files that are copied during the build, such as in a Copy Bundle Resources or Copy Files build phase, should be stripped of debugging symbols. It does not cause the linked product of a target to be stripped—use Strip Linked Product (STRIP_INSTALLED_PRODUCT) for that. \b与 Strip Linked Product 类似，但是这个是将那些拷贝进项目包的三方库、\b资源或者 Extension 的 Debug Symbol 去除掉，同样也是使用的 strip 命令。\b\b这个选项没有前置条件，所以我们只需要在 Release 模式下开启，不然就不能对\b三方库进行断点调试和符号化了。 如果依赖的 Target 是独立签名的（比如 App Extension），\bstrip 操作就会失效，\b并伴随着 Warning：warning: skipping copy phase strip, binary is code signed: xxxx。此情况将依赖的 Target 中的 Strip Linked Product 修改为 YES，保证依赖的 Target 是\b已经去除了符号即可，Waning 忽略掉就可以了。 Cocoapods 管理的动态库(use_framework!)的情况就相对要特殊一点，因为 Cocoapods 中的的动态库是使用自己实现的脚本 Pods-xxx-frameworks.sh 来实现拷贝的，所以并不会走 Xcode 的流程，当然也就不受 Strip Debug Symbols During Copy 的影响。当然 Cocoapods 是源码管理的，所以只需要将源码 Target 中的 Strip Linked Product 设置为 YES 即可。 Strip Swift Symbols Adjust the level of symbol stripping specified by the STRIP_STYLE setting so that when the linked product of the build is stripped, all Swift symbols will be removed. 开启 Strip Swift Symbols 能\b帮助我们移除相应 Target \b中的所有的 Swift 符号，\b这个选项也是默认打开的。 补充一点：Swift ABI 稳定之前，Swift 标准库是会打进目标文件的，想要同时移除 Swift 标准库\b里面的符号的话需要在发布选项中勾选 Strip Swift symbols。 修正 Exported Symbols 配置上面说到可以通过设置 STRIP_STYLE= all来裁剪所有符号。但通过： 1objdump -exports-trie &#x2F;path&#x2F;to&#x2F;MyApp.app&#x2F;MyApp 还能获取到可执行文件中的符号，这部分可以通过设置 EXPORTED_SYMBOLS_FILE为一个空文件解决 EXPORTED_SYMBOLS_FILE=/path/to/emptyfile.txt。 Xcode Build Settings 中的 EXPORTED_SYMBOLS_FILE配置，控制着 Mach-O 中 __LINKEDIT段中 Export Info 的信息。动态链接器 dyld 在做符号绑定时，会读取被绑定的动态库或可执行文件的 Export Info 信息，得到一个符号对应的实际调用地址。如果正在被绑定的符号，在目标动态库的 Export Info 中缺失，dyld 则会抛出异常，表现为 App 崩溃。 虽然从原理上看，Export Info 中的信息不可或缺。但是，对于一个 Mach-O 文件来说，并非所有的符号都是需要暴露给其他动态库或可执行文件的。理想情况下，私有的符号应该在编码时就应该以 __attribute__((visibility(hidden)))修饰。但在历史代码难以逐个添加修饰符的情况下，Exported Symbols 配置给了工程一个维护公有符号白名单的机会。如果填写了有效的 EXPORTED_SYMBOLS_FILE配置，动态库或者可执行文件会在静态链接时去掉白名单以外的符号，起到缩减包大小、增加逆向难度的作用。 死代码裁剪在构建完成之后如果是 C、C++ 等静态的语言的代码、一些常量定义，如果发现没有被使用到将会被标记为 Dead code。开启 DEAD_CODE_STRIP = YES这些 Dead code 将不会被打包到安装包中。在 LinkMap 这些符号也会被标记为 &lt;&lt;dead&gt;&gt;。 清理无用代码扫描无用代码方式可以分为动态和静态两种方式。静态的方式主要是通过代码扫描、参与编译构建过程或者分析最终产物来确认哪些代码没有被用到。而动态的方式主要是靠插桩或者运行时信息来获取哪些代码没有执行。由于 Objc 强大的动态特性，我们在样本量足够大的场景使用动态方式会比静态方式准确率高很多。 静态筛查筛查方案： 最简单的静态扫描是基于 AppCode，但是项目大了之后 AppCode 的索引速度非常慢。另一种方式是基于 Mach-O 的的一种静态扫描方式，在 otool dump 最终产物中的 objc_class_list &amp; objc_class_refs 做差集找到未使用的 Objc 类。 上面提到，如果代码采用 C 、C++ 等静态语言编写代码时，编译期已经确定了基本的代码逻辑，编译器会帮助我们将没有使用到的代码标记为 Dead code 并裁剪，最终不会打包到安装包中。但 Objc 是典型的动态语言，很多逻辑都是在运行时决议的，我们通过静态扫描的方式扫描出来的误差会比较大。 Objc 动态特性引入的的主要的问题包括： 实际用到了但被扫描成无用类： 一个类确实没有被其他地方使用， 但是本身逻辑依赖 +load、+initialize、__attribute__((constructor))在启动时调用 通过 string 动态调用 抽象基类、基类等会被认为是无用类 通过运行时动态生成的代码引用了某个类 一个类专门作为通知处理类 MTLModel 等，通过运行时消息机制 assign value 的无法通过 classref 统计 典型的 DI 场景。如果一个类声明遵循了某个 Protocol，外部使用的时候使用了这个 Protocol 进行方法调用 实际没用到但被认为有用到： 某个对象被另外一个对象引用，但是另外一个对象本身未被使用到。这时候会遗漏掉这个对象所属 Class 的检查 动态筛查方案： 基于插桩的行级别代码覆盖率 基于 GCOV 或者 LLVM Profile 二进制的插桩方案可以实现在运行时收集插桩数据来指导无用代码的删除。但插桩方案局限性也显而易见，插桩会劣化二进制本身的大小和性能，同时原生的插桩方案是无法过审上线。数据收集只能局限于线下。 基于 Runtime 的轻量级运行时「类覆盖率」方案 Objc 的类首次调用类初始化时，+initialize被执行，系统会自动标记已被调用，在 metaClass 中 data 的 flags 字段第 29 位就存着这个这个状态。可以使用 flags &amp; RW_INITIALIZED获取。iOS14 之后这个值的获取方式有变化。具体参考：WWDC：Advancements in the Objective-C runtime 1234#define RW_INITIALIZED (1&lt;&lt;29)bool isInitialized() &#123; return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;&#125; 上报的数据可以让我们了解我们线上真实的 Class 使用情况，对得到的数据不仅可以用来删减未使用的代码。还可以分辨使用率低的场景，如果是低频且必须的场景可以考虑使用跨端技术这种对原生包大小影响比较小的方案实现。而如果这些场景是某个渗透率很低的需求可以考虑直接下线为其他需求做置换。 重构重复代码重复代码堆积太多，不仅意味着 Bad Code Smell，我们的包大小也会受到影响。如果没有开启-Oz编译选项，我们可以使用 PMD 来\b检查项目中的重复代码然后做选择性的重构。 属性动态化属性是 OC 中最常见的概念之一。然而，一个属性并没有我们想象的这么小。通过分析 Mach-O 文件，我们发现，一个属性可以分为三个部分： （1）成员变量部分：成员变量本质是一个大小 32B 的结构体，结构体中三个指针（Offset、Name、Type）指向的内容的大小分别为 8B、10B、10B，其中 Name、Type 指针指向的内容的大小和成员变量的类型、名字长度相关。总大小大约 60B。 12345@interface presentViewController ()@property (nonatomic,strong) UIImageView *imageView;@property (nonatomic,strong) UIButton *button;@property (nonatomic,strong) NSString *name;@end （2）自动生成的 set/get 方法部分：set/get 方法本质是一个大小 24B 的结构体，结构体包含三个指针 Name、Type、Implementation，指向的内容大小大概为 10B、10B、20B。一个方法大小大概是64B，set、get 两个方法就是 128B。 （3）property 部分：property 的本质仍然是个结构体，大小是 16B，结构体中两个指针指向内容的大小分别大概是 10B、10B，和属性的名字和类型相关。总大小大概 36B。 即一个属性占用的包大小大约为 224B。 如果我们用 @dynamic修饰一个属性，不生成成员变量、get/set 方法，则一个属性可以由 224B 减少到 36B，即仅包含 property 部分的大小。 同时，代码中存在大量通过脚本自动生成的 JSONModel子类，这些子类往往拥有大量属性。这里也就存在着包大小优化空间。 于是我们通过修改生成 JSONModel子类的脚本，实现了： 1、属性全部使用 @dynamic修饰，基础变量额外生成 IVAR 2、所有 JSONModel的子类继承自新的父类，新的父类实现 resolveInstanceMethod，在该方法中用 class_addMethod统一为属性添加 get/set 方法。对象类型的属性使用关联对象的方式存取，基础类型的属性使用额外生成的 IVAR 存取。 __TEXT 段迁移安装包经过压缩后的 Download Size 若超过 200 MB，在蜂窝网络下载 App 就会受到限制，这对新增会有较大影响。在 2020 年下半年，我们探索实践了 TEXT 段迁移技术：在链接阶段使用 -rename_section选项将 `TEXT,text迁移到BD_TEXT,__text`，减少苹果对可执行文件的加密范围，提升可执行文件的压缩效率，从而减少 Download Size。 使用该方案我们最终减少了 60 MB 的 Download Size 以及 2 MB 的 Install Size。详细的原理可以参考：《今日头条优化实践： iOS 包大小二进制优化，一行代码减少 60 MB 下载大小》 二进制段压缩Mach-O 文件占据了 Install Size 中很大一部分比例，但并不是文件中的每个段/节在程序启动的第一时间都要被用到。可以在构建过程中将 Mach-O 文件中的这部分段/节压缩，然后只要在这些段被使用到之前将其解压到内存中，就能达到了减少包大小的效果，同时也能保证程序正常运行。由于苹果的一些限制，推荐只压缩了 __TEXT,__gcc_except_tab与 __TEXT,__objc_methtype两个节，然后在 _dyld_register_func_for_add_image的回调中对它进行解压。 资源文件瘦身无用资源的移除未使用的资源可以使用脚本来进行删除。强烈推荐使用 FengNiao 来自动删除图片，\b因为其相对比较新，是 2017 年开始\b开发的，并且是使用 swift 语言开发的，方便进行二次开发\b。FengNiao 的基本原理是查找出项目中所有使用到的字符串和项目中所有的资源文件。两者进行匹配（完全匹配和模式匹配，模式匹配支持带数字资源的前缀/中缀/后缀匹配），计算差集就为\b未使用的资源。 相比于之前流行的 LSUnusedResources，FengNiao 支持模式匹配会更加强大：比如我们导入 image_01 image_02 image_03 这样的图片资源作为帧动画素材，使用的时候是 image_%d 或者 image_(index) 方式，FengNiao 会把这些图片资源作为使用中的资源，不会出现误删的情况。当然如果你还是用了其他 Pattern，可以考虑扩展 FengNiao。 除了这些之外，FengNiao 是命令行工具，我们可以给 Xcode 添加 Run Script，在每次构建的时候自动检测/清理未使用的资源。 由于基于源码的扫描工具结果不是百分百准确的，所以建议最好的做法是在项目编译的时候提供出显式的 Warning，然后再次确认之后\b再去删除。同时也可以配合资源命名规范来优化工具，如果你们的命名规范和工具的检测规范能够保持一致的话，搜索的结果无疑是最为准确的。 之所以要使用自动化工具来检测重复资源的原因是因为资源是\b弱类型，我们在项目迭代过程\b中手动去维护是相当麻烦的一个过程。转换一下思维，如果资源变成强类型了，\b那我们维护起来就相当容易了。目前就有这样一个工具-R.swift，\b类似于 Android \b开发中的 R 文件，有兴趣的可以去尝试。 去除重复资源这里所说的重复资源是\b资源内容相同但是命名不相同的一些资源，对于此类资源，\b我们可以使用 fdupes 来进行扫描并去除，fdupes 的原理\b\b是对比不同文件的签名，签名相同的文件就会判定为重复资源。 然后我们就\b可以在 Xcode 中添加 Run Script，对于扫描到的相同的资源，我们可以显式的报出 Warning，然后我们在开发阶段解决资源重复的问题。 资源文件动态化可以将一些低频场景下的资源放到云端，在进入 app 安装之后再去云端按需获取。 ODR 的资源获取方案Apple 提供了按需资源（On-Demand Resource）的方式来帮助减小安装包首次下载的大小, 当有一些由于审核原因必须要内置在安装包中，但又可以走下发的情况可以尝试以下这种解决方案。当然 ODR 中的资源也需要符合 App Store 的审核标准，否则也会存在拒审风险。 资源压缩当我们一定要在安装包内置某个资源的话，应该在可接受的范畴之内，尽可能的小。比如我们安装包中内置的视频、音频资源可以采用降低清晰度、码率等等方式进行压缩。iOS 原生的多语言方案比较消耗空间，可以考虑自研更加紧凑的方案。 使用 RGB with palette 压缩图片做过包体优化的话，你可能会发现，如果对 Asset Catalog 中的 png 图片做无损压缩，虽然放入 Asset Catalog 的图片大小有了明显减小，但是构建的产物的大小却几乎没有变化。这是因为，Xcode 中，构建 Asset Catalog 的工具 actool 会首先对 Asset Catalog 中的 png 图片进行解码，得到 Bitmap 数据，然后再运用 actool 的编码压缩算法进行编码压缩处理。无损压缩通过变换图片的编码压缩算法减少大小，但是不会改变 Bitmap 数据。对于 actool 来说，它接收的输入没有改变，所以无损压缩无法优化 Assets.car 的大小。所以要优化 Assets.car 的大小，做合适的有损压缩是一个思路。 有损压缩可以尝试 RGB with palette 编码方式。RGB with palette 编码的得到的字节流首先维护了一个颜色数组。颜色数组每个成员用 RGBA 四个分量维护一个颜色。图像中的每个像素点则存储颜色数组的下标代表该点的颜色。颜色数组维护的颜色种类和数量由图片决定，同时可以人为的限制颜色数组维护颜色的种类的上限，默认为最大值 256 种。这种编码方式正如它的名字：palette（调色板）。 App 中大部分图片虽然使用了很多种类的颜色，但这些颜色中大多数都非常接近，从视觉上很难分辨，比如大量扁平风格的 icon。这种类型的图片非常适合用 palette 编码且减少颜色数组大小的方式来进行有损压缩，既能减少颜色数量实现有损压缩，也能保证保留的颜色贴近原始图片，使得经过有损压缩后的也看起来质量无损。 在具体执行中，我们使用了 ImageOptim 工具改变图片的编码方式为 RGB with palette ： 1imageoptim -Q --no-imageoptim --imagealpha --number-of-colors 16 --quality 40-80 ./1.png 其中 --number-of-colors控制颜色数组维护颜色的数量；--quality控制图片的质量变为原来的百分比。我们的经验表明，当 --number-of-colors从 16 开始向上调整，--quality维持 40-80，能够在显著减少包大小的同时维持肉眼看不到的质量变化。经过 UI 同学的像素眼审查，确认优化前后的图片看起来无差别。 Asset.car 中图片的优化Assets.car 编译过程中有时会选择一些图片，拼凑成一张大图（ZZZZPackedAsset）来提高图片的加载效率。被放进这张大图的小图会变为通过偏移量的引用。 建议使用频率高且小的图片放到 Asset.car 中，Asset.car 能保证其加载和渲染的速度最优。而大的图片比如背景图之类的，长宽尺寸就有上千个像素，而这种放到 Asset.car 中会大大的增加安装包的大小。建议实践中比如页面背景图，或者其他 png 格式超过 100KB 大小的图片都使用 WebP 的方式引入。相较于 PNG 格式，WebP 具有更加优秀的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量。 当我们在构建过程中，Xcode 会通过自己的压缩算法重新对图片进行处理。这也是为什么我们通过对图片无损压缩来优化包大小没有效果的原因。对于放入 Asset.car 中的图片如果图片没有半透明效果，使用 70% 的有损压缩是一个不错的方式，既能保证图片清晰度的同时获得更小的大小。如果对于有半透明效果的图片，采用 70% 的有损压缩会导致半透明的地方出现噪点，所以压缩过后的图片最好找设计师同学再确认一次。 我们通过对 Asset.car 进行了逆向研究，同一张图片，在不同设备、iOS 系统上 Xcode 采用了不同的压缩算法这也导致了下载时候不同的设备针对图片出现大小的区别。 截止目前 Xcode 会使用的压缩算法有 lzfse、palette_img、deepmap2、deepmap_lzfse、zip。 以 iPhoneX 为例子： iOS 11.x 版本：对应的压缩算法为 lzfse、zip； iOS 12.0.x - iOS 12.4.x: 对应的压缩算法为 deepmap_lzfse、palette_img； iOS 13.x: 对应的压缩算法为deepmap2； 按照压缩比来讲 lzfse&lt; palette_img~= deepmap_lzfse&lt; deepmap2。 我们可以使用 xcrun assetutil --info Assets.car 命令检查 Assets.car 中每张图片使用的编码压缩算法。在 BuildSetting 中如果设置了 ASSETCATALOG_COMPILER_OPTIMIZATION=space那么低版本的使用 lzfse压缩算法的图片会变成 zip的算法可减少 iOS11.x 及以下的 iOS 设备图片的占用大小。其他 iOS 版本的压缩算法不受这个配置的影响。 FrameworkFramework 文件夹存放的是 Embedded Framework，它\b在打包的时候最终会被拷贝进 Target App Bundle 中的 \bFramework 文件夹中，在 App 启动的时候才会被链接\b和加载。Embedded Framework 主要分类两类： SwiftSupport：Framework 文件夹中前缀是 libSwift 的一些 framework。之前版本，由于 Swift ABI 还未稳定，\b我们发布应用的时候还需要带上一份自己应用中使用到的 Swift 标准库代码，这部分占用最终\b ipa 的大小可能在 10M 左右。 其他依赖库：使用 Cocoapods 管理依赖并且设置\b了 user_framework! 时三方库源码都会打包成 framework，然后导入到工程当中。 Framework 中的\b资源 这里所说的 Framework 表示的是: 静态库(.a) Framework(Static Library) 目前绝\b大部分的 Framework 的做法是直接将资源放进 bundle 中进行管理的，在主工程打包的时候，Xcode 会将这部分资源直接拷贝进\b App Target Bundle 中，这样做就存在2个问题： 使用 bundle 管理的资源是不会被 Xcode 优化的(图片压缩等) 使用 bundle 管理的资源不享受 App Thinning/Slicing。 所以尽量还是选择 XCAsset 进行 Framework 的资源管理，静态库和动态库的管理方式有所不同： 静态库(.a)/Framework(Static Library): 静态库的目标文件(.a/.framework) 中\b是不能包含资源文件的，所以这部分只能使用 bundle 来管理。但是由于 bundle 直拷贝的特性，我们需要把 xib/storyboard/asset catalog 编译后的产物(nib/storyboardc/Asset.car)放进 bundle 里。比较普遍的一个做法是借助 Bundle Target 来编译我们的资源文件。 \b动态库: 动态库相对来说要简单一点，因为动态库本身就是一个 bundle。所以我们直接把资源文件放在目标文件(.framework)中就可以了。 如果你是使用 Cocoapods 管理你的源码，也可以使用 XCAsset 来管理资源，参考 在 Cocoapods\b \b中使用 XCAsset。 Framework 中的可执行文件这部分可以参考以上的可执行文件瘦身。 PluginsPlugin \b内部主要存放的就是 App Extension，App Extension 是独立打包签名，然后再拷贝进 Target App Bundle 的。 Plugin 中的静态库静态库最终会打包进可执行文件内部，所以\b如果 App Extension 依赖了\b三方静态库，\b同时主工程也引用了相同的静态库的话，最终 App 包中可能会包含两份三方静态库的体积。 Plugin 中的动态库动态库是在运行的时候才进行加载链接的，所以 Plugin 的动态库是可以和主工程共享的，把动态库的加载路径 Runpath Search Paths 修改为跟主工程一致就可以共享主工程引入的动态库。 Plugin 中的 Swift Standard Library在 Swift ABI 稳定之前，Swift 标准库会被拷贝进 App 当中。Swift 标准库是动态链接库，也是可以在主工程和其他的 App Extensions \b之间共享的，前提当然是\b所有 Target 使用的 \bSwift 版本是一致的，否则就会出现意料之外的 bug。 设置共享分为两步： 设置 Extension 中的 \bAlways Embed Swift Standard Libraries 为 NO，让编译器不再为 Extension 生成 Swift 标准库 设置 Extension 中的动态库的查找路径为主工程的 Framework 文件夹 防劣化的建设在优化之后，一定要做好防劣化的建设，尤其是业务迭代迅速的团队，否则很有可能优化的速度赶不上劣化。 各业务线对包大小占用的展示和监控一般大型项目都是分多个业务线，对各业务线代码占用状况进行摸底和监控，有助于从全局的角度了解头条的代码状况，找到“性价比”较低的模块。 进行“摸底和监控”的第一步，是需要展示出各业务线代码所占的安装包大小，即获得这些业务方向的代码，分别占用了多少安装包大小。 要统计代码对包大小的贡献，基本的方法是查看link map。网络上流行着一些分析link map的工具，可以查看每个类、每个静态库所占的大小。然而，如果app业务庞大，类众多（几千个），且主要功能都在主工程而非静态库中的话，展示每个类所占的二进制文件大小依然可读性较差，无法从中看出每个业务占用的大小。 那么如何将一个类归类到某个业务线呢？一种可行的方式，就是利用现成的数据：工程的目录结构。 通常项目中各个group的命名都能表明这个group属于哪个业务线。所以结合工程的目录结构，应该可以较方便的将一个类归类到某个业务线中去。通过编写脚本，可以按照工程目录的树形结构输出各个类、各个group的大小占用。脚本可以借助开源的ruby工具Xcodeproj读取工程目录，使用开源的python脚本linkmap.py读取link map，获得类和静态库的大小，最后进行整合，输出link map分析报表。 虽然工程中的类有几千个，但group的数目显然是非常有限的。人工的对一些group进行合计，我们可以轻松的获得各个业务线占用的二进制文件大小。 这些数据也可以成为了我们推动各业务线“删除冗余代码、下线废弃业务、为包大小优化作贡献”的依据。对于安装包大小占用特别大的业务，我们会优先进行包大小优化推动。 另外，通过观察link map分析报表，可以发现一些收益较低但代码颇多的业务并推动加速这类代码的下线。 在业务方对自身业务进行优化时，link map分析报表也具有指导性意义。业务方可以查看自己业务中哪些子方向相关的代码占用最多从而优先进行优化。 对各业务线所占包大小进行盘点后，也方便推动各业务线对无用的业务和代码进行了下线。 为了便于及时的产出报告，这一脚本可以集成到工程的Run Script中去，这样在需要时只用build一下，在构建的最后一步便会执行脚本，产出分析报告。 版本差异监控在安装包大小的优化中，不仅需要优化当前的安装包大小，更需要控制包大小的增长。否则，就可能会出现业务增长造成的包大小增长快过包大小优化量的尴尬局面。 可以在自动打包平台增加了一些用于监控版本差异的脚本，用于对比各个版本间包大小的增长量。如果发现当前版本的包大小较上一版本有较大增长，则会以报警的方式通知给开发人员。 这时我们就需要排查这两个版本间包大小的增长点。为此我们编写了一个脚本辅助我们快速排查版本间的差异。 这个脚本执行的工作有： 1、从打包平台上抓去特定两个版本的安装包和linkmap文件。 2、解压两个安装包，对比安装包中的每个文件，输出每个文件的差量值 3、解压两个asset.car文件，对比安装包中的图片的差量，输出增加/减少的图片的top x 4、处理和对比两个linkmap文件，输出增长/减小的类的top x 最后它可以输出报表，帮助开发人员快速定位版本间的增长点。 TODO: 按照group展示.o大小的脚本 检查图片大小的脚本 未初始化的类的代码 linkmap统计未使用的方法 参考：iOS 安装包瘦身 （上篇） iOS 安装包瘦身（下篇） 今日头条 iOS 安装包大小优化 - 新阶段、新实践 抖音品质建设 - iOS 安装包大小优化实践篇 干货｜今日头条iOS端安装包大小优化—思路与实践 今日头条优化实践： iOS 包大小二进制优化，一行代码减少 60 MB 下载大小","categories":[{"name":"性能优化","slug":"性能优化","permalink":"http://heseng91.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"「性能优化」之启动优化","slug":"「性能优化」之启动优化","date":"2018-12-04T08:30:33.000Z","updated":"2022-07-25T19:30:09.325Z","comments":true,"path":"2018/12/04/「性能优化」之启动优化/","link":"","permalink":"http://heseng91.github.io/2018/12/04/%E3%80%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8B%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/","excerpt":"启动是 App 给用户的第一印象，启动越慢用户流失的概率就越高，良好的启动速度是用户体验不可缺少的一环。本文先梳理app构建和启动流程，并结合app构建和启动流程讲述一些可优化点。","text":"启动是 App 给用户的第一印象，启动越慢用户流失的概率就越高，良好的启动速度是用户体验不可缺少的一环。本文先梳理app构建和启动流程，并结合app构建和启动流程讲述一些可优化点。 因为启动涉及面很广，牵扯很多概念。鉴于网上相关概念定义已经比较多了，本文将通过技术的发展及实际问题来介绍这个技术 or 概念。 IPA 构建编译和链接技术发展史计算机只能处理由0和1两个二进制数组成的数据。各种用二进制编码方式表示的指令，叫做机器指令码。 在计算机早期阶段，必须用机器码写程序。具体来讲，就是先在纸上用英语写一个高层次的版本，也就是对程序的高层次描述，叫 “伪代码”，然后用”操作码表”把伪代码转成二进制机器码，再给计算机喂码。 机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，而且需要人工计算每个子程序或者跳转的目标地址，当程序修改的时候，这些位置需要重新计算，十分繁琐又耗时，并且很容易出错。 于是，先驱者发明了汇编语言。汇编语言使用使用接近人类的各种符号和标记来帮助记忆，于是程序员不再使用0和1写代码，转而使用 “jmp”这样的助记符；汇编语言还可以用符号来标记位置。比如如果一种计算机，它的每条指令是一个字节，也就是8位，我们假设有一种跳转指令，它的高4位是0001，表示这是一条跳转指令，低4位存放的是跳转目的地的绝对地址。 1234560 0001 01001 ...2 ...3 ...4 1000 01115 ... 那么以上表示的就是程序的第一条指令为一个跳转指令，它的目的地址是第5条指令。使用汇编后，如果我们把刚开始第5条指令开始的子程序命名为“foo”，那么第一条指令的汇编就是：jmp foo，相比 00010100要好记太多。 然而虽然使用汇编语言之后，方便了人类记忆和编码，但是计算机并不认识助记符和符号（symbol），于是就需要使用二进制编制”汇编器” 来转译”助记符”或者叫做”汇编语言”，形成”机器码” 这样计算机就可以读懂了。汇编器在每次汇编程序的时候，会重新计算“foo”这个符号的地址，然后把所有引用到“foo”的指令修正到这个正确的地址。整个过程不需要人工参与，极大地提高了生产力。随着生产力的提高，软件的规模也开始日渐庞大，代码量开始快速膨胀。人们开始思考将不同功能的代码以一定的方式组织起来，使得更加容易阅读和理解，以便于日后修改和重复使用。自然而然，人们开始将代码按照功能和性质划分，分别形成不同的功能模块，不同的模块之间按照层次结构或其他结构来组织。随着软件规模变大，多则数百万行，如果都放在一个模块肯定无法想象。所以大型软件往往拥有成千上万个模块，这些模块互相依赖又相对独立。在一个程序被分割成多个模块以后，这些模块之间最后如何组合形成一个单一的程序是须解决的问题。模块之间如何组合的问题可以归结为模块之间如何通信的问题，通信可分两种，一种是模块间的函数调用，另外一种是模块间的变量访问。函数访问须知道目标函数的地址，变量访问也须知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是模块间符号的引用。模块间依靠符号来通信类似于拼图版，定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域，两者一拼刚好完美组合，这个模块的拼接过程就是：链接。从原理上来讲，链接的工作无非就是把一些指令对其它符号的引用加以修正。 汇编只是修饰了一下机器码。一般来说，一条汇编指令对应一条机器指令，所以汇编码和底层硬件的连接很紧密。汇编器仍然强迫程序员思考，用什么寄存器和内存地址。所以汇编语言编写起来也不容易，阅读和理解很难。而且汇编语言的编写严格依赖于特定的机器，所以在一种计算机编写的代码在应用于另一种算机时可能需要完全重写。 为了进一步将程序员从直接使用地址编程的梦魇中解救出来，人们开始探索以一个更类似于数学定义或自然语言的简洁形式来编写程序的操作，它应与任何机器都无关，而且也可由一个程序翻译为可执行的代码。在这种背景下，以后很多人开始创作编程语言，编译器也应运而生。这些语言中就包括上世纪80年代初被发明的Objective-C，它需要编译器专门把高级语言转换成低级语言。大多数编译器由两部分组成：前端和后端。 前端负责词法分析、语法分析、生成中间代码； 后端以中间代码作为输入，进行与架构无关的代码优化，接着针对不同架构生成汇编不同的机器码。 前后端依赖统一格式的中间代码（IR），使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个 CPU 架构只需要修改后端即可。 Objective-C/C/C++ 使用的编译器前端是clang，swift 是 swiftc，后端都是 LLVM。 clang 编译源代码转化生成mach-o的大致流程如下： pipeline除了代码文件之外，现代移动软件不可避免为会有一些资源文件（如 storyboard，asset ），这些资源文件也需要编译以加快加载速度，然后，同资源文件一起打包成.app。最后出乎安全考虑，还需要对.app进行签名，防篡改。 以单 Target 为例，整个构建流程如下： 源文件(.m/.c/.swift 等)是单独编译的，输出对应的目标文件(.o) 目标文件和静态库/动态库一起，链接出最后的 Mach-O Mach-O 会被裁剪，去掉一些不必要的信息 资源文件如 storyboard，asset 也会编译，编译后加载速度会变快 Mach-O 和资源文件一起，打包出最后的.app 对.app 签名，防篡改 主要可分为如下几个阶段： 编译编译器构成如下： 编译的具体转化过程如下： 1、预处理（preprocessor）：预处理会进行头文件引入、宏替换、注释处理、条件编译（#ifdef）等操作； 2、词法分析（lexical anaysis）：词法分析器读入源文件的字符流，将它们组织成有意义的词素（lexeme）序列，对于每个词素，词法分析器产生词法单元（token）作为输出； 3、语法分析（semantic analysis）：词法分析的 Token 流会被解析成一颗抽象语法树（abstract syntax tree - AST）。有了抽象语法树，clang 就可以对这个树进行分析，找出代码中的错误。比如类型不匹配，亦或 Objective-C 中向 target 发送了一个未实现的消息。AST 是开发者编写 clang 插件主要交互的数据结构，clang 也提供很多 API 去读取 AST。更多细节：Introduction to the Clang AST； 4、CodeGen：CodeGen 遍历语法树，生成 LLVM IR 代码。LLVM IR 是前端的输出，后端的输入。Objective-C 代码在这一步会进行 runtime 的桥接：property 合成、ARC 处理等。LLVM 会对生成的 IR 进行优化，优化会调用相应的 Pass 进行处理。Pass 由多个节点组成，都是 Pass 类的子类，每个节点负责做特定的优化，更多细节：Writing an LLVM Pass； 5、生成汇编代码：LLVM 对 IR 进行优化后，会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出； 6、汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出目标文件（object file）。 链接连接器把编译产生的 .o 文件和（dylib、a、tbd）文件，生成一个 mach-o 文件。链接的过程并不产生新的代码，只会做一些移动和补丁。 tbd 的全称是 text-based stub library，是因为链接的过程中只需要符号就可以了，所以 Xcode 6 开始，像 UIKit 等系统库就不提供完整的 Mach-O，而是提供一个只包含符号等信息的 tbd 文件。 裁剪编译完 Mach-O 之后会进行裁剪(strip)，是因为里面有些信息，如调试符号，是不需要带到线上去的。裁剪有多种级别，一般的配置如下： All Symbols，主二进制 Non-Global Symbols，动态库 Debugging Symbols，二方静态库 为什么二方库在出静态库的时候要选择 Debugging Symbols 呢？是因为像 order_file 等链接期间的优化是基于符号的，如果把符号裁剪掉，那么这些优化也就不会生效了。 签名 &amp; 上传裁剪完二进制后，会和编译好的资源文件一起打包成.app 文件，接着对这个文件进行签名。签名的作用是保证文件内容不多不少，没有被篡改过。接着会把包上传到 iTunes Connect，上传后会对__TEXT段加密，加密会减弱 IPA 的压缩效果，增加包大小，也会降低启动速度（iOS 13 优化了加密过程，不会对包大小和启动耗时有影响）。 以上就是ipa构建相关，接下来重点了解一下App启动流程。 启动流程概念从appstore下载的安装包，是保存在磁盘中的，要运行就需要载入到内存。 下面介绍一下链接和装入技术的发展史： 一、静态链接、静态装入这种方法最早被采用，其特点是简单，不需要操作系统提供任何额外的支持。程序的不同模块可以并行开发，分别独立编译为相应的目标文件。在得到了所有的目标文件后，静态链接、静态装入的做法是将所有目标文件链接成一个可执行映象，随后在创建进程时将该可执行映象一次全部装入内存。 举个简单的例子，假设我们开发了两个程序Program1和Program2，Program1由main1.c、utilities.c以及errhdl1.c三部分组成，分别对应程序的主框架、一些公用的辅助函数（其作用相当于库）以及错误处理部分，这三部分代码编译后分别得到各自对应的目标文件main1.o、utilities.o以及errhdl1.o。同样，Program2由main2.c、utilities.c以及errhdl2.c三部分组成，三部分代码编译后分别得到各自对应的目标文件main2.o、utilities.o以及errhdl2.o。值得注意的是，这里Program1和Program2使用了相同的公用辅助函数utilities.o。当我们采用静态链接、静态装入的方法，同时运行这两个程序时内存和硬盘的使用情况如下图所示： 这种方式会带来如下问题： 安全问题 ：由于在内存条中使用的都是真实物理地址，而且内存条中各个应用进程都是按顺序依次排列的。 那么在 进程1 中通过地址偏移就可以访问到 其他进程 的内存。 内存空间浪费问题：假如程序在运行过程中没有出现任何错误，那么错误处理部分的代码就不应该被装入内存。但是操作系统在创建进程时将程序的可执行映象一次全部装入内存，之后进程才能开始运行。造成很大的内存浪费。 硬盘空间浪费问题：就硬盘的使用来讲，既然两个程序共享使用了utilities，那么我们只要在硬盘上保存utilities.o的一份拷贝应该就足够了，但这并没有在硬盘保存的可执行程序映象上体现出来。相反，utilities.o被链接进了每一个用到它的程序的可执行映象。 二、静态链接、动态装入前面提到，静态链接、静态装入由于直接暴露的是物理地址，所以进程可以访问到任何物理地址，地址空间缺乏保护，会有比较严重的安全问题。另外，内存紧张的问题在早期的系统中显得更加突出，因此人们首先想到的是要解决内存空间使用方面的问题。为了给进程提供独立而互不访问的内存空间同时提高内存使用效率，于是虚拟内存应运而生了。 虚拟内存工作原理虚拟内存是在物理内存之上建立的一层逻辑地址，保证内存访问安全的同时为应用提供了连续的地址空间。 引用了虚拟内存后，在进程创建时，虚拟内存管理器会为每个进程创建一个称作逻辑地址的空间，并将这些地址空间分割成了大小一致的块，这样的块称之为“页”。分页的概念，下面会详细讲述。对进程而言，它的逻辑地址空间中的地址总是可访问的。因此进程会认为自己拥有连续的可用的内存（一个连续完整的地址空间），但是实际上这个内存地址只是一个虚拟地址，虚拟地址需要经过一张映射表映射后才可以获取到真实的物理地址，这样就限制了对真实物理地址的访问。映射表是进程和它的内存管理单元（MMU）维护的一个页表，该页表将程序的逻辑内存地址空间和实际的物理内存地址空间做了映射。映射过程如下： 1、cpu通过虚拟内存地址，找到对应进程的映射表。 2、通过映射表找到其对应的真实物理地址，进而找到数据。 这个过程又被称为 地址翻译，是由操作系统以及 cpu上集成的 硬件单元 MMU 协同来完成的。找到数据后，mmap到内存。mmap的全称是 memory map，是一种内存映射技术，可以把文件映射到虚拟内存的地址空间里，这样就可以像直接操作内存那样来读写文件。 整个虚拟内存的工作原理这里用一张图来展示： 虚拟内存解决效率问题刚刚提到虚拟内存空间会被分页，实际上物理内存也会被划分为大小相同的页（page）。虚拟内存空间和物理内存空间都以页作为内存空间的最小单位，而映射表同样是以页为单位的。换句话说，映射表最小只会映射到一页，并不会映射到具体每一个地址。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。 对内存分页之后，可以对物理内存进行离散使用。由于存在映射过程，所以虚拟内存对应的物理内存可以任意存放，也不需要一一对应，这样就方便了操作系统对物理内存的管理，也能够可以最大化利用物理内存。同时，也可以采用一些页面调度（Paging）算法，利用翻译过程中也存在的局部性原理，将大概率被使用的帧地址加入到 TLB 或者页表之中，提高翻译的效率。 由于可以对物理内存进行离散使用，人们就可以采用动态装入的方式来优化内存浪费问题。其想法也非常简单，即一个函数只有当它被调用时，其所在的模块才会被装入内存。 仍然以上面提到的两个程序Program1和Program2为例，假如Program1运行过程中出现了错误而Program2在运行过程中没有出现任何错误。当我们采用静态链接、动态装入的方法，同时运行这两个程序时内存和硬盘的使用情况如下图所示： （ 上图中我们也看出，实际物理内存并不是连续以及某个进程完整的）。 当应用被加载到内存中时，并不会将整个应用加载到内存中 。只会放用到的那一部分。也就是动态载入的概念，换句话说就是应用使用多少，实际物理内存就实际存储多少。映射表左侧的 0和 1代表当前地址有没有在物理内存中。当应用访问到某个地址，映射表中为 0，也就是说并没有被加载到物理内存中时，系统就会立刻阻塞整个进程， 触发一个我们所熟知的 缺页中断 - Page Fault。当一个缺页中断被触发，操作系统会从磁盘中重新读取这页数据到物理内存上，然后将映射表中虚拟内存指向对应（如果当前内存已满，操作系统会通过置换页算法 找一页数据进行覆盖，这也是为什么开再多的应用也不会崩掉， 但是之前开的应用再打开时，就重新启动了的根本原因）。通过这种分页和覆盖机制，就完美的解决了内存浪费和效率问题。 安全问题：针对静态链接、静态装入阶段通过地址偏移就可以访问到 其他进程 的内存的安全问题，引用虚拟内存后就不存在了。因为每个进程的映射表是单独的，实际上在进程中每次进行地址翻译，都会先使用界限寄存器判断是否越界，没有越界才会加上基址寄存器的值，转换为物理内存地址。这样就能保证真实物理地址永远在规定范围内，也就不存在通过偏移获取到其他进程的内存空间的问题了。 但是随之而来的确是另外一个安全问题。当应用开发完成以后由于采用了虚拟内存 , 那么其中一个函数无论如何运行，运行多少次，都会是虚拟内存中的固定地址。假设应用有一个函数，基于首地址偏移量为 0x00a000，那么虚拟地址从 0x000000 ~ 0xffffff，基于这个，那么这个函数我无论如何只需要通过 0x00a000这个虚拟地址就可以拿到其真实实现地址。而这种机制就给了很多黑客可操作性的空间，他们可以很轻易的提前写好程序获取固定函数的实现进行修改 hook操作。 为了解决这个问题 , ASLR应运而生。 其原理就是 每次虚拟地址在映射真实地址之前，增加一个随机偏移值，以此来解决我们刚刚所提到的这个问题。 三、动态链接、动态装入采用静态链接、动态装入的方法后看似只剩下硬盘空间使用效率不高的问题了，实际上内存使用效率不高的问题仍然没有完全解决。图2中，既然两个程序用到的是相同的utilities.o，那么理想的情况是系统中只保存一份utilities.o的拷贝，无论是在内存中还是在硬盘上，于是人们想到了动态链接。 下面我们就来看看上面提到的两个程序Program1和Program2在采用动态链接、动态装入的方法，同时运行这两个程序时内存和硬盘的使用情况（见下图）。仍然假设Program1运行过程中出现了错误而Program2在运行过程中没有出现任何错误。 动态链接的这一特性对于库的升级（比如错误的修正）是至关重要的。当一个库升级到一个新版本时，所有用到这个库的程序将自动使用新的版本。如果不使用动态链接技术，那么所有这些程序都需要被重新链接才能得以访问新版的库。为了避免程序意外使用到一些不兼容的新版的库，通常在程序和库中都包含各自的版本信息。内存中可能会同时存在着一个库的几个版本，但是每个程序可以通过版本信息来决定它到底应该使用哪一个。如果对库只做了微小的改动，库的版本号将保持不变；如果改动较大，则相应递增版本号。因此，如果新版库中含有与早期不兼容的改动，只有那些使用新版库进行编译的程序才会受到影响，而在新版库安装之前进行过链接的程序将继续使用以前的库。这样的系统被称作共享库系统。 相比之前的静态链接，动态链接有以下几点好处： 代码共用：图中，无论是硬盘还是内存中都只存在一份utilities.o的拷贝。内存中，两个进程通过将地址映射到相同的utilities.o实现对其的共享。解决了共享的目标文件存在多个副本浪费磁盘和内存空间的问题； 提高载入速度：减少物理页面的换入换出，还增加了CPU的缓存命中率，因为不同进程间的数据和指令访问都集中在了同一个共享模块上； 易于维护：由于被依赖的 lib 是程序执行时才 link 的，所以这些 lib 很容易做更新。系统升级只需要替换掉对应的共享模块，当程序下次启动时新版本的共享模块会被自动装载并链接起来，程序就无感的对接到了新版本。 减少可执行文件体积：相比静态链接，动态链接在编译时不需要打进去，所以可执行文件的体积要小很多 dyld引入动态装载后，就不得不提dyld，全名 The dynamic link editor，他是苹果的平台用于加载链接库的帮助程序，主要提供动态加载的支持。APP启动的时候会把 dyld 加载到进程的地址空间里，然后把后续的启动过程交给 dyld。dyld是开源的，我们可以在官网下载它的源码来阅读理解。 dyld发展简史dyld 1.0 (1996-2004)dyld 最初是作为NeXTStep 3.3的一部分于1996年上市的，所以其实没有版本号的，为了方便追溯苹果将当时的dyld版本命名的为1.0。dyld诞生背景： dyld 1.0 发明之前NeXT使用的都是静态二进制数据 POSIX dlopen调用还没有标准化：当时人们采用的是定制拓展的方式来在Unix上支持dlopen。在NeXTStep上使用的是不同的拓展。为了在NeXTStep上运行标准的Unix软件，有人在macOS 10的早期版本上编写了第三方包装程序。问题是由于并不完全支持相同的语义，在一些奇怪的边缘情况下，会不起作用，而且也会导致程序运行的比较慢。 没有广泛使用C++动态库：很重要的一点，dyld 1.0 发布时，大多数系统还没有使用大型c++动态库。c++有一些特性，比如初始化命令，在静态系统中可以很好的运行，但是在动态系统中很难至少是性能方面很难高性能的运行。基于c++的庞大代码库会导致动态链接器需要做很多工作，而且速度相当慢。 在发布macOS 10.0(Cheetah)前，苹果为dyld增加了一个特性，即Prebinding预绑定。预绑定会尝试查找每个系统dylib和程序二进制文件中需要修正地址，然后动态加载程序会尝试加载所有这些地址中需要的文件，如果加载成功，它会编辑所有的二进制文件，使用预计算地址替换需要修正的地址。这样当下一次需要加载到相同的地址时，就不需要做任何额外的工作了。这大大加快了启动速度，但这意味着我们在每次启动时都要编辑你的二进制文件，这不仅不安全，也会有一些其它的问题。 dyld 2 (2004-2007)鉴于dyld已经不能满足软件需要，并且也会有安全问题等等的问题。dyld 2作为苹果macOS Tiger的一部分被出了。dyld 2 是对dyld的完全重写，可以正确支持C++ initializer语义，同时扩展了mach-o格式并更新dyld,以获得了高效率C++库的支持。dyld 2使用正确的语义完整实现了本地的dlopen和dlsym功能，由此苹果弃用了传统API。dyld 2 是为提升速度而设计，因此只有有限的完整性检查，当时不像今天有这么多的恶意软件。也正因为只有有限的完整性检查，dyld 2会有安全问题，为此苹果不得不重新调整一些功能，使它在今天的平台上更安全。最后由于启动速度的大幅提升，我们可以减少Prebinding的工作量。相较于dyld 1的编辑程序数据，现在仅会编辑系统库，且可以仅在软件更新时做这些事情。现在Prebinding被用于所有的优化，但那是推动力。因此在软件更新过程中，可能会看到“优化系统性能”类似的文字。这就是在更新时进行Prebinding。当今这已被用于所有的优化。 dyld 2.x (2007-2017)相较于 dyld 2，过去的几年里我们做了很多非常重要的改进。 1、首先，我们添加了大量的架构和平台。 自从dyld 2在PowerPC发布之后，增加了x86、x86_64、arm、arm64和许多的衍生平台。 还推出了iOS、tvOS和watchOS，这些都需要新的dyld功能 2、通过多种方式增加安全性 增加 codeSigning代码签名 ASLR（Address space layout randomization）地址空间配置随机加载：每次加载库时，可能位于不同的地址 bound checking边界检查：mach-o文件中增加了Header的边界检查功能，从而避免恶意二进制数据的注入 3、提升性能 用share cache共享缓存完全替代prebinding。share cache是一个包含大多数系统dylibs的单一文件，由苹果在iOS 3.1和macOS Snow Leopard中引入。由于是单一文件，我们可以以下通过多种方式优化： 重新排列二进制文件以提高加载速度 预链接dylibs 预构建dyld和obc在运行时使用的数据结构 尽管dyld 2.x已经有了比较多的改进，但是仍有一些不足： 1、首先，性能方面：针对一些不能复现的场景，我们希望能采集到启动速度全面的数据。除此之外，我们还在思考，怎样最小化或者理论上最小化app启动过程中的工作量，以及我们要怎样实现这一目标； 2、其次，安全方面：如前所述，苹果在dyld 2中通过多种方式增加了安全性。但是后面再想增加更多安全性已经很困难了，因此需要有更积极的安全检查，也需要预先为安全方面。 3、最后，可测试性和可靠性：苹果发布了大量优秀的测试框架，例如XCTest，这些框架都依赖于动态链接器的底层功能来将这些库插入到进程中，从根本上说不能用于测试现有的dyld代码，所以很难验证其安全性和性能。 dyld 3 (2017-至今)鉴于以上原因，苹果在2017年WWDC推出了全新的动态链接器，dyld 3。dyld 3是苹果对动态连接的一次全新思考。2017 年开始Apple OS平台上的所有系统程序都已经默认使用dyld 3。iOS 13 开始 Apple 对三方 App 启用了 dyld3。 那么dyld 3相比 dyld 2是怎么做优化的呢？要回答这个问题，需要先简要介绍分别介绍一下app的启动流程。 用户点击图标之后，会发送一个系统调用 execve 到内核，内核创建进程。接着会把主二进制 mmap 进来，读取 load command 中的LC_LOAD_DYLINKER，找到 dyld 的的路径。然后 mmap dyld 到虚拟内存，找到 dyld 的入口函数_dyld_start，把 PC 寄存器设置成_dyld_start，接下来启动流程交给了 dyld。 dyld 2的工作流程图如下： 1、首先，dyld 会解析mach-o header，从中找到依赖的库。然后这些库也可能依赖其它库，所以dyld会不断递归找到所有依赖的库，并形成一张动态库的依赖图。一个iOS应用平均3 到 600 动态链接库，所以这个步骤包含了较大的工作量。 2、接着dyld会把依赖的动态库映射到应用地址空间。 3、然后开始符号查找，比如，如果我们的应用使用了printf函数，dyld会从系统库中找到函数地址。 4、下一步，会对每个 Mach-O 做 fixup，包括 Rebase 和 Bind。 Rebase：修复内部指针。这是因为引入用了ASLR后， Mach-O 在 mmap 到虚拟内存的时候，起始地址会有一个随机的偏移量 slide，需要把内部的指针指向加上这个 slide。 Bind：修复外部指针。这个比较好理解，因为像 printf 等外部函数，只有运行时才知道它的地址是什么，bind 就是把指针指向第三步中找到的函数地址。 5、最后，我们可以运行所有的initializers。 LibSystem Initializer：Bind &amp; Rebase 之后，首先会执行 LibSystem 的 Initializer，做一些最基本的初始化，包括：初始化 libdispatch、初始化 objc runtime，注册 sel，加载 category Load &amp; Static Initializer：接下来会进行 main 函数之前的一些初始化，主要包括+load 和 static initializer。 dyld 2是纯粹的in-process，即在程序进程内执行的，也就意味着只有当应用程序被启动时，dyld 2才能开始执行任务。 相比dyld 2，dyld 3将安全敏感的部分和占用大量资源的部分移至进程外。 安全敏感部分：在苹果看来，最大的安全敏感部分是：Parse mach-o headers 和 Find dependencies。因为被撰改的mach-o headers存在被攻击的风险，另外如果我们项目中使用了@rpath（搜索路径），通过篡改这些篡改这些路径或在正确的地方插入库，人们可以破坏应用程序。 占用大量资源的部分：这里主要指的是symbol lookups。对于给定的库，除非执行了软件更新或更改了磁盘上的库，否则该库中的符号将始终处于相同的偏移量。所以这是可以缓存的。 以下是dyld 2 和 dyld 3流程对比： dyld 3主要被分为三个组件： 1、进程外的Mach-O分析器/编译器：负责预先处理所有可能影响启动速度的 search path、@rpaths 和环境变量，然后分析 Mach-O 的 Header 和依赖，并完成了所有符号查找的工作，最后将这些结果创建成了一个启动闭包。启动闭包是为了提升速度而生，是内存映射文件，不需要以任何复杂的方式解析，比Mach-O简单的多，它包含了启动app所需的一切。 2、一个启动闭包缓存服务：系统 App 的启动闭包被构建在前文提到的 Shared Cache 中， 我们甚至不需要打开一个单独的文件。对于第三方的 App，会系统库发生变化时，即 App 安装或者升级的时候构建启动闭包。所以默认情况下，在App运行之前，启动闭包就已经在iOS上预先构建了。 3、进程内执行启动闭包的引擎：这是进程内执行的部分，主要负责：验证启动闭包的安全性、映射 dylib 到内存、每个 Mach-O 做 fixup、以及Run initiazlizers最后跳转到 main 函数。相比dyld 2，不再需要解析 Mach-O 的 Header 和依赖，也不需要进行符号查找。因为这是启动流程中花费大部分时间的步骤，所以将会为你带来更快的应用启动。 dyld 3将安全敏感的部分和占用大量资源的部分移至进程之外，并创建一个启动闭包写到磁盘里。这样后续启动的时候，就可以直接读入缓存，不再需要调用进程外的mach-o解析器或编译器，进程内执行的操作尽可能少，从而增强应用程序安全性。这样也加快了启动速度，俗话说，最快的代码是从未编写的代码，紧随其后的是几乎从未执行的代码。mach-o解析器或编译器被移至进程外之后，就变成了是一个常规的daemon进程，苹果就可以使用测试框架来测试，也就能在未来更好地改进它。 main函数之后dyld 执行完毕之后， 会把启动流程交给 App，开始执行 main 函数。main 函数里要做的最重要的事情就是初始化 UIKit。UIKit 主要会做两个大的初始化：初始化 UIApplication 和 启动主线程的 Runloop。UIKit 初始化之后，就进入了我们熟悉的 UIApplicationDelegate 回调了。 Runloop线程在执行完代码就会退出，很明显主线程是不能退出的，那么就需要一种机制：事件来的时候执行任务，否则让线程休眠，Runloop 就是实现这个功能的。 Runloop 本质上是一个While 循环，在图中橙色部分的 mach_msg_trap 就是触发一个系统调用，让线程休眠，等待事件到来，唤醒 Runloop，继续执行这个 while循环。 Runloop 主要处理几种任务：Source0，Source1，Timer，GCD MainQueue，Block。在循环的合适时机，会以 Observer 的方式通知外部执行到了哪里。 那么，Runloop 与启动又有什么关系呢？ App 的 LifeCycle 方法是基于 Runloop 的 Source0 的 首帧渲染是基于 Runloop Block 的 Runloop 在启动上主要有几点应用： 精准统计启动时间 找到一个时机，在启动结束去执行一些预热任务 利用 Runloop 打散耗时的启动预热任务 Tips : 会有一些逻辑要在启动之后 delay 一小段时间再回到主线程上执行，对于性能较差的设备，主线程 Runloop 可能一直处于忙的状态，所以这个 delay 的任务并不一定能按时执行。 AppLifeCycleUIKit 初始化之后，就进入了我们熟悉的 UIApplicationDelegate 回调了，在这些会调里去做一些业务上的初始化： willFinishLaunch didFinishLaunch didFinishLaunchNotification 要特别提一下 didFinishLaunchNotification，是因为大家在埋点的时候通常会忽略还有这个通知的存在，导致把这部分时间算到 UI 渲染里。 First Frame Render一般会用 Root Controller 的 viewDidApper 作为渲染的终点，但其实这时候首帧已经渲染完成一小段时间了，Apple 在 MetricsKit 里对启动终点定义是第一个CA::Transaction::commit()。 什么是 CATransaction 呢？我们先来看一下渲染的大致流程。 回到过去的 CRT 显示器时期，CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。 了解了显示器的显示原理之后，我们来看下渲染的大致流程。通常来说，渲染是由计算机系统中 CPU、GPU、显示器按下图方式共同协同完成的。 1、首先，在VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。 2、app 本身并不负责渲染，渲染是在一个单独的进程 RenderServer 做的。在完成对显示内容的计算之后，app通过 IPC 将渲染任务及相关数据进行打包并发送至 Render Server。 3、Render Server 主要执行 Open GL、Core Graphics 等相关程序处理完数据后再传递至 GPU。 4、GPU 进行变换、合成、渲染，渲染完成后将渲染结果放入帧缓冲区。 5、视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。 如果上述步骤串联执行，它们执行所消耗的时间将远远超过 16.67 ms。为了满足对屏幕的 60 FPS 刷新率的支持，需要将这些步骤进行分解，通过流水线的方式并行执行，如下图所示。 整个流水线一共有下面几个步骤： Handle Events：这个过程中会先处理点击事件，这个过程中有可能会需要改变页面的布局和界面层次。 Commit Transaction：此时 app 会通过 CPU 处理显示内容的前置计算，比如视图的创建、布局计算、图片解码、文本绘制等任务。之后将计算好的图层进行打包发给 Render Server。 Decode：打包好的图层被传输到 Render Server 之后，首先会进行解码。注意完成解码之后需要等待下一个 RunLoop 才会执行下一步 Draw Calls。 Draw Calls：解码完成后，Core Animation 会调用下层渲染框架（比如 OpenGL 或者 Metal）的方法进行绘制，进而调用到 GPU。 Render：这一阶段主要由 GPU 进行渲染。 Display：显示阶段，需要等 render 结束的下一个 RunLoop 触发显示。 Commit Transaction一般开发当中能影响到的就是 Handle Events 和 Commit Transaction 这两个阶段，这也是开发者接触最多的部分。Handle Events 就是处理触摸事件，而 Commit Transaction 这部分中主要进行的是：Layout、Display、Prepare、Commit 等四个具体的操作。 Layout：构建视图 这个阶段主要处理视图的构建和布局，具体步骤包括： 调用重载的 layoutSubviews 方法 创建视图，并通过 addSubview 方法添加子视图 计算视图布局，即所有的 Layout Constraint Display：绘制视图 这个阶段主要是交给 Core Graphics 进行视图的绘制，得到三角形、线段、顶点等数据，这部分信息被叫做图元（primitives）： 根据上一阶段 Layout 的结果创建得到图元信息。 如果重写了 drawRect: 方法，那么会调用重载的 drawRect: 方法，在 drawRect: 方法中手动绘制得到 bitmap 数据，从而自定义视图的绘制。 注意正常情况下 Display 阶段只会得到图元 primitives 信息，而位图 bitmap 是在 GPU 中根据图元信息绘制得到的。但是如果重写了 drawRect: 方法，这个方法会直接调用 Core Graphics 绘制方法得到 bitmap 数据，同时系统会额外申请一块内存，用于暂存绘制好的 bitmap。 由于重写了 drawRect: 方法，导致绘制过程从 GPU 转移到了 CPU，这就导致了一定的效率损失。与此同时，这个过程会额外使用 CPU 和内存，因此需要高效绘制，否则容易造成 CPU 卡顿或者内存爆炸。 Prepare：Core Animation 额外的工作 这一步主要是：图片解码和转换 Commit：打包并发送 这一步主要是：图层打包并发送到 Render Server。 启动pipeline详细回顾下整个启动过程，以及各个阶段耗时的影响因素： 1、用户点击图标之后，会发送一个系统调用 execve 到内核，内核创建进程； 2、接着会把主二进制 mmap 进来，读取 load command 中的LC_LOAD_DYLINKER，找到 dyld 的的路径，本阶段影响启动速度的因素主要是主二进制大小，可以通过下线代码来优化； 3、然后 mmap dyld 到虚拟内存，找到 dyld 的入口函数_dyld_start，把 PC 寄存器设置成_dyld_start，接下来启动流程交给了 dyld。 4、重启手机/更新/下载 App 的第一次启动，会创建启动闭包，并存储在沙盒的 tmp/com.apple.dyld 目录。闭包包含的内容有： dependends，依赖动态库列表 fixup：bind &amp; rebase 的地址 initializer-order：初始化调用顺序 optimizeObjc: Objective C 的元数据 其他：main entry, uuid… 本阶段影响启动速度的因素主要有：依赖的动态库数量、需要修正（fix-up）的指针数量和Objective-C类的数量等，可以通过减少动态库数量、减少指针数量和下线代码的方式进行优化。 5、有了闭包之后，就可以用闭包启动 App 了。这时候很多动态库还没有加载进来，会首先对这些动态库 mmap 加载到虚拟内存里，可以通过减少动态库数量来优化启动速度； 6、接着会对每个 Mach-O 做 fixup，包括 Rebase 和 Bind； Rebase：修复内部指针。这是因为引入用了ASLR后， Mach-O 在 mmap 到虚拟内存的时候，起始地址会有一个随机的偏移量 slide，需要把内部的指针指向加上这个 slide。 Bind：修复外部指针。这个比较好理解，因为像 printf 等外部函数，只有运行时才知道它的地址是什么，bind 就是把指针指向第三步中找到的函数地址。 Rebase/Binding阶段时间主要耗费在Page In 和计算上，可以通过下线代码、二进制重排和减少指针数量来减少Page In的次数和计算量。对于单次Page In，因为App Store 会对上传的 App 的 TEXT 段加密，在发生 Page In 的时候会解密，解密的过程是很耗时的，所以可以通过 rename_section 重命名，把 TEXT 段中的内容移动到其它段来优化（这个优化方式在 iOS 13 下有效，因为 iOS 13 优化了解密流程，Page In 的时候不需要解密了，这是 iOS 13 启动速度变快的原因之一。）。 7、Bind &amp; Rebase 之后，首先会执行 LibSystem 的 Initializer，做一些最基本的初始化： 初始化 libdispatch 初始化 objc runtime，注册 sel，加载 category 这里没有初始化 objc 的类方法等信息，是因为启动闭包的缓存数据已经包含了 optimizeObjc。 本阶段主要可以通过减少Class、selector 和 category 这些元数据的数量来进行优化，即下线代码。 8、接下来会进行 main 函数之前的一些初始化，主要包括+load 和 static initializer。想要查看代码里有哪些 load 和 static initializer，可以在 Build Settings 里可以配置 write linkmap，这样在生成的 linkmap 文件里就可以找到有哪些文件里包含 load 或者 static initializer： __mod_init_func，static initializer __objc_nlclslist，实现+load 的类 __objc_nlcatlist，实现+load 的 Category 不是所有的 static 变量都会产生static initializer，对于在编译期间就能确定的变量是会直接 inline。会导致静态初始化的代码有： __attribute__((constructor)) static class object static object in global namespace 静态初始化和 +load 方法除了方法本身的耗时，还会引起大量 Page In，可以通过+load 迁移和静态初始化迁移的方式来进行优化。 9、接着，dyld 会把启动流程交给 App，开始执行 main 函数，main 函数调用了UIApplicationMain 函数来初始化 UIKit。UIKit 主要会做两个大的初始化： 初始化 UIApplication 启动主线程的 Runloop 10、UIKit 初始化之后，基于 Runloop 的 Source0 的 App LifeCycle 方法就被触发了。在这些会调里去做一些业务上的初始化： willFinishLaunch didFinishLaunch didFinishLaunchNotification 在生命周期回调里主要执行的是App自身的代码，主要可以通过Xcode里的Time Profiler、System Trace、os_signpost、Static Initializer、App Launch等来检测并发现耗时部分，并针对性优化。主要优化的方向有：使用启动器来管理任务的顺序和线程、下线或者联系提供方优化耗时的三方SDK、优化高频次方法、线程阻塞、线程数量等。 11、Layout，这个阶段主要处理视图的构建和布局。在didFinishLaunch方法中我们会初始化keyWindow 并设置 rootViewController。当第一次访问rootViewController的view时会调用view的get方法，进而调用loadView来创建UIViewController的view。view创建完毕加载到内存后会调用viewDidLoad方法，在viewDidLoad方法中进行页面布局，接着调用Layoutsubviews； 12、Display，这个阶段主要是交给 Core Graphics 进行视图的绘制，得到三角形、线段、顶点等图元数据。如果重写了 drawRect: 方法，那么会调用重载的 drawRect: 方法； 13、prepare，这个阶段主要是图片解码和转换； 14、commit，这个阶段主要是打包 Render Tree 通过 XPC 的方式发给 Render Server。这也是是Apple 在 MetricsKit 里对启动终点的定义，即第一个CA::Transaction::commit()。首帧渲染是基于 Runloop Block 的，可以基于Runloop来精准统计启动时间。11、12、13、14 四步统称为Commit Transaction。 15、随后，请求网络并更新数据，至此整个启动流程结束。 优化动态库减少动态库数量可以加减少启动闭包创建和加载动态库阶段的耗时，官方建议动态库数量小于 6 个。 推荐的方式是动态库转静态库，因为还能额外减少包大小。另外一个方式是合并动态库，但实践下来可操作性不大。最后一点要提的是，不要链接那些用不到的库（包括系统），因为会拖慢创建闭包的速度。 下线代码下线代码首先要筛选出用不到的代码，一般的无用代码筛查方式可以分为动态和静态两种方式。静态的方式主要是通过代码扫描、参与编译构建过程或者分析最终产物来确认哪些代码没有被用到。而动态的方式主要是靠插桩或者运行时信息来获取哪些代码没有执行。由于 Objc 强大的动态特性，我们在样本量足够大的场景使用动态方式会比静态方式准确率高很多。 静态筛查筛查方案： 最简单的静态扫描是基于 AppCode，但是项目大了之后 AppCode 的索引速度非常慢。另一种方式是基于 Mach-O 的的一种静态扫描方式，在 otool dump 最终产物中的 __objc_class_list &amp; __objc_class_refs 做差集找到未使用的 Objc 类。 如果代码采用 C 、C++ 等静态语言编写代码时，编译期已经确定了基本的代码逻辑，编译器会帮助我们将没有使用到的代码标记为 Dead code 最终不会打包到安装包中。但 Objc 是典型的动态语言，很多逻辑都是在运行时决议的，我们通过静态扫描的方式扫描出来的误差会比较大。 Objc 动态特性引入的的主要的问题包括： 实际用到了但被扫描成无用类： 一个类确实没有被其他地方使用， 但是本身逻辑依赖 +load、+initialize、__attribute__((constructor))在启动时调用 通过 string 动态调用 抽象基类、基类等会被认为是无用类 通过运行时动态生成的代码引用了某个类 一个类专门作为通知处理类 MTLModel 等，通过运行时消息机制 assign value 的无法通过 classref 统计 典型的 DI 场景。如果一个类声明遵循了某个 Protocol，外部使用的时候使用了这个 Protocol 进行方法调用 实际没用到但被认为有用到： 某个对象被另外一个对象引用，但是另外一个对象本身未被使用到。这时候会遗漏掉这个对象所属 Class 的检查 动态筛查方案： 基于插桩的行级别代码覆盖率 基于 GCOV 或者 LLVM Profile 二进制的插桩方案可以实现在运行时收集插桩数据来指导无用代码的删除。但插桩方案局限性也显而易见，插桩会劣化二进制本身的大小和性能，同时原生的插桩方案是无法过审上线。数据收集只能局限于线下。 基于 Runtime 的轻量级运行时「类覆盖率」方案 Objc 的类首次调用类初始化时，+initialize被执行，系统会自动标记已被调用，在 metaClass 中 data 的 flags 字段第 29 位就存着这个这个状态。可以使用 flags &amp; RW_INITIALIZED获取。iOS14 之后这个值的获取方式有变化。具体参考：WWDC：Advancements in the Objective-C runtime 1234#define RW_INITIALIZED (1&lt;&lt;29)bool isInitialized() &#123; return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;&#125; 上报的数据可以让我们了解我们线上真实的 Class 使用情况，对得到的数据不仅可以用来删减未使用的代码。还可以分辨使用率低的场景，如果是低频且必须的场景可以考虑使用跨端技术这种对原生包大小影响比较小的方案实现。而如果这些场景是某个渗透率很低的需求可以考虑直接下线为其他需求做置换。 +load 迁移和静态初始化迁移每当一个类或类别被添加到Objective-C runtime都会调用+load方法，可以通过实现此方法以在加载时执行类特定的行为。 初始化顺序如下: 主二进制中链接的所有framework中的initializers 主二进制中所有的+load方法 主二进制中所有的 C++ static initializers 和C/C++ __attribute__(constructor) 方法 链接主二进制的所有framework中的initializers 如果类或者分类实现了+load方法，那么当该类或者分类被动态加载或者静态链接的时候，+load方法就会被调用，与这个类是否被用到无关，且+load方法只会被调用一次。调用顺序为父类-&gt;子类-&gt;分类，当子类未实现+load方法时，不会显示调用父类+load方法，当有多个Category都实现了load方法，这几个load方法都会执行，但执行顺序不确定，其执行顺序与Category在Compile Sources中出现的顺序一致。 +load 和静态初始化除了方法本身的耗时，还会引起大量 Page In，另外 +load 的存在对 App 稳定性也是冲击，因为 Crash 了捕获不到。所以如果可以应尽量减少+load和静态初始化。 对+load，迁移思路有： 1、使用+initialize替代 2、将一些绑定相关代码，利用 clang attribute，这个过程可以迁移到编译期 针对静态初始化，典型的迁移思路有： 1、将std:string 转换成 const char * 2、静态变量移动到方法内部，因为方法内部的静态变量会在方法第一次调用的时候初始化 main函数之后main函数之后可以通过Xcode里的Time Profiler、System Trace、os_signpost、Static Initializer、App Launch等来检测并发现耗时部分，并针对性优化。主要优化的方向有： 使用启动器为什么需要启动器呢？ 全局并发调度：比如 AB 任务并发，C 任务等待 AB 执行完毕，框架调度还能减少线程数量和控制优先级 延迟执行：提供一些时机，业务可以做预热性质的初始化 精细化监控：所有任务的耗时都能监控到，线下自动化监控也能受益 管控：启动任务的顺序调整，新增/删除都能通过 Code Review 管控 三方 SDK针对测量发现的启动耗时很高的三方 SDK ，可以考虑下线。如果不能下线，应确认是否可以延迟，比如分享和登录的 SDK都是可以延迟。此外，在接入 SDK 之前可以先评估下对启动性能的影响，如果影响较大是可以反馈给 SDK 的提供方去修改的，尤其是付费的 SDK，他们其实很愿意配合做一些修改。 高频次方法有些方法的单个耗时不高，但是在启动路径上会调用很多次的，这种累计起来的耗时也不低。这种问题在 TimeProfiler 里时间段选长一些往往就能发现，发现之后可以针对性进行优化。 锁锁之所以会影响启动时间，是因为有时候子线程先持有了锁，主线程就需要等待子线程锁释放。还要警惕系统会有很多隐藏的全局锁，比如 dyld 和 Runtime。可以借助System Trace来及时发现。 线程数量线程的数量和优先级都会影响启动时间。可以通过设置 QoS 来配置优先级，两个高优的 QoS 是 User Interactive/Initiated，启动的时候，需要主线程等待的子线程任务都应该设置成高优的。 高优的线程数量不应该多于 CPU 核心数量，可以通过 System Trace 的 System Load 来分析这种情况。 123456/GCDdispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, -1);dispatch_queue_t queue = dispatch_queue_create(\"com.custom.utility.queue\", attr);//NSOperationQueueoperationQueue.qualityOfService = NSQualityOfServiceUtility复制代码 线程的数量也会影响启动时间，但 iOS 中是不太好全局管控线程的，比如二/三方库要起后台线程就不太好管控，不过业务上的线程可以通过启动任务管控。 线程多没关系，只要同时并发执行的不多就好，大家可以利用 System Trace 来看看上下文切换耗时，确认线程数量是否是启动的瓶颈。 图片启动难免会用到很多图，有没有办法优化图片加载的耗时呢？ 用 Asset 管理图片而不是直接放在 bundle 里。Asset 会在编译期做优化，让加载的时候更快，此外在 Asset 中加载图片是要比 Bundle 快的，因为 UIImage imageNamed 要遍历 Bundle 才能找到图。加载 Asset 中图的耗时主要在在第一次张图，因为要建立索引，可以通过把启动的图放到一个小的 Asset 里来减少这部分耗时。 每次创建 UIImage 都需要 IO，在首帧渲染的时候会解码。所以可以通过提前子线程预加载（创建 UIImage）来优化这部分耗时。 如下图，启动只有到了比较晚的阶段“RootWindow 创建”和“首帧渲染”才会用到图片，所以可以在启动的早期开预加载的子线程启动任务。 Fishhookfishhook 是一个用来 hook C 函数的库，但这个库的第一次调用耗时很高，最好不要带到线上。Fishhook 是按照下图的方式遍历 Mach-O 的多个段来找函数指针和函数符号名的映射关系，带来的副作用就是要大量的 Page In，对于大型 App 来说在 iPhone X 冷启耗时 200ms+。 如果不得不用 fishhook，请在子线程调用，且不要在在_dyld_register_func_for_add_image直接调用 fishhook。因为这个方法会持有 dyld 的一个全局互斥锁，主线程在启动的时候系统库经常会调用 dlsym和 dlopen，其内部也需要这个锁，造成上文提到的子线程阻塞主线程。 首帧渲染不同 App 的业务形态不同，首帧渲染优化方式也相差的比较多，几个常见的优化点： LottieView：lottie 是 airbnb 用来做 AE 动画的库，但是加载动画的 json 和读图是比较慢的，可以先显示一帧静态图，启动结束后再开始动画，或者子线程预先把图和 json 设置到 lottie cache 里 Lazy 初始化 View：不要先创建设置成 hidden，这是很不好的习惯 AutoLayout：AutoLayout 的耗时也是比较高的，但这块往往历史包袱比较重，可以评估 ROI 看看要不要改成 frame Loading 动画：App 一般都会有个 loading 动画表示加载中，这个动画最好不要用 gif，线下测量一个 60 帧的 gif 加载耗时接近 70ms 其他 Tips启动优化里有一些需要注意的 Tips： 不要删除tmp/com.apple.dyld目录，因为这个目录下存储着 iOS 13+ 的启动闭包，如果删除了下次启动会重新创建，创建闭包的过程是很慢的。接下来是 IO 优化，常见的方式是用 mmap让 IO 更快一些，也可以在启动的早期预加载数据。 还有一些 iPhone 6 上耗时会明显增加的点： WebView User Agent：第一次在启动时获取，之后缓存，每次启动结束后刷新 KeyChain：可以延迟获取或者预加载 VolumeView：建议直接删掉 iPhone 6 是个分水岭，性能会断崖式下跌，可以在 iPhone 6 上下掉部分用户交互来换取核心体验（记得 AB 验证）。 Page In 耗时启动路径上会触发大量 Page In，优化这部分耗时有两个方向：一个是减少Page In数量 – 二进制重排 ，一种是减少单次Page In耗时 – 段重命名。 二进制重排 启动具有局部性特征，即只有少部分函数在启动的时候用到，这些函数在中的分布是零散的，所以 Page In 读入的数据利用率并不高。如果我们可以把启动用到的函数排列到二进制的连续区间，那么就可以减少 Page In 的次数，从而优化启动时间： 以下图为例，方法 1 和方法 3 是启动的时候用到的，为了执行对应的代码，就需要两次 Page In。假如我们把方法 1 和 3 排列到一起，那么只需要一次 Page In，从而提升启动速度。 链接器 ld 有个参数-order_file 支持按照符号的方式排列二进制。 获取启动时候用到的符号主流有两种方式： 静态扫描获取 +load 和 C++静态初始化，hook objc_msgSend 获取 Objective C 符号。参考：https://mp.weixin.qq.com/s/Drmmx5JtjG3UtTFksL6Q8Q LLVM 函数插桩，灰度统计启动路径符号，用大多数用户的符号生成 order_file。参考：https://juejin.cn/post/6844904130406793224 段重命名 App Store 会对上传的 App 的 TEXT 段加密，在发生 Page In 的时候会解密，解密的过程是很耗时的。既然会 TEXT 段加密，那么直接的思路就是把 TEXT 段中的内容移动到其它段，ld 也有个参数 rename_section支持重命名： 抖音重命名方案： 1234567\"-Wl,-rename_section,__TEXT,__cstring,__RODATA,__cstring\",\"-Wl,-rename_section,__TEXT,__const,__RODATA,__const\",\"-Wl,-rename_section,__TEXT,__gcc_except_tab,__RODATA,__gcc_except_tab\",\"-Wl,-rename_section,__TEXT,__objc_methname,__RODATA,__objc_methname\",\"-Wl,-rename_section,__TEXT,__objc_classname,__RODATA,__objc_classname\",\"-Wl,-rename_section,__TEXT,__objc_methtype,__RODATA,__objc_methtype\"复制代码 这个优化方式在 iOS 13 下有效，因为 iOS 13 优化了解密流程，Page In 的时候不需要解密了，这是 iOS 13 启动速度变快的原因之一。 详情请参考：https://juejin.cn/post/6911121493573402638 参考： 抖音品质建设 - iOS启动优化《原理篇》 iOS 优化篇 - 启动优化之Clang插桩实现二进制重排 程序的链接和装入及linux下动态链接的实现 iOS 优化篇 - 启动优化之Clang插桩实现二进制重排 iOS 渲染原理解析 抖音品质建设 - iOS 安装包大小优化实践篇","categories":[{"name":"性能优化","slug":"性能优化","permalink":"http://heseng91.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"「刨根问底」之内存管理","slug":"「刨根问底」之内存管理","date":"2018-12-04T08:30:33.000Z","updated":"2022-07-25T19:28:40.301Z","comments":true,"path":"2018/12/04/「刨根问底」之内存管理/","link":"","permalink":"http://heseng91.github.io/2018/12/04/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"应用程序内存管理是在程序运行时分配内存，使用它并在使用完后释放它的过程。编写良好的程序将使用尽可能少的内存。在 Objective-C 中，它也可以看作是在许多数据和代码之间分配有限内存资源所有权的一种方式。掌握内存管理知识，我们就可以很好地管理对象生命周期并在不再需要它们时释放它们，从而管理应用程序的内存。本文从内存管理概念开始，介绍内存管理的思想、方式和系统实现，阅读本文后你将对内存管理有一个整体认知。","text":"应用程序内存管理是在程序运行时分配内存，使用它并在使用完后释放它的过程。编写良好的程序将使用尽可能少的内存。在 Objective-C 中，它也可以看作是在许多数据和代码之间分配有限内存资源所有权的一种方式。掌握内存管理知识，我们就可以很好地管理对象生命周期并在不再需要它们时释放它们，从而管理应用程序的内存。本文从内存管理概念开始，介绍内存管理的思想、方式和系统实现，阅读本文后你将对内存管理有一个整体认知。 什么是内存管理Objective-C 中的内存管理，也就是引用计数。 引用计数机制可以用开关房间的灯为例来说明。假设办公室里的照明设备只有一个。上班进入办公室的人需要照明，所以要把灯打开。而对于下班离开办公室的人来说，已经不需要照明了，所以要把灯关掉。 若是很多人上下班，每个人都开灯或者关灯，那么办公室的情况又将如何呢？最早下班的人如果关了灯，那就会像下图那样，办公室里还没走的所有人都将处于一片黑暗之中。 解决这一问题的办法就是使办公室在还有至少一人的情况下保持开灯状态，而在无人时保持关灯状态。 （1）最早进入办公室的人开灯。 （2）之后进入办公室的人，需要照明。 （3）下班离开办公室的人，不需要照明。 （4）最后离开办公室的人关灯（此时已无人需要照明）。 为判断是否还有人在办公室里，这里导入计数功能来计算 “需要照明的人数”。下面让我们来看看这一功能是如何运作的吧。 （1）第一个人进入办公室，“需要照明的人数” 加 1。计数值从 0 变成了 1，因此要开灯。 （2）之后每当有人进入办公室，“需要照明的人数” 就加 1。如计数值从 1 变成 2。 （3）每当有人下班离开办公室，“需要照明的人数” 就减 1。如计数值从 2 变成 1。 （4）最后一个人下班离开办公室，“需要照明的人数” 减 1。计数值从 1 变成了 0，因此要关灯。 这样就能在不需要照明的时候保持关灯状态。办公室中仅有的照明设备得到了很好的管理，如下图所示： 在 Objective-C 中，“对象” 相当于办公室里的照明设备。在现实世界中办公室里的照明设备只有一个，但在 Objective-C 的世界里，虽然计算机的资源有限，但一台计算机可以同时处理好几个对象。 此外，“对象的使用环境” 相当于上班进入办公室的人。虽然这里的 “环境” 有时也指在运行中的程序代码、变量、变量作用域、对象等，但在概念上就是使用对象的环境。上班进入办公室的人对办公室照明设备发出的动作，与 Objective-C 中的对应关系则如下表所示： 对照明设备所做的动作 对 Objective-C 对象所做的动作 开灯 生成对象 需要照明 持有对象 不需要照明 释放对象 关灯 废弃对象 使用计数功能计算需要照明的人数，使办公室的照明得到了很好的管理。同样，使用引用计数功能，对象也就能够得到很好的管理，这就是 Objective-C 的内存管理。如下图所示： 内存管理实现看到引用计数，我们便会不自觉地将注意力放到计数上。但这往往会适得其反，因为这样是在从实现细节而非实现目标角度来理解内存管理。其实，更加客观、正确的思考内存管理方式应该是从对象所有权和对象图的角度。 对象图：在面向对象编程中，一组组的对象根据彼此之间直接或者间接的持有关系形成一个网络。这样的一组组数据就称为对象图。对象图或大或小，或简单或复杂，多种多样。 例如，一个包含单一字符串对象的数组表示一个小而简单的对象图。而持有application对象的一组对象，可能表示的就是一个大的而复杂的对象图，因为application对象会持有多个windows、menus、视图以及其它其他支持对象。有时，您可能希望将对象图(通常只是应用程序中整个对象图的一部分)转换为一种可以保存到文件或传输到另一个进程或机器的形式，然后重新构建。这个过程被称为“归档”。有些对象图可能是不完整的——这些通常被称为部分对象图。 部分对象图包含有占位符对象，这些占位符对象表示图的边界，便于在后续阶段进行填充。例如：包含文件所有者占位符的nib文件。 内存管理模型是基于对象所有权的。任何对象都可能有一个或多个持有者。只要一个对象至少有一个持有者，它就会继续存在。如果对象没有持有者，运行时系统会自动销毁它。为了确保清楚地知道什么时候持有一个对象，什么时候不持有，苹果设置了以下内存管理策略: 自己生成的对象，自己持有 非自己生成的对象自己也能持有 不再需要自己持有的对象时释放 非自己持有的对象无法释放 上述生成、持有、释放等内存管理的相关操作，实际上不包括在 Objective-C 语言中，而是包含在Cocoa框架中，由NSObject类负责。内存管理的相关方法定义在NSObject协议中。NSObject类还定义了一个方法dealloc，当一个对象被销毁时，它会自动调用。另外，Cocoa还使用了一个简单的命名约定来指示何时应持有一个由方法返回的对象。对象操作与 Objective-C 方法的对应关系如下： 对象操作 Objective-C 方法 生成并持有对象 alloc/new/copy/mutableCopy 等方法和以它们驼峰命名开头的方法 持有对象 retain 方法 释放对象 release方法 销毁对象 dealloc方法 虽然通常在单个对象级别上考虑内存管理，但实际上我们的目标是管理对象图，要保证在内存中只保留需要用到的对象，确保没有发生内存泄漏。 Objective-C 在iOS中提供了两种内存管理方法：MRC 和 ARC。MRC时期，iOS 开发需要通过跟踪自己持有的对象来显式管理内存。这是使用一个称为 “引用计数” 的模型来实现的，由 Foundation 框架的 NSObject 类与运行时环境一起提供。为了降低程序崩溃、内存泄露等风险的同时，比较大程度减少开发程序的工作量，苹果在iOS 5时推出了ARC。ARC，全称 Automatic Reference Counting，就是让编译器进行内存管理，这样就无需再次键入retain或release代码。编译器完全清楚目标对象，并能立即释放哪些不再被使用的对象，从而提高应用程序的可预测性，保证程序能流畅运行，速度也将大幅提高。 内存管理源码探究上文提到Objective-C 中的内存管理，也就是引用计数管理。下面我们围绕引用计数源码来探究一下内存管理，本次探索基于objc4-756.2，使用Xcode 11.3.1 (11C504)。阅读之前需要对类和对象的结构有所了解。 引用计数存储对象引用计数存储上文中提到在iOS中，内存管理的相关操作是由NSObject类负责。NSObject在NSObject.h中的定义如下： 123456@interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125; NSObject类只包含一个Class类型成员变量。Class 其实是一个指向 objc_class 结构体的指针： 1typedef struct objc_class *Class; objc_class结构体定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125; /*...*/ // 对象是否重写了以下内存管理方法：retain/release/autorelease/retainCount/_tryRetain/_isdealocation /retainWeakReference/allowsWeakReference bool hasCustomRR() &#123; return ! bits.hasDefaultRR(); &#125; // 设置类或父类以下内存管理方法是否有默认实现：retain/release/autorelease/retainCount/_tryRetain/_isdealocation /retainWeakReference/allowsWeakReference void setHasDefaultRR() &#123; assert(isInitializing()); bits.setHasDefaultRR(); &#125; void setHasCustomRR(bool inherited = false); void printCustomRR(bool inherited); // 对象是否自定义实现了 alloc/allocWithZone: 方法 bool hasCustomAWZ() &#123; return ! bits.hasDefaultAWZ(); &#125; // 类或父类有默认的 alloc/allocWithZone: 方法实现，信息存储在元类中 void setHasDefaultAWZ() &#123; assert(isInitializing()); bits.setHasDefaultAWZ(); &#125; void setHasCustomAWZ(bool inherited = false); void printCustomAWZ(bool inherited); /*...*/ // 类或父类具有有c++ 构造函数 bool hasCxxCtor() &#123; // addSubclass() propagates this flag from the superclass. assert(isRealized()); return bits.hasCxxCtor(); &#125; void setHasCxxCtor() &#123; bits.setHasCxxCtor(); &#125; // 类或父类具有有c++ 析构函数 bool hasCxxDtor() &#123; // addSubclass() propagates this flag from the superclass. assert(isRealized()); return bits.hasCxxDtor(); &#125; void setHasCxxDtor() &#123; bits.setHasCxxDtor(); &#125; /*...*/&#125; objc_class结构体拥有 superclass、cache 和 bits三个成员变量，以及封装了获取和更改bits数据的一些函数、计算等实力大小等的函数。 cache成员变量的类型为cache_t，用于对方法调用的性能进行优化。cache_t定义如下： 1234567struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied; /*...*/&#125; 其中，bucket_t *_buckets 是一个散列表，用来存储 Method 方法列表；_mask：分配用来缓存 bucket 的总数；_occupied：表明目前实际占用的缓存 bucket 的个数。 bits是objc_class 中最复杂的，类型为class_data_bits_t，用于存储属性、方法等类的源数据。class_data_bits_t结构体定义如下： 123456789101112struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;private: bool getBit(uintptr_t bit) &#123; return bits &amp; bit; &#125;/*...*/&#125;; bits 在内存中每个位的含义定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// Values for class_rw_t-&gt;flags or class_t-&gt;bits// These flags are optimized for retain/release and alloc/dealloc// 64-bit stores more of them in class_t-&gt;bits to reduce pointer indirection.#if !__LP64__// class or superclass has .cxx_construct implementation#define RW_HAS_CXX_CTOR (1&lt;&lt;18)// class or superclass has .cxx_destruct implementation#define RW_HAS_CXX_DTOR (1&lt;&lt;17)// class or superclass has default alloc/allocWithZone: implementation// Note this is is stored in the metaclass.#define RW_HAS_DEFAULT_AWZ (1&lt;&lt;16)// class's instances requires raw isa#if SUPPORT_NONPOINTER_ISA#define RW_REQUIRES_RAW_ISA (1&lt;&lt;15)#endif// class or superclass has default retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference#define RW_HAS_DEFAULT_RR (1&lt;&lt;14)// class is a Swift class from the pre-stable Swift ABI#define FAST_IS_SWIFT_LEGACY (1UL&lt;&lt;0)// class is a Swift class from the stable Swift ABI#define FAST_IS_SWIFT_STABLE (1UL&lt;&lt;1)// data pointer#define FAST_DATA_MASK 0xfffffffcUL#elif 1// Leaks-compatible version that steals low bits only.// class or superclass has .cxx_construct implementation#define RW_HAS_CXX_CTOR (1&lt;&lt;18)// class or superclass has .cxx_destruct implementation#define RW_HAS_CXX_DTOR (1&lt;&lt;17)// class or superclass has default alloc/allocWithZone: implementation// Note this is is stored in the metaclass.#define RW_HAS_DEFAULT_AWZ (1&lt;&lt;16)// class's instances requires raw isa#define RW_REQUIRES_RAW_ISA (1&lt;&lt;15)// class is a Swift class from the pre-stable Swift ABI#define FAST_IS_SWIFT_LEGACY (1UL&lt;&lt;0)// class is a Swift class from the stable Swift ABI#define FAST_IS_SWIFT_STABLE (1UL&lt;&lt;1)// class or superclass has default retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference#define FAST_HAS_DEFAULT_RR (1UL&lt;&lt;2)// data pointer#define FAST_DATA_MASK 0x00007ffffffffff8UL#else// Leaks-incompatible version that steals lots of bits.// class is a Swift class from the pre-stable Swift ABI#define FAST_IS_SWIFT_LEGACY (1UL&lt;&lt;0)// class is a Swift class from the stable Swift ABI#define FAST_IS_SWIFT_STABLE (1UL&lt;&lt;1)// summary bit for fast alloc path: !hasCxxCtor and // !instancesRequireRawIsa and instanceSize fits into shiftedSize#define FAST_ALLOC (1UL&lt;&lt;2)// data pointer#define FAST_DATA_MASK 0x00007ffffffffff8UL// class or superclass has .cxx_construct implementation#define FAST_HAS_CXX_CTOR (1UL&lt;&lt;47)// class or superclass has default alloc/allocWithZone: implementation// Note this is is stored in the metaclass.#define FAST_HAS_DEFAULT_AWZ (1UL&lt;&lt;48)// class or superclass has default retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference#define FAST_HAS_DEFAULT_RR (1UL&lt;&lt;49)// class's instances requires raw isa// This bit is aligned with isa_t-&gt;hasCxxDtor to save an instruction.#define FAST_REQUIRES_RAW_ISA (1UL&lt;&lt;50)// class or superclass has .cxx_destruct implementation#define FAST_HAS_CXX_DTOR (1UL&lt;&lt;51)// instance size in units of 16 bytes// or 0 if the instance size is too big in this field// This field must be LAST#define FAST_SHIFTED_SIZE_SHIFT 52// FAST_ALLOC means// FAST_HAS_CXX_CTOR is set// FAST_REQUIRES_RAW_ISA is not set// FAST_SHIFTED_SIZE is not zero// FAST_ALLOC does NOT check FAST_HAS_DEFAULT_AWZ because that // bit is stored on the metaclass.#define FAST_ALLOC_MASK (FAST_HAS_CXX_CTOR | FAST_REQUIRES_RAW_ISA)#define FAST_ALLOC_VALUE (0)#endif 这里面除了 FAST_DATA_MASK 是用一段空间存储数据外，其他宏都是只用 1 bit 存储 bool 值。class_data_bits_t 提供了三个方法用于位操作：getBit, setBits 和 clearBits，对应到存储 bool 值的掩码也有封装函数，比如： 123456bool hasCxxCtor() &#123; return getBit(FAST_HAS_CXX_CTOR);&#125;void setHasCxxCtor() &#123; setBits(FAST_HAS_CXX_CTOR);&#125; objc_class结构体继承至 object_object， object_object定义如下： 12345678910111213struct objc_object &#123;private: isa_t isa;public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // getIsa() allows this to be a tagged pointer object Class getIsa(); /*...*/&#125; objc_object 结构体包含一个 isa 指针，类型为 isa_t 联合体。根据 isa 就可以顺藤摸瓜找到对象所属的类。 isa_t 类型的共用体（union），在objc-private.h 文件中定义如下： 123456789101112union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 其中 ISA_BITFIELD在 isa.h文件中定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#if SUPPORT_PACKED_ISA // extra_rc must be the MSB-most field (so it matches carry/overflow flags) // nonpointer must be the LSB (fixme or get rid of it) // shiftcls must occupy the same bits that a real class pointer would // bits + RC_ONE is equivalent to extra_rc + 1 // RC_HALF is the high bit of extra_rc (i.e. half of its range) // future expansion: // uintptr_t fast_rr : 1; // no r/r overrides // uintptr_t lock : 2; // lock for atomic property, @synch // uintptr_t extraBytes : 1; // allocated with extra bytes# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18)# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 8# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7)# else# error unknown architecture for packed isa# endif SUPPORT_PACKED_ISA 用于标记是否支持优化的 isa 指针，其字面含义意思是 isa 的内容不再是类的指针了，而是包含了更多信息，比如引用计数，析构状态，被其他 weak 变量引用情况。判断方法也是根据设备类型： 12345678// Define SUPPORT_PACKED_ISA=1 on platforms that store the class in the isa // field as a maskable pointer with other data around it.#if (!__LP64__ || TARGET_OS_WIN32 || \\ (TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_IOSMAC))# define SUPPORT_PACKED_ISA 0#else# define SUPPORT_PACKED_ISA 1#endif 综合看来目前只有 arm64 架构的设备支持，下面列出了 isa 指针中变量对应的含义： 变量名 含义 nonpointer 0 表示普通的 isa 指针，1 表示使用优化，存储引用计数 has_assoc 表示该对象是否包含 associated object，如果没有，则析构时会更快 has_cxx_dtor 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls 类的指针 magic 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。 weakly_referenced 表示该对象是否有过 weak 对象，如果没有，则析构时更快 deallocating 表示该对象是否正在析构 has_sidetable_rc 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_rc 存储引用计数值减一后的结果 在 64 位环境下，优化的 isa 指针并不是就一定会存储引用计数，毕竟用 19bit （iOS 系统）保存引用计数不一定够。需要注意的是这 19 位保存的是引用计数的值减一。has_sidetable_rc 的值如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中。SideTable 定义如下： 1234567struct SideTable &#123; spinlock_t slock;//保证原子操作的自选锁 RefcountMap refcnts;//引用计数表，保存引用计数的散列表 weak_table_t weak_table;//保存 weak 引用的全局散列表 /*...*/&#125;; SideTable 用于管理引用计数表和 weak 表，并使用 spinlock_lock 自旋锁来防止操作表结构时可能的竞态条件。它用一个 64*128 大小的 uint8_t 静态数组作为 buffer 来保存所有的 SideTable 实例。RefcountMap定义如下： 1typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap; DenseMap 类中包含好多映射实例到其引用计数的键值对，并支持用 DenseMapIterator 迭代器快速查找遍历这些键值对。键的类型为 DisguisedPtr&lt;objc_object&gt;，DisguisedPtr 类是对 objc_object * 指针及其一些操作进行的封装，目的就是为了让它给人看起来不会有内存泄露的样子，其内容可以理解为对象的内存地址；值的类型为 size_t，size_t 是为了方便系统之间的移植而定义的，在32位系统上定义为 unsigned int，在64位系统上定义为 unsigned long。其实这里保存的值也是等于引用计数减一。使用散列表保存引用计数的设计很好，即使出现故障导致对象的内存块损坏，只要引用计数表没有被破坏，依然可以顺藤摸瓜找到内存块的位置。 Tagged Pointerisa 这里还涉及到 Tagged Pointer 等概念。因为 isa_t 使用 union 实现，所以可能表示多种形态，既可以当成是指针，也可以存储标志位。 Tagged Pointer 是一种特殊标记的对象，Tagged Pointer 通过在其最后一个 bit 位设置为特殊标记位，并且把数据直接保存在指针本身中。Tagged Pointer 是一个”伪”对象，使用 Tagged Pointer 有 3 倍的访问速度提升，100 倍的创建、销毁速度提升。 Tips：Advances in Objective-C 在我们查看对象指针时，在 64 位系统中，我们会看到 16 进制地址如0x00000001003041e0，我们把它转换为二进制表示如下图 在 64 位系统中，我们有 64 位可以表示一个对象指针，但是我们通常没有真正使用到所有这些位。由于内存对齐要求的存在，低位始终为0，对象必须始终位于指针大小倍数的地址中。由于地址空间有限，所以高位也始终为0。所以实际上我们只在一个真正的对象指针中使用了中间的这些位，而不会用到用到2^64，这些高位和低位总是0。 苹果从这些始终为0的位中选择了低位并把它设置为1。以标识这不是一个真正的对象指针，然后就可以给其他位赋予一些其他的意义，苹果称这种指针为tagged pointer。 例如：NSNumber指针，苹果在其它位中塞入的是一个数值。（PS：这些值实际上是通过与进程启动时初始化的随机值相结合而被混淆的）。 在设置为 1 表示为 Tagged Pointer 对象之后，在最低位之后的 3 位，苹果给他赋予类型意义，由于只有 3 位，所以它可以表示 7 种数据类型 12345678OBJC_TAG_NSAtom = 0, OBJC_TAG_1 = 1, OBJC_TAG_NSString = 2, OBJC_TAG_NSNumber = 3, OBJC_TAG_NSIndexPath = 4, OBJC_TAG_NSManagedObjectID = 5, OBJC_TAG_NSDate = 6, OBJC_TAG_7 = 7 在剩余的字段中，我们可以赋予他所包含的数据。在 Intel 中，我们 Tagged Pointer 对象的表示如下： OBJC_TAG_7类型的 Tagged Pointer 是个例外，它可以将接下来后 8 位作为它的扩展类型字段，基于此我们可以多支持 256 中类型的 Tagged Pointer，如 UIColors 或 NSIndexSets 之类的对象。 对象如果支持使用 TaggedPointer，苹果会直接将其指针值作为引用计数返回。 获取引用计数在非 ARC 环境可以使用 retainCount 方法获取某个对象的引用计数，其会调用 objc_object 的 rootRetainCount() 方法： 123- (NSUInteger)retainCount &#123; return ((id)self)-&gt;rootRetainCount();&#125; 在 ARC 时代除了使用 Core Foundation 库的 CFGetRetainCount() 方法，也可以使用 Runtime 的 _objc_rootRetainCount(id obj) 方法来获取引用计数，此时需要引入 &lt;objc/runtime.h&gt; 头文件。这个函数也是调用 objc_object 的 rootRetainCount() 方法： 1234567891011121314151617181920212223242526272829inline uintptr_t objc_object::rootRetainCount()&#123; // 如果是 tagged pointer，直接返回 this if (isTaggedPointer()) return (uintptr_t)this; // sidetable加锁 sidetable_lock(); // 获取 isa isa_t bits = LoadExclusive(&amp;isa.bits); ClearExclusive(&amp;isa.bits); // 如果 isa 是 nonpointer if (bits.nonpointer) &#123; // 获取extra_rc中保存的引用计数并+1 uintptr_t rc = 1 + bits.extra_rc; // 如果sidetable中存储有对象的引用计数值 if (bits.has_sidetable_rc) &#123; // 获取sidetable中保存的引用计数值并和前面获取到的引用计数相加 rc += sidetable_getExtraRC_nolock(); &#125; // sidetable解锁 sidetable_unlock(); // 返回获取到的引用计数 return rc; &#125; // sidetable解锁 sidetable_unlock(); // 从sidetable中查找保存的对象引用计数值+1之后返回 return sidetable_retainCount();&#125; rootRetainCount() 方法对引用计数存储逻辑进行了判断， 如果是 tagged pointer，直接返回对象本身； isTaggedPointer()定义在 objc-object.h文件中，实现如下： 12345inline bool objc_object::isTaggedPointer() &#123; return _objc_isTaggedPointer(this);&#125; 方法只是调用了_objc_isTaggedPointer()方法，对对象指针进行位运算，获取标识位的值并返回。 12345static inline bool _objc_isTaggedPointer(const void * _Nullable ptr)&#123; return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) &#x3D;&#x3D; _OBJC_TAG_MASK;&#125; _OBJC_TAG_MASK定义如下： 1234567891011121314151617181920212223#if OBJC_MSB_TAGGED_POINTERS# define _OBJC_TAG_MASK (1UL&lt;&lt;63)# define _OBJC_TAG_INDEX_SHIFT 60# define _OBJC_TAG_SLOT_SHIFT 60# define _OBJC_TAG_PAYLOAD_LSHIFT 4# define _OBJC_TAG_PAYLOAD_RSHIFT 4# define _OBJC_TAG_EXT_MASK (0xfUL&lt;&lt;60)# define _OBJC_TAG_EXT_INDEX_SHIFT 52# define _OBJC_TAG_EXT_SLOT_SHIFT 52# define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 12# define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12#else# define _OBJC_TAG_MASK 1UL# define _OBJC_TAG_INDEX_SHIFT 1# define _OBJC_TAG_SLOT_SHIFT 0# define _OBJC_TAG_PAYLOAD_LSHIFT 0# define _OBJC_TAG_PAYLOAD_RSHIFT 4# define _OBJC_TAG_EXT_MASK 0xfUL# define _OBJC_TAG_EXT_INDEX_SHIFT 4# define _OBJC_TAG_EXT_SLOT_SHIFT 4# define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 0# define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12#endif 其中OBJC_MSB_TAGGED_POINTERS定义如下，根据设备类型不同，标识位的位置也会有所不同 1234567#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__ // 64-bit Mac - tag bit is LSB# define OBJC_MSB_TAGGED_POINTERS 0#else // Everything else - tag bit is MSB# define OBJC_MSB_TAGGED_POINTERS 1#endif sidetable加锁； 调用 LoadExclusive，获取 isa； 123456static ALWAYS_INLINEuintptr_tLoadExclusive(uintptr_t *src)&#123; return __c11_atomic_load((_Atomic(uintptr_t) *)src, __ATOMIC_RELAXED);&#125; __c11_atomic_load() 函数是以原子方式加载并返回指向的原子变量的当前值obj。该操作是原子读取操作。 调用 ClearExclusive() 在独占访问结束时，清除cpu中本地处理器针对某块内存区域的独占访问标志（核中的某个状态寄存器），以防在未清除时的其他操作，对系统产生影响。对于是否同时清除全局的独占访问标志，需要在设计cpu时的架构师决定。ClearExclusive() 在只针对arm64架构生效，其它架构下为空实现。arm64架构下ClearExclusive() 在函数只是简单调用__builtin_arm_clrex()来实现实际功能； 12345678910111213141516171819202122#if __arm64__ &amp;&amp; !__arm64e__/*...*/static ALWAYS_INLINEvoidClearExclusive(uintptr_t *dst __unused)&#123; __builtin_arm_clrex();&#125;#else/*...*/static ALWAYS_INLINEvoidClearExclusive(uintptr_t *dst __unused)&#123;&#125;#endif 如果是 nonpointer isa，获取前文说的isa_t结构体的 extra_rc 中保存的引用计数并在此基础上 +1 ，这也就是为什么之前说引用计数存储的值为实际引用计数减一。然后判断如果has_sidetable_rc 的值为 1，即引用计数还有部分存储在side table。调用sidetable_getExtraRC_nolock() 12345678910111213size_t objc_object::sidetable_getExtraRC_nolock()&#123; assert(isa.nonpointer); // 查找到对象所在的SideTable SideTable&amp; table = SideTables()[this]; // 在SideTables的引用计数表（RefcountMap）中查找对象的应用计数值 RefcountMap::iterator it = table.refcnts.find(this); // 如果没有查找到，则返回0 if (it == table.refcnts.end()) return 0; // 否则对查找到的值进行向右移位操作获取保存的引用计数并返回 else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;&#125; 获取当前实例对应的 SideTable 对象，其 refcnts 属性就是存储引用计数的散列表，这里将其类型简写为 RefcountMap： 1typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap; 然后在引用计数表中用迭代器查找当前实例对应的键值对，获取引用计数值，并和之前获取的引用计数相加，然后返回； 需要注意的是为什么这里把键值对的值做了向右移位操作（it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT）: 12345678// The order of these bits is important.#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)#define SIDE_TABLE_DEALLOCATING (1UL&lt;&lt;1) // MSB-ward of weak bit#define SIDE_TABLE_RC_ONE (1UL&lt;&lt;2) // MSB-ward of deallocating bit#define SIDE_TABLE_RC_PINNED (1UL&lt;&lt;(WORD_BITS-1))#define SIDE_TABLE_RC_SHIFT 2#define SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1) 可以看出值的第一个 bit 表示该对象是否有过 weak 对象，如果没有，在析构释放内存时可以更快，原因请看后面对象销毁部分；第二个 bit 表示该对象是否正在析构。从第三个 bit 开始才是存储引用计数数值的地方。所以这里要做向右移两位的操作，而对引用计数的 +1 和 -1 可以使用 SIDE_TABLE_RC_ONE，还可以用 SIDE_TABLE_RC_PINNED 来判断是否引用计数值有可能溢出。 sidetable解锁； 调用 sidetable_retainCount() 方法： 123456789101112131415161718192021uintptr_tobjc_object::sidetable_retainCount()&#123; // 查找到对象所在的SideTable SideTable&amp; table = SideTables()[this]; // 设置的引用计数为1 size_t refcnt_result = 1; // sidetable加锁 table.lock(); // 在SideTables的引用计数表（RefcountMap）中查找对象的应用计数值 RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) &#123;// 如果查找到了 // this is valid for SIDE_TABLE_RC_PINNED too // 将查找到的值进行向右移位操作获取保存的引用计数并+1 refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; &#125; // sidetable解锁 table.unlock(); // 返回引用计数 return refcnt_result;&#125; 逻辑和前面sidetable_getExtraRC_nolock方法类似，获取当前实例对应的 SideTable 对象，其 refcnts 属性就是之前说的存储引用计数的散列表，然后在引用计数表中用迭代器查找当前实例对应的键值对，一样向右移位操作（it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT）获取引用计数值，+1然后返回。所以说引用计数表存储的值也为实际引用计数减一。 生成对象前文说到，生成对象对应的Objective-C方法为 alloc/new/copy/mutableCopy 等。下面我们逐个解析源码实现。 alloc在objc4-756.2源码中，新建一个target，在对象alloc的地方下一个端点，调用栈如下图： 通过调用栈发现，[Person alloc]首先会调用objc_alloc()。objc_alloc()实现如下： 123456// Calls [cls alloc].idobjc_alloc(Class cls)&#123; return callAlloc(cls, true/*checkNil*/, false/*allocWithZone*/);&#125; 该方法只是调用了callAlloc()，callAlloc()实现如下： 12345678910111213141516171819202122232425262728293031323334353637// Call [cls alloc] or [cls allocWithZone:nil], with appropriate // shortcutting optimizations.// 调用 [cls alloc] or [cls allocWithZone:nil] 会来到这个函数static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123; // 如果 (checkNil &amp;&amp; !cls)，直接返回 nil if (slowpath(checkNil &amp;&amp; !cls)) return nil;#if __OBJC2__ // 判断是否是 Objective-C 2.0 // 如果 cls 没有重写 alloc/allocWithZone: 方法 if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123; // No alloc/allocWithZone implementation. Go straight to the allocator. // fixme store hasCustomAWZ in the non-meta class and // add it to canAllocFast's summary // canAllocFast()函数返回false，所以只会执行else中的代码 if (fastpath(cls-&gt;canAllocFast())) &#123; // No ctors, raw isa, etc. Go straight to the metal. bool dtor = cls-&gt;hasCxxDtor(); id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize()); if (slowpath(!obj)) return callBadAllocHandler(cls); obj-&gt;initInstanceIsa(cls, dtor); return obj; &#125; else &#123; // Has ctor or raw isa or something. Use the slower path. id obj = class_createInstance(cls, 0); if (slowpath(!obj)) return callBadAllocHandler(cls); return obj; &#125; &#125;#endif // No shortcuts available. if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc];&#125; 该方法主要以下几步： 如果入参传入的checkNil为true，且class为nil，则直接return；这里牵扯到 fastpath &amp;&amp; slowpath 的概念。 fastpath &amp;&amp; slowpath 是定义在 objc-os.h中的两个宏： 12#define fastpath(x) (__builtin_expect(bool(x), 1))#define slowpath(x) (__builtin_expect(bool(x), 0)) fastpath 和 slowpath 其实就是为了告诉编译器，if 中的判断条件是大概率 ( fastpath ) 还是小概率 ( slowpath ) 事件，从而让编译器对代码进行优化。举个例子： 1234if (x) return 1;else return 39; 由于计算机并非一次只读取一条指令，而是读取多条指令，所以在读到 if 语句时也会把 return 1读取进来。如果 x 为 0，那么会重新读取 return 39，重读指令相对来说比较耗时。 如过 x 有非常大的概率是 0，那么 return 1这条指令每次不可避免的会被读取，并且实际上几乎没有机会执行， 造成了不必要的指令重读。当然，最简单的优化就是: 1234if (!x) return 39;else return 1; 然而对程序员来说，每次都做这样的判断非常不友好，而且容易出错。于是 GCC 提供了一个内置函数 __builtin_expect: 1long __builtin_expect (long EXP, long C) 它的返回值就是整个函数的返回值，参数 C 代表预计的值，表示程序员知道 EXP 的值很可能就是 C。比如上文中的例子可以这样写: 1234if (__builtin_expect(x, 0)) return 1;else return 39; 虽然写法逻辑不变，但是编译器会把汇编代码优化成 if(!x) 的形式。 因此，在苹果定义的两个宏中，fastpath(x)依然返回 x，只是告诉编译器 x 的值一般不为 0，从而编译器可以进行优化。同理，slowpath(x)表示 x 的值很可能为 0，希望编译器进行优化。 这里因为传入的 checkNil 为false，所以这一步忽略； 接着判断如果没有自己实现 alloc/allocWithZone:方法，接着判断是否 canAllocFast 然后执行相关的初始化方法; 判断有没有自己实现 alloc/allocWithZone: 方法，是通过调用类的结构体 objc_class 中的hasCustomAWZ() 方法判断的。 hasCustomAWZ()方法，定义在 objc-runtime-new.h文件的 objc_class 结构体中。 123bool hasCustomAWZ() &#123; return ! bits.hasDefaultAWZ();&#125; hasDefaultAWZ() 实现如下 : 123456789bool hasDefaultAWZ() &#123; return getBit(FAST_HAS_DEFAULT_AWZ);&#125;void setHasDefaultAWZ() &#123; setBits(FAST_HAS_DEFAULT_AWZ);&#125;void setHasCustomAWZ() &#123; clearBits(FAST_HAS_DEFAULT_AWZ);&#125; 其实是位运算获取 bits 中用来标识用户是否自己实现了 alloc/allocWithZone: 的标记位，该标记位保存在metaclass中。 由于类是有懒加载概念的，当第一次给该类发消息之前，类并没有被加载，因此，当类第一次调用 alloc，进入到 hasCustomAWZ时，并没有 DefaultAWZ，所以 hasCustomAWZ则为 true，因此会直接调用 [cls alloc]。 [cls alloc] 是通过消息机制触发，向对象发送消息的时候，会判断如果对象没有没有实例化则进行处理： 123456789101112131415161718192021222324252627IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = nil; bool triedResolver = NO; /*...*/ // 判断类是否已经Realized，如果没有，需要先Realized if (!cls-&gt;isRealized()) &#123; cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock); // runtimeLock may have been dropped but is now locked again &#125; // 判断如果入参传入的initialize为true，且类未实例化，需要先实例化 if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; cls = initializeAndLeaveLocked(cls, inst, runtimeLock); // runtimeLock may have been dropped but is now locked again // If sel == initialize, class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won't happen. 2778172 &#125;/*...*/&#125; 实例化之后，Person类的DefaultAWZ 为 true 。 alloc 在 NSObject.mm 文件中的定义如下： 123+ (id)alloc &#123; return _objc_rootAlloc(self);&#125; 方法只是调用了_objc_rootAlloc()方法： 1234567// Base class implementation of +alloc. cls is not nil.// Calls [cls allocWithZone:nil].id_objc_rootAlloc(Class cls)&#123; return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);&#125; _objc_rootAlloc()也只是做了转发，又一次调用callAlloc()，不过入参不同。此时 DefaultAWZ 为 true，那么 hasCustomAWZ 则为 false，因此(fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ()))判断为true。执行if 判断中的代码。首先会判断canAllocFast，相关源码如下： 1234567891011121314bool canAllocFast() &#123; assert(!isFuture()); return bits.canAllocFast();&#125;#if FAST_ALLOC bool canAllocFast() &#123; return bits &amp; FAST_ALLOC; &#125;#else bool canAllocFast() &#123; return false; &#125;#endif 参见前文中bits 在内存中每个位的含义定义，FAST_ALLOC 的定义是在最后一个 else 中，但前面是 #elif 1，这个条件是恒真的，因此永远不会走到最后一个 else，也就是说，FAST_ALLOC永远不会被赋值，所以canAllocFast 返回 false。因此 callAlloc 会进入上面 else 分之。执行 class_createInstance() 12345id class_createInstance(Class cls, size_t extraBytes)&#123; return _class_createInstanceFromZone(cls, extraBytes, nil);&#125; class_createInstance() 调用了 _class_createInstanceFromZone()来真正创建对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/************************************************************************ class_createInstance* fixme* Locking: none**********************************************************************/static __attribute__((always_inline)) id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil)&#123; // 如果入参 cls 为nil，直接返回nil if (!cls) return nil; // 校验对象是否已经Realized assert(cls-&gt;isRealized()); // Read class's info bits all at once for performance // 读取 class 中的bits信息中标识信息 bool hasCxxCtor = cls-&gt;hasCxxCtor(); bool hasCxxDtor = cls-&gt;hasCxxDtor(); bool fast = cls-&gt;canAllocNonpointer(); size_t size = cls-&gt;instanceSize(extraBytes); if (outAllocatedSize) *outAllocatedSize = size; id obj; if (!zone &amp;&amp; fast) &#123; obj = (id)calloc(1, size); if (!obj) return nil; obj-&gt;initInstanceIsa(cls, hasCxxDtor); &#125; else &#123; if (zone) &#123; obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size); &#125; else &#123; obj = (id)calloc(1, size); &#125; if (!obj) return nil; // Use raw pointer isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); &#125; if (cxxConstruct &amp;&amp; hasCxxCtor) &#123; obj = _objc_constructOrFree(obj, cls); &#125; return obj;&#125; 方法包含如下几步： 判断如果入参 cls 为nil，直接返回nil； 断言校验对象是否已经Realized realizeClass：在某个类初始化之前，objc_class-&gt;data() 返回的指针指向的其实是个 class_ro_t 结构体。等到 static Class realizeClass(Class cls) 静态方法在类第一次初始化时被调用，它会: 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针 初始化一个 class_rw_t 结构体 设置结构体 ro 的值以及 flag 最后设置正确的 data。 class_rw_t 的内容是可以在运行时被动态修改的，可以说运行时对类的拓展大都是存储在这里的，而 class_ro_t 存储的大多是类在编译时就已经确定的信息。 经过 realizeClass 函数处理的类才是『真正的』类，调用它时不能对类做写操作。 读取 class 中的bits信息中标识信息，此处hasCxxCtor = false, hasCxxDtor = false, fast = true； hasCxxCtor() 用于获取类或父类是否有c++ 构造函数，相关源码如下： 123456789101112131415161718192021bool hasCxxCtor() &#123; // addSubclass() propagates this flag from the superclass. assert(isRealized()); return bits.hasCxxCtor();&#125;#if FAST_HAS_CXX_CTOR bool hasCxxCtor() &#123; return getBit(FAST_HAS_CXX_CTOR); &#125; void setHasCxxCtor() &#123; setBits(FAST_HAS_CXX_CTOR); &#125;#else bool hasCxxCtor() &#123; return data()-&gt;flags &amp; RW_HAS_CXX_CTOR; &#125; void setHasCxxCtor() &#123; data()-&gt;setFlags(RW_HAS_CXX_CTOR); &#125;#endif hasCxxDtor()函数用于获取类或父类是否有c++ 析构函数，相关源码如下： 123456789101112131415161718192021bool hasCxxDtor() &#123; // addSubclass() propagates this flag from the superclass. assert(isRealized()); return bits.hasCxxDtor();&#125;#if FAST_HAS_CXX_DTOR bool hasCxxDtor() &#123; return getBit(FAST_HAS_CXX_DTOR); &#125; void setHasCxxDtor() &#123; setBits(FAST_HAS_CXX_DTOR); &#125;#else bool hasCxxDtor() &#123; return data()-&gt;flags &amp; RW_HAS_CXX_DTOR; &#125; void setHasCxxDtor() &#123; data()-&gt;setFlags(RW_HAS_CXX_DTOR); &#125;#endif canAllocNonpointer() 用于获取类的实例是否需要raw isa，相关源码如下： 12345678910111213141516171819202122232425262728293031bool canAllocNonpointer() &#123; assert(!isFuture()); return !instancesRequireRawIsa();&#125;bool instancesRequireRawIsa() &#123; return bits.instancesRequireRawIsa();&#125;#if FAST_REQUIRES_RAW_ISA bool instancesRequireRawIsa() &#123; return getBit(FAST_REQUIRES_RAW_ISA); &#125; void setInstancesRequireRawIsa() &#123; setBits(FAST_REQUIRES_RAW_ISA); &#125;#elif SUPPORT_NONPOINTER_ISA bool instancesRequireRawIsa() &#123; return data()-&gt;flags &amp; RW_REQUIRES_RAW_ISA; &#125; void setInstancesRequireRawIsa() &#123; data()-&gt;setFlags(RW_REQUIRES_RAW_ISA); &#125;#else bool instancesRequireRawIsa() &#123; return true; &#125; void setInstancesRequireRawIsa() &#123; // nothing &#125;#endif 其中 SUPPORT_NONPOINTER_ISA 宏定义和含义如下： 1234567891011121314151617181920212223242526// Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa // field as an index into a class table.// Note, keep this in sync with any .s files which also define it.// Be sure to edit objc-abi.h as well.#if __ARM_ARCH_7K__ &gt;= 2 || (__arm64__ &amp;&amp; !__LP64__)# define SUPPORT_INDEXED_ISA 1#else# define SUPPORT_INDEXED_ISA 0#endif// Define SUPPORT_PACKED_ISA=1 on platforms that store the class in the isa // field as a maskable pointer with other data around it.#if (!__LP64__ || TARGET_OS_WIN32 || \\ (TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_IOSMAC))# define SUPPORT_PACKED_ISA 0#else# define SUPPORT_PACKED_ISA 1#endif// Define SUPPORT_NONPOINTER_ISA=1 on any platform that may store something// in the isa field that is not a raw pointer.#if !SUPPORT_INDEXED_ISA &amp;&amp; !SUPPORT_PACKED_ISA# define SUPPORT_NONPOINTER_ISA 0#else# define SUPPORT_NONPOINTER_ISA 1#endif 如果是64位设备，canAllocNonpointer()函数返回值为true。 计算所需开辟内存空间，这里涉及到了经常被提及的 内存对齐； 一样通过源码来解读一下，objc_class 中有获取实例占用内存大小的函数 instanceSize 1234567891011size_t instanceSize(size_t extraBytes) &#123; size_t size = alignedInstanceSize() + extraBytes; // CF 要求 all objects 需要最少为 16 bytes. if (size &lt; 16) size = 16; return size;&#125;// Class's ivar size 四舍五入 to a pointer-size boundary.uint32_t alignedInstanceSize() &#123; return word_align(unalignedInstanceSize());&#125; 12345678910111213static inline uint32_t word_align(uint32_t x) &#123; return (x + WORD_MASK) &amp; ~WORD_MASK;&#125;#ifdef __LP64__# define WORD_SHIFT 3UL# define WORD_MASK 7UL# define WORD_BITS 64#else# define WORD_SHIFT 2UL# define WORD_MASK 3UL# define WORD_BITS 32#endif instanceSize传入参数 extraBytes为 0，从上面源码我们首先可以看到，属性64位下满足 8字节对齐，32位下满足 4字节对齐。 使用的是 (x + WORD_MASK) &amp; ~WORD_MASK ;。跟位运算左移三位右移三位是同样的效果，类结构体 RO中的信息在编译期就已经确定了 ( data()-&gt;ro-&gt;instanceSize，也就是 unalignedInstanceSize) 。 同时，满足最小 16字节 ( if (size &lt; 16) size = 16) 。 因为入参zone 为 nil，且如果是64位设备，fast为true，所以 if 判断为true； 执行如下代码块： 123456id obj;if (!zone &amp;&amp; fast) &#123; obj &#x3D; (id)calloc(1, size); if (!obj) return nil; obj-&gt;initInstanceIsa(cls, hasCxxDtor);&#125; 首先调用calloc() 函数在内存中分配1个长度为size的连续空间。calloc() 函数分配的对象内存是按 16 字节对齐标准的。 calloc() 开辟了内存空间后返回一个指向该内存地址的指针。如果内存分配不成功，则直接返回 nil。否则执行initInstanceIsa() 12345678inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)&#123; assert(!cls-&gt;instancesRequireRawIsa()); assert(hasCxxDtor &#x3D;&#x3D; cls-&gt;hasCxxDtor()); initIsa(cls, true, hasCxxDtor);&#125; 方法调用initIsa() 12345678910111213141516171819202122232425262728293031323334353637inline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) &#123; assert(!isTaggedPointer()); if (!nonpointer) &#123; isa.cls &#x3D; cls; &#125; else &#123; assert(!DisableNonpointerIsa); assert(!cls-&gt;instancesRequireRawIsa()); isa_t newisa(0);#if SUPPORT_INDEXED_ISA assert(cls-&gt;classArrayIndex() &gt; 0); newisa.bits &#x3D; ISA_INDEX_MAGIC_VALUE; &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor &#x3D; hasCxxDtor; newisa.indexcls &#x3D; (uintptr_t)cls-&gt;classArrayIndex();#else newisa.bits &#x3D; ISA_MAGIC_VALUE; &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor &#x3D; hasCxxDtor; newisa.shiftcls &#x3D; (uintptr_t)cls &gt;&gt; 3;#endif &#x2F;&#x2F; This write must be performed in a single store in some cases &#x2F;&#x2F; (for example when realizing a class because other threads &#x2F;&#x2F; may simultaneously try to use the class). &#x2F;&#x2F; fixme use atomics here to guarantee single-store and to &#x2F;&#x2F; guarantee memory order w.r.t. the class index table &#x2F;&#x2F; ...but not too atomic because we don&#39;t want to hurt instantiation isa &#x3D; newisa; &#125;&#125; 这里就是初始化 isa，并将 isa 的 bits 赋值为 ISA_MAGIC_VALUE。ISA_MAGIC_VALUE初始化了 isa 的 magic 和 nonpointer 字段，并绑定指向 cls：newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3。参考前面 ISA_BITFIELD介绍，前三位分别是nonpointer、has_assoc和has_cxx_dtor，各占一位。后面就是固定位数为shiftcls。在初始化 isa 的时候，并没有对extra_rc 进行操作。也就是说 alloc 方法实际上并没有设置对象的引用计数值为 1。 问题：1、从调用栈中可以看到 NSObject 是有 alloc 类方法的，那么我们外部所写的 [NSObject alloc] 为什么不调用 alloc 类方法 , 反而来到了 objc_alloc 中呢？对于OC运行时，入口方法如下 123456789101112131415161718192021/************************************************************************ _objc_init* Bootstrap initialization. Registers our image notifier with dyld.* Called by libSystem BEFORE library initialization time**********************************************************************/void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);&#125; 方法中调用的 map_images 会调用 map_images_nolock 方法： 1234567891011121314/************************************************************************ map_images* Process the given images which are being mapped in by dyld.* Calls ABI-agnostic code after taking ABI-specific locks.** Locking: write-locks runtimeLock**********************************************************************/voidmap_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[])&#123; mutex_locker_t lock(runtimeLock); return map_images_nolock(count, paths, mhdrs);&#125; map_images_nolock 方法会调用 _read_images 1234567891011121314151617181920212223242526272829/************************************************************************ map_images_nolock* Process the given images which are being mapped in by dyld.* All class registration and fixups are performed (or deferred pending* discovery of missing superclasses etc), and +load methods are called.** info[] is in bottom-up order i.e. libobjc will be earlier in the * array than any library that links to libobjc.** Locking: loadMethodLock(old) or runtimeLock(new) acquired by map_images.**********************************************************************/#if __OBJC2__#include \"objc-file.h\"#else#include \"objc-file-old.h\"#endifvoid map_images_nolock(unsigned mhCount, const char * const mhPaths[], const struct mach_header * const mhdrs[])&#123; /*...*/ if (hCount &gt; 0) &#123; _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses); &#125; firstTime = NO;&#125; _read_images 方法中会调用 123456789101112131415161718192021222324252627282930313233/************************************************************************ _read_images* Perform initial processing of the headers in the linked * list beginning with headerList. ** Called by: map_images_nolock** Locking: runtimeLock acquired by map_images**********************************************************************/void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)&#123;/*...*/#if SUPPORT_FIXUP // Fix up old objc_msgSend_fixup call sites for (EACH_HEADER) &#123; message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count); if (count == 0) continue; if (PrintVtables) &#123; _objc_inform(\"VTABLES: repairing %zu unsupported vtable dispatch \" \"call sites in %s\", count, hi-&gt;fname()); &#125; for (i = 0; i &lt; count; i++) &#123; fixupMessageRef(refs+i); &#125; &#125; ts.log(\"IMAGE TIMES: fix up objc_msgSend_fixup\");#endif /*...*/&#125; fixupMessageRef 方法中 alloc 对应符号会被设置为 objc_alloc 123456789101112131415161718192021222324252627282930/************************************************************************ fixupMessageRef* Repairs an old vtable dispatch call site. * vtable dispatch itself is not supported.**********************************************************************/static void fixupMessageRef(message_ref_t *msg)&#123; msg-&gt;sel = sel_registerName((const char *)msg-&gt;sel); if (msg-&gt;imp == &amp;objc_msgSend_fixup) &#123; if (msg-&gt;sel == SEL_alloc) &#123; msg-&gt;imp = (IMP)&amp;objc_alloc; &#125; else if (msg-&gt;sel == SEL_allocWithZone) &#123; msg-&gt;imp = (IMP)&amp;objc_allocWithZone; &#125; else if (msg-&gt;sel == SEL_retain) &#123; msg-&gt;imp = (IMP)&amp;objc_retain; &#125; else if (msg-&gt;sel == SEL_release) &#123; msg-&gt;imp = (IMP)&amp;objc_release; &#125; else if (msg-&gt;sel == SEL_autorelease) &#123; msg-&gt;imp = (IMP)&amp;objc_autorelease; &#125; else &#123; msg-&gt;imp = &amp;objc_msgSend_fixedup; &#125; &#125; /*...*/&#125;// SUPPORT_FIXUP#endif 2、为什么 alloc 没有设置引用计数值为 1呢？前文说到，引用计数存储的值为实际引用计数减一，在获取对象的引用计数时，会对存储的值进行+1操作，因此这里就不需要设置引用计数值为 1。 initalloc 执行完之后，则会调用 init 方法： 12345678910111213141516// Replaced by CF (throws an NSException)+ (id)init &#123; return (id)self;&#125;- (id)init &#123; return _objc_rootInit(self);&#125;id_objc_rootInit(id obj)&#123; // In practice, it will be hard to rely on this function. // Many classes do not properly chain -init calls. return obj;&#125; init 默认返回方法调用者。这个设计其实是为了方便工程设计，以便于在初始化对象时做一些初始化或者赋值操作。 new123+ (id)new &#123; return [callAlloc(self, false/*checkNil*/) init];&#125; new相当于 alloc + init。但是使用 new 并不能调用我们所重写的各种 init工厂方法 。 copy 和 mutableCopy1234567- (id)copy &#123; return [(id)self copyWithZone:nil];&#125;- (id)mutableCopy &#123; return [(id)self mutableCopyWithZone:nil];&#125; copy 和 mutableCopy 都是基于 NSCopying 和 NSMutableCopying 方法约定，分别调用各类自己实现的 copyWithZone: 和 mutableCopyWithZone: 方法。这些方法无论实现方式是深拷贝还是浅拷贝，都会增加引用计数。（有些类的策略是懒拷贝，只增加引用计数但并不真的拷贝，等对象内容发生变化时再拷贝一份出来，比如 NSArray）。 持有对象在非 ARC 环境下可以使用 retain 方法对引用计数进行+1操作。上文中提到，runtime 初始化的时候，会进行符号绑定。 retain 对应符号会被设置为 objc_retain 。所以我们从objc_retain 方法开始探究： 123456789101112131415161718192021222324252627/************************************************************************ Optimized retain/release/autorelease entrypoints**********************************************************************/#if __OBJC2____attribute__((aligned(16)))id objc_retain(id obj)&#123; if (!obj) return obj; if (obj-&gt;isTaggedPointer()) return obj; return obj-&gt;retain();&#125;/*...*/// OBJC2#else// not OBJC2id objc_retain(id obj) &#123; return [obj retain]; &#125;/*...*/#endif 如果是__OBJC2__，则调用objc_object::retain函数；否则调用retain方法。objc_object::retain函数实现如下： 1234567891011// Equivalent to calling [this retain], with shortcuts if there is no overrideinline id objc_object::retain()&#123; assert(!isTaggedPointer()); if (fastpath(!ISA()-&gt;hasCustomRR())) &#123; return rootRetain(); &#125; return ((id(*)(objc_object *, SEL))objc_msgSend)(this, SEL_retain);&#125; 如果以下内存管理方法：retain/release/autorelease/retainCount/_tryRetain/_isdealocation /retainWeakReference/allowsWeakReference 没有被重写，直接调用 objc_object::rootRetain，这是快捷方式；否则调用 retain 方法。 retain 方法实现如下 12345678+ (id)retain &#123; return (id)self;&#125;// Replaced by ObjectAlloc- (id)retain &#123; return ((id)self)-&gt;rootRetain();&#125; 如果是类对象，则直接返回自身，否则调用 rootRetain() 12345ALWAYS_INLINE id objc_object::rootRetain()&#123; return rootRetain(false, false);&#125; 方法只是做了转发，实际负责修改引用计数的是objc_object::rootRetain() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465ALWAYS_INLINE id objc_object::rootRetain(bool tryRetain, bool handleOverflow)&#123; // 如果是 tagged pointer，直接返回 this if (isTaggedPointer()) return (id)this; bool sideTableLocked = false; bool transcribeToSideTable = false; // 是否需要将部分引用计数迁移到 sideTable 中 isa_t oldisa; isa_t newisa; do &#123; transcribeToSideTable = false; // 获取 isa oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; // 如果不是 nonpointer isa if (slowpath(!newisa.nonpointer)) &#123; ClearExclusive(&amp;isa.bits); if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock(); // tryRetain == false，调用 sidetable_retain，获取 SideTable 的引用计数表中保存的对象引用计数值，并判断如果没有溢出，更新引用计数值为原来的值+1 if (tryRetain) return sidetable_tryRetain() ? (id)this : nil; else return sidetable_retain(); &#125; // don't check newisa.fast_rr; we already called any RR overrides if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123; ClearExclusive(&amp;isa.bits); if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock(); return nil; &#125; uintptr_t carry; // 用于判断 isa 的 extra_rc 是否溢出 // 将 `extra_rc` 中的引用计数值 +1 newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry); // extra_rc++ // 如果 extra_rc 溢出 if (slowpath(carry)) &#123; // newisa.extra_rc++ overflowed // 如果 handleOverflow == false，调用 rootRetain_overflow if (!handleOverflow) &#123; ClearExclusive(&amp;isa.bits); return rootRetain_overflow(tryRetain); &#125; // Leave half of the retain counts inline and // prepare to copy the other half to the side table. // 保留一半的引用计数在 extra_rc 中 // 准备把另一半引用计数存储到 Sidetable 中 if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock(); sideTableLocked = true; transcribeToSideTable = true; // 设置 transcribeToSideTable 为 true newisa.extra_rc = RC_HALF; // 设置 extra_rc 的值为 RC_HALF # define RC_HALF (1ULL&lt;&lt;18) newisa.has_sidetable_rc = true; // 设置 has_sidetable_rc 为 true &#125; &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits))); // 更新 isa.bits 成功 // 如果需要将溢出的引用计数存储到 sidetable 中 if (slowpath(transcribeToSideTable)) &#123; // Copy the other half of the retain counts to the side table. // 将 `extra_rc` 中引用计数值的一半，迁移至 side table sidetable_addExtraRC_nolock(RC_HALF); &#125; if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock(); return (id)this;&#125; 忽略部分细节和不会执行的代码，方法主要包含以下几步： 【第一步】校验如果是 tagged pointer，直接返回 this 【第二步】定义局部变量 【第三步】进入 do-while 循环 获取isa并保存在局部变量中 如果 isa 不是 nonpointer 判断如果入参 tryRetain 为false 且 sidetable上锁了，解锁sidetable； 执行 sidetable_retain()，获取 SideTable 的引用计数表中保存的对象引用计数值，并判断如果没有溢出，更新引用计数值为原来的值+1； 12345678910111213141516171819202122idobjc_object::sidetable_retain()&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.nonpointer);#endif // 根据对象查找到SideTable SideTable&amp; table = SideTables()[this]; // SideTable 上锁 table.lock(); // 获取 SideTable 的引用计数表中保存的对象引用计数值 size_t&amp; refcntStorage = table.refcnts[this]; // 如果获取到的对象引用计数值没有溢出 if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123; // 更新对象引用计数表中对象的引用计数值为原来的值+1 refcntStorage += SIDE_TABLE_RC_ONE; &#125; // SideTable 上锁 table.unlock(); // 返回对象本身 return (id)this;&#125; 其中 SIDE_TABLE_RC_PINNED 和 SIDE_TABLE_RC_ONE定义如下： 123456789101112131415// The order of these bits is important.#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)#define SIDE_TABLE_DEALLOCATING (1UL&lt;&lt;1) // MSB-ward of weak bit#define SIDE_TABLE_RC_ONE (1UL&lt;&lt;2) // MSB-ward of deallocating bit#define SIDE_TABLE_RC_PINNED (1UL&lt;&lt;(WORD_BITS-1))#ifdef __LP64__# define WORD_SHIFT 3UL# define WORD_MASK 7UL# define WORD_BITS 64#else# define WORD_SHIFT 2UL# define WORD_MASK 3UL# define WORD_BITS 32#endif 如果 isa 是 nonpointer，就会调用 addc 将 extra_rc 中的引用计数值 +1 12345static ALWAYS_INLINE uintptr_t addc(uintptr_t lhs, uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout)&#123; return __builtin_addcl(lhs, rhs, carryin, carryout);&#125; 这个函数的作用就是增加引用计数。 判断如果 extra_rc 溢出 判断如果入参 handleOverflow 为false，就会调用rootRetain_overflow并返回； 12345NEVER_INLINE id objc_object::rootRetain_overflow(bool tryRetain)&#123; return rootRetain(tryRetain, true);&#125; 该函数又调用了 rootRetain，但参数 handleOverflow 传 true。 否则，将 extra_rc 中保存的引用计数值的一半迁移到 sideTable，并更新isa的 extra_rc 和 has_sidetable_rc 循环退出条件为 StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits) == true，即成功更新isa.bits 123456static ALWAYS_INLINEboolStoreExclusive(uintptr_t *dst, uintptr_t oldvalue, uintptr_t value)&#123; return __c11_atomic_compare_exchange_weak((_Atomic(uintptr_t) *)dst, &amp;oldvalue, value, __ATOMIC_RELAXED, __ATOMIC_RELAXED);&#125; __c11_atomic_compare_exchange_weak() 函数是将 dst 与 oldvalue进行原子比较，如果相等，则用value替换 dst（执行读取 - 修改 - 写入操作）。否则，将 dst 的值修改为 oldvalue（进行负载操作） 。返回值：true如果dst等于oldvalue，否则false； 【第四步】如果上一步循环中判断extra_rc中溢出了，则执行 sidetable_addExtraRC_nolock()将 extra_rc 中的引用计数值的一半，迁移至 side table 12345678910111213141516171819202122232425262728293031323334353637// Move some retain counts to the side table from the isa field.// Returns true if the object is now pinned.bool objc_object::sidetable_addExtraRC_nolock(size_t delta_rc)&#123; assert(isa.nonpointer); // 根据对象查找到SideTable SideTable&amp; table = SideTables()[this]; // 获取 SideTable 的引用计数表中保存的对象引用计数值 size_t&amp; refcntStorage = table.refcnts[this]; size_t oldRefcnt = refcntStorage; // isa-side bits should not be set here assert((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == 0); assert((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == 0); // 如果获取到的对象引用计数值溢出了，返回true if (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) return true; uintptr_t carry; // 调用 addc 将前面获取到的 SideTable 的引用计数表中保存的对象引用计数值加上 `extra_rc` 中的引用计数值的一半 size_t newRefcnt = addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, 0, &amp;carry); // 如果相加之后溢出了 if (carry) &#123; // 更新对象引用计数表中对象的引用计数值标记为溢出 refcntStorage = SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK); // 返回true return true; &#125; else &#123; // 更新对象引用计数表中对象的引用计数值相加之后的值 refcntStorage = newRefcnt; // 返回false return false; &#125;&#125; 如果 extra_rc 溢出了，就会调用 sidetable_addExtraRC_nolock 将 extra_rc 的一半引用计数转移到 sidetable 中存储，也是调用 addc 对 refcnt 引用计数表进行引用计数增加操作，进行相应容错处理后，更新引用计数表中的引用计数值。 释放对象当我们在不需要使用（持有）对象的时候，需要调用一下release方法进行释放。release方法会将对象的引用计数 -1。同样的，由于runtime 初始化的时候，会进行符号绑定。 release 对应符号会被设置为 objc_release 。所以我们从 objc_release 方法开始探究： 1234567891011121314151617181920212223242526272829/************************************************************************ Optimized retain/release/autorelease entrypoints**********************************************************************/#if __OBJC2__/*...*/__attribute__((aligned(16)))void objc_release(id obj)&#123; if (!obj) return; if (obj-&gt;isTaggedPointer()) return; return obj-&gt;release();&#125;/*...*/// OBJC2#else// not OBJC2/*...*/void objc_release(id obj) &#123; [obj release]; &#125;/*...*/#endif 如果是 __OBJC2__，则调用 objc_object::release 函数；否则调用 release 方法。 12345678910111213// Equivalent to calling [this release], with shortcuts if there is no overrideinline voidobjc_object::release()&#123; assert(!isTaggedPointer()); if (fastpath(!ISA()-&gt;hasCustomRR())) &#123; rootRelease(); return; &#125; ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_release);&#125; 如果以下内存管理方法：retain/release/autorelease/retainCount/_tryRetain/_isdealocation /retainWeakReference/allowsWeakReference 没有被重写，直接调用objc_object::rootRelease；否则调用release方法。release方法实现如下： 1234567+ (oneway void)release &#123;&#125;&#x2F;&#x2F; Replaced by ObjectAlloc- (oneway void)release &#123; ((id)self)-&gt;rootRelease();&#125; 如果是实例对象调用 objc_object::rootRelease() 123456789101112131415// Base release implementation, ignoring overrides.// Does not call -dealloc.// Returns true if the object should now be deallocated.// This does not check isa.fast_rr; if there is an RR override then // it was already called and it chose to call [super release].// // handleUnderflow=false is the frameless fast path.// handleUnderflow=true is the framed slow path including side table borrow// The code is structured this way to prevent duplication.ALWAYS_INLINE bool objc_object::rootRelease()&#123; return rootRelease(true, false);&#125; 方法只是做了转发，实际负责修改引用计数的是objc_object::rootRelease()，该方法实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147ALWAYS_INLINE bool objc_object::rootRelease(bool performDealloc, bool handleUnderflow)&#123; // 如果是 tagged pointer，直接返回 false if (isTaggedPointer()) return false; bool sideTableLocked = false; isa_t oldisa; isa_t newisa; retry: do &#123; // 获取 isa oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; // 如果不是 nonpointer isa if (slowpath(!newisa.nonpointer)) &#123; ClearExclusive(&amp;isa.bits); if (sideTableLocked) sidetable_unlock(); // 调用 sidetable_release return sidetable_release(performDealloc); &#125; // don't check newisa.fast_rr; we already called any RR overrides uintptr_t carry; newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry); // extra_rc-- // 如果发现 extra_rc 中的引用计数已经为 0 了 if (slowpath(carry)) &#123; // don't ClearExclusive() // 跳转到 underflow goto underflow; &#125; &#125; while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits))); // 保存更新后的 isa.bits if (slowpath(sideTableLocked)) sidetable_unlock(); return false; underflow: // newisa.extra_rc-- underflowed: borrow from side table or deallocate // abandon newisa to undo the decrement // 如果引用计数为0，丢弃对extra_rc--操作 newisa = oldisa; // 如果 isa 的 has_sidetable_rc 字段值为 1 if (slowpath(newisa.has_sidetable_rc)) &#123; // 如果 handleUnderflow == false，调用 rootRelease_underflow if (!handleUnderflow) &#123; ClearExclusive(&amp;isa.bits); return rootRelease_underflow(performDealloc); &#125; // Transfer retain count from side table to inline storage. // 将引用计数从 sidetable 中转到 extra_rc 中存储 if (!sideTableLocked) &#123; ClearExclusive(&amp;isa.bits); sidetable_lock(); sideTableLocked = true; // Need to start over to avoid a race against // the nonpointer -&gt; raw pointer transition. goto retry; &#125; // Try to remove some retain counts from the side table. // 尝试从 sidetable 中删除（借出）一些引用计数，传入 RC_HALF // borrowed 为 sidetable 实际删除（借出）的引用计数 size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF); // To avoid races, has_sidetable_rc must remain set // even if the side table count is now zero. // 为了避免竞争，has_sidetable_rc 必须保持设置 // 即使 sidetable 中的引用计数现在是 0 if (borrowed &gt; 0) &#123; // Side table retain count decreased. // Try to add them to the inline count. // 将它进行 -1，赋值给 extra_rc newisa.extra_rc = borrowed - 1; // redo the original decrement too // 存储更改后的 isa.bits bool stored = StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits); // 如果存储失败，立刻重试一次 if (!stored) &#123; // Inline update failed. // Try it again right now. This prevents livelock on LL/SC // architectures where the side table access itself may have // dropped the reservation. isa_t oldisa2 = LoadExclusive(&amp;isa.bits); isa_t newisa2 = oldisa2; if (newisa2.nonpointer) &#123; uintptr_t overflow; newisa2.bits = addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow); if (!overflow) &#123; stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, newisa2.bits); &#125; &#125; &#125; // 如果还是存储失败，把引用计数再重新保存到 sidetable 中 if (!stored) &#123; // Inline update failed. // Put the retains back in the side table. sidetable_addExtraRC_nolock(borrowed); goto retry; &#125; // Decrement successful after borrowing from side table. // This decrement cannot be the deallocating decrement - the side // table lock and has_sidetable_rc bit ensure that if everyone // else tried to -release while we worked, the last one would block. sidetable_unlock(); return false; &#125; else &#123; // Side table is empty after all. Fall-through to the dealloc path. &#125; &#125; // 如果引用计数为 0，dealloc 对象 // Really deallocate. // 如果当前 newisa 处于 deallocating 状态，保证对象只会 dealloc 一次 if (slowpath(newisa.deallocating)) &#123; ClearExclusive(&amp;isa.bits); if (sideTableLocked) sidetable_unlock(); // 调用 overrelease_error return overrelease_error(); // does not actually return &#125; // 设置 newisa 为 deallocating 状态 newisa.deallocating = true; // 如果存储失败，继续重试 if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry; if (slowpath(sideTableLocked)) sidetable_unlock(); __sync_synchronize(); // 如果 performDealloc == true，给对象发送一条 dealloc 消息 if (performDealloc) &#123; ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc); &#125; return true;&#125; 忽略部分细节和不会执行的代码，方法主要包含以下几步： 【第一步】校验如果是 tagged pointer，直接返回 false 【第二步】定义局部变量 【第三步】进入 do-while 循环 获取isa并保存在局部变量中 如果不是 nonpointer isa 判断如果sidetable上锁了，则进行解锁； 执行 sidetable_retain()，找到对象所在的引用计数表，并将引用计数 -1； 12345678910111213141516171819202122232425262728293031323334353637383940414243// rdar://20206767// return uintptr_t instead of bool so that the various raw-isa // -release paths all return zero in eaxuintptr_tobjc_object::sidetable_release(bool performDealloc)&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.nonpointer);#endif // 根据对象查找到所在的SideTable SideTable&amp; table = SideTables()[this]; // 标识是否需要销毁对象 bool do_dealloc = false; // SideTable 上锁 table.lock(); // 在SideTables的引用计数表（RefcountMap）中查找对象的应用计数 RefcountMap::iterator it = table.refcnts.find(this); if (it == table.refcnts.end()) &#123;// 如果没有查找到 // 标识对象需要销毁 do_dealloc = true; // 将正在销毁标识（1UL&lt;&lt;1）保存为对象在引用计数表中的引用计数值 table.refcnts[this] = SIDE_TABLE_DEALLOCATING; &#125; else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;// 如果查找到了，但是引用计数值为 0 // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it. // 标识对象需要销毁 do_dealloc = true; // 将对象标记正在销毁 it-&gt;second |= SIDE_TABLE_DEALLOCATING; &#125; else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;// 如果对象没有溢出 // 将引用计数值-1 it-&gt;second -= SIDE_TABLE_RC_ONE; &#125; // SideTable 解锁 table.unlock(); // 如果对象需要销毁 且 入参为true if (do_dealloc &amp;&amp; performDealloc) &#123; // 发送dealloc消息，销毁对象 ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc); &#125; // 返回是否需要销毁对象标识 return do_dealloc;&#125; 方法会查找对象所在的SideTable并从引用计数表中查找对象的引用计数。如果引用计数表中没有查找到对象的引用计数（it == table.refcnts.end()），则标记对象为正在销毁；如果对象的引用计数值为 0（it-&gt;second &lt; SIDE_TABLE_DEALLOCATING），将对象标记为正在销毁（it-&gt;second |= SIDE_TABLE_DEALLOCATING）；否则就将引用计数减一（it-&gt;second -= SIDE_TABLE_RC_ONE）。 这也解释了为什么在存储引用计数时总是真正的引用计数值减一。因为 release 本来是要将引用计数-1，所以存储引用计数时先预留了-1，在-1之前会先判断引用计数值是否为 0 ，如果是，那就将对象标记为正在销毁，否则才进行-1，这样就避免了负数的产生。 针对nonpointer isa，执行 subc()，对extra_rc进行-1 12345static ALWAYS_INLINE uintptr_t subc(uintptr_t lhs, uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout)&#123; return __builtin_subcl(lhs, rhs, carryin, carryout);&#125; 判断如果此时 extra_rc 中存储的引用计数为0 a. 撤消 extra_rc-- 操作 b. 如果 SideTable 中存储有对象引用计数， 如果入参 handleUnderflow 为 false，调用 rootRelease_underflow() 并返回； 12345NEVER_INLINE bool objc_object::rootRelease_underflow(bool performDealloc)&#123; return rootRelease(performDealloc, true);&#125; 函数又调用了rootRelease，但参数handleUnderflow传true。 判断如果当前sideTable 不在加锁状态，为了保证线程安全，将sideTable 加锁，并跳转到【第三步】从头开始执行； 调用 sidetable_subExtraRC_nolock() 将 sidetable 中存储的一些引用计数值转移到isa中 1234567891011121314151617181920212223242526272829// Move some retain counts from the side table to the isa field.// Returns the actual count subtracted, which may be less than the request.size_t objc_object::sidetable_subExtraRC_nolock(size_t delta_rc)&#123; assert(isa.nonpointer); // 根据对象查找到SideTable SideTable&amp; table = SideTables()[this]; RefcountMap::iterator it = table.refcnts.find(this); // 如果引用计数表中没有查找到对象的引用计数值或者查找到的引用计数值为0，直接返回0 if (it == table.refcnts.end() || it-&gt;second == 0) &#123; // Side table retain count is zero. Can't borrow. return 0; &#125; // 取出引用计数表中查找到的引用计数值 size_t oldRefcnt = it-&gt;second; // isa-side bits should not be set here assert((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == 0); assert((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == 0); // 将对象的引用计数值减去入参传入的要迁移的值 size_t newRefcnt = oldRefcnt - (delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT); assert(oldRefcnt &gt; newRefcnt); // shouldn't underflow // 更新引用计数表中对象的引用计数值为新值 it-&gt;second = newRefcnt; // 返回入参 return delta_rc;&#125; 函数会查询 SideTables 中对象的引用计数，如果引用计数表中没有查找到该对象会查找到的引用计数为0，则直接返回0；否则，将查找到的引用计数值减去对入参进行向右移位操作（it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT）获取到的引用计数值，获取到新的引用计数值，校验之后用新的引用计数值更新引用计数表中对象的引用计数并返回。 如果实际迁移的值大于0 1）将迁移值减一之后存入isa bits的 extra_rc中。 2）然后调用 StoreReleaseExclusive() 存储更改后的 isa.bits 123456static ALWAYS_INLINEboolStoreReleaseExclusive(uintptr_t *dst, uintptr_t oldvalue, uintptr_t value)&#123; return __c11_atomic_compare_exchange_weak((_Atomic(uintptr_t) *)dst, &amp;oldvalue, value, __ATOMIC_RELEASE, __ATOMIC_RELAXED);&#125; 函数和前文中 retain 一样调用 __c11_atomic_compare_exchange_weak() 。 3）如果存储不成功，立即重试更新：重新获取isa，判断如果是 nonpointer isa，调用 addc 将 extra_rc 中的引用计数加上迁移的值减一，然后判断如果 extra_rc 没有溢出，则调用 StoreReleaseExclusive() 存储更改后的 isa.bits 如果还是没有保存成功，则执行 sidetable_addExtraRC_nolock()将迁移的引用计数值，重新存储在引用计数表中，并跳转到【第三步】从头开始执行 SideTable 解锁，并返回false 判断如果对象正在销毁，SideTable如果正在上锁状态则解锁，然后执行 overrelease_error() 12345678NEVER_INLINEbool objc_object::overrelease_error()&#123; _objc_inform_now_and_on_crash(\"%s object %p overreleased while already deallocating; break on objc_overrelease_during_dealloc_error to debug\", object_getClassName((id)this), this); objc_overrelease_during_dealloc_error(); return false; // allow rootRelease() to tail-call this&#125; 如果当前对象处于deallocating状态，再次release就会执行overrelease_error，该函数就是用来在过度调用release的时候报错用的。其中 objc_overrelease_during_dealloc_error()实现如下： 123BREAKPOINT_FUNCTION( void objc_overrelease_during_dealloc_error(void)); 将对象标记为“正在析构” 如果调用 StoreExclusive() 存储更改后的 isa.bits 失败。跳转到【第三步】从头开始执行 SideTable如果正在上锁状态则解锁 调用 __sync_synchronize() 设置内存屏障 调用 dealloc方法销毁对象 返回 true 循环退出条件为 StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits) == true，即更新 isa.bit 成功则退出循环； SideTable如果正在上锁状态则解锁 返回 false 销毁对象在 release 相关逻辑里，如果对象的引用计数为 0，则标记为正在销毁，并调用 dealloc 方法，销毁对象。 dealloc 方法实现如下： 1234// Replaced by NSZombies- (void)dealloc &#123; _objc_rootDealloc(self);&#125; _objc_rootDealloc 函数实现如下： 1234567void_objc_rootDealloc(id obj)&#123; assert(obj); obj-&gt;rootDealloc();&#125; _objc_rootDealloc 函数除了断言外，也只是调用了rootDealloc 12345678910111213141516171819202122inline voidobjc_object::rootDealloc()&#123; // 判断如果是 tagged pointer，直接返回 if (isTaggedPointer()) return; // fixme necessary? if (fastpath(isa.nonpointer &amp;&amp; // 如果是 nonpointer isa !isa.weakly_referenced &amp;&amp; // 没有被弱引用指向过 !isa.has_assoc &amp;&amp; // 对象没有关联对象 !isa.has_cxx_dtor &amp;&amp; // 没有 C++ 的析构函数 !isa.has_sidetable_rc)) // 没有额外采用 SideTabel 进行引用计数存储 &#123; // 断言校验对象不在 side table（应用计数表 和 弱引用表）中 assert(!sidetable_present()); // 释放对象内存空间 free(this); &#125; else &#123; // 析构对象并释放对象内存空间 object_dispose((id)this); &#125;&#125; 方法逻辑如下： 【第一步】判断如果是 tagged pointer，直接返回； 【第二步】判断如果满足如下条件：是nonpointer isa 且 没有被弱引用指向过 且 对象没有关联对象 且 对象没有 C++ 或 ARC 的析构函数 且 对象的引用计数值有在side table存储 调用 sidetable_present 断言校验对象不在 side table（应用计数表 和 弱引用表）中 1234567891011121314151617181920#if DEBUG// Used to assert that an object is not present in the side table.boolobjc_object::sidetable_present()&#123; bool result = false; SideTable&amp; table = SideTables()[this]; table.lock(); RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) result = true; if (weak_is_registered_no_lock(&amp;table.weak_table, (id)this)) result = true; table.unlock(); return result;&#125;#endif 仅在 DEBUG 有效 调用 free 释放对象内存空间 【第三步】如果【第二步】判断条件没有满足，调用 object_dispose 123456789101112131415/************************************************************************ object_dispose* fixme* Locking: none**********************************************************************/id object_dispose(id obj)&#123; if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;&#125; 函数首先判断如果对象已经不存在了，直接返回nil，否则调用 objc_destructInstance 析构对象，然后调用 free 释放对象并返回nil，objc_destructInstance 实现如下： 1234567891011121314151617181920212223/************************************************************************ objc_destructInstance* Destroys an instance without freeing memory. * Calls C++ destructors.* Calls ARC ivar cleanup.* Removes associative references.* Returns `obj`. Does nothing if `obj` is nil.**********************************************************************/void *objc_destructInstance(id obj) &#123; if (obj) &#123; // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); // This order is important. if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); obj-&gt;clearDeallocating(); &#125; return obj;&#125; 如果对象存在，则判断对象是否有 C++ 析构函数，如果有则调用 object_cxxDestruct 从对象继承树中查找C++ 析构函数并调用，相关源代码如下： 1234567891011/************************************************************************ object_cxxDestruct.* Call C++ destructors on obj, if any.* Uses methodListLock and cacheUpdateLock. The caller must hold neither.**********************************************************************/void object_cxxDestruct(id obj)&#123; if (!obj) return; if (obj-&gt;isTaggedPointer()) return; object_cxxDestructFromClass(obj, obj-&gt;ISA());&#125; 1234567891011121314151617181920212223242526/************************************************************************ object_cxxDestructFromClass.* Call C++ destructors on obj, starting with cls's * dtor method (if any) followed by superclasses' dtors (if any), * stopping at cls's dtor (if any).* Uses methodListLock and cacheUpdateLock. The caller must hold neither.**********************************************************************/static void object_cxxDestructFromClass(id obj, Class cls)&#123; void (*dtor)(id); // Call cls's dtor first, then superclasses's dtors. for ( ; cls; cls = cls-&gt;superclass) &#123; if (!cls-&gt;hasCxxDtor()) return; dtor = (void(*)(id)) lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct); if (dtor != (void(*)(id))_objc_msgForward_impcache) &#123; if (PrintCxxCtors) &#123; _objc_inform(\"CXX: calling C++ destructors for class %s\", cls-&gt;nameForLogging()); &#125; (*dtor)(obj); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334/************************************************************************ lookupMethodInClassAndLoadCache.* Like _class_lookupMethodAndLoadCache, but does not search superclasses.* Caches and returns objc_msgForward if the method is not found in the class.**********************************************************************/IMP lookupMethodInClassAndLoadCache(Class cls, SEL sel)&#123; Method meth; IMP imp; // fixme this is incomplete - no resolver, +initialize - // but it's only used for .cxx_construct/destruct so we don't care assert(sel == SEL_cxx_construct || sel == SEL_cxx_destruct); // Search cache first. imp = cache_getImp(cls, sel); if (imp) return imp; // Cache miss. Search method list. mutex_locker_t lock(runtimeLock); meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123; // Hit in method list. Cache it. cache_fill(cls, sel, meth-&gt;imp, nil); return meth-&gt;imp; &#125; else &#123; // Miss in method list. Cache objc_msgForward. cache_fill(cls, sel, _objc_msgForward_impcache, nil); return _objc_msgForward_impcache; &#125;&#125; 判断对象是否有管理对象，如果有则调用 _object_remove_assocations 函数，移除关联对象 调用 clearDeallocating 清理side table 中对象相关数据 1234567891011121314inline void objc_object::clearDeallocating()&#123; if (slowpath(!isa.nonpointer)) &#123; // Slow path for raw pointer isa. sidetable_clearDeallocating(); &#125; else if (slowpath(isa.weakly_referenced || isa.has_sidetable_rc)) &#123; // Slow path for non-pointer isa with weak refs and/or side table data. clearDeallocating_slow(); &#125; assert(!sidetable_present());&#125; 主要调用两个方法，针对不是 nonpointer 的 isa 调用 sidetable_clearDeallocating()，针对 nonpointer isa 判断如果有被弱引用指向过 或者 对象的引用计数值有在side table存储则调用 clearDeallocating_slow()，修改弱引用表 及 从引用计数表中清除对象相关数据。 sidetable_clearDeallocating() 函数实现如下： 123456789101112131415161718void objc_object::sidetable_clearDeallocating()&#123; SideTable&amp; table = SideTables()[this]; // clear any weak table items // clear extra retain count and deallocating bit // (fixme warn or abort if extra retain count == 0 ?) table.lock(); RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) &#123; if (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123; weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; table.refcnts.erase(it); &#125; table.unlock();&#125; clearDeallocating_slow() 函数实现如下： 12345678910111213141516171819// Slow path of clearDeallocating() // for objects with nonpointer isa// that were ever weakly referenced // or whose retain count ever overflowed to the side table.NEVER_INLINE voidobjc_object::clearDeallocating_slow()&#123; assert(isa.nonpointer &amp;&amp; (isa.weakly_referenced || isa.has_sidetable_rc)); SideTable&amp; table = SideTables()[this]; table.lock(); if (isa.weakly_referenced) &#123; weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; if (isa.has_sidetable_rc) &#123; table.refcnts.erase(this); &#125; table.unlock();&#125; autoreleasepool在前面内存管理策略部分有提到，通过alloc/new/copy/mutableCopy 等方法和以它们驼峰命名开头的方法会生成并持有对象。那么调用如 [NSMutableArray array] 等不以 alloc/new/copy/mutableCopy 开头的方法使取得的对象存在，但自己不持有对象，要怎么实现呢？这里就要引入另一个概念autoreleasepool。MRC 环境中，可以通过通过调用 autorelease 可以将对象注册到autoreleasepool中，使对象在超出指定的生存范围时能够自动并正确地释放。如下图所示加入autoreleasepool中的对象可以做到延迟释放： @autoreleasepool众所周知，iOS项目都是以main函数为入口。新建一个iOS项目，可以看到main.m文件中代码如下： 12345678#import &lt;UIKit&#x2F;UIKit.h&gt;#import &quot;AppDelegate.h&quot;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 可以看到函数中使用 @autoreleasepool 包裹了实现语句，那么@autoreleasepool 到底是什么？ 打开命令行，cd到工程目录，执行 clang -rewrite-objc main.m 让编译器重新改写main.m文件: 1clang -rewrite-objc main.m 如遇如下报错： 1234main.m:9:9: fatal error: &#39;UIKit&#x2F;UIKit.h&#39; file not found#import &lt;UIKit&#x2F;UIKit.h&gt; ^~~~~~~~~~~~~~~1 error generated. 可将上面的命令替换成如下命令： 1clang -x objective-c -rewrite-objc -isysroot &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneSimulator.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneSimulator.sdk main.m 就会在当前目录下生成一个 main.cpp 文件。在文件末尾可以看到函数变成了这样： 12345int main(int argc, char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AppDelegate\"), sel_registerName(\"class\")))); &#125;&#125; 原先的@autoreleasepool没有了，取而代之的是一个 __AtAutoreleasePool 结构体。前面的注释写到 /* @autoreleasepopl */。也就是说 @autoreleasepool {} 被转换为一个 __AtAutoreleasePool 结构体： 1__AtAutoreleasePool __autoreleasepool; 在 main.cpp 中查找 __AtAutoreleasePool 结构体定义如下： 12345struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; 这个结构体会在初始化时调用 objc_autoreleasePoolPush() 方法，会在析构时调用 objc_autoreleasePoolPop 方法。 因此 main 函数在实际工作时其实是这样的： 123456789int main(int argc, char * argv[]) &#123; &#123; void * atautoreleasepoolobj = objc_autoreleasePoolPush(); return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AppDelegate\"), sel_registerName(\"class\")))); objc_autoreleasePoolPop(atautoreleasepoolobj); &#125;&#125; objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 方法在 NSObject.mm 中定义如下： 1234567891011void *objc_autoreleasePoolPush(void)&#123; return AutoreleasePoolPage::push();&#125;voidobjc_autoreleasePoolPop(void *ctxt)&#123; AutoreleasePoolPage::pop(ctxt);&#125; 可以看到上述方法只是对 AutoreleasePoolPage 类对应静态方法 push 和 pop 的封装。 AutoreleasePoolPage AutoreleasePoolPage 类也定义在NSObject.mm中，包含如下成员变量： 123456789101112131415161718192021222324class AutoreleasePoolPage &#123; // EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is // pushed and it has never contained any objects. This saves memory // when the top level (i.e. libdispatch) pushes and pops pools but // never uses them./*...*/ static size_t const SIZE = #if PROTECT_AUTORELEASEPOOL PAGE_MAX_SIZE; // must be multiple of vm page size#else PAGE_MAX_SIZE; // size and alignment, power of 2#endif static size_t const COUNT = SIZE / sizeof(id); magic_t const magic;// 16字节 id *next;// 8字节 pthread_t const thread;// 8字节 AutoreleasePoolPage * const parent;// 8字节 AutoreleasePoolPage *child;// 8字节 uint32_t const depth;// 4字节 uint32_t hiwat;// 4字节 /*...*/&#125;; SIZE 表示每个page占用大小。相关宏定义如下： 123456// Set this to 1 to mprotect() autorelease pool contents#define PROTECT_AUTORELEASEPOOL 0#define PAGE_MAX_SIZE PAGE_SIZE#define PAGE_SIZE I386_PGBYTES#define I386_PGBYTES 4096 /* bytes per 80386 page */ 可知每个page占用 4096 字节。 类中包含的变量对应的含义如下： magic：magic 用于对当前 AutoreleasePoolPage 完整性的校验 thread：AutoreleasePool是按线程一一对应的，thread指针指向当前线程 parrent &amp; child：AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成的，parent指针和child指针分别指向上下节点 next：作为游标指向栈顶最新add进来的autorelease对象的下一个位置 depth：page的深度，首次为0，以后每次初始化一个page都加1，4字节 thread：用来计算pool中最多存放的对象个数 自动释放池中的栈如果我们的一个 AutoreleasePoolPage 被初始化在内存的 0x100816000 ~ 0x100817000 中，它在内存中的结构如下： 其中有 56 bit 用于存储 AutoreleasePoolPage 的成员变量，剩下的 0x100816038 ~ 0x100817000 都是用来存储加入到自动释放池中的对象。 begin() 和 end() 这两个类的实例方法帮助我们快速获取 0x100816038 ~ 0x100817000 这一范围的边界地址。 next 指向了下一个为空的内存地址，如果 next 指向的地址加入一个 object，它就会如下图所示移动到下一个为空的内存地址中： POOL_SENTINEL（哨兵对象）细心的朋友可能会发现栈里有个陌生的东西 POOL_SENTINEL ， POOL_SENTINEL 只是 nil 的别名。 1# define POOL_BOUNDARY nil Objective-C 在每个自动释放池初始化调用 objc_autoreleasePoolPush 的时候，都会把一个 POOL_SENTINEL push 到自动释放池的栈顶，并且返回这个 POOL_SENTINEL哨兵对象。 12345678910int main(int argc, const char * argv[]) &#123; &#123; void * atautoreleasepoolobj = objc_autoreleasePoolPush(); // do whatever you want objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; Objective-C 上面的 atautoreleasepoolobj 就是一个 POOL_SENTINEL。 而当方法 objc_autoreleasePoolPop 调用时，就会向自动释放池中的对象发送 release 消息，直到第一个 POOL_SENTINEL： AutoreleasePoolPage双向链表上面讲到的都是单个AutoreleasePoolPage。当对象比较多，一个AutoreleasePoolPage如果满了，会新建一个AutoreleasePoolPage对象，与原来页链表连接完成后，后来的autorelease对象在新的page加入。 AutoreleasePoolPage 是以双向链表的形式连接起来的： 介绍完 AutoreleasePoolPage 之后，我们接下来来看两个关键方法。 objc_autoreleasePoolPush 方法objc_autoreleasePoolPush() 方法前文中有提到，只是调用了 AutoreleasePoolPage 结构体的 push() 方法。该方法实现如下： 123456789101112static inline void *push() &#123; id *dest; if (DebugPoolAllocation) &#123; // Each autorelease pool starts on a new pool page. dest = autoreleaseNewPage(POOL_BOUNDARY); &#125; else &#123; dest = autoreleaseFast(POOL_BOUNDARY); &#125; assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY); return dest;&#125; 忽略debug相关代码，方法其实也只是调用了 autoreleaseFast 方法，并传入哨兵对象 POOL_SENTINEL： 1234567891011static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123; return autoreleaseNoPage(obj); &#125;&#125; 方法分以下几步： 一、调用 hotPage() 方法获取当前正在操作的页，hotPage() 方法实现及相关变量定义如下： 123456789101112# define EMPTY_POOL_PLACEHOLDER ((id*)1)static pthread_key_t const key = AUTORELEASE_POOL_KEY;static inline AutoreleasePoolPage *hotPage() &#123; AutoreleasePoolPage *result = (AutoreleasePoolPage *) tls_get_direct(key); if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil; if (result) result-&gt;fastcheck(); return result;&#125; 从线程局部存储（TLS）中根据key获取页对象，TLS 全称Thread Local Storage，是某个线程专有的存储内存空间，以key-value的形式进行读写。 判断获取到的页为占位对象返回nil 判断如果页存在，调用 fastcheck() 通过页的magic对完整性进行校验 返回获取到的页 二、如果成功获取到 AutoreleasePoolPage 且 页没有满，则调用 add 方法添加对象 123456789id *add(id obj)&#123; assert(!full()); unprotect(); id *ret = next; // faster than `return next-1` because of aliasing *next++ = obj; protect(); return ret;&#125; 这个方法其实就是一个压栈的操作，将对象加入 AutoreleasePoolPage 然后移动栈顶的指针。 三、判断如果成功获取到 AutoreleasePoolPage 但 页已满，则调用 autoreleaseFullPage()，从传入的 page 开始向后遍历整个双向链表查找未满的 AutoreleasePoolPage，如果没有查找到，创建一个新的 AutoreleasePoolPage 并将page连接到链表。最后将查找到或者新建的page设置为hotpage。 1234567891011121314151617181920212223static __attribute__((noinline)) id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)&#123; // The hot page is full. // Step to the next non-full page, adding a new page if necessary. // Then add the object to that page. assert(page == hotPage()); assert(page-&gt;full() || DebugPoolAllocation); do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page); &#125; while (page-&gt;full()); setHotPage(page); return page-&gt;add(obj);&#125;static inline void setHotPage(AutoreleasePoolPage *page) &#123; if (page) page-&gt;fastcheck(); tls_set_direct(key, (void *)page);&#125; 四、如果当前内存中不存在 hotPage，就会调用 autoreleaseNoPage 方法初始化一个 AutoreleasePoolPage 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162BREAKPOINT_FUNCTION(void objc_autoreleaseNoPool(id obj)); static inline bool haveEmptyPoolPlaceholder()&#123; id *tls = (id *)tls_get_direct(key); return (tls == EMPTY_POOL_PLACEHOLDER);&#125;static inline id* setEmptyPoolPlaceholder()&#123; assert(tls_get_direct(key) == nil); tls_set_direct(key, (void *)EMPTY_POOL_PLACEHOLDER); return EMPTY_POOL_PLACEHOLDER;&#125; static __attribute__((noinline))id *autoreleaseNoPage(id obj)&#123; // \"No page\" could mean no pool has been pushed // or an empty placeholder pool has been pushed and has no contents yet assert(!hotPage()); bool pushExtraBoundary = false; if (haveEmptyPoolPlaceholder()) &#123; // We are pushing a second pool over the empty placeholder pool // or pushing the first object into the empty placeholder pool. // Before doing that, push a pool boundary on behalf of the pool // that is currently represented by the empty placeholder. pushExtraBoundary = true; &#125; else if (obj != POOL_BOUNDARY &amp;&amp; DebugMissingPools) &#123; // We are pushing an object with no pool in place, // and no-pool debugging was requested by environment. _objc_inform(\"MISSING POOLS: (%p) Object %p of class %s \" \"autoreleased with no pool in place - \" \"just leaking - break on \" \"objc_autoreleaseNoPool() to debug\", pthread_self(), (void*)obj, object_getClassName(obj)); objc_autoreleaseNoPool(obj); return nil; &#125; else if (obj == POOL_BOUNDARY &amp;&amp; !DebugPoolAllocation) &#123; // We are pushing a pool with no pool in place, // and alloc-per-pool debugging was not requested. // Install and return the empty pool placeholder. return setEmptyPoolPlaceholder(); &#125; // We are pushing an object or a non-placeholder'd pool. // Install the first page. AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); // Push a boundary on behalf of the previously-placeholder'd pool. if (pushExtraBoundary) &#123; page-&gt;add(POOL_BOUNDARY); &#125; // Push the requested object or pool. return page-&gt;add(obj);&#125; 第一次调用这个方法时，haveEmptyPoolPlaceholder()返回的是false，会执行 setEmptyPoolPlaceholder。这个方法调用完之后，再次进入autoreleaseNoPage()时，就会进入第一个if判断中了。接着就会走到这个方法的最后那部分，从头开始构建这个自动释放池的双向链表。初始化之后，将当前页标记为 hotPage，然后会先向这个 page 中添加一个 POOL_SENTINEL 对象，来确保在 pop 调用的时候，不会出现异常。最后，将 obj 添加到自动释放池中。 objc_autoreleasePoolPop 方法和objc_autoreleasePoolPush() 一样，objc_autoreleasePoolPop也只是调用了 AutoreleasePoolPage 结构体的 pop() 方法。该方法实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static inline void pop(void *token) &#123; AutoreleasePoolPage *page; id *stop; // ********** part1 ********** if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123; // Popping the top-level placeholder pool. if (hotPage()) &#123; // Pool was used. Pop its contents normally. // Pool pages remain allocated for re-use as usual. pop(coldPage()-&gt;begin()); &#125; else &#123; // Pool was never used. Clear the placeholder. setHotPage(nil); &#125; return; &#125; page = pageForPointer(token); // ********** part2 ********** stop = (id *)token; if (*stop != POOL_BOUNDARY) &#123; if (stop == page-&gt;begin() &amp;&amp; !page-&gt;parent) &#123; // Start of coldest page may correctly not be POOL_BOUNDARY: // 1. top-level pool is popped, leaving the cold page in place // 2. an object is autoreleased with no pool &#125; else &#123; // Error. For bincompat purposes this is not // fatal in executables built with old SDKs. return badPop(token); &#125; &#125; // ********** part3 ********** if (PrintPoolHiwat) printHiwat(); page-&gt;releaseUntil(stop); // memory: delete empty children if (DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // special case: delete everything during page-per-pool debugging AutoreleasePoolPage *parent = page-&gt;parent; page-&gt;kill(); setHotPage(parent); &#125; else if (DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // special case: delete everything for pop(top) // when debugging missing autorelease pools page-&gt;kill(); setHotPage(nil); &#125; else if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half full if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 方法大致可以分为如下3个部分： 判断token是否是EMPTY_POOL_PLACEHOLDER，这是autoreleasepool首次push的时候返回的，也就是最顶层的page调用pop会执行这一部分 在非ARC情况下，在新创建的子线程中不使用autoreleasepool，直接调用autorelease方法时会出现自动释放池page双向链表表头page栈最底部不是哨兵对象的情况，这里针对这种情况进行处理。 多数情况下，都会进入到这一部分。重点说一下这个部分: 第一步，调用 page = pageForPointer(token) 根据token获取 AutoreleasePoolPage 1234567891011121314151617static AutoreleasePoolPage *pageForPointer(const void *p) &#123; return pageForPointer((uintptr_t)p);&#125;static AutoreleasePoolPage *pageForPointer(uintptr_t p) &#123; AutoreleasePoolPage *result; uintptr_t offset = p % SIZE; assert(offset &gt;= sizeof(AutoreleasePoolPage)); result = (AutoreleasePoolPage *)(p - offset); result-&gt;fastcheck(); return result;&#125; 获取page的地址之后，接下来就调用 releaseUntil 方法来release对象，该方法实现如下： 1234567891011121314151617181920212223242526272829303132333435void releaseUntil(id *stop) &#123; // Not recursive: we don't want to blow out the stack // if a thread accumulates a stupendous amount of garbage while (this-&gt;next != stop) &#123; // Restart from hotPage() every time, in case -release // autoreleased more objects AutoreleasePoolPage *page = hotPage(); // fixme I think this `while` can be `if`, but I can't prove it while (page-&gt;empty()) &#123; page = page-&gt;parent; setHotPage(page); &#125; page-&gt;unprotect(); id obj = *--page-&gt;next; memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next)); page-&gt;protect(); if (obj != POOL_BOUNDARY) &#123; objc_release(obj); &#125; &#125; setHotPage(this);#if DEBUG // we expect any children to be completely empty for (AutoreleasePoolPage *page = child; page; page = page-&gt;child) &#123; assert(page-&gt;empty()); &#125;#endif&#125; 从next指针开始，一个一个向前调用release方法，直到碰到push时压入的token为止。 在释放完对象之后，接下来就是kill 空的 AutoreleasePoolPage 12345678if (page-&gt;child) &#123; if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125;&#125; 判断如果child page存在，调用 lessThanHalfFull() 方法 123bool lessThanHalfFull() &#123; return (next - begin() &lt; (end() - begin()) / 2);&#125; 判断当前page小于一半满，则调用 kill 方法将当前页的所有孩子都释放掉。 12345678910111213141516171819void kill() &#123; // Not recursive: we don't want to blow out the stack // if a thread accumulates a stupendous amount of garbage AutoreleasePoolPage *page = this; while (page-&gt;child) page = page-&gt;child; AutoreleasePoolPage *deathptr; do &#123; deathptr = page; page = page-&gt;parent; if (page) &#123; page-&gt;unprotect(); page-&gt;child = nil; page-&gt;protect(); &#125; delete deathptr; &#125; while (deathptr != this);&#125; 否则，留下一个child，从孙子page开始杀。正是因为这一步，在autoreleaseFullPage()方法中才会有如下步骤 1234do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page);&#125; while (page-&gt;full()); objc_autoreleaseReturnValue优化上文中提到，如 [NSMutableArray array] 等不以 alloc/new/copy/mutableCopy 开头的方法创建的对象。秉着谁创建谁释放的原则，返回值需要是一个autorelease对象才能配合调用方正确管理内存。比如如下一个工厂方法： 123456+ (instancetype)person &#123; return [[Person alloc] init];&#125;&#x2F;&#x2F; 调用Person *person &#x3D; [Person person]; 会被编译器改写成如下代码： 12345678910+ (instancetype)person &#123; id obj = objc_msgSend(Person, @selector(alloc)); objc_msgSend(obj, @selector(init)); return objc_autoreleaseReturnValue(obj);&#125;// 调用id obj = objc_msgSend(Person, @selector(person));objc_retainAutoreleasedReturnValue(obj);objc_release)(objc); objc_retainAutoreleasedReturnValue函数主要用于最优化程序运行。顾名思义，它是用于自己持有（retain）对象的函数，但它持有的对象应为返回注册在autoreleasepool中对象的方法，或是函数的返回值，在调用 alloc/new/copy/mutableCopy 以外的方法，有编译器插入该函数。 这种 objc_retainAutoreleasedReturnValue 函数是成对的，与之相对的函数是 objc_autoreleaseReturnValue。它用于 alloc/new/copy/mutableCopy 方法以外的，如 NSMutableArray 类的 array 类方法等返回对象的实现上。该方法会返回注册到autoreleasepool中的对象。但是 objc_autoreleaseReturnValue 函数同 objc_autorelease函数不同，一般不仅限于注册对象到 autoreleasepool中。 objc_autoreleaseReturnValue 函数会检查使用该函数的方法或函数调用方的执行命令列表，如果方法或函数的调用方在调用了方法或函数后紧接着调用 objc_retainAutoreleasedReturnValue() 函数，那么就不将返回的对象注册到 autoreleasepool中，而是直接传递到方法或函数的调用方。objc_retainAutoreleasedReturnValue 函数与 objc_retain 函数不同，它即便不注册到 autoreleasepool 而返回对象，也能够正确地获取对象。通过 objc_autoreleaseReturnValue 函数和 objc_retainAutoreleasedReturnValue 函数的协作，可以不将对象注册到 autoreleasepool 中而直接传递，这一过程达到了最优化。 ![autorelease 优化](/Users/ethenfarben/Desktop/Blog/source/_posts/「刨根问底」之内存管理/autorelease 优化.png) Autorelease 释放时机有runloop的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop。 autoreleasepool在没有runloop的情况下何时释放呢？ 局部autoreleasepool drain的时候，就是常规的page push以及对应的page pop； 线程退出的时候；那么线程退出释放是如何确定的呢？ 在runtime初始化的过程中，会调用AutoReleasePoolPage::init方法注册tls_dealloc， AutoreleasePoolPage 类的初始化方法如下： 123456static void init()&#123; int r __unused = pthread_key_init_np(AutoreleasePoolPage::key, AutoreleasePoolPage::tls_dealloc); assert(r == 0);&#125; 而 tls_dealloc 方法实现如下： 12345678910111213141516171819202122static void tls_dealloc(void *p) &#123; if (p == (void*)EMPTY_POOL_PLACEHOLDER) &#123; // No objects or pool pages to clean up here. return; &#125; // reinstate TLS value while we work setHotPage((AutoreleasePoolPage *)p); if (AutoreleasePoolPage *page = coldPage()) &#123; if (!page-&gt;empty()) pop(page-&gt;begin()); // pop all of the pools if (DebugMissingPools || DebugPoolAllocation) &#123; // pop() killed the pages already &#125; else &#123; page-&gt;kill(); // free all of the pages &#125; &#125; // clear TLS value so TLS destruction doesn't loop setHotPage(nil);&#125; 结合这两段代码，我们大致可以猜测下phtread_key_init_np是将tls_dealloc注册给某个回调使用。那具体是干嘛的？ 实际上phtread_key_init_np时给thread注册了线程销毁时的自定义析构函数，这里我们可以一起来看看darwin-apple的libpthread代码，这里我直接简化掉流程，输出大致的过程： _pthread_exit 在线程销毁时调用 -&gt; _pthread_tsd_cleanup -&gt; _pthread_tsd_cleanup_new -&gt; _pthread_tsd_cleanup_key。 在最终的函数里，会遍历所有的自定义销毁函数，逐个触发： 123456789101112131415static void_pthread_tsd_cleanup_key(pthread_t self, pthread_key_t key)&#123; void (*destructor)(void *); if (_pthread_key_get_destructor(key, &amp;destructor)) &#123; void **ptr = &amp;self-&gt;tsd[key]; void *value = *ptr; if (value) &#123; *ptr = NULL; if (destructor) &#123; destructor(value); &#125; &#125; &#125;&#125; 问题案例NSAttributedString的autorelease内存风暴: http://wereadteam.github.io/2020/11/11/AttributeString/ Autorelease 之不经意间可能被影响的优化: http://satanwoo.github.io/2019/07/02/RevisitAutorelease/#disqus_thread 属性Property所有权修饰符ARC有效时，id类型和对象类型上必须附加所有权修饰符。所有权修饰符一共有4种。 __strong 修饰符：__strong 修饰符是id类型和对象类型默认的所有权修饰符。id和对象类型在没有明确指定所有权修饰符时，默认是 __strong 修饰符。附有 __strong 修饰符的变量 obj 在超出其变量作用域时，即在该变量被废弃时，会释放其被赋予的对象。 __strong 和 __weak、__autorelease修饰符一起，可以保证附有这些修饰符的自动变量初始化为nil。 __weak 修饰符： 为了解决仅使用 __strong 修饰符编译器所不能解决的重大问题–引用计数式内存管理中必然会发生的”循环引用”问题，可以使用与 __strong 对应的 __weak。也就是说使用 __weak 可以避免循环引用。 __weak 修饰符与 __strong 修饰符相反，提供弱引用，弱引用不能持有对象实例。 __weak 修饰符还有另一优点。在持有对象的弱引用时，若该对象被废弃，则此弱引用将自动失效并被置为nil。 __unsafe_unretained 修饰符： __weak 修饰符只能用于 iOS 5 以上及 OS X Lion 以上版本的应用程序。在 iOS 4以及OS X Snow Leopard的应用程序中可使用 __unsafe_unretained 修饰符来代替。__unsafe_unretained 修饰符正如其名 unsafe所示，是不安全的所有权修饰符。尽管 ARC 式的内存管理时编译器的工作，但附有 __unsafe_unretained 修饰符的变量不属于编译器的内存管理对象。附有 __unsafe_unretained 修饰符的变量同附有 __weak 修饰符的变量一样，不会改变对象的引用计数。同时因为附有 __unsafe_unretained 修饰符的变量不属于编译器的内存管理对象，所以弱引用不会被自动置为nil，所以在使用附有 __unsafe_unretained 修饰符的变量是，需要确保其确实存在，否则程序会崩溃。 __autoreleasing 修饰符： ARC有效时，不能使用 autorelease方法，而是通过将对象赋值给附加了__autoreleasing 修饰符的变量来替代。对象赋值给附有 __autoreleasing 修饰符的变量等价于在ARC无效时调用对象的 autorelease 方法，即对象被注册到 autorelease。前文中提到，编译器会检查如果方法名不是以alloc/new/copy/mutableCopy 和以它们驼峰命名开头的，会自动将返回值的对象注册到 autoreleasepool。另外虽然 __weak 修饰符是为了避免循环引用而使用的，但在访问附有 __weak 修饰符的变量是，实际上必定要访问注册到 autoreleasepool 的对象。这是因为 __weak 修饰符只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果把要访问的对象注册到 autoreleasepool 中，那么在 @autoreleasepool 块结束之前都能确保该对象存在。因此，在使用附有 __weak 修饰符的变量时，就必定要使用注册到 autoreleasepool 中的对象。 属性我们知道，在声明属性的时候，是可以指定内存管理特性的。property属性的内存管理特性包含如下几种： 属性声明的属性 所有权修饰符 assign __unsafe_unretained 修饰符 copy __strong 修饰符（但是赋值的是被复制的对象） retain __strong 修饰符 strong __strong 修饰符 unsafe_unretained __unsafe_unretained 修饰符 weak __weak 修饰符 只有copy属性不是简单的赋值，它赋值的是通过 NSCopying 接口的 copyWithZone: 方法复制赋值源所生成的对象。 assign（默认参数）：setter方法直接赋值，不进行任何retain操作，不改变引用计数。该方法只会针对“纯量类型”(CGFloat或NSInteger等)和C数据类型（int, float, double, char, 等等）的简单赋值操作。基础数据类型： 如short、int、double、long等他们不在【堆】中，可能在【全局区】也可能在【栈】中，根据他们定义的位置而定，而这些内存都是由系统自动管理的，所以基本数据类型可以使用assign来生成set方法直接进行赋值。 retain：生成符合内存管理的set方法（release旧值，retain新值），适用于OC对象的成员变量。 copy：生成符合内存管理的set方法（release旧值，copy新值），适用于NSString、NSArray等不可变对象。和strong类似，不过该属性会被复制一个新的副本。很多时候使用copy是为了防止Mutable（可变类型）在我们不知道的情况下修改了属性值，而用copy可以生成一个不可变的副本防止被修改。如果我们自己实现setter方法的话，需要手动copy。 strong：强引用，其存亡直接决定了所指向对象的存亡。使用该特性实例变量在赋值时，会释放旧值同时设置新值，对对象产生一个强引用，即引用计数+1。如果不存在指向一个对象的引用，并且此对象不再显示在列表中，则此对象会被从内存中释放。适用于一般OC对象。 weak：表示的是一个弱引用，这个引用不会增加对象的引用计数，并且在所指向的对象被释放之后，weak指针会被置为nil。weak引用通常是用于处理循环引用的问题，如代理及block的使用中，相对会较多的使用到weak。即使一个对象被持有无数个弱引用，只要没有强引用指向它，那么还是会被清除。相比于assign，声明为weak的指针，指针指向的地址一旦被释放，这些指针都将被赋值为 nil。这样的好处能有效的防止野指针。因为ViewController对控件强引用，如果delegate声明为strong，UI控件代理一般指向ViewController本身，那么就会造成循环引用。不过非UI控件的delegate的属性声明是weak还是strong就要视情况而定。一般iOS的ARC中的代理delegate属性都会用weak，有时候也用于UI控件(如果是懒加载则必须用strong)。 Property源码探究新建一个项目，在ViewController.m中添加如下代码： 123456789101112131415161718192021222324252627282930#import &quot;ViewController.h&quot;@interface ViewController ()@property (nonatomic, copy) NSString *str;@property (nonatomic, strong) NSMutableArray *arr;@property (nonatomic, copy) NSDictionary *dic;@property (nonatomic, weak) id delegate;@property (nonatomic, assign) NSInteger num;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _str &#x3D; [NSString new]; _arr &#x3D; [NSMutableArray array]; _dic &#x3D; [[NSDictionary alloc] init]; NSObject *obj &#x3D; [NSObject new]; _delegate &#x3D; obj; _num &#x3D; 1;&#125;@end 和前文一样，打开命令行，cd到工程目录，执行前文中的命令让编译器重新改写ViewController.m文件: 1clang -x objective-c -rewrite-objc -isysroot &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneSimulator.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneSimulator.sdk ViewController.m 如遇如下报错： 1234&#x2F;var&#x2F;folders&#x2F;0b&#x2F;z9zhp5nd1m31p32z0jbmyfhm0000gn&#x2F;T&#x2F;ViewController-d731ff.mi:60126:1: error: cannot synthesize weak property because the current deployment target does not support weak references@implementation ViewController 可执行如下命令： 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime&#x3D;ios-8.0.0 ViewController.m -o ViewController.cpp 找到生成的 ViewController.cpp 文件，在文件最下方找到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#ifndef _REWRITER_typedef_ViewController#define _REWRITER_typedef_ViewController// 编译器将struct objc_object重命名为 ViewController类typedef struct objc_object ViewController;typedef struct &#123;&#125; _objc_exc_ViewController;#endif// 定义了属性的偏移量，指实例变量在内存中存储的偏移量，通过这两个值就能够在内存中定位到这实例变量的位置。值是运行时计算出偏移量硬编码(hard code)写入的，是non-fragile 特性的一种体现extern \"C\" unsigned long OBJC_IVAR_$_ViewController$_str;extern \"C\" unsigned long OBJC_IVAR_$_ViewController$_arr;extern \"C\" unsigned long OBJC_IVAR_$_ViewController$_dic;extern \"C\" unsigned long OBJC_IVAR_$_ViewController$_delegate;extern \"C\" unsigned long OBJC_IVAR_$_ViewController$_num;// 该结构体就是ViewController类实现，struct ViewController_IMPL结构体只有一个Class isa结构体指针变量，指向类对象，用于获取ViewController类的方法列表、实例变量列表、属性列表、版本等信息。struct ViewController_IMPL &#123; struct UIViewController_IMPL UIViewController_IVARS; NSString *__strong _str; NSMutableArray *__strong _arr; NSDictionary *__strong _dic; __weak id _delegate; NSInteger _num;&#125;;/* @end */// @interface ViewController ()// @property (nonatomic, copy) NSString *str;// @property (nonatomic, strong) NSMutableArray *arr;// @property (nonatomic, copy) NSDictionary *dic;// @property (nonatomic, weak) id delegate;// @property (nonatomic, assign) NSInteger num;/* @end */// @implementation ViewControllerstatic void _I_ViewController_viewDidLoad(ViewController * self, SEL _cmd) &#123; ((void (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(\"ViewController\"))&#125;, sel_registerName(\"viewDidLoad\")); (*(NSString *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_str)) = ((NSString *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSString\"), sel_registerName(\"new\")); (*(NSMutableArray *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_arr)) = ((NSMutableArray * _Nonnull (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"array\")); (*(NSDictionary *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_dic)) = ((NSDictionary *(*)(id, SEL))(void *)objc_msgSend)((id)((NSDictionary *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSDictionary\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")); NSObject *obj = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"new\")); (*(__weak id *)((char *)self + OBJC_IVAR_$_ViewController$_delegate)) = obj; (*(NSInteger *)((char *)self + OBJC_IVAR_$_ViewController$_num)) = 1;&#125;static void _I_ViewController_didReceiveMemoryWarning(ViewController * self, SEL _cmd) &#123; ((void (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(\"ViewController\"))&#125;, sel_registerName(\"didReceiveMemoryWarning\"));&#125;// 属性的 setter 和 getter 方法static NSString * _I_ViewController_str(ViewController * self, SEL _cmd) &#123; return (*(NSString *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_str)); &#125;extern \"C\" __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);static void _I_ViewController_setStr_(ViewController * self, SEL _cmd, NSString *str) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct ViewController, _str), (id)str, 0, 1); &#125;static NSMutableArray * _I_ViewController_arr(ViewController * self, SEL _cmd) &#123; return (*(NSMutableArray *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_arr)); &#125;static void _I_ViewController_setArr_(ViewController * self, SEL _cmd, NSMutableArray *arr) &#123; (*(NSMutableArray *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_arr)) = arr; &#125;static NSDictionary * _I_ViewController_dic(ViewController * self, SEL _cmd) &#123; return (*(NSDictionary *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_dic)); &#125;static void _I_ViewController_setDic_(ViewController * self, SEL _cmd, NSDictionary *dic) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct ViewController, _dic), (id)dic, 0, 1); &#125;static id _I_ViewController_delegate(ViewController * self, SEL _cmd) &#123; return (*(__weak id *)((char *)self + OBJC_IVAR_$_ViewController$_delegate)); &#125;static void _I_ViewController_setDelegate_(ViewController * self, SEL _cmd, id delegate) &#123; (*(__weak id *)((char *)self + OBJC_IVAR_$_ViewController$_delegate)) = delegate; &#125;static NSInteger _I_ViewController_num(ViewController * self, SEL _cmd) &#123; return (*(NSInteger *)((char *)self + OBJC_IVAR_$_ViewController$_num)); &#125;static void _I_ViewController_setNum_(ViewController * self, SEL _cmd, NSInteger num) &#123; (*(NSInteger *)((char *)self + OBJC_IVAR_$_ViewController$_num)) = num; &#125;// @end/*...*/// #define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)，member对于(结构体类型)type起始的偏移，type一般为一个结构体类型// 这两句代码是使用__OFFSETOFIVAR__(TYPE, MEMBER)宏定义来计算偏移量，并存储在上文提到的偏移量中extern \"C\" unsigned long int OBJC_IVAR_$_ViewController$_str __attribute__ ((used, section (\"__DATA,__objc_ivar\"))) = __OFFSETOFIVAR__(struct ViewController, _str);extern \"C\" unsigned long int OBJC_IVAR_$_ViewController$_arr __attribute__ ((used, section (\"__DATA,__objc_ivar\"))) = __OFFSETOFIVAR__(struct ViewController, _arr);extern \"C\" unsigned long int OBJC_IVAR_$_ViewController$_dic __attribute__ ((used, section (\"__DATA,__objc_ivar\"))) = __OFFSETOFIVAR__(struct ViewController, _dic);extern \"C\" unsigned long int OBJC_IVAR_$_ViewController$_delegate __attribute__ ((used, section (\"__DATA,__objc_ivar\"))) = __OFFSETOFIVAR__(struct ViewController, _delegate);extern \"C\" unsigned long int OBJC_IVAR_$_ViewController$_num __attribute__ ((used, section (\"__DATA,__objc_ivar\"))) = __OFFSETOFIVAR__(struct ViewController, _num);// 成员变量列表static struct /*_ivar_list_t*/ &#123; unsigned int entsize; // sizeof(struct _prop_t) unsigned int count; struct _ivar_t ivar_list[5];&#125; _OBJC_$_INSTANCE_VARIABLES_ViewController __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_ivar_t), 5, &#123;&#123;(unsigned long int *)&amp;OBJC_IVAR_$_ViewController$_str, \"_str\", \"@\\\"NSString\\\"\", 3, 8&#125;, &#123;(unsigned long int *)&amp;OBJC_IVAR_$_ViewController$_arr, \"_arr\", \"@\\\"NSMutableArray\\\"\", 3, 8&#125;, &#123;(unsigned long int *)&amp;OBJC_IVAR_$_ViewController$_dic, \"_dic\", \"@\\\"NSDictionary\\\"\", 3, 8&#125;, &#123;(unsigned long int *)&amp;OBJC_IVAR_$_ViewController$_delegate, \"_delegate\", \"@\", 3, 8&#125;, &#123;(unsigned long int *)&amp;OBJC_IVAR_$_ViewController$_num, \"_num\", \"q\", 3, 8&#125;&#125;&#125;;// 方法列表static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[12];&#125; _OBJC_$_INSTANCE_METHODS_ViewController __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 12, &#123;&#123;(struct objc_selector *)\"viewDidLoad\", \"v16@0:8\", (void *)_I_ViewController_viewDidLoad&#125;, &#123;(struct objc_selector *)\"didReceiveMemoryWarning\", \"v16@0:8\", (void *)_I_ViewController_didReceiveMemoryWarning&#125;, &#123;(struct objc_selector *)\"str\", \"@16@0:8\", (void *)_I_ViewController_str&#125;, &#123;(struct objc_selector *)\"setStr:\", \"v24@0:8@16\", (void *)_I_ViewController_setStr_&#125;, &#123;(struct objc_selector *)\"arr\", \"@16@0:8\", (void *)_I_ViewController_arr&#125;, &#123;(struct objc_selector *)\"setArr:\", \"v24@0:8@16\", (void *)_I_ViewController_setArr_&#125;, &#123;(struct objc_selector *)\"dic\", \"@16@0:8\", (void *)_I_ViewController_dic&#125;, &#123;(struct objc_selector *)\"setDic:\", \"v24@0:8@16\", (void *)_I_ViewController_setDic_&#125;, &#123;(struct objc_selector *)\"delegate\", \"@16@0:8\", (void *)_I_ViewController_delegate&#125;, &#123;(struct objc_selector *)\"setDelegate:\", \"v24@0:8@16\", (void *)_I_ViewController_setDelegate_&#125;, &#123;(struct objc_selector *)\"num\", \"q16@0:8\", (void *)_I_ViewController_num&#125;, &#123;(struct objc_selector *)\"setNum:\", \"v24@0:8q16\", (void *)_I_ViewController_setNum_&#125;&#125;&#125;;static struct _class_ro_t _OBJC_METACLASS_RO_$_ViewController __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; 1, sizeof(struct _class_t), sizeof(struct _class_t), 0, \"ViewController\", 0, 0, 0, 0, 0, &#125;;static struct _class_ro_t _OBJC_CLASS_RO_$_ViewController __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; 0, __OFFSETOFIVAR__(struct ViewController, _str), sizeof(struct ViewController_IMPL), 0, \"ViewController\", (const struct _method_list_t *)&amp;_OBJC_$_INSTANCE_METHODS_ViewController, 0, (const struct _ivar_list_t *)&amp;_OBJC_$_INSTANCE_VARIABLES_ViewController, 0, 0, &#125;;extern \"C\" __declspec(dllimport) struct _class_t OBJC_METACLASS_$_UIViewController;extern \"C\" __declspec(dllimport) struct _class_t OBJC_METACLASS_$_NSObject;extern \"C\" __declspec(dllexport) struct _class_t OBJC_METACLASS_$_ViewController __attribute__ ((used, section (\"__DATA,__objc_data\"))) = &#123; 0, // &amp;OBJC_METACLASS_$_NSObject, 0, // &amp;OBJC_METACLASS_$_UIViewController, 0, // (void *)&amp;_objc_empty_cache, 0, // unused, was (void *)&amp;_objc_empty_vtable, &amp;_OBJC_METACLASS_RO_$_ViewController,&#125;;extern \"C\" __declspec(dllimport) struct _class_t OBJC_CLASS_$_UIViewController;extern \"C\" __declspec(dllexport) struct _class_t OBJC_CLASS_$_ViewController __attribute__ ((used, section (\"__DATA,__objc_data\"))) = &#123; 0, // &amp;OBJC_METACLASS_$_ViewController, 0, // &amp;OBJC_CLASS_$_UIViewController, 0, // (void *)&amp;_objc_empty_cache, 0, // unused, was (void *)&amp;_objc_empty_vtable, &amp;_OBJC_CLASS_RO_$_ViewController,&#125;;static void OBJC_CLASS_SETUP_$_ViewController(void ) &#123; OBJC_METACLASS_$_ViewController.isa = &amp;OBJC_METACLASS_$_NSObject; OBJC_METACLASS_$_ViewController.superclass = &amp;OBJC_METACLASS_$_UIViewController; OBJC_METACLASS_$_ViewController.cache = &amp;_objc_empty_cache; OBJC_CLASS_$_ViewController.isa = &amp;OBJC_METACLASS_$_ViewController; OBJC_CLASS_$_ViewController.superclass = &amp;OBJC_CLASS_$_UIViewController; OBJC_CLASS_$_ViewController.cache = &amp;_objc_empty_cache;&#125;#pragma section(\".objc_inithooks$B\", long, read, write)__declspec(allocate(\".objc_inithooks$B\")) static void *OBJC_CLASS_SETUP[] = &#123; (void *)&amp;OBJC_CLASS_SETUP_$_ViewController,&#125;;static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (\"__DATA, __objc_classlist,regular,no_dead_strip\")))= &#123; &amp;OBJC_CLASS_$_ViewController,&#125;;static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;; 在上述 setter 方法中可以看到，copy修饰的不可变系统类属性会调用用objc_setProperty方法，但是其它属性所有权修饰符修饰的属性都是直接复制。 在runtime源码的objc-accessors.mm文件中， objc_setProperty 方法实现如下： 123456void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) &#123; bool copy = (shouldCopy &amp;&amp; shouldCopy != MUTABLE_COPY); bool mutableCopy = (shouldCopy == MUTABLE_COPY); reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);&#125; 方法会确定下一个方法的入参是 copy 还是 mutableCopy，然后调用 reallySetProperty 方法： 1234567891011121314151617181920212223242526272829303132static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)&#123; if (offset == 0) &#123; object_setClass(self, newValue); return; &#125; id oldValue; id *slot = (id*) ((char*)self + offset); if (copy) &#123; newValue = [newValue copyWithZone:nil]; &#125; else if (mutableCopy) &#123; newValue = [newValue mutableCopyWithZone:nil]; &#125; else &#123; if (*slot == newValue) return; newValue = objc_retain(newValue); &#125; if (!atomic) &#123; oldValue = *slot; *slot = newValue; &#125; else &#123; spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125; objc_release(oldValue);&#125; 方法首先会判断，如果偏移为0，说明是要更新当前类，调用 object_setClass 来初始化类，然后更新 isa。 1234567891011121314151617181920/************************************************************************ object_setClass.**********************************************************************/Class object_setClass(id obj, Class cls)&#123; if (!obj) return nil; // Prevent a deadlock between the weak reference machinery // and the +initialize machinery by ensuring that no // weakly-referenced object has an un-+initialized isa. // Unresolved future classes are not so protected. if (!cls-&gt;isFuture() &amp;&amp; !cls-&gt;isInitialized()) &#123; // use lookUpImpOrForward to indirectly provoke +initialize // to avoid duplicating the code to actually send +initialize lookUpImpOrForward(cls, SEL_initialize, nil, YES/*initialize*/, YES/*cache*/, NO/*resolver*/); &#125; return obj-&gt;changeIsa(cls);&#125; 根据偏移获取当前属性值 根据入参判断，如果入参 copy 为 true，调用 copyWithZone:方法，如果入参 mutableCopy 为 true，调用 mutableCopyWithZone:方法，否则，判断如果新属性值和旧值相等，调用 objc_retain(newValue)，增加引用计数 判断入参atomic，如果不为true，则保存旧属性值为oldValue，并使用新值更新属性值；否则，在进行前面操作的同时，使用PropertyLocks进行加锁，保证操作的原子性 调用 objc_release 释放旧值 总结参考： Pro Multithreading and Memory Management for iOS and OS X Advanced Memory Management Programming Guide 深入理解 GCD https://juejin.cn/post/6844904063465685000 https://draveness.me/autoreleasepool/#AutoreleasePoolPage","categories":[{"name":"刨根问底","slug":"刨根问底","permalink":"http://heseng91.github.io/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}],"tags":[]}],"categories":[{"name":"App优化","slug":"App优化","permalink":"http://heseng91.github.io/categories/App%E4%BC%98%E5%8C%96/"},{"name":"刨根问底","slug":"刨根问底","permalink":"http://heseng91.github.io/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"},{"name":"性能优化","slug":"性能优化","permalink":"http://heseng91.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]}