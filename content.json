{"meta":{"title":"和僧","subtitle":"","description":"技术博客","author":"和僧","url":"http://heseng91.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-07-25T18:29:43.000Z","updated":"2022-07-25T18:37:04.171Z","comments":true,"path":"categories/index.html","permalink":"http://heseng91.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"「精益求精」之iOS通知机制","slug":"「精益求精」之iOS通知机制","date":"2022-11-02T17:35:39.000Z","updated":"2023-02-04T19:33:24.750Z","comments":true,"path":"2022/11/03/「精益求精」之iOS通知机制/","link":"","permalink":"http://heseng91.github.io/2022/11/03/%E3%80%8C%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%E3%80%8D%E4%B9%8BiOS%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/","excerpt":"作为一个iOS开发，想必对通知应该都不陌生。本文主要是针对iOS通知机制的全面解析，从接口到原理面面俱到。 由于苹果没有对相关源码开放，所以以GNUStep源码为基础进行研究，GNUStep虽然不是苹果官方的源码，但彼此之间都在努力的保持一致，因此很具有参考意义，根据实现原理来猜测和实践，更重要的还可以学习观察者模式的架构设计。","text":"作为一个iOS开发，想必对通知应该都不陌生。本文主要是针对iOS通知机制的全面解析，从接口到原理面面俱到。 由于苹果没有对相关源码开放，所以以GNUStep源码为基础进行研究，GNUStep虽然不是苹果官方的源码，但彼此之间都在努力的保持一致，因此很具有参考意义，根据实现原理来猜测和实践，更重要的还可以学习观察者模式的架构设计。 关键类结构首先介绍接口部分，这里将介绍首先一起来了解一下通知相关的关键类，也为后面介绍原理做铺垫。 NSNotification用于描述通知的类，一个NSNotification对象就包含了一条通知的信息，所以当创建一个通知时通常包含如下属性： 123456789@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;...&#x2F;* Querying a Notification Object *&#x2F;- (NSString*) name; &#x2F;&#x2F; 通知的name- (id) object; &#x2F;&#x2F; 携带的对象- (NSDictionary*) userInfo; &#x2F;&#x2F; 配置信息@end 一般用于发送通知时使用，常用api如下： 1- (void)postNotification:(NSNotification *)notification; NSNotificationCenter这是个单例类，负责管理通知的创建和发送，属于最核心的类了。而NSNotificationCenter类主要负责三件事 添加通知 发送通知 移除通知 核心API如下： 123456789&#x2F;&#x2F; 添加通知- (void) addObserver: (id)observer selector: (SEL)selector name: (NSString*)name object: (id)object;- (id) addObserverForName: (NSString *)name object: (id)object queue: (NSOperationQueue *)queue usingBlock: (GSNotificationBlock)block;&#x2F;&#x2F; 发送通知- (void)postNotification:(NSNotification *)notification;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;&#x2F;&#x2F; 删除通知- (void)removeObserver:(id)observer; NSNotificationQueue功能介绍通知队列，用于异步发送消息，这个异步并不是开启线程，而是把通知存到双向链表实现的队列里面，等待某个时机触发时调用NSNotificationCenter的发送接口进行发送通知，这么看NSNotificationQueue最终还是调用NSNotificationCenter进行消息的分发 另外NSNotificationQueue是依赖runloop的，所以如果线程的runloop未开启则无效，至于为什么依赖runloop下面会解释 NSNotificationQueue主要做了两件事： 添加通知到队列 删除通知 核心API如下： 1234&#x2F;&#x2F; 把通知添加到队列中，NSPostingStyle是个枚举，下面会介绍- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;&#x2F;&#x2F; 删除通知，把满足合并条件的通知从队列中删除- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask; 队列的合并策略和发送时机把通知添加到队列等待发送，同时提供了一些附加条件供开发者选择，如：什么时候发送通知、如何合并通知等，系统给了如下定义： 123456789101112&#x2F;&#x2F; 表示通知的发送时机typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123; NSPostWhenIdle &#x3D; 1, &#x2F;&#x2F; runloop空闲时发送通知 NSPostASAP &#x3D; 2, &#x2F;&#x2F; 尽快发送，这种情况稍微复杂，这种时机是穿插在每次事件完成期间来做的 NSPostNow &#x3D; 3 &#x2F;&#x2F; 立刻发送或者合并通知完成之后发送&#125;;&#x2F;&#x2F; 通知合并的策略，有些时候同名通知只想存在一个，这时候就可以用到它了typedef NS_OPTIONS(NSUInteger, NSNotificationCoalescing) &#123; NSNotificationNoCoalescing &#x3D; 0, &#x2F;&#x2F; 默认不合并 NSNotificationCoalescingOnName &#x3D; 1, &#x2F;&#x2F; 只要name相同，就认为是相同通知 NSNotificationCoalescingOnSender &#x3D; 2 &#x2F;&#x2F; object相同&#125;; GSNotificationObserver这个类是GNUStep源码中定义的，它的作用是代理观察者，主要用来实现接口：addObserverForName：object: queue: usingBlock:时用到，即要实现在指定队列回调block，那么GSNotificationObserver对象保存了queue和block信息，并且作为观察者注册到通知中心，等到接收通知时触发了响应方法，并在响应方法中把block抛到指定queue中执行，定义如下： 1234567891011121314151617181920212223242526272829303132@implementation GSNotificationObserver&#123; NSOperationQueue *_queue; &#x2F;&#x2F; 保存传入的队列 GSNotificationBlock _block; &#x2F;&#x2F; 保存传入的block&#125;- (id) initWithQueue: (NSOperationQueue *)queue block: (GSNotificationBlock)block&#123;......初始化操作&#125;- (void) dealloc&#123;....&#125;&#x2F;&#x2F; 响应接收通知的方法，并在指定队列中执行block- (void) didReceiveNotification: (NSNotification *)notif&#123; if (_queue !&#x3D; nil) &#123; GSNotificationBlockOperation *op &#x3D; [[GSNotificationBlockOperation alloc] initWithNotification: notif block: _block]; [_queue addOperation: op]; &#125; else &#123; CALL_BLOCK(_block, notif); &#125;&#125;@end 存储容器上面介绍了一些类的功能，但是要想实现通知中心的逻辑必须设计一套合理的存储结构，对于通知的存储基本上围绕下面几个结构体来做（大致了解下，后面章节会用到），后面会详细介绍具体逻辑的 123456789101112131415&#x2F;&#x2F; 根容器，NSNotificationCenter持有typedef struct NCTbl &#123; Observation *wildcard; &#x2F;* 链表结构，保存既没有name也没有object的通知 *&#x2F; GSIMapTable nameless; &#x2F;* 存储没有name但是有object的通知 *&#x2F; GSIMapTable named; &#x2F;* 存储带有name的通知，不管有没有object *&#x2F; ...&#125; NCTable;&#x2F;&#x2F; Observation 存储观察者和响应结构体，基本的存储单元typedef struct Obs &#123; id observer; &#x2F;* 观察者，接收通知的对象 *&#x2F; SEL selector; &#x2F;* 响应方法 *&#x2F; struct Obs *next; &#x2F;* Next item in linked list. *&#x2F; ...&#125; Observation; 源码探究介绍完通知关键类，下面我们就开始一起通过阅读源码来深入探究一下通知原理。 添加监听首先开始“添加监听”的深入研究，目前只介绍NSNotificationCenter的添加监听，NSNotificationQueue的方式在下面章节单独拎出来解释。NSNotificationCenter有两个添加监听的API。下面我们逐一介绍。 接口1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&#x2F;* Adding new observers. *&#x2F;&#x2F;** * &lt;p&gt;Registers observer to receive notifications with the name * notificationName and&#x2F;or containing object (one or both of these two must be * non-nil; nil acts like a wildcard). When a notification of name name * containing object is posted, observer receives a selector message with this * notification as the argument. The notification center waits for the * observer to finish processing the message, then informs the next registree * matching the notification, and after all of this is done, control returns * to the poster of the notification. Therefore the processing in the * selector implementation should be short.&lt;&#x2F;p&gt; * * &lt;p&gt;The notification center does not retain observer or object. Therefore, * you should always send removeObserver: or removeObserver:name:object: to * the notification center before releasing these objects.&lt;br &#x2F;&gt; * &lt;&#x2F;p&gt; * * &lt;p&gt;NB. For MacOS-X compatibility, adding an observer multiple times will * register it to receive multiple copies of any matching notification, however * removing an observer will remove &lt;em&gt;all&lt;&#x2F;em&gt; of the multiple registrations. * &lt;&#x2F;p&gt; *&#x2F;- (void) addObserver: (id)observer selector: (SEL)selector name: (NSString*)name object: (id)object&#123; Observation *list; Observation *o; GSIMapTable m; GSIMapNode n; &#x2F;&#x2F; 前置条件判断 if (observer &#x3D;&#x3D; nil) [NSException raise: NSInvalidArgumentException format: @&quot;Nil observer passed to addObserver ...&quot;]; if (selector &#x3D;&#x3D; 0) [NSException raise: NSInvalidArgumentException format: @&quot;Null selector passed to addObserver ...&quot;]; if ([observer respondsToSelector: selector] &#x3D;&#x3D; NO) &#123; [NSException raise: NSInvalidArgumentException format: @&quot;[%@-%@] Observer &#39;%@&#39; does not respond to selector &#39;%@&#39;&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd), observer, NSStringFromSelector(selector)]; &#125; lockNCTable(TABLE); &#x2F;&#x2F; 创建一个observation对象，持有观察者和SEL，下面进行的所有逻辑就是为了存储它 o &#x3D; obsNew(TABLE, selector, observer); &#x2F;* * Record the Observation in one of the linked lists. * * NB. It is possible to register an observer for a notification more than * once - in which case, the observer will receive multiple messages when * the notification is posted... odd, but the MacOS-X docs specify this. *&#x2F; &#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; case1： 如果name存在 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F; if (name) &#123; &#x2F;* * Locate the map table for this name - create it if not present. *&#x2F; &#x2F;&#x2F;-------- NAMED是个宏，表示名为named字典。以name为key，从named表中获取对应的mapTable n &#x3D; GSIMapNodeForKey(NAMED, (GSIMapKey)(id)name); if (n &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 不存在，则创建 m &#x3D; mapNew(TABLE);&#x2F;&#x2F; 先取缓存，如果缓存没有则新建一个map &#x2F;* * As this is the first observation for the given name, we take a * copy of the name so it cannot be mutated while in the map. *&#x2F; name &#x3D; [name copyWithZone: NSDefaultMallocZone()]; GSIMapAddPair(NAMED, (GSIMapKey)(id)name, (GSIMapVal)(void*)m); GS_CONSUMED(name) &#125; else &#123; &#x2F;&#x2F; 存在则把值取出来 赋值给m m &#x3D; (GSIMapTable)n-&gt;value.ptr; &#125; &#x2F;* * Add the observation to the list for the correct object. *&#x2F; &#x2F;&#x2F;-------- 以object为key，从字典m中取出对应的value，其实value被MapNode的结构包装了一层，这里不追究细节 n &#x3D; GSIMapNodeForSimpleKey(m, (GSIMapKey)object); if (n &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; 不存在，则创建 o-&gt;next &#x3D; ENDOBS; GSIMapAddPair(m, (GSIMapKey)object, (GSIMapVal)o); &#125; else &#123; list &#x3D; (Observation*)n-&gt;value.ptr; o-&gt;next &#x3D; list-&gt;next; list-&gt;next &#x3D; o; &#125; &#125; else if (object) &#123;&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; case2：如果name为空，但object不为空 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F; &#x2F;&#x2F; 以object为key，从nameless字典中取出对应的value，value是个链表结构 n &#x3D; GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object); if (n &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; 不存在则新建链表，并存到map中 o-&gt;next &#x3D; ENDOBS; GSIMapAddPair(NAMELESS, (GSIMapKey)object, (GSIMapVal)o); &#125; else &#123;&#x2F;&#x2F; 存在 则把值接到链表的节点上 list &#x3D; (Observation*)n-&gt;value.ptr; o-&gt;next &#x3D; list-&gt;next; list-&gt;next &#x3D; o; &#125; &#125; else &#123;&#x2F;*&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; case3：name 和 object 都为空 则存储到wildcard链表中 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F; o-&gt;next &#x3D; WILDCARD; WILDCARD &#x3D; o; &#125; unlockNCTable(TABLE);&#125; 从上面介绍的存储容器中我们了解到NCTable结构体中核心的三个变量以及功能：wildcard、named、nameless，在源码中直接用宏定义表示了：WILDCARD、NAMELESS、NAMED，下面逻辑会用到。 建议如果看文字说明觉得复杂不好理解，就看看下节介绍的存储关系图。 case1: 存在name（无论object是否存在） 注册通知，如果通知的name存在，则以name为key从named字典中取出值n(这个n其实被MapNode包装了一层，便于理解这里直接认为没有包装)，这个n还是个字典，各种判空新建逻辑不讨论； 然后以object为key，从字典n中取出对应的值，这个值就是Observation类型(后面简称obs)的链表，然后把刚开始创建的obs对象o存储进去； 数据结构关系图如下： 如果注册通知时传入name，那么会是一个双层的存储结构 找到NCTable中的named表，这个表存储了还有name的通知； 以name作为key，找到value，这个value依然是一个map； map的结构是以object作为key，obs对象为value，这个obs对象的结构上面已经解释，主要存储了observer &amp; SEL； case2: 只存在object 以object为key，从nameless字典中取出value，此value是个obs类型的链表； 把创建的obs类型的对象o存储到链表中； 数据结构关系图如下： 只存在object时存储只有一层，那就是object和obs对象之间的映射。 case3: 没有name和object这种情况直接把obs对象存放在了Observation *wildcard 链表结构中。 接口21234567891011121314151617181920212223242526272829&#x2F;** * &lt;p&gt;Returns a new observer added to the notification center, in order to * observe the given notification name posted by an object or any object (if * the object argument is nil).&lt;&#x2F;p&gt; * * &lt;p&gt;For the name and object arguments, the constraints and behavior described * in -addObserver:name:selector:object: remain valid.&lt;&#x2F;p&gt; * * &lt;p&gt;For each notification received by the center, the observer will execute * the notification block. If the queue is not nil, the notification block is * wrapped in a NSOperation and scheduled in the queue, otherwise the block is * executed immediately in the posting thread.&lt;&#x2F;p&gt; *&#x2F;- (id) addObserverForName: (NSString *)name object: (id)object queue: (NSOperationQueue *)queue usingBlock: (GSNotificationBlock)block&#123; &#x2F;&#x2F; 创建一个临时观察者 GSNotificationObserver *observer &#x3D; [[GSNotificationObserver alloc] initWithQueue: queue block: block]; &#x2F;&#x2F; 调用了接口1的注册方法 [self addObserver: observer selector: @selector(didReceiveNotification:) name: name object: object]; return observer;&#125; 逻辑说明这个接口依赖于接口1，只是多了一层代理观察者GSNotificationObserver，在关键类结构中已经介绍了它，设计思路值得学习 创建一个GSNotificationObserver类型的对象observer，并把queue和block保存下来; 调用接口1进行通知的注册; 接收到通知时会响应observer的didReceiveNotification:方法，然后在didReceiveNotification:中把block抛给指定的queue去执行; 小结 从上述介绍可以总结，存储是以name和object为维度的，即判定是不是同一个通知要从name和object区分，如果他们都相同则认为是同一个通知，后面包括查找逻辑、删除逻辑都是以这两个为维度的； 理解数据结构的设计是整个通知机制的核心，其他功能只是在此基础上扩展了一些逻辑； 存储过程并没有做去重操作，这也解释了为什么同一个通知注册多次则响应多次。 发送通知发送通知相关代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#x2F;** * Posts notification to all the observers that match its NAME and OBJECT.&lt;br &#x2F;&gt; * The GNUstep implementation calls -postNotificationName:object:userInfo: to * perform the actual posting. *&#x2F;- (void) postNotification: (NSNotification*)notification&#123; if (notification &#x3D;&#x3D; nil) &#123; [NSException raise: NSInvalidArgumentException format: @&quot;Tried to post a nil notification.&quot;]; &#125; [self _postAndRelease: RETAIN(notification)];&#125;&#x2F;** * Creates and posts a notification using the * -postNotificationName:object:userInfo: passing a nil user info argument. *&#x2F;- (void) postNotificationName: (NSString*)name object: (id)object&#123; [self postNotificationName: name object: object userInfo: nil];&#125;&#x2F;** * The preferred method for posting a notification. * &lt;br &#x2F;&gt; * For performance reasons, we don&#39;t wrap an exception handler round every * message sent to an observer. This means that, if one observer raises * an exception, later observers in the lists will not get the notification. *&#x2F;- (void) postNotificationName: (NSString*)name object: (id)object userInfo: (NSDictionary*)info&#123; &#x2F;&#x2F; 构造一个GSNotification对象， GSNotification继承了NSNotification GSNotification *notification; notification &#x3D; (id)NSAllocateObject(concrete, 0, NSDefaultMallocZone()); notification-&gt;_name &#x3D; [name copyWithZone: [self zone]]; notification-&gt;_object &#x3D; [object retain]; notification-&gt;_info &#x3D; [info retain]; &#x2F;&#x2F; 进行发送操作 [self _postAndRelease: notification];&#125; 可见发送通知实际都调用了_postAndRelease:方法来完成世纪的发送操作，该函数源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&#x2F;** * Private method to perform the actual posting of a notification. * Release the notification before returning, or before we raise * any exception ... to avoid leaks. *&#x2F;- (void) _postAndRelease: (NSNotification*)notification&#123; &#x2F;&#x2F;step1: 从named、nameless、wildcard表中查找对应的通知 Observation *o; unsigned count; NSString *name &#x3D; [notification name]; id object; GSIMapNode n; GSIMapTable m; GSIArrayItem i[64]; GSIArray_t b; GSIArray a &#x3D; &amp;b; if (name &#x3D;&#x3D; nil) &#123; RELEASE(notification); [NSException raise: NSInvalidArgumentException format: @&quot;Tried to post a notification with no name.&quot;]; &#125; object &#x3D; [notification object]; &#x2F;* * Lock the table of observations while we traverse it. * * The table of observations contains weak pointers which are zeroed when * the observers get destroyed. So to avoid consistency problems * we use scanned memory in the array in the case where there are more * than the 64 observers we allowed room for on the stack. *&#x2F; GSIArrayInitWithZoneAndStaticCapacity(a, _zone, 64, i); lockNCTable(TABLE); &#x2F;* * Find all the observers that specified neither NAME nor OBJECT. *&#x2F; for (o &#x3D; WILDCARD &#x3D; purgeCollected(WILDCARD); o !&#x3D; ENDOBS; o &#x3D; o-&gt;next) &#123; GSIArrayAddItem(a, (GSIArrayItem)o); &#125; &#x2F;* * Find the observers that specified OBJECT, but didn&#39;t specify NAME. *&#x2F; if (object) &#123; n &#x3D; GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object); if (n !&#x3D; 0) &#123; o &#x3D; purgeCollectedFromMapNode(NAMELESS, n); while (o !&#x3D; ENDOBS) &#123; GSIArrayAddItem(a, (GSIArrayItem)o); o &#x3D; o-&gt;next; &#125; &#125; &#125; &#x2F;* * Find the observers of NAME, except those observers with a non-nil OBJECT * that doesn&#39;t match the notification&#39;s OBJECT). *&#x2F; if (name) &#123; n &#x3D; GSIMapNodeForKey(NAMED, (GSIMapKey)((id)name)); if (n) &#123; m &#x3D; (GSIMapTable)n-&gt;value.ptr; &#125; else &#123; m &#x3D; 0; &#125; if (m !&#x3D; 0) &#123; &#x2F;* * First, observers with a matching object. *&#x2F; n &#x3D; GSIMapNodeForSimpleKey(m, (GSIMapKey)object); if (n !&#x3D; 0) &#123; o &#x3D; purgeCollectedFromMapNode(m, n); while (o !&#x3D; ENDOBS) &#123; GSIArrayAddItem(a, (GSIArrayItem)o); o &#x3D; o-&gt;next; &#125; &#125; if (object !&#x3D; nil) &#123; &#x2F;* * Now observers with a nil object. *&#x2F; n &#x3D; GSIMapNodeForSimpleKey(m, (GSIMapKey)(id)nil); if (n !&#x3D; 0) &#123; o &#x3D; purgeCollectedFromMapNode(m, n); while (o !&#x3D; ENDOBS) &#123; GSIArrayAddItem(a, (GSIArrayItem)o); o &#x3D; o-&gt;next; &#125; &#125; &#125; &#125; &#125; &#x2F;* Finished with the table ... we can unlock it, *&#x2F; unlockNCTable(TABLE); &#x2F;* * Now send all the notifications. *&#x2F; &#x2F;&#x2F;step2：执行发送，即调用performSelector执行响应方法，从这里可以看出是同步的 count &#x3D; GSIArrayCount(a); while (count-- &gt; 0) &#123; o &#x3D; GSIArrayItemAtIndex(a, count).ext; if (o-&gt;next !&#x3D; 0) &#123; NS_DURING &#123; [o-&gt;observer performSelector: o-&gt;selector withObject: notification]; &#125; NS_HANDLER &#123; BOOL logged; &#x2F;* Try to report the notification along with the exception, * but if there&#39;s a problem with the notification itself, * we just log the exception. *&#x2F; NS_DURING NSLog(@&quot;Problem posting %@: %@&quot;, notification, localException); logged &#x3D; YES; NS_HANDLER logged &#x3D; NO; NS_ENDHANDLER if (NO &#x3D;&#x3D; logged) &#123; NSLog(@&quot;Problem posting notification: %@&quot;, localException); &#125; &#125; NS_ENDHANDLER &#125; &#125; lockNCTable(TABLE); GSIArrayEmpty(a); unlockNCTable(TABLE); RELEASE(notification);&#125; 逻辑说明其实上述代码注释说的很清晰了，主要做了三件事 通过name &amp; object查找到所有的obs对象(保存了observer和sel)，放到数组中； 通过performSelector：逐一调用sel，这是个同步操作； 释放notification对象。 小结从源码逻辑可以看出发送过程的概述：从三个存储容器中：named、nameless、wildcard去查找对应的obs对象，然后通过performSelector：逐一调用响应方法，这就完成了发送流程。 核心点： 同步发送 遍历所有列表，即注册多次通知就会响应多次 删除通知这里源码太长而且基本上都是查找删除逻辑，不一一列举，感兴趣的去下载源码看下吧要注意的点： 查找时仍然以name和object为维度的，再加上observer做区分 因为查找时做了这个链表的遍历，所以删除时会把重复的通知全都删除掉 12345678910111213141516// 删除已经注册的通知- (void) removeObserver: (id)observer name: (NSString*)name object: (id)object &#123; if (name == nil &amp;&amp; object == nil &amp;&amp; observer == nil) return; ...&#125;- (void) removeObserver: (id)observer&#123; if (observer == nil) return; [self removeObserver: observer name: nil object: nil];&#125; 异步通知上面介绍的NSNotificationCenter都是同步发送的，而这里介绍关于NSNotificationQueue的异步发送，从线程的角度看并不是真正的异步发送，或可称为延时发送，它是利用了runloop的时机来触发的。 入队相关源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&#x2F;** * Sets notification to be posted to notification center at time dependent on * postingStyle, which may be either &lt;code&gt;NSPostNow&lt;&#x2F;code&gt; (synchronous post), * &lt;code&gt;NSPostASAP&lt;&#x2F;code&gt; (post soon), or &lt;code&gt;NSPostWhenIdle&lt;&#x2F;code&gt; (post * when runloop is idle). *&#x2F;- (void) enqueueNotification: (NSNotification*)notification postingStyle: (NSPostingStyle)postingStyle &#123; [self enqueueNotification: notification postingStyle: postingStyle coalesceMask: NSNotificationCoalescingOnName + NSNotificationCoalescingOnSender forModes: nil];&#125;&#x2F;** * Sets notification to be posted to notification center at time dependent on * postingStyle, which may be either &lt;code&gt;NSPostNow&lt;&#x2F;code&gt; (synchronous * post), &lt;code&gt;NSPostASAP&lt;&#x2F;code&gt; (post soon), or &lt;code&gt;NSPostWhenIdle&lt;&#x2F;code&gt; * (post when runloop is idle). coalesceMask determines whether this * notification should be considered same as other ones already on the queue, * in which case they are removed through a call to * -dequeueNotificationsMatching:coalesceMask: . The modes argument * determines which [NSRunLoop] mode notification may be posted in (nil means * NSDefaultRunLoopMode). *&#x2F;&#x2F;** * 把要发送的通知添加到队列，等待发送 * NSPostingStyle 和 coalesceMask在上面的类结构中有介绍 * modes这个就和runloop有关了，指的是runloop的mode *&#x2F; - (void) enqueueNotification: (NSNotification*)notification postingStyle: (NSPostingStyle)postingStyle coalesceMask: (NSUInteger)coalesceMask forModes: (NSArray*)modes&#123; if (modes &#x3D;&#x3D; nil) &#123; modes &#x3D; defaultMode; &#125; &#x2F;&#x2F; 判断是否需要合并通知 if (coalesceMask !&#x3D; NSNotificationNoCoalescing) &#123; [self dequeueNotificationsMatching: notification coalesceMask: coalesceMask]; &#125; switch (postingStyle) &#123; case NSPostNow: &#123; NSString *mode; mode &#x3D; [[NSRunLoop currentRunLoop] currentMode]; if (mode &#x3D;&#x3D; nil || [modes indexOfObject: mode] !&#x3D; NSNotFound) &#123; &#x2F;&#x2F; 调用NSNotificationCenter进行发送 [_center postNotification: notification]; &#125; &#125; break; case NSPostASAP: &#x2F;&#x2F; 添加到_asapQueue队列，等待发送 add_to_queue(_asapQueue, notification, modes, _zone); break; case NSPostWhenIdle: &#x2F;&#x2F; 添加到_idleQueue队列，等待发送 add_to_queue(_idleQueue, notification, modes, _zone); break; &#125;&#125; 看源码的注释，基本上能明白大致逻辑： 根据coalesceMask参数判断是否合并通知； 接着根据postingStyle参数，判断通知发送的时机，如果不是立即发送则把通知加入到队列中：_asapQueue、_idleQueue。 核心点： 队列是双向链表实现； 当postingStyle值是立即发送时，调用的是NSNotificationCenter进行发送的，所以NSNotificationQueue还是依赖NSNotificationCenter进行发送。 发送通知NSPostNow枚举的发送前面的代码已经有所体现。这里主要介绍NSPostASAP 和 NSPostWhenIdle 两种枚举的通知发送。NSPostASAP 和 NSPostWhenIdle 会分别调用GSPrivateNotifyASAP()和GSPrivateNotifyIdle()方法来发送通知，方法的调用主要是通过RunLoop，调用的时机参见GNUStep的NSRunLoop。 异步发送通知的相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124static voidnotify(NSNotificationCenter *center, NSNotificationQueueList *list, NSString *mode, NSZone *zone)&#123; BOOL allocated &#x3D; NO; void *buf[100]; void **ptr &#x3D; buf; unsigned len &#x3D; sizeof(buf) &#x2F; sizeof(*buf); unsigned pos &#x3D; 0; NSNotificationQueueRegistration *item &#x3D; list-&gt;head; &#x2F;* Gather matching items into a buffer. *&#x2F; while (item !&#x3D; 0) &#123; if (mode &#x3D;&#x3D; nil || [item-&gt;modes indexOfObject: mode] !&#x3D; NSNotFound) &#123; if (pos &#x3D;&#x3D; len) &#123; unsigned want; want &#x3D; (len &#x3D;&#x3D; 0) ? 2 : len * 2; if (NO &#x3D;&#x3D; allocated) &#123; void *tmp; tmp &#x3D; NSZoneMalloc(NSDefaultMallocZone(), want * sizeof(void*)); memcpy(tmp, (void*)ptr, len * sizeof(void*)); ptr &#x3D; tmp; allocated &#x3D; YES; &#125; else &#123; ptr &#x3D; NSZoneRealloc(NSDefaultMallocZone(), ptr, want * sizeof(void*)); &#125; len &#x3D; want; &#125; ptr[pos++] &#x3D; item; &#125; item &#x3D; item-&gt;next; &#x2F;&#x2F; head --&gt; tail uses next link &#125; len &#x3D; pos; &#x2F;&#x2F; Number of items found &#x2F;* Posting a notification catches exceptions, so it&#39;s OK to use * retain&#x2F;release of objects here as we won&#39;t get an exception * causing a leak. *&#x2F; if (len &gt; 0) &#123; &#x2F;* First, we make a note of each notification while removing the * corresponding list item from the queue ... so that when we get * round to posting the notifications we will not get problems * with another notif() trying to use the same items. *&#x2F; for (pos &#x3D; 0; pos &lt; len; pos++) &#123; item &#x3D; ptr[pos]; ptr[pos] &#x3D; RETAIN(item-&gt;notification); remove_from_queue(list, item, zone); &#125; &#x2F;* Now that we no longer need to worry about r-entrancy, * we step through our notifications, posting each one in turn. *&#x2F; &#x2F;&#x2F; 循环遍历发送通知 for (pos &#x3D; 0; pos &lt; len; pos++) &#123; NSNotification *n &#x3D; (NSNotification*)ptr[pos]; [center postNotification: n]; RELEASE(n); &#125; if (allocated) &#123; NSZoneFree(NSDefaultMallocZone(), ptr); &#125; &#125;&#125;&#x2F;* * The following code handles sending of queued notifications by * NSRunLoop. *&#x2F;&#x2F;&#x2F; 发送_asapQueue中的通知voidGSPrivateNotifyASAP(NSString *mode)&#123; NotificationQueueList *item; GSPrivateCheckTasks(); for (item &#x3D; currentList(); item; item &#x3D; item-&gt;next) &#123; if (item-&gt;queue) &#123; notify(item-&gt;queue-&gt;_center, item-&gt;queue-&gt;_asapQueue, mode, item-&gt;queue-&gt;_zone); &#125; &#125;&#125;&#x2F;&#x2F; 发送_idleQueue中的通知voidGSPrivateNotifyIdle(NSString *mode)&#123; NotificationQueueList *item; for (item &#x3D; currentList(); item; item &#x3D; item-&gt;next) &#123; if (item-&gt;queue) &#123; notify(item-&gt;queue-&gt;_center, item-&gt;queue-&gt;_idleQueue, mode, item-&gt;queue-&gt;_zone); &#125; &#125;&#125; 逻辑说明 runloop触发某个时机，调用GSPrivateNotifyASAP()和GSPrivateNotifyIdle()方法，这两个方法最终都调用了notify()方法； notify()所做的事情就是调用NSNotificationCenter的postNotification:进行发送通知； 小结对于NSNotificationQueue总结如下 依赖runloop，所以如果在其他子线程使用NSNotificationQueue，需要开启runloop； 最终还是通过NSNotificationCenter进行发送通知，所以这个角度讲它还是同步的； 所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程； 主线程响应通知异步线程发送通知则响应函数也是在异步线程，如果执行UI刷新相关的话就会出问题，那么如何保证在主线程响应通知呢？ 其实也是比较常见的问题了，基本上解决方式如下几种： 使用addObserverForName: object: queue: usingBlock方法注册通知，指定在mainqueue上响应block； 在主线程注册一个machPort，它是用来做线程通信的，当在异步线程收到通知，然后给machPort发送消息，这样肯定是在主线程处理的，具体用法去网上资料很多，苹果官网也有。 参考： 轻松过面：一文全解iOS通知机制(经典收藏)","categories":[{"name":"精益求精","slug":"精益求精","permalink":"http://heseng91.github.io/categories/%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE/"}],"tags":[]},{"title":"「精益求精」之iOS APP签名机制","slug":"「精益求精」之iOS-APP签名机制","date":"2022-11-02T17:33:14.000Z","updated":"2022-12-09T16:40:35.511Z","comments":true,"path":"2022/11/03/「精益求精」之iOS-APP签名机制/","link":"","permalink":"http://heseng91.github.io/2022/11/03/%E3%80%8C%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%E3%80%8D%E4%B9%8BiOS-APP%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/","excerpt":"日常iOS开发中，真机测试与打包等很多流程都会牵扯到各种证书、Provisioning Profile、entitlements、CertificateSigningRequest、p12、AppID等。如果不理解iOS App应用签名的原理和流程，就会容易出错。本文转载自Bang的blog：iOS App 签名的原理。文章尝试从原理出发，一步步推出为什么会有这么多概念，希望能有助于理解 iOS App 签名的原理和流程。","text":"日常iOS开发中，真机测试与打包等很多流程都会牵扯到各种证书、Provisioning Profile、entitlements、CertificateSigningRequest、p12、AppID等。如果不理解iOS App应用签名的原理和流程，就会容易出错。本文转载自Bang的blog：iOS App 签名的原理。文章尝试从原理出发，一步步推出为什么会有这么多概念，希望能有助于理解 iOS App 签名的原理和流程。 目的先来看看苹果的签名机制是为了做什么。在 iOS 出来之前，在主流操作系统(Mac/Windows/Linux)上开发和运行软件是不需要签名的，软件随便从哪里下载都能运行，导致平台对第三方软件难以控制，盗版流行。苹果希望解决这样的问题，在 iOS 平台对第三方 APP 有绝对的控制权，一定要保证每一个安装到 iOS 上的 APP 都是经过苹果官方允许的，怎样保证呢？就是通过签名机制。 非对称加密通常我们说的签名就是数字签名，它是基于非对称加密算法实现的。对称加密是通过同一份密钥加密和解密数据，而非对称加密则有两份密钥，分别是公钥和私钥，用公钥加密的数据，要用私钥才能解密，用私钥加密的数据，要用公钥才能解密。 简单说一下常用的非对称加密算法 RSA 的数学原理，理解简单的数学原理，就可以理解非对称加密是怎么做到的，为什么会是安全的： 选两个质数 p 和 q，相乘得出一个大整数n，例如 p = 61，q = 53，n = pq = 3233 选 1-n 间的随便一个质数e，例如 e = 17 经过一系列数学公式，算出一个数字 d，满足：a.通过 n 和 e 这两个数据一组数据进行数学运算后，可以通过 n 和 d 去反解运算，反过来也可以。b.如果只知道 n 和 e，要推导出 d，需要知道 p 和 q，也就是要需要把 n 因数分解。 上述的 (n,e) 这两个数据在一起就是公钥，(n,d) 这两个数据就是私钥，满足用私钥加密，公钥解密，或反过来公钥加密，私钥解密，也满足在只暴露公钥 (只知道 n 和 e)的情况下，要推导出私钥 (n,d)，需要把大整数 n 因数分解。目前因数分解只能靠暴力穷举，而 n 数字越大，越难以用穷举计算出因数 p 和 q，也就越安全，当 n 大到二进制 1024 位或 2048 位时，以目前技术要破解几乎不可能，所以非常安全。 若对数字 d 是怎样计算出来的感兴趣，可以详读这两篇文章：RSA 算法原理（一）（二） 数字签名现在知道了有非对称加密这东西，那数字签名是怎么回事呢？ 数字签名的作用是我对某一份数据打个标记，表示我认可了这份数据（签了个名），然后我发送给其他人，其他人可以知道这份数据是经过我认证的，数据没有被篡改过。 有了上述非对称加密算法，就可以实现这个需求： 首先用一种算法，算出原始数据的摘要。需满足 a.若原始数据有任何变化，计算出来的摘要值都会变化。 b.摘要要够短。这里最常用的算法是MD5。 生成一份非对称加密的公钥和私钥，私钥我自己拿着，公钥公布出去。 对一份数据，算出摘要后，用私钥加密这个摘要，得到一份加密后的数据，称为原始数据的签名。把它跟原始数据一起发送给用户。 用户收到数据和签名后，用公钥解密得到摘要。同时用户用同样的算法计算原始数据的摘要，对比这里计算出来的摘要和用公钥解密签名得到的摘要是否相等，若相等则表示这份数据中途没有被篡改过，因为如果篡改过，摘要会变化。 之所以要有第一步计算摘要，是因为非对称加密的原理限制可加密的内容不能太大（不能大于上述 n 的位数，也就是一般不能大于 1024 位 / 2048 位），于是若要对任意大的数据签名，就需要改成对它的特征值签名，效果是一样的。 好了，有了非对称加密的基础，知道了数字签名是什么，怎样可以保证一份数据是经过某个地方认证的，来看看怎样通过数字签名的机制保证每一个安装到 iOS 上的 APP 都是经过苹果认证允许的。 最简单的签名要实现这个需求很简单，最直接的方式，苹果官方生成一对公私钥，在 iOS 里内置一个公钥，私钥由苹果后台保存，我们传 App 上 AppStore 时，苹果后台用私钥对 APP 数据进行签名，iOS 系统下载这个 APP 后，用公钥验证这个签名，若签名正确，这个 APP 肯定是由苹果后台认证的，并且没有被修改过，也就达到了苹果的需求：保证安装的每一个 APP 都是经过苹果官方允许的。 如果我们 iOS 设备安装 APP 只有从 AppStore 下载这一种方式的话，这件事就结束了，没有任何复杂的东西，只有一个数字签名，非常简单地解决问题。 但实际上因为除了从 AppStore 下载，我们还可以有三种方式安装一个 App： 开发 App 时可以直接把开发中的应用安装进手机进行调试。 In-House 企业内部分发，可以直接安装企业证书签名后的 APP。 AD-Hoc 相当于企业分发的限制版，限制安装设备数量，较少用。 苹果要对用这三种方式安装的 App 进行控制，就有了新的需求，无法像上面这样简单了。 新的需求我们先来看第一个，开发时安装APP，它有两个个需求： 安装包不需要传到苹果服务器，可以直接安装到手机上。如果你编译一个 APP 到手机前要先传到苹果服务器签名，这显然是不能接受的。 苹果必须对这里的安装有控制权，包括a. 经过苹果允许才可以这样安装。b. 不能被滥用导致非开发app也能被安装。 为了实现这些需求，iOS 签名的复杂度也就开始增加了。 苹果这里给出的方案是使用了双层签名，会比较绕，流程大概是这样的： 在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local 苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple 把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。 在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第三步得到的证书一起打包进 APP 里，安装到手机上。 在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证证书的数字签名是否正确。 验证证书后确保了公钥 L 是苹果认证过的，再用公钥 L 去验证 APP 的签名，这里就间接验证了这个 APP 安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证APP 是否被改动，因为开发阶段 APP 内容总是不断变化的，苹果不需要管。） 加点东西上述流程只解决了上面第一个需求，也就是需要经过苹果允许才可以安装，还未解决第二个避免被滥用的问题。怎么解决呢？苹果再加了两个限制，一是限制在苹果后台注册过的设备才可以安装，二是限制签名只能针对某一个具体的 APP。 怎么加的？在上述第三步，苹果用私钥 A 签名我们本地公钥 L 时，实际上除了签名公钥 L，还可以加上无限多数据，这些数据都可以保证是经过苹果官方认证的，不会有被篡改的可能。 可以想到把 允许安装的设备 ID 列表 和 App对应的 AppID 等数据，都在第三步这里跟公钥L一起组成证书，再用苹果私钥 A 对这个证书签名。在最后第 5 步验证时就可以拿到设备 ID 列表，判断当前设备是否符合要求。根据数字签名的原理，只要数字签名通过验证，第 5 步这里的设备 IDs / AppID / 公钥 L 就都是经过苹果认证的，无法被修改，苹果就可以限制可安装的设备和 APP，避免滥用。 最终流程到这里这个证书已经变得很复杂了，有很多额外信息，实际上除了 设备 ID / AppID，还有其他信息也需要在这里用苹果签名，像这个 APP 里 iCloud / push / 后台运行 等权限苹果都想控制，苹果把这些权限开关统一称为 Entitlements，它也需要通过签名去授权。 实际上一个“证书”本来就有规定的格式规范，上面我们把各种额外信息塞入证书里是不合适的，于是苹果另外搞了个东西，叫 Provisioning Profile，一个 Provisioning Profile 里就包含了证书以及上述提到的所有额外信息，以及所有信息的签名。 所以整个流程稍微变一下，就变成这样了： 因为步骤有小变动，这里我们不辞啰嗦重新再列一遍整个流程： 在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local 苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple 把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。 在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。 在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为 embedded.mobileprovision，把 APP 安装到手机上。 在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 embedded.mobileprovision 的数字签名是否正确，里面的证书签名也会再验一遍。 确保了 embedded.mobileprovision 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。 开发者证书从签名到认证最终苹果采用的流程大致是这样，还有一些细节像证书有效期/证书类型等就不细说了。 概念和操作上面的步骤对应到我们平常具体的操作和概念是这样的： 第 1 步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一对公私钥，保存的 CertificateSigningRequest 就是公钥，私钥保存在本地电脑里。 第 2 步苹果处理，不用管。 第 3 步对应把 CertificateSigningRequest 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第 1 步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 .p12 文件，其他 Mac 打开后就导入了这个私钥。 第 4 步都是在苹果网站上操作，配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件。 第 5 步 XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。 第 6 – 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。 这里再总结一下这些概念： 证书：内容是公钥或私钥，由其他机构对其签名组成的数据包。 Entitlements：包含了 App 权限开关列表。 CertificateSigningRequest：本地公钥。 p12：本地私钥，可以导入到其他电脑。 Provisioning Profile：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。 其他发布方式前面以开发包为例子说了签名和验证的流程，另外两种方式 In-House 企业签名和 AD-Hoc 流程也是差不多的，只是企业签名不限制安装的设备数，另外需要用户在 iOS 系统设置上手动点击信任这个企业才能通过验证。 而 AppStore 的签名验证方式有些不一样，前面我们说到最简单的签名方式，苹果在后台直接用私钥签名 App 就可以了，实际上苹果确实是这样做的，如果去下载一个 AppStore 的安装包，会发现它里面是没有 embedded.mobileprovision 文件的，也就是它安装和启动的流程是不依赖这个文件，验证流程也就跟上述几种类型不一样了。 据猜测，因为上传到 AppStore 的包苹果会重新对内容加密，原来的本地私钥签名就没有用了，需要重新签名，从 AppStore 下载的包苹果也并不打算控制它的有效期，不需要内置一个 embedded.mobileprovision 去做校验，直接在苹果用后台的私钥重新签名，iOS 安装时用本地公钥验证 App 签名就可以了。 那为什么发布 AppStore 的包还是要跟开发版一样搞各种证书和 Provisioning Profile？猜测因为苹果想做统一管理，Provisioning Profile 里包含一些权限控制，AppID 的检验等，苹果不想在上传 AppStore 包时重新用另一种协议做一遍这些验证，就不如统一把这部分放在 Provisioning Profile 里，上传 AppStore 时只要用同样的流程验证这个 Provisioning Profile 是否合法就可以了。 所以 App 上传到 AppStore 后，就跟你的 证书 / Provisioning Profile 都没有关系了，无论他们是否过期或被废除，都不会影响 AppStore 上的安装包。 到这里 iOS 签名机制的原理和主流程大致说完了，希望能对理解苹果签名和排查日常签名问题有所帮助。 P.S.一些疑问最后这里再提一下我关于签名流程的一些的疑问。 企业证书企业证书签名因为限制少，在国内被广泛用于测试和盗版，fir.im / 蒲公英等测试平台都是通过企业证书分发，国内一些市场像 PP 助手，爱思助手，一部分安装手段也是通过企业证书重签名。通过企业证书签名安装的 App，启动时都会验证证书的有效期，并且不定期请求苹果服务器看证书是否被吊销，若已过期或被吊销，就会无法启动 App。对于这种助手的盗版安装手段，苹果想打击只能一个个吊销企业证书，并没有太好的办法。 这里我的疑问是，苹果做了那么多签名和验证机制去限制在 iOS 安装 App，为什么又要出这样一个限制很少的方式让盗版钻空子呢？若真的是企业用途不适合上 AppStore，也完全可以在 AppStore 开辟一个小的私密版块，还是通过 AppStore 去安装，就不会有这个问题了。 AppStore 加密另一个问题是我们把 App 传上 AppStore 后，苹果会对 App 进行加密，导致 App 体积增大不少，这个加密实际上是没卵用的，只是让破解的人要多做一个步骤，运行 App 去内存 dump 出可执行文件而已，无论怎样加密，都可以用这种方式拿出加密前的可执行文件。所以为什么要做这样的加密呢？想不到有什么好处。 本地私钥我们看到前面说的签名流程很绕很复杂，经常出现各种问题，像有 Provisioning Profile 文件但证书又不对，本地有公钥证书没对应私钥等情况，不理解原理的情况下会被绕晕，我的疑问是，这里为什么不能简化呢？还是以开发证书为例，为什么一定要用本地 Mac 生成的私钥去签名？苹果要的只是本地签名，私钥不一定是要本地生成的，苹果也可以自己生成一对公私钥给我们，放在 Provisioning Profile 里，我们用里面的私钥去加密就行了，这样就不会有 CertificateSigningRequest 和 p12 的概念，跟本地 keychain 没有关系，不需要关心证书，只要有 Provisioning Profile 就能签名，流程会减少，易用性会提高很多，同时苹果想要的控制一点都不会少，也没有什么安全问题，为什么不这样设计呢？ 能想到的一个原因是 Provisioning Profile 在非 AppStore 安装时会打包进安装包，第三方拿到这个 Provisioning Profile 文件就能直接用起来给他自己的 App 签名了。但这种问题也挺好解决，只需要打包时去掉文件里的私钥就行了，所以仍不明白为什么这样设计。","categories":[{"name":"精益求精","slug":"精益求精","permalink":"http://heseng91.github.io/categories/%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE/"}],"tags":[]},{"title":"「精益求精」之网络","slug":"「精益求精」之网络","date":"2022-11-02T17:20:51.000Z","updated":"2022-11-26T19:22:45.964Z","comments":true,"path":"2022/11/03/「精益求精」之网络/","link":"","permalink":"http://heseng91.github.io/2022/11/03/%E3%80%8C%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%E3%80%8D%E4%B9%8B%E7%BD%91%E7%BB%9C/","excerpt":"如果说计算机把我们从工业时代带到了信息时代，那么计算机网络就可以说把我们带到了网络时代。现如今，随着越来越多的终端设备接入互联网，人们尤其是程序员不可能不与网络打交道。现在我们的手机，电脑，不夸张地说，离开了网络就是一块“废铁”，它们的作用将大打折扣。了解网络知识可以扩展我们的知识面，也有助于我们更好的编程，因此本文就对程序员需要了解的网络知识做一个简要介绍。","text":"如果说计算机把我们从工业时代带到了信息时代，那么计算机网络就可以说把我们带到了网络时代。现如今，随着越来越多的终端设备接入互联网，人们尤其是程序员不可能不与网络打交道。现在我们的手机，电脑，不夸张地说，离开了网络就是一块“废铁”，它们的作用将大打折扣。了解网络知识可以扩展我们的知识面，也有助于我们更好的编程，因此本文就对程序员需要了解的网络知识做一个简要介绍。 OSI七层模型OSI模型是什么OSI模型即开放式系统互联模型（Open System Interconnection Model），它是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互联为网络的标准框架。 也就是说，因为有这个模型，所以一台计算机发送的信息才能被另一台计算机准确的解析出来，两台计算机才能互相交流。 OSI模型的诞生OSI模型它是服务于计算机网络的，而计算机网络是一个非常复杂的系统。可以想像一个场景，两个连接在网络上的两台计算机需要互相传送文件。 显然，他们两之间必须要有一条链路对吧。但是只有一条链路远远不够，至少还要有以下6个功能： 发起通信的计算机必须要把数据通信的通路进行“激活”，所谓“激活”就是发送一些信令，保证要传送的计算机数据能在这条通路上正确的发送和接收。 告诉计算机如何识别接收数据的计算机。 发起通信的计算机必须查明对方的计算机是否已开机，并且网络连接正常。 发起通信的计算机中的应用程序必须弄清楚，在对方的文件管理程序已经做好接收文件和存储文件的准备工作。 若计算机的文件格式不兼容，那么至少有一台计算机能完成格式转换。 对出现的各种差错和意外事故，如数据传送错误，重复或丢失，网络中某个节点交换机出现故障等，应当有可靠的措施保证对方计算机最终能接收到正确的文件。 这六个功能总结下来就是，我发送数据之前必须要知道要发给谁，必须要保证对方能接收和处理我的数据，对于可能出现错误的情况我们两能够处理。那我们就可以看出，两台互相通信的计算机必须要能够高度作协调工作。而这些“协调”相当复杂，为了设计出这样复杂的计算机网络，在APRANET设计的时候就提出了分层的方法，就是化繁为简，各层处理各层的工作，分工合作，有点我们封装函数的那个意思。 网络出现后，各大公司意识到了网络的好处，都争相推出自己公司的体系结构，每个公司都想垄断市场，因为不同的网络体系结构，同一家公司的互联网能很快的连接成网，但是对于两个不同公司的计算机没办法交流。 全球经济发展为了让每台计算机都能信息交互，国际化标准组织ISO在1997年成立专门机构解决这个问题，并提出了OSI模型。 OSI七层模型、TCP/IP四层模型和五层协议OSI七层模型 模型把网络通信的工作分为7层。1至4层被认为是低层，这些层与数据移动密切相关。5至7层是高层，包含应用程序级的数据。每一层负责一项具体的工作，然后把数据传送到下一层。由低到高具体分为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 第7层应用层—直接对应用程序提供服务，应用程序可以变化，但要包括电子消息传输； 第6层表示层—格式化数据，以便为应用程序提供通用接口。这可以包括加密服务； 第5层会话层—在两个节点之间建立端连接。此服务包括建立连接是以全双工还是以半双工的方式进行设置，尽管可以在层4中处理双工方式第4层传输层—常规数据递送－面向连接或无连接。包括全双工或半双工、流控制和错误恢复服务； 第3层网络层—本层通过寻址来建立两个节点之间的连接，它包括通过互连网络来路由和中继数据； 第2层数据链路层—在此层将数据分帧，并处理流控制。本层指定拓扑结构并提供硬件寻址； 第1层物理层—原始比特流的传输； 电子信号传输和硬件接口数据发送时，从第七层传到第一层，接受方则相反。 各层对应的典型设备如下： 应用层……………….计算机：应用程序，如FTP，SMTP，HTTP 表示层……………….计算机：编码方式，图像编解码、URL字段传输编码 会话层……………….计算机：建立会话，SESSION认证、断点续传 传输层……………….计算机：进程和端口 网络层……………….网络：路由器，防火墙、多层交换机 数据链路层………..网络：网卡，网桥，交换机 物理层……………….网络：中继器，集线器、网线、HUB OSI分层的优点 人们可以很容易的讨论和学习协议的规范细节。 层间的标准接口方便了工程模块化。 创建了一个更好的互连环境。 降低了复杂度，使程序更容易修改，产品开发的速度更快。 每层利用紧邻的下层服务，更容易记住个层的功能。 OSI是一个定义良好的协议规范集，并有许多可选部分完成类似的任务。 它定义了开放系统的层次结构、层次之间的相互关系以及各层所包括的可能的任务。是作为一个框架来协调和组织各层所提供的服务。 OSI参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的制定。即OSI参考模型并不是一个标准，而是一个在制定标准时所使用的概念性框架。 TCP/IP四层模型和五层协议说到OSI七层模型，不得不提到的就是TCP/IP四层模型和五层协议了。这两个又是什么呢。大家可以看看这个对比图。 简单介绍一下TCP/IP四层协议和五层协议 1997年，国际标准化组织花了5年推出OSI模型后，OSI模型并没有实际的成为一个国际标准。因为当时市面上已经非常流行TCP/IP四层协议了，而且，OSI模型定制的条件过于严苛试图达到一种理想境界，当时并没有一家生产商能生产出符合他们标准的商用产品。所以OSI只获取到理论成果，并没有能市场化。所以现在我们使用最广泛，规模最大，覆盖全球的反而是TCP/IP四层协议。 而五层协议就是后来方便我们理解和学习抽象出来的一个模型。 总结OSI七层模型和TCP/IP四层协议的关系： OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。 OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。 OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。 五层协议是供我们学习计算机网络的模型。 网络传输过程OSI参考模型中数据传输过程在前面我们介绍了OSI参考模型的分层结构，以及各层在其体系结构中的主要功能等知识。下面我们来学习OSI参考模型中数据的传输过程。 在OSI参考模型中交换数据，首先由发送端的发送进程将数据交给应用层，应用层在数据的前面加上该层控制和识别信息， 并将其传送到表示层。该过程一直重复到物理层，并由传输介质把数据传送到接收端，在接收进程所在计算机史，信息向上传送，各层的控制和识别信息逐层去掉，最后数据被送到接收进程。如下图所示，为OSI参考模型中数据传输过程。 而数据的传输过程，如下图所示，图中，实线表示数据的实际传递，虚线表示数据的虚拟传递。 如果主机A需要将数据从其应用进程发送到主机B的应用进程，其数据传输过程如下： 在主机A的发送进程中，首先需要将数据送到应用层，加上应用层协议要求的控制信息AH（AH表示应用层控制信息），形成应用层的协议数据单元；再将应用层的协议数据单元传到表示层，形成表示层的服务数据单元，，加上表示层的协议控制信息PH（PH表示表示层控制信息），形成表示层的协议数据单元。 表示层的协议数据单元传到会话层，形成会话层的服务数据单元，加上会话层协议要求的控制信息SH（SH表示会话层控制信息），形成会话层的协议数据单元。依次类推，到达数据链路层后，数据链路层的协议控制信息分为两部分，分别为控制头部信息和尾部信息，形成赖；将传到物理层，不再加任何控制信息，转换成比特流，并通过传输介质将其传送到主机B的物理层。 各层的协议控制信息，因协议和传送内容不同，分别有不同的内容和格式要求。主机 B的物理层将比特流传给数据链路层，将帧中的控制头部信息和尾部信息去掉，形成网络层的协议数据单元，然后，去掉网络层协议控制信息NH（NH表示网络层控制信息），形成网络层的服务数据单元。依次类推，直到数据传送到主机B的应用进程。 URL访问网站的网络传输全过程了解了数据传输过程，HTTP、TCP、DNS、IP这些耳熟能详的名词都在什么时候起着什么作用呢？下面我们结合生活中浏览器浏览操作，再来整体梳理一下URL访问网站的网络传输全过程。 简单来说，从浏览器输入地址到呈现页面中间会经历如下阶段： 浏览器（客户端）进行地址解析。 将解析出的域名进行dns解析。 通过ip寻址和arp，找到目标（服务器）地址。 进行tcp三次握手，建立tcp连接。 浏览器发送数据，等待服务器响应。 服务器处理请求，并对请求做出响应。 浏览器收到服务器响应，得到html代码。 渲染页面。 浏览器（客户端）地址解析当我们在浏览器中输入一个地址，按下回车后，浏览器获取到的是一个字符串。浏览器此时要对这个地址进行解析，获取协议，主机，端口，路径等信息。 URL的一般格式为： 1protocol:&#x2F;&#x2F;hostname[:port]&#x2F;path&#x2F;[;parameters][?query]#fragment 例如： http://www.imooc.com/article/draft/id/430 这个网址缺少了一些东西，端口号，用户名，密码，query和flag都没有。这些东西都是非必须的，甚至协议、路径都可以不要，最简洁的方式为imooc.com，浏览器会对一些默认的东西进行补齐。例如：互联网url默认端口号为80，浏览器默认补齐功能会补齐协议http，有些还会直接在域名前面补上www。所以实际上，即使我们输入的是imooc.com，然而实际访问的却是http://www.imooc.com。 DNS解析第一步地址解析中我们已经获取到服务器的域名。此时就需要将域名换成对应的ip地址，这就是DNS解析。 DNS（Domain Names System），域名系统，是互联网一项服务，用来将域名转换为IP地址。为什么要转换？因为IP地址固定32位计算机能处理，但是人记不住。就有了域名，但是域名长度不固定，机器处理不了，为了同时满足机器和人的要求就有了域名系统来做转换。 IP地址： 32位二进制，能唯一标记网络上的计算机。域名： 是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识。 互联网域名结构和域名服务器结构域名也不是随便取的，DNS系统定义了域名必须要有的结构。早期的互联网使用了非等级的名字空间，名字随便取，优点就是名字简短。但是互联网用户数剧增，为了方便管理，就采用了层次树状结构的命名方法，就像全球的邮政系统和电话系统一样。 例如www.igetget.com，www为三级域名、igetget 为二级域名、com为顶级域名，系统为用户做了兼容，域名末尾的根域名.一般不需要输入。 这只是我们抽象出来便于大家理解的的域名体系结构，具体要实现域名系统则是使用分布在各地的域名服务器。理论上讲每一级域名都要有一个相应的域名服务器，构成和互联网域名空间对应的一个域名服务器树的结构，但是这样会导致域名服务器数量过多，使域名系统的运行效率降低（服务器多要发送的请求就多，会很浪费时间），所以在二级域名及以下域名服务器采用了分区方式来解决这个问题，就是一个域名服务器管辖不止一个域名的方式。 看一个服务器分区的例子： 我们看下图这个例子，abc这个公司有两个分区，对应的域名服务器树状结构如下： 服务器分为四大类，根域名服务器，顶级域名服务器，权限域名服务器，本地域名服务器。 域名解析过程查询方式有两种：递归查询，迭代查询。 迭代查询：先在本地域名服务器查询，没有就在根域名服务器查询，跟域名服务器会告诉你应该在哪个顶级域名服务器查询，然后顶级域名服务器告诉你应该在哪个权限域名服务器查询，然后权限域名服务器就会讲查询姐股票返回给本地域名服务器 递归查询：先在本地域名服务器查询，没有就在根域名服务器查询，然后根域名服务器会去查找顶级域名服务器，顶级域名服务器又会去查找权限域名服务器。然后再依次返回到根域名服务器，最后由根域名服务器返回给本地域名服务器。 因为每个在本地域名服务器查询不到IP地址的请求都会发给根域名服务器，所以根域名服务器接收到的请求非常多，使用递归查询的方式对根域名服务器的压力特别大，所以本地域名查询根域名一般采用迭代查询的方式。 域名缓存在域名服务器解析的时候，域名服务器会使用缓存保存域名和IP地址的映射。 计算机中DNS的记录也分成了两种缓存方式： 浏览器缓存：浏览器在获取网站域名的实际IP地址后会对其进行缓存，减少网络请求的损耗 操作系统缓存：操作系统的缓存其实是用户自己配置的hosts文件。 DNS解析过程dns解析分为以下几个步骤： 先查看浏览器dns缓存中是否有域名对应的ip。 如果没有，则产看操作系统dns缓存中是否有对应的ip（例如windows的hosts文件）。 依旧没有就对本地区的dns服务器发起请求， 如果还是没有，就直接到Root Server域名服务器请求解析。 这里面有几点需要关注： DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议； 全球只有十三台逻辑根服务器，为什么是十三台，请参考https://www.zhihu.com/question/22587247?answer_deleted_redirect=true。其中任何一次解析成功就返回对应的ip地址。 通过ip寻址和arp，找到目标服务器地址。第二步获取到了ip，此时直接通过ip寻址找到ip对应的服务器，然后通过arp协议找到服务器的mac地址。 那么IP寻址是如何工作的呢？ ip寻址主要有两种方式，一种是同一网段，一种是不同网段。要判断两个IP地址是不是在同一个网段，就将它们的IP地址分别与子网掩码做与运算，得到的结果一网络号，如果网络号相同，就在同一子网，否则，不在同一子网。 同一网段的情况：主机A和主机B，首先主机A通过本机的hosts表或者wins系统或dns系统先将主机B的计算机名转换为Ip地址，然后用自己的 Ip地址与子网掩码计算出自己所出的网段，比较目的主机B的ip地址与自己的子网掩码，发现与自己是出于相同的网段，于是在自己的ARP缓存中查找是否有主机B 的mac地址，如果能找到就直接做数据链路层封装并且通过网卡将封装好的以太网帧发送有物理线路上去：如果arp缓存中没有主机B的的mac地址，主机A将启动arp协议通过在本地网络上的arp广播来查询主机B的mac地址，获得主机B的mac地址厚写入arp缓存表，进行数据链路层的封装，发送数据。 不同网段的情况：不同的数据链路层网络必须分配不同网段的Ip地址并且由路由器将其连接起来。和上面一样，主机A发现和主机B不在同一个网段，于是主机A将知道应该将次数据包发送给自己的缺省网关，即路由器的本地接口。主机A在自己的ARP缓存中查找是否有缺省网关的MAC地址，如果能够找到就直接做数据链路层封装并通过网卡 将封装好的以太网数据帧发送到物理线路上去，如果arp缓存表中没有缺省网关的Mac地址，主机A将启动arp协议通过在本地网络上的arp广播来查询缺省网关的mac地址，获得缺省网关的mac地址后写入arp缓存表，进行数据链路层的封装，发送数据。数据帧到达路由器的接受接口后首先解封装，变成ip数据包，对ip 包进行处理，根据目的Ip地址查找路由表，决定转发接口后做适应转发接口数据链路层协议帧的封装，并且发送到下一跳路由器，次过程继续直至到达目的的网络与目的主机。整个过程有点像dns解析，只是dns服务器换成了下一跳路由器，udp编程了tcp，其他差别不大。 其中提到了一个ARP的概念，ARP就是地址转化协议，类似于DNS将域名翻译成IP，ARP则是把ip地址转化为mac地址。我们知道了IP后，需要通过主机的MAC地址来更具体的找到主机。同样的也有一个ARP缓存，其中存储了一些IP与MAC地址的对应关系，如果缓存中找不到，就会进行广播来查找MAC地址，收到广播的主机会检查自己的IP是否是待查找的IP，是的话就返回自己的MAC地址。 TCP建立连接三次握手得到域名对应的IP地址后，也就表示可以将数据送达目的主机了，就会开始我们常说的三次握手建立连接。 TCP报文段首部格式在谈及TCP建立连接和释放连接过程，先来简单认识一下TCP报文段首部格式的几个名词。 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。 三次握手的过程 主机A向主机B发送TCP连接请求数据包，其中包含主机A的初始序列号seq(A)=x。 （其中报文中同步标志位SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x） ； 主机B收到请求后，会发回连接确认数据包。 （其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含主机B的初始序列号seq(B)=y，以及主机B对主机A初始序列号的确认号ack(B)=seq(A)+1=x+1） 第三次，主机A收到主机B的确认报文后，还需作出确认，即发送一个序列号seq(A)=x+1；确认号为ack(A)=y+1的报文； 为什么需要第三次握手还要再发送一次确认是为了，防止已失效的连接请求报文段突然又传到了B，因而产生错误。 已失效的报文段：正常情况下：A发出连接请求，但因为丢失了，故而不能收到B的确认。于是A重新发出请求，然后收到确认，建立连接，数据传输完毕后，释放连接，A发了2个，一个丢掉，一个到达，没有“已失效的报文段” 但是，某种情况下，A的第一个在某个节点滞留了，延误到达，本来这是一个早已失效的报文段，但是在A发送第二个，并且得到B的回应，建立了连接以后，这个报文段竟然到达了，于是B就认为，A又发送了一个新的请求，于是发送确认报文段，同意建立连接，假若没有三次的握手，那么这个连接就建立起来了（有一个请求和一个回应），此时，A收到B的确认，但A知道自己并没有发送建立连接的请求，因为不会理睬B的这个确认，于是呢，A也不会发送任何数据，而B呢却以为新的连接建立了起来，一直等待A发送数据给自己，此时B的资源就被白白浪费了。但是采用三次握手的话，A就不发送确认，那么B由于收不到确认，也就知道并没有要求建立连接。 简而言之： 第三次握手，主机 A 发送一次确认是为了防止： 如果客户端迟迟没有收到服务器返回的确认报文，这时他会放弃连接，重新启动一条连接请求；但问题是：服务器不知客户端没收到，所以他会收到两个连接请求，白白浪费了一条连接开销。 发送与收取数据链接建立之后，即可以进行数据发送与收取了。万维网中，浏览器和服务器之间的数据传输必须按照规定的格式和遵循一定的规则，这些格式和规则就是超文本传输协议。这里就要介绍一下另一个耳熟能详的概念HTTP。 HTTP协议HTTP协议（HyperText Transfer Protocol），就是超文本传输协议，它定义了浏览器怎么向万维网服务器请求万维网文档，以及服务器怎么将文档传输给浏览器。数据以明文传送，不提供任何方式的数据加密。 HTTP本身是无连接协议，它使用了TCP作为传输协议，保障了数据的可靠传输。虽然http使用了TCP连接，但是通信双方在交换HTTP报文之前不需要先建立HTTP连接。只用在传输层建立TCP连接即可。 HTTP也是无状态协议，同一个客户端无论访问同一个浏览器的同一个页面几次返回的数据都是相同的，这样有利于服务器处理大量并发的HTTP请求。 http协议的格式 请求报文就是客户端发送给服务器的报文，响应报文就是服务器发送给客户端的报文，然后请求报文有请求行、首部、空行和实体主体，响应报文有状态行、首部、空行和实体主体。 数据包的传输过程此阶段的数据传输过程即前面介绍的OSI参考模型中数据传输过程。以HTTP的GET方法请求为例，浏览器会对请求进行包装，包装成上面提到格式的请求报文。然后开始数据包的传输，传输过程如下： 浏览器向域名发出GET方法报文； 该GET方法报文通过TCP-&gt;IP（DNS）-&gt;MAC（ARP）-&gt;网关-&gt;目的主机； 目的主机收到数据帧，通过IP-&gt;TCP-&gt;HTTP，HTTP协议单元会回应HTTP协议格式封装好的HTML形式数据； 该HTML数据通过TCP-&gt;IP（DNS）-&gt;MAC（ARP）-&gt;网关-&gt;我的主机； 我的主机收到数据帧，通过IP-&gt;TCP-&gt;HTTP-&gt;浏览器，浏览器以网页形式显示HTML内容。 其他的HTTP方法在传输数据时方法都类似，只是所携带的内容不同。 HTTP发展史(包括版本) HTTP/0.9：1991年发布，极其简单，只有一个get命令 HTTP/1.0：1996年5月发布，增加了大量内容 HTTP/1.1：1997年1月发布，进一步完善HTTP协议，是目前最流行的版本 SPDY ：2009年谷歌发布SPDY协议，主要解决HTTP/1.1效率不高的问题 HTTP/2 ：2015年借鉴SPDY的HTTP/2发布 HTTP1.1协议前面说到，网络传输过程要等链接建立之后，才会开始网络传输。 那么请求一个文档至少需要耗费文档传输时间加上两倍往返时间RTT(一个RTT用于TCP连接，另一个RTT用于请求和接受文档)。 HTTP1.0，每次都要新建立TCP连接，服务端返回之后就会断开链接。因此每次请求都会导致2倍RTT的开销，新建立TCP连接服务器都需要给它分配缓存和变量，会导致服务器压力巨大。鉴于这些缺点，人们推出了HTTP1.1。HTTP1.1相比1.0有如下改进： 缓存处理：HTTP/1.0 使用 Pragma:no-cache + Last-Modified/If-Modified-Since来作为缓存判断的标准；HTTP/1.1 引入了更多的缓存控制策略：Cache-Control、Etag/If-None-Match等 错误状态管理：HTTP/1.1新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 范围请求：HTTP/1.1在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接，支持断点续传 Host头：HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础 持久连接：HTTP/1.1 最大的变化就是引入了持久连接（persistent connection），在HTTP/1.1中默认开启 Connection: keep-alive，即TCP连接默认不关闭，可以被多个请求复用。 客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。 管道机制：HTTP/1.1中引入了管道机制（pipelining）,即在同一个TCP连接中，客户端可以同时发送多个请求。 HTTP/1.1的缺点HTTP/1.1 的持久连接和管道机制允许复用TCP连接，在一个TCP连接中，也可以同时发送多个请求，但是所有的数据通信都是按次序完成的，服务器只有处理完一个回应，才会处理下一个回应。比如客户端需要A、B两个资源，管道机制允许浏览器同时发出A请求和B请求，但服务器还是按照顺序，先回应A请求，完成后再回应B请求，这样如果前面的回应特别慢，后面就会有很多请求排队等着，这称为”队头阻塞(Head-of-line blocking)”。 HTTP2HTTP2以Google发布的SPDY协议为基础，于2015年发布。它不叫HTTP2.0，因为标准委员会不打算再发布子版本了，下一个新版本将是HTTP3。HTTP2协议只在HTTPS环境下才有效，升级到HTTP2，必须先启用HTTPS。HTTP2解决了HTTP1.1的性能问题，主要特点如下： 二进制分帧：HTTP1.1的头信息是文本（ASCII编码），数据体可以是文本，也可以是二进制；HTTP2 头信息和数据体都是二进制，统称为“帧”：头信息帧和数据帧。比起像HTTP/1.x这样的文本协议，二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。 多路复用（双工通信）：通过单一的 HTTP2 连接发起多重的请求-响应消息，即在一个连接里，客户端和浏览器都可以同时发送多个请求和响应，而不用按照顺序一一对应，这样避免了“队头堵塞”。HTTP2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。 数据流：因为 HTTP2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。HTTP2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。HTTP1.1取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。 首部压缩：HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息压缩后再发送（SPDY 使用的是通用的DEFLATE 算法，而 HTTP2 则使用了专门为首部压缩而设计的 HPACK 算法）。；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 服务端推送：HTTP2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。 HTTPS在上述介绍HTTP中，了解到HTTP传递信息是以明文的形式发送内容，这并不安全。而HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议））出现正是为了解决HTTP不安全的特性。 为了保证这些隐私数据能加密传输，让HTTP运行在安全的SSL/TLS协议上，即 HTTPS = HTTP + SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。 SSL 协议位于TCP/IP 协议与各种应用层协议之间，浏览器和服务器在使用 SSL 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持。 https大致过程如下： 建立服务器443端口连接 SSL握手：随机数，证书，密钥，加密算法 发送加密请求 发送加密响应 关闭SSL 关闭TCP 其中SSL握手过程如下图所示： 客户端发出加密通信请求ClientHello 提供如下信息： 协议版本（如TSL1.0） ； 随机数1（用于生成对话密钥） ； 支持的加密方法（如RSA公钥加密） ； 支持的压缩方法； 服务器回应SeverHello 回应内容： 确认使用的加密通信协议版本（TSL1.0） ； 随机数2（用于生成对话密钥） ； 确认加密方法（RSA） ； 服务器证书（包含非对称加密的公钥） ； （可选）要求客户端提供证书的请求； 客户端验证证书 如果证书不是可信机构颁布，或证书域名与实际域名不符，或者证书已经过期，就会向访问者显示一个警告，是否继续通信。 客户端回应 证书没有问题，就会取出证书中的服务器公钥，然后发送： 随机数3（pre-master key，此随机数用服务器公钥加密，防止被窃听） ； 编码改变通知（表示随后的信息都将用双方商定的方法和密钥发送） ； 客户端握手结束通知； 双方生成会话密钥 双方同时有了三个随机数，接着就用事先商定的加密方法，各自生成同一把“会话密钥”服务器端用自己的私钥（非对称加密的）获取第三个随机数，会计算生成本次所用的会话密钥（对称加密的密钥），如果前一步要求客户端证书，会在这一步验证。 服务器最后响应 服务器生成会话密钥后，向客户端发送： 编码改变通知（后面的信息都用双方的加密方法和密钥来发送） ； 服务器握手结束通知； 至此，握手阶段全部结束，接下来客户端与服务器进入加密通信，用会话密钥加密内容。 浏览器收到服务器响应，得到html代码浏览器发出请求时，请求报文的报文头包含一个accept字段。accept代表发送端（客户端）希望接受的数据类型，这是浏览器自动封装的请求头。如果服务器返回的content-type是accept中的任何一个，浏览器都能解析，并直接展示在网页上。如果服务器返回的content-type是其他类型，此时浏览器有三种处理状态： 正常显示。例如返回类型为text/javascript，浏览器能直接处理并展示。 下载。例如返回类型为application/octet-stream（二进制流，不知道下载文件类型），这种浏览器不能直接处理的，会被下载。 报错。当我们返回一个字符串hello world，却使用text/xml，格式时，浏览器不能正确解析，就会报错，并把报错信息呈现在网页中。 浏览器能直接处理很多种格式，并直接呈现在网页中，并不限于accept中规定的字段。 渲染页面获取到服务器相应之后，浏览器会根据相应的content-type字段对响应字符串进行解析。能够解析并成功解析就显示，能够解析但解析错误就报错，不能解析就下载。由于浏览器采用至上而下的方式解析，所以会先解析html，直到遇到外部样式和外部脚本。这时会阻塞浏览器的解析，外部样式和外部脚本（在没有async、defer属性下）会并行加载，但是外部样式会阻塞外部脚本的执行，dom加载完毕，js脚本执行成功后dom树构建完成（DOMContentLoaded），之后就加载dom中引用的图片等静态资源。即：html解析-&gt;外部样式、脚本加载-&gt;外部样式执行-&gt;外部脚本执行-&gt;html继续解析-&gt;dom树构建完成-&gt;加载图片-&gt;页面加载完成。 如果是动态脚本（即内联脚本）则不受样式影响，在解析到它时会执行。 外部样式后续外部脚本含有async属性（IE下为defer），外部样式不会阻塞该脚本的加载与执行。 在外部样式执行完毕后，css附着于DOM，创建了一个渲染树（渲染树是一些被渲染对象的集）。每个渲染对象都包含了与之对应的计算过样式的DOM对象，对于每个渲染元素来说，位置都经过计算，所以这里被叫做“布局”。然后将“布局”显示在浏览器窗口，称之为“绘制”。 最后页面加载完成，页面load。 TCP释放连接四次握手当数据传输完成，需要释放TCP链接，TCP释放连接需要四次握手。 四次握手过程假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下： 关闭客户端到服务器的连接：首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u 服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。 关闭服务器到客户端的连接：也是发送一个FIN给客户端。 客户段收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 主机A发送FIN后，进入终止等待状态， 服务器B收到主机A连接释放报文段后，就立即给主机A发送确认，然后服务器B就进入close-wait状态，此时TCP服务器进程就通知高层应用进程，因而从A到B的连接就释放了。此时是“半关闭”状态。即A不可以发送给B，但是B可以发送给A。 此时，若B没有数据报要发送给A了，其应用进程就通知TCP释放连接，然后发送给A连接释放报文段，并等待确认。A发送确认后，进入time-wait，注意，此时TCP连接还没有释放掉，然后经过时间等待计时器设置的2MSL后，A才进入到close状态。 为什么要等待2MSL MSL即Maximum Segment Lifetime，也就是最大报文生存时间，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。引用《TCP/IP详解》中的话：“它(MSL)是任何报文段被丢弃前在网络内的最长时间”。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。 TCP的TIME_WAIT状态需要等待2MSL，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。概括原因如下： 为了保证A发送的最后一个ACK报文段能够到达B。即最后这个确认报文段很有可能丢失，那么B会超时重传，然后A再一次确认，同时启动2MSL计时器，如此下去。如果没有等待时间，发送完确认报文段就立即释放连接的话，B就无法重传了（连接已被释放，任何数据都不能出传了），因而也就收不到确认，就无法按照步骤进入CLOSE状态，即必须收到确认才能close。 防止“已失效的连接请求报文段”出现在连接中。经过2MSL，那些在这个连接持续的时间内，产生的所有报文段就可以都从网络中消失。即在这个连接释放的过程中会有一些无效的报文段滞留在楼阁结点，但是呢，经过2MSL这些无效报文段就肯定可以发送到目的地，不会滞留在网络中。这样的话，在下一个连接中就不会出现上一个连接遗留下来的请求报文段了。 可以看出：B结束TCP连接的时间比A早一点，因为B收到确认就断开连接了，而A还得等待2MSL。 为什么TCP释放连接需要四次TCP建立连接要进行三次握手，而断开连接要进行四次。这是由于TCP的半关闭造成的。因为TCP连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个FIN来向另一方通告将要终止这个方向的连接。注意： 发送了FIN只是表示这端不能继续发送数据(应用层不能再调用send发送)，但是还可以接收数据。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据，比如：如主机A收到主机B的FIN断开TCP连接请求，只是表示主机B已经发送完数据，主机A收到FIN后作出应答，并终止这个方向的数据传输，此时处于半关闭状态。但是主机A仍然可以发送数据的，只有当主机A发送完数据并发送FIN给主机B时，主机B才停止这个方向的数据传输，并关闭TCP连接。 在很多时候，TCP连接的断开都会由TCP层自动进行，例如你CTRL+C终止你的程序，TCP连接依然会正常关闭，你可以写代码试试。 总结综上，在浏览器地址栏输入域名后，首先浏览器会对输入的地址进行地址解析，接着对解析出的域名进行DNS解析。DNS解析会首先搜索浏览器的DNS缓存，没有命中就在操作系统hosts文件中查找，还没命中就在本地服务器中查找，本地服务器也没有相关缓存就在根域名服务器查找，然后在相应的顶级域名服务器查找，然后在权限域名服务器中查找。本地域名服务器缓存IP地址，并返回给操作系统，操作系统缓存IP地址并返回给浏览器，然后浏览器缓存这个IP地址。 在查询到目标服务器之后，就会建立TCP连接，开始发送与收取数据，待数据传输完成后再释放TCP链接。 每一个服务器都有一个进程不断监听TCP的端口80，以便发现是否有浏览器向它发出连接建立请求，一旦监听到链接建立请求并建立TCP链接之后，浏览器就向服务器发出浏览某个页面的请求，服务器接着返回所请求的页面作为响应，浏览器收到html页面后渲染页面，待数据传输完成TCP链接被释放。 补充IP头、TCP头、UDP头详解以及定义MAC地址、IP地址和端口号在利用TCP/IP协议族进行通信的时候，有三个比较关键的确认身份的信息：MAC地址、IP地址和端口号。一个主机会有一个 MAC 地址，而每个网络会有一个专属于它的 IP 地址。 MAC地址MAC地址即网卡号，每块网卡出厂的时候，都有一个全世界独一无二的 MAC 地址，长度是 48 个二进制位，通常用 12 个十六进制数表示，如：00-16-EA-AE-3C-40就是一个MAC地址，其中前6位16进制数00-16-EA代表网络硬件制造商的编号，它由IEEE(电气与电子工程师协会)分配，而后6位16进制数AE-3C-40代表该制造商所制造的某个网络产品(如网卡)的系列号。 MAC地址工作在OSI模型中的数据链路层，在数据链路层包裹在以太网头部中的，它主要用来识别同一个链路中的不同计算机。 IP地址IP地址是由网络号和主机号组成。在OSI 模型中，IP地址是工作在OSI模型中的网络层，IP地址为32位，IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址分为A、B、C、D、E五大类： A类地址：一个字节（8位）的网络地址和三个字节的主机地址。地址范围为：1.0.0.0~126.255.255.255。 B类地址：二个字节的网络地址和二个字节的主机地址。地址范围为：128.0.0.0~191.255.255.255。 C类地址：三个字节的网络地址和一个字节的主机地址。地址范围为：192.0.0.0~223.255.255.255。 D类地址：D类地址用于多点广播（Multicast），D类IP地址第一个字节以“lll0”开始，它是一个专门保留的地址。地址范围为：224.0.0.0~239.255.255.255。 E类地址：E类IP地址 以“llll0”开始，为将来使用保留。地址范围为：240.0.0.0~255.255.255.254。，255.255.255.255用于广播地址。 其中缺失了两部分，一个是0开头的，“0”表示该地址是本地主机，不能传送。一个是127开头的，127开头的是网卡自身，常用于测试。这里为什么是十进制的数字，为什么中间有‘.’，其实这都是为了方便人类而人为加上去的。转化为计算机语言就是二进制的，每一个字节八位，八位二进制能表示的最大数字就是255，这样ip地址就齐全了。可能有些人还发现ip地址为 10.170.8.61/23 ，这里涉及到局域网、保留地址和子网掩码。这里的意思是，前23位表示为该台主机的网络地址，该网络有 2^(32-23) = 512台主机。具体就不展开讲了，感兴趣的可以参考https://www.zhihu.com/question/56895036。 端口号在传输层包含在TCP/UDP头部中的，用于识别应用程序。 一台主机上能运行多个程序，那么接收到的消息到底是哪个程序的呢？就需要端口号来确认。 端口号有两种： 固定的端口号：是形如http，telnet，ftp等广为使用的应用协议所使用的端口号是固定的；动态分配的端口号：这个时候服务端要确定监听端口号，接受服务的客户端没必要确定端口号；端口号由传输层协议决定，因此不同传输协议可以使用相同的端口号，所以TCP和UDP可以使用同一个端口号。 为什么有了ip地址，还要mac地址？这个问题很关键，就像是我有驾驶证了你非要让我提供身份证。这个涉及一些历史问题，因为一开始没有互联网的时候就只有mac地址，还不存在ip地址。后来互联网越来越大之后，发现mac地址找起来太麻烦，并且耗时也越来越久，就发明了ip地址。并且mac地址在一个局域网中还是很有用的，所以就两个一起存在了。详细的信息，大家可以参考https://www.zhihu.com/question/21546408。 IP头、TCP头、UDP头详解以及定义数据传输的封装与解封装前文中提到，数据在发送阶段，每层都要加上协议要求的控制信息，而在接收阶段，每层都会去掉该层的控制信息，该过程就是数据的封装与解封装，详细过程见下图。 图中提到了几种报头，我们接下来逐个介绍。 MAC报文段结构 目的地址：接收帧的网络适配器的物理地址（MAC 地址），为 6 个字节（48 比特）。作用是当网卡接收到一个数据帧时，首先会检查该帧的目的地址，是否与当前适配器的物理地址相同，如果相同，就会进一步处理；如果不同，则直接丢弃。 源地址：发送帧的网络适配器的物理地址（MAC 地址），为 6 个字节（48 比特）。 类型：上层协议的类型](https://link.zhihu.com/?target=https%3A//blog.csdn.net/weixin_38387929/article/details/116558181)，由于上层协议众多，所以在处理数据的时候必须设置该字段，标识数据交付哪个协议处理。例如，字段为 0x0800 时，表示将数据交付给 IP 协议。 数据：也称为效载荷，表示交付给上层的数据。以太网帧数据长度最小为 46 字节，最大为 1500 字节。如果不足 46 字节时，会填充到最小长度。最大值也叫最大传输单元（MTU）。 在 Linux 中，使用 ifconfig 命令可以查看该值，通常为 1500。 帧检验序列 FCS：检测该帧是否出现差错，占 4 个字节（32 比特）。发送方计算帧的循环冗余码校验（CRC）值，把这个值写到帧里。接收方计算机重新计算 CRC，与 FCS 字段的值进行比较。如果两个值不相同，则表示传输过程中发生了数据丢失或改变。这时，就需要重新传输这一帧。 IP报文段结构 4位版本： IP协议的版本号｡ 4位首部长度：由于IPv4的包头可能包含可变数量的可选项，用来确定IPv4数据报中数据部分的偏移位置｡ 8位服务类型 ：定义IP封包在传送过程中要求的服务类型，类型如下 000….. (Routine): 过程字段,占3位｡设置了数据包的重要性,取值越大数据越重要,取值范围为:0(正常)~ 7(网络控制) …0….(Delay):延迟字段 ,占1位,取值:0(正常)､1(期特低的延迟) ….0…(Throughput):流量字段,占1位｡取值:0(正常)､1(期特高的流量) …..0..(Reliability) :可靠性字段,占1位｡取值:0(正常)､1(期特高的可靠性) …..0.(ECN-Capable Transport):显式拥塞指示传输字段,占1位｡由源端设置,以显示源端节点的传输协议是支持ECN(Explicit Cogestion Notifica tion,显式拥塞指示)的｡取值:0(不支持ECN)､1(支持ECN) …….0(Congestion Experienced):拥塞预警字段,占1位｡取值:0(正常,不拥塞)､1(拥塞) 16位总长度：指定IP包的总长 利用首部长度字段和总长度字段,就可以知道IP数据报中数据内容的起始位置和长度｡ 因为一些数据链路(如以太网)需要填充一些数据以达到最小长度｡以太网的最小帧长为46个字节，但IP数据可能会更短｡所以通过总长度字段，在IP层中确定46字节中有多少是IP数据报的内容｡ 16位标识：发送方发送的数据会被拆散成封包形式通过网络传送，接收方收到封包后要进行重组的时候通过这个ID确定是否为同一条数据｡ 3位标志：当封包在传输过程中进行最佳组合时使用的识别记号。 000(Reserved Fragment):保留分段｡当此值为0的时候表示目前未被使用｡ .0.(Don’t Fragment):不分段｡当此值为0的时候表示封包可以被分段,如果为1则不能被分割｡ ..0( More Fragment):更多分段｡当上一个值为0时,此值为0就示该封包是最後一个封包,如果为1则表示其後还有被分割的封包｡ 13位分段偏移：封包片段定位标记，解决封包抵达顺序和切割顺序不一致时，重组不能对号入座问题｡如果封包并没有被分段，则FO值为“0”｡ 8位生存时间：每经过一个路由设备-1，当该字段的值为0时,数据报就被丢弃，防止进入死循环｡ 8位协议：封包所使用的网络协议类型,如ICMP､DNS等｡各协议对应的值如图： 16位首部检验和：用来校验错误，确保封包被正确无误的接收到｡一旦校验出差错消息，由上层去发现丢失的数据报并进行重传｡首部检验和字段是根据IP首部计算的检验和码,不对首部后面的数据进行计算｡ 32位源IP地址：发送IP数据包的IP地址｡ 32位目的IP地址：接收IP数据包的IP地址｡ 32位选项：这两个选项较少使用，只有某些特殊的封包需要特定的控制才会利用到｡这些选项通常包括: 安全和处理限制:用于军事领域 记录路径:让每个路由器都记下它的IP地址 时间戳:让每个路由器都记下它的IP地址和时间 宽松的源站选路:为数据报指定一系列必须经过的IP地址 严格的源站选路:与宽松的源站选路类似,但是要求只能经过指定的这些地址,不能经过其他的地址｡ 以上这些选项很少被使用，而且并非所有的主机和路由器都支持这些选项｡选项字段一直都是以32位作为界限,在必要的时候插入值为0的填充字节｡这样就保证IP首部始终是32位的整数倍(这是首部长度字段所要求的)｡ 数据：用户发送数据。 TCP报文段结构 源端口号：发送方的端口号，范围(0~65535) 目的端口号： 接收者的端口号，范围(0~65535) 序号：如果 TCP 数据太大时(大于 IP 封包的容许程度)， 就得要进行分段。这个序号就是记录每个封包的序号，可以让接收端重新将 TCP 的数据组合起来，序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。简称为seq 确认号：为了确认接收端确实有收到发送端所送出的封包数据，当发送端收到这个确认码时，就能够确定之前传递的封包已经被正确的收下了，这个确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。简称ack 首部长度：表示TCP首部的长度，范围(0~15)，单位32bit，例如值为5时，表示首部长度是20Byte(160bit)，如果选项字段为空，则TCP首部长度为20Byte，即值为5 URG：URG=1时表示存在着紧急数据，紧急是数据的最后一个字节由紧急数据指针指出，一般较少使用 ACK：ACK=1表示确认号字段中的值是有效的，为0表示无效 PSH：当URG＝1时，表明紧急指针字段有效,代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据) RST：RSP=1时重建连接，如果接收到RST位时候，通常发生了某些错误 SYN：SYN=1时，就表示这是一个连接请求或连接接受报文，一般用于握手阶段 FIN：用来释放一个连接，当FIN＝1时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 接收窗口：用于流量控制，指示接收方愿意接收的字节数量，范围0~65535字节。 因特网校验和：检验和覆盖了整个的TCP报文段即TCP首部和TCP数据，这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。 紧急数据指针：当URG=1时有效，是一个正的偏移量，和序号中的值相加表示表示紧急数据最后一个字节的序号。 选项：用于发送方和接收方协商最大报文长度(MSS)时(只存在于SYN报文)或在高速网络环境下用作窗口调节因子时使用，还可存放时间戳数据 数据：报文实体数据 UDP报文段结构 源端口号：发送方的端口号，范围(0~65535) 目的端口号： 接收者的端口号，范围(0~65535) 长度：表示UDP报文段的长度(包括首部和数据) 校验和：接收方用于校验该报文段中是否存在了差错 应用数据：报文实体数据。 TCP和UDP的区别TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。 UDPUDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。 TCPTCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。 TCP与UDP区别总结 TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接 TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付 TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 TCP首部开销20字节;UDP的首部开销小，只有8个字节 TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 TCP的拥塞控制不知读者有无注意，前文中多次提到拥塞一词，那么什么是拥塞呢？ 计算机网络中的带宽、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫做拥塞。 拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。 为了防止网络的拥塞现象，TCP提出了一系列的拥塞控制机制。最初由V. Jacobson在1988年的论文中提出的TCP的拥塞控制由慢启动(Slow Start)和拥塞避免(Congestion Avoidance)组成，后来TCP Reno版本中又针对性的加入了快速重传(Fast Retransmit)、快速恢复(Fast Recovery)算法，再后来在TCP NewReno中又对快速恢复算法进行了改进，近些年又出现了选择性应答(Selective Acknowledgement, SACK)算法，还有其他方面的大大小小的改进，成为网络研究的一个热点。 TCP的拥塞控制主要原理依赖于一个拥塞窗口cwnd（Congestion Window）来控制，TCP还有一个对端通告的接收窗口(Receive Window，rwnd)用于流量控制。窗口值的大小就代表能够发送出去的但还没有收到ACK的最大数据报文段，显然窗口越大那么数据发送的速度也就越快，但是也有越可能使得网络出现拥塞，如果窗口值为1，那么就简化为一个停等协议，每发送一个数据，都要等到对方的确认才能发送第二个数据包，显然数据传输效率低下。TCP的拥塞控制算法就是要在这两者之间权衡，选取最好的cwnd值，从而使得网络吞吐量最大化且不产生拥塞。 由于需要考虑拥塞控制和流量控制两个方面的内容，因此TCP的真正的发送窗口=min(rwnd, cwnd)，接收窗口太小也会成为cwnd的天花板。但是rwnd是由对端确定的，网络环境对其没有影响，所以在考虑拥塞的时候我们一般不考虑rwnd的值，我们暂时只讨论如何确定cwnd值的大小。关于cwnd的单位，在TCP中是以字节来做单位的，我们假设TCP每次传输都是按照MSS大小来发送数据的，因此你可以认为cwnd按照数据包个数来做单位也可以理解，所以有时我们说cwnd增加1也就是相当于字节数增加1个MSS大小。 慢启动与拥塞避免发送方维持一个叫做拥塞窗口cwnd的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。 慢启动Slow Start算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。 这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。如下图： 当然收到单个确认但此确认多个数据报的时候就加相应的数值。所以一次传输轮次之后拥塞窗口就加倍。这就是乘法增长，和后面的拥塞避免算法的加法增长比较。 为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下： 当cwnd &lt; ssthresh时，使用慢开始算法。 当cwnd &gt; ssthresh时，改用拥塞避免算法。 当cwnd = ssthresh时，慢开始与拥塞避免算法任意。 为什么要使用慢启动：最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。 慢启动的过程：当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time, RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。我们可以简单计算下： 开始 -&gt; cwnd = 1 经过1个RTT后 -&gt; cwnd = 2*1 = 2 经过2个RTT后 -&gt; cwnd = 2*2 = 4 类推，如果带宽为W，那么经过RTT*log2W时间就可以占满带宽。 拥塞避免Congestion Avoidance算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。 无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如下图： 再次提醒这里只是为了讨论方便而将拥塞窗口大小的单位改为数据报的个数，实际上应当是字节。 为什么要使用拥塞避免：从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。 拥塞避免的主要步骤： TCP使用了一个叫慢启动门限(ssthresh)的变量，当慢启动的cwnd超过该值，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。 上面讨论的两个机制都是没有检测到拥塞的情况下的行为，那么当发现拥塞了cwnd又该怎样去调整呢？ 快重传和快恢复从整体上来讲，TCP拥塞控制窗口变化的原则是AIMD原则，即加法增大、乘法减小。可以看出TCP的该原则可以较好地保证流之间的公平性，因为一旦出现丢包，那么立即减半退避，可以给其他新建的流留有足够的空间，从而保证整个的公平性。 首先来看TCP是如何确定网络进入了拥塞状态的，TCP认为网络拥塞的一种依据是它重传了一个报文段。上面提到过，TCP对每一个报文段都有一个定时器，称为重传定时器(RTO)，当RTO超时且还没有得到数据确认，那么TCP就会对该报文段进行重传，当发生超时时，那么出现拥塞的可能性就很大，某个报文段可能在网络中某处丢失，并且后续的报文段也没有了消息，在这种RTO超时重传的情况下，TCP反应比较“强烈”（TCP认为发生了严重拥塞）： 把ssthresh降低为cwnd值的一半 把cwnd重新设置为1 重新进入慢启动过程。 TCP确定网络拥塞的另一种依据是发生快速重传：收到3个相同的ACK进入快速重传状态。TCP在收到乱序到达包时就会立即发送ACK，TCP利用3个相同的ACK来判定数据包的丢失，此时进行快速重传，在发生快速重传的情况下，TCP反应比较“温和”（TCP认为还能收到ACK，应该是局部拥塞）： 把ssthresh设置为cwnd的一半 把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3) 重新进入拥塞避免阶段。 快速重传算法首次出现在4.3BSD的Tahoe版本，快速恢复首次出现在4.3BSD的Reno版本，也称之为Reno版的TCP拥塞控制算法。 可以看出Reno的快速重传算法是针对一个包的重传情况的，然而在实际中，一个重传超时可能导致许多的数据包的重传，因此当多个数据包从一个数据窗口中丢失时并且触发快速重传和快速恢复算法时，问题就产生了。因此NewReno出现了，它在Reno快速恢复的基础上稍加了修改，可以恢复一个窗口内多个包丢失的情况。具体来讲就是：Reno在收到一个新的数据的ACK时就退出了快速恢复状态了，而NewReno需要收到该窗口内所有数据包的确认后才会退出快速恢复状态，从而更一步提高吞吐量。 快速重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期（超时等待的效率是最低的）。如下图： 快重传配合使用的还有快恢复（快速恢复Fast Recovery）算法，有以下两个要点: 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。如下图： 后来的“快速恢复”算法是在上述的“快速重传”算法后添加的，当收到3个重复ACK时，TCP最后进入的不是拥塞避免阶段，而是快速恢复阶段。快速重传和快速恢复算法一般同时使用。快速恢复的思想是“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是cwnd加1。如果能够严格按照该原则那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。具体来说快速恢复的主要步骤是： 当收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh+3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。 再收到重复的ACK时，拥塞窗口增加1。 当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。 随机早期检测RED以上的拥塞避免算法并没有和网络层联系起来，实际上网络层的策略对拥塞避免算法影响最大的就是路由器的丢弃策略。在简单的情况下路由器通常按照先进先出的策略处理到来的分组。当路由器的缓存装不下分组的时候就丢弃到来的分组，这叫做尾部丢弃策略。这样就会导致分组丢失，发送方认为网络产生拥塞。更为严重的是网络中存在很多的TCP连接，这些连接中的报文段通常是复用路由路径。若发生路由器的尾部丢弃，可能影响到很多条TCP连接，结果就是这许多的TCP连接在同一时间进入慢开始状态，这在术语中称为全局同步。全局同步会使得网络的通信量突然下降很多，而在网络恢复正常之后，其通信量又突然增大很多。为避免发生网路中的全局同步现象，路由器采用随机早期检测(RED，Random Early Detection)。该算法要点如下： 使路由器的队列维持两个参数，即队列长队最小门限min和最大门限max，每当一个分组到达的时候，RED就计算平均队列长度。然后分情况对待到来的分组： 平均队列长度小于最小门限——把新到达的分组放入队列排队。 平均队列长度在最小门限与最大门限之间——则按照某一概率将分组丢弃。 平均队列长度大于最大门限——丢弃新到达的分组。 RED以概率p随机丢弃分组，让拥塞控制只在个别的TCP连接上执行，因而避免全局性的拥塞控制。 RED的关键就是选择三个参数最小门限、最大门限、丢弃概率和计算平均队列长度。平均队列长度采用加权平均的方法计算平均队列长度，这和往返时间（RTT）的计算策略是一样的。 HTTP中GET与POST的区别标准答案GET和POST是HTTP请求的两种基本方法，你可能自己写过无数个GET和POST请求，所以如果被问到两者之间的区别，相信你能轻轻松松的给出了一个“标准答案”： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 本质区别然而这些其实都是应用上表现出的区别，GET和POST其实本质上没有区别。 那么GET和POST是什么？HTTP协议中的两种发送请求的方法。 HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。 HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 那么，“标准答案”里的那些区别是怎么回事？ 在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？ 在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 总结一下，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 GET和POST区别补充GET和POST还有一个重大区别，GET产生一个TCP数据包；POST产生两个TCP数据包。 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 https为什么安全前文中提到，HTTP协议（HyperText Transfer Protocol），数据以明文传送，不提供任何方式的数据加密，通信双方也没有进行任何认证，通信过程非常容易遭遇劫持、监听、篡改，严重情况下，会造成恶意的流量劫持等问题，甚至造成个人隐私泄露（比如银行卡卡号和密码泄露）等严重的安全问题。 如果把http通信比喻成寄送信件一样，A给B寄信，信件在寄送过程中，会经过很多的邮递员之手，他们可以拆开信读取里面的内容（因为http是明文传输的）。A的信件里面的任何内容（包括各类账号和密码）都会被轻易窃取。除此之外，邮递员们还可以伪造或者修改信件的内容，导致B接收到的信件内容是假的。 https如何保证安全要解决http带来的问题，就要引入加密以及身份验证机制。 如果Server（以后简称服务器）给Client（以后简称 客户端）的消息是密文的，只有服务器和客户端才能读懂，就可以保证数据的保密性。同时，在交换数据之前，验证一下对方的合法身份，就可以保证通信双方的安全。那么，问题来了，服务器把数据加密后，客户端如何读懂这些数据呢？这时服务器必须要把加密的密钥（对称密钥，后面会详细说明）告诉客户端，客户端才能利用对称密钥解开密文的内容。但是，服务器如果将这个对称密钥以明文的方式给客户端，还是会被中间人截获，中间人也会知道对称密钥，依然无法保证通信的保密性。但是，如果服务器以密文的方式将对称密钥发给客户端，客户端又如何解开这个密文，得到其中的对称密钥呢？ 说到这里，大家是不是有点儿糊涂了？一会儿密钥，一会儿对称密钥，都有点儿被搞晕的节奏。在这里提到的密钥，指的是非对称加解密的密钥，是用于TLS握手阶段的； 对称密钥，指的是对称加解密的密钥，是用于后续传输数据加解密的。下面将详细说明。 这时，我们引入了非对称加解密的概念。在非对称加解密算法里，公钥加密的数据，有且只有唯一的私钥才能够解密，所以服务器只要把公钥发给客户端，客户端就可以用这个公钥来加密进行数据传输的对称密钥。客户端利用公钥将对称密钥发给服务器时，即使中间人截取了信息，也无法解密，因为私钥只部署在服务器，其他任何人都没有私钥，因此，只有服务器才能够解密。服务器拿到客户端的信息并用私钥解密之后，就可以拿到加解密数据用的对称密钥，通过这个对称密钥来进行后续通信的数据加解密。除此之外，非对称加密可以很好的管理对称密钥，保证每次数据加密的对称密钥都是不相同的，这样子的话，即使客户端病毒拉取到通信缓存信息，也无法窃取正常通信内容。 上述通信过程，可以画成以下交互图： 但是这样似乎还不够，如果通信过程中，在三次握手或者客户端发起HTTP请求过程中，客户端的请求被中间人劫持，那么中间人就可以伪装成“假冒客户端”和服务器通信；中间人又可以伪装成“假冒服务器”和客户端通信。接下来，我们详细阐述中间人获取对称密钥的过程： 中间人在收到服务器发送给客户端的公钥（这里是“正确的公钥”）后，并没有发给客户端，而是中间人将自己的公钥（这里中间人也会有一对公钥和私钥，这里称呼为“伪造公钥”）发给客户端。之后，客户端把对称密钥用这个“伪造公钥”加密后，发送过程中经过了中间人，中间人就可以用自己的私钥解密数据并拿到对称密钥，此时中间人再把对称密钥用“正确的公钥”加密发回给服务器。此时，客户端、中间人、服务器都拥有了一样的对称密钥，后续客户端和服务器的所有加密数据，中间人都可以通过对称密钥解密出来。 中间人获取对称密钥的过程如下： 为了解决此问题，人们引入了数字证书的概念。服务器首先生成公私钥，将公钥提供给相关机构（CA），CA将公钥放入数字证书并将数字证书颁布给服务器，此时服务器就不是简单的把公钥给客户端，而是给客户端一个数字证书，数字证书中加入了一些数字签名的机制，保证了数字证书一定是服务器给客户端的。中间人发送的伪造证书，不能够获得CA的认证，此时，客户端和服务器就知道通信被劫持了。加入了CA数字签名认证的SSL会话过程如下所示： 所以综合以上三点：非对称加密算法（公钥和私钥）交换对称密钥+数字证书验证身份（验证公钥是否是伪造的）+利用对称密钥加解密后续传输的数据=安全 对称和非对称加密算法前文提到了对称密钥和非对称密钥的概念，这里做一个详细介绍。 对称加密算法对称加密是指：加密和解密使用相同密钥的算法。它要求发送方和接收方在安全通信之前，商定一个对称密钥。对称算法的安全性完全依赖于密钥，密钥泄漏就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。 对称加密又分为两种模式： 流加密：流加密是将消息作为字节流对待，并且使用数学函数分别作用在每一个字节位上。使用流加密时，每加密一次，相同的明文位会转换成不同的密文位。流加密使用了密钥流生成器，它生成的字节流与明文字节流进行异或，从而生成密文。 分组加密：分组加密是将消息划分为若干个分组，这些分组随后会通过数学函数进行处理，每次一个分组。假设使用64位的分组密码，此时如果消息长度为640位，就会被划分成10个64位的分组（如果最后一个分组长度不到64，则用0补齐之后加到64位），每个分组都用一系列数学公式进行处理，最后得到10个加密文本分组。然后，将这条密文消息发送给对端。对端必须拥有相同的分组密码，以相反的顺序对10个密文分组使用前面的算法解密，最终得到明文消息。比较常用的分组加密算法有DES、3DES、AES。其中DES是比较老的加密算法，现在已经被证明不安全。而3DES是一个过渡的加密算法，相当于在DES基础上进行三重运算来提高安全性，但其本质上还是和DES算法一致。而AES是DES算法的替代算法，是现在最安全的对称加密算法之一。 对称加密算法的优缺点： 优点：计算量小、加密速度快、加密效率高。 缺点： 交易双方都使用同样密钥，安全性得不到保证； 每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信息双方所拥有的钥匙数量呈几何级数增长，密钥管理成为负担。 非对称加密算法在非对称密钥交换算法出现以前，对称加密的最主要缺陷就是不知道如何在通信双方之间传输对称密钥，而又不让中间人窃取。非对称密钥交换算法诞生之后，专门针对对称密钥传输做加解密，使得对称密钥的交互传输变得非常安全了。 非对称密钥交换算法本身非常复杂，密钥交换过程涉及到随机数生成，模指数运算，空白补齐，加密，签名等等一系列极其复杂的过程，作者本人也没有研究完全透彻。常见的密钥交换算法有RSA，ECDHE，DH，DHE等算法。涉及到比较复杂的数学问题。其中，最经典也是最常用的是RSA算法。关于RSA算法的原理的介绍，可以参考 RSA算法原理。 RSA：诞生于1977年，经过了长时间的破解测试，算法安全性很高，最重要的是，算法实现非常简单。缺点就是需要比较大的质数（目前常用的是2048位）来保证安全强度，极其消耗CPU运算资源。RSA是目前唯一一个既能用于密钥交换又能用于证书签名的算法，RSA 是最经典，同时也是最常用的是非对称加解密算法。 非对称加密相比对称加密更加安全，但也存在两个致命的缺点： CPU计算资源消耗非常大。一次完全TLS握手，密钥交换时的非对称解密计算量占整个握手过程的90%以上。而对称加密的计算量只相当于非对称加密的0.1%。如果后续的应用层数据传输过程也使用非对称加解密，那么CPU性能开销太庞大，服务器是根本无法承受的。赛门特克给出的实验数据显示，加解密同等数量的文件，非对称算法消耗的CPU资源是对称算法的1000倍以上。 非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是2048位，意味着待加密内容不能超过256个字节。 所以非对称加解密（极端消耗CPU资源）目前只能用来作对称密钥交换或者CA签名，不适合用来做应用层内容传输的加解密。 身份认证https协议中身份认证的部分是由CA数字证书完成的，因此可以说数字证书是网络上的身份证明。 数字证书作用：数字证书有三个作用： 身份授权：确保浏览器访问的网站是经过CA验证的可信任的网站。 分发公钥：每个数字证书都包含了注册者生成的公钥（验证确保是合法的，非伪造的公钥）。在SSL握手时会通过certificate消息传输给客户端。 验证证书合法性：客户端接收到数字证书后，会对证书合法性进行验证。只有验证通过后的证书，才能够进行后续通信过程。 数字证书验证流程CA下发给网站的证书都是一个证书链，也就是一层一层的证书，从根证书开始，到下级CA，一层一层，最后一层就是网站证书。 SSL握手过程中，客户端收到服务器发送的证书后，需要对其签名进行验证，来确认证书是否可信。校验数字签名是使用CA的公钥解密签名，然后使用相同的签名函数对签名证书内容进行签名，并和服务端数字签名里的签名内容进行比较，如果相同就认为校验成功。证书的签名是通过签名算法和上级CA的私钥生成的。而上级CA的公钥来自于证书链该层的上级CA的证书明文内。单个X509v3证书由以下部分组成： X.509v3证书由三部分组成： tbsCertificate (to be signed certificate)，待签名证书。 SignatureAlgorithm，签名算法。 SignatureValue，签名值。 tbsCertificate又包含10项内容，在HTTPS握手过程中以明文方式传输： Version Number，版本号。 Serial Number，序列号。 Signature Algorithm ID，签名算法ID。 Issuer Name，发行者。 Validity period，有效时间。 Subject name ，证书主体名称。 Subject Public Key Info ，证书主体公钥信息，包含公钥算法和公钥值。 Issuer Unique Identifier (optional)，发行商唯一ID。 Subject Unique Identifier (optional)，主体唯一ID。 Extensions (optional)，扩展。 证书链由多个证书一层一层组成的，除了最底层的网站证书的公钥是给用户加密报文外，其他层证书中的公钥均用于解密底层的证书指纹签名。最高层的根证书是自签名的，也就是自己颁发给自己，所以它的公钥不仅用来解密下层的签名，也用来给自己的签名解密。只要根证书可靠，整个证书链就可靠，而根证书是否可靠要看这个根证书是否在操作系统或浏览器内置的可信根证书内，在的话就可信。 参考： OSI七层模型基础知识及各层常见应用 OSI七层模型 URL访问网站的网络传输全过程 详解HTTP/1.0、HTTP/1.1、HTTP/2、HTTPS TCP建立连接三次握手和释放连接四次握手 TCP和UDP的最完整的区别 IP头、TCP头、UDP头详解以及定义 数据包结构与传输详解 99%的人都理解错了HTTP中GET与POST的区别 TCP的拥塞控制 (Tahoe Reno NewReno SACK) HTTPS中的对称密钥加密，公开密钥加密，数字证书","categories":[{"name":"精益求精","slug":"精益求精","permalink":"http://heseng91.github.io/categories/%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE/"}],"tags":[]},{"title":"「精益求精」之多线程","slug":"「精益求精」之多线程","date":"2022-11-02T17:11:24.000Z","updated":"2022-11-02T17:36:25.561Z","comments":true,"path":"2022/11/03/「精益求精」之多线程/","link":"","permalink":"http://heseng91.github.io/2022/11/03/%E3%80%8C%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%E3%80%8D%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"","categories":[{"name":"精益求精","slug":"精益求精","permalink":"http://heseng91.github.io/categories/%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE/"}],"tags":[]},{"title":"「刨根问底」之block","slug":"「刨根问底」之block","date":"2019-02-04T19:42:44.000Z","updated":"2023-02-11T18:12:40.327Z","comments":true,"path":"2019/02/05/「刨根问底」之block/","link":"","permalink":"http://heseng91.github.io/2019/02/05/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8Bblock/","excerpt":"作为一名iOS开发，想必对Blocks都不陌生。Blocks是iOS4引入的C语言的扩充功能。本文将从什么是Blocks、Blocks的使用以及Blocks的实现，3个方面来全面介绍Blocks。","text":"作为一名iOS开发，想必对Blocks都不陌生。Blocks是iOS4引入的C语言的扩充功能。本文将从什么是Blocks、Blocks的使用以及Blocks的实现，3个方面来全面介绍Blocks。 什么是BlocksBlocks是C语言的扩充功能。可以用一句话来表示Blocks的扩充功能：带有自动变量（局部变量）的匿名函数。 顾名思义，所谓匿名函数就是不带有名称的函数。而“带有自动变量值”究竟是什么呢？“带有自动变量值”在Blocks中表现为“截获自动变量值”。截获自动变量值的实例如下： 12345678910111213int main() &#123; int dmy = 256; int val = 10; const char *fmt = \"val = %d\\n\"; void (^blk)(void) = ^&#123;printf(fmt, val);&#125;; val = 2; fmt = \"These values were changed. val = %d\\n\"; b1k(); return 0;&#125; 该源代码中，Block语法的表达式使用的是它之前声明的自动变量fmt和val。Blocks中，Block表达式截获所使用的自动变量的值，即保存该自动变量的瞬间值，因此在执行Block语法后，即使改写Block中使用的自动变量的值也不会影响Block执行时自动变量的值。该源代码就在Block语法后改写了Block中的自动变量val和fmt。下面我们一起看一下执行结果。 1val = 10 执行结果并不是改写后的值“These values were changed. val = 2”，而是执行Block语法时的自动变量的瞬间值。该Block语法在执行时，字符串指针“val=%d\\n”被赋值到自动变量fmt中，int值10被赋值到自动变量val中，因此这些值被保存（即被截获），从而在执行块时使用。 这就是自动变量值的截获。 Blocks的使用Blocks语法下面我们详细讲解一下带有自动变量值的匿名函数Block的语法，即Block表达式语法（Block Literal Syntax）。 以下为Block语法的BN范式(巴科斯-诺尔范式（BNF）)。 1234Block_literal_expression ::= ^ block_decl compound_statement_bodyblock_decl ::=block_decl ::= parameter_listblock_decl ::= type_expression 即使此前不了解BN范式，通过说明也能有个概念。Block语法如下所示。 ^ 返回值类型 参数列表 表达式 “返回值类型”同C语言函数的返回值类型，“参数列表”同C语言函数的参数列表，“表达式”同C语言函数中允许使用的表达式。当然与C语言函数一样，表达式中含有return语句时，其类型必须与返回值类型相同。例如可以写出如下形式的Block语法： 1^int (int count)&#123;retuurn count + 1;&#125; 虽然前面出现过省略方式，但Block语法可省略好几个项目。首先是返回值类型。省略返回值可以写成如下形式： ^ 参数列表 表达式 省略返回值类型时，如果表达式中有return语句就使用该返回值的类型，如果表达式中没有return 语句就使用void类型。表达式中含有多个return语句时，所有return的返回值类型必须相同。前面的源代码省略其返回值类型时如下所示： 1^(int count) &#123;return count + 1;&#125; 该Block语法将按照 return 语句的类型，返回int型返回值。 其次，如果不使用参数，参数列表也可省略。以下为不使用参数的Block语法： 1^void (void) &#123;printf(\"Blocks\\n\");&#125; 该源代码可省略为如下形式： 1^&#123;printf(\"Blocks\\n\");&#125; 返回值类型以及参数列表均被省略的Block语法是大家最为熟知的记述方式吧。如下所示。 ^ 表达式 Block 类型变量上节中讲到的Block 语法单从其记述方式上来看，除了没有名称以及带有“＾”以外，其他都与C语言函数定义相同。在定义C语言函数时，就可以将所定义函数的地址赋值给函数指针类型变量中。 123456int func(int count) &#123; return count + 1;&#125;int (*funcptr)(int)=)=&amp;func 这样一来，函数func的地址就能赋值给函数指针类型变量funcptr中了。 同样地，在Block语法下，可将Block语法赋值给声明为Block类型的变量中。即源代码中一旦使用Block语法就相当于生成了可赋值给Block类型变量的“值”。Blocks中由Block语法生成的值也被称为“Block”。在有关Blocks的文档中，“Block”既指源代码中的Block语法，也指由Block语法所生成的值。 声明Block类型变量的示例如下： 1int (^blk)(int); 与前面的使用函数指针的源代码对比可知，声明Block类型变量仅仅是将声明函数指针类型变量的“＊”变为“＾”。该Block类型变量与一般的C语言变量完全相同，可作为以下用途使用。 自动变量 函数参数 静态变量 静态全局变量 全局变量 当使用Block时，如果需要在多个地方使用或者记述方式比较复杂，可以使用typedef来优化： 1typedef int (^blk_t)(int); 优化后，使用示例代码如下： 123typedef int (^blk_t)(int);blk_t blk = ^(int count)&#123;return count + 1;&#125;; __block说明符前面说过，自动变量值截获只能保存执行Block语法瞬间的值。保存后就不能改写该值。下面我们来尝试改写截获的自动变量值，看看会出现什么结果。下面的源代码中，Block语法之前声明的自动变量val的值被赋予1。 1234int val &#x3D; 0;void (^blk)(void) &#x3D; ^&#123;val &#x3D; 1;&#125;;blk();printf(&quot;val &#x3D; %d\\n&quot;, val); 以上为在Block语法外声明的给自动变量赋值的源代码。该源代码会产生编译错误。 error: variable is not assignable (missing __block type specifier)若想在Block语法的表达式中将值赋给在Block语法外声明的自动变量，需要在该自动变量上附加__block说明符。该源代码中，如果给自动变量声明int val附加__block说明符，就能实现在Block内赋值。 1234__block int va l= 0;void (^blk)(void) = ^&#123;val = 1;&#125;;blk();printf(\"val = %d\\n\", val); 该源代码的执行结果为： 1val = 1 使用附有__block说明符的自动变量可在Block中赋值，该变量称为＿block变量。 Blocks的实现Block的实质Block是“带有自动变量值的匿名函数”，但Block究竟是什么呢？本节将通过Block的实现进一步帮大家加深理解。 前几节讲的Block语法看上去好像很特别，但它实际上是作为普通的C语言源代码来处理的。通过支持Block的编译器，含有Block语法的源代码转换为一般C语言编译器能够处理的源代码，并作为极为普通的C语言源代码被编译。下面就让我们结合通过clang被转换后的源代码来一窥Block的实现。 新建一个 Command Line Tool 工程，main.m的代码修改为如下代码： 1234567#import &lt;Foundation&#x2F;Foundation.h&gt;int main() &#123; void (^blk)(void) &#x3D; ^&#123; printf(&quot;Hello, World!&quot;); &#125;; blk(); return 0;&#125; 打开“终端”，cd到工程目录中main.m所在文件夹，然后输入如下命令行： 1clang -rewrite-objc main.m 就会在main.m所在文件夹生成一个main.cpp文件，在文件中能找到源代码通过clang被转换为如下内容： 123456789101112131415161718192021222324252627282930313233343536/* ... */#ifndef BLOCK_IMPL#define BLOCK_IMPLstruct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;/* ... */struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; printf(\"Hello, World!\"); &#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main() &#123; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 0;&#125;/* ... */ 下面，我们将源代码分成几个部分逐步理解。首先来看最初的源代码中的Block语法。 1^&#123; printf(\"Hello, World!\"); &#125;; 可以看到，变换后的源代码中也含有相同的表达式。 12static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; printf(\"Hello, World!\"); &#125; 如变换后的源代码所示，通过Blocks使用的匿名函数实际上被作为简单的C语言函数来处理。另外，根据Block语法所属的函数名（此处为main）和该Block语法在该函数出现的顺序值（此处为0）来给经clang变换的函数命名。 该函数的参数＿cself相当于C＋＋实例方法中指向实例自身的变量this，或是Objective-C实例方法中指向对象自身的变量self，即参数＿cself为指向Block值的变量。该参数的声明如下： 1struct __main_block_impl_0 *__cself 参数__cself是__main_block_impl_0结构体的指针。该结构体声明如下： 1234struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc;&#125;; 由于转换后的源代码中，也一并写入了其构造函数，所以看起来稍显复杂，如果除去该构造函数，__main_block_impl_0结构体会变得非常简单。第一个成员变量是impl，我们先来看一下其__block_impl结构体的声明。 123456struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;; 我们从其名称可以联想到某些标志、今后版本升级所需的区域以及函数指针。这些会在后面详细说明。第二个成员变量是Desc指针，以下为其__main_block_desc_0结构体的声明： 1234static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; 这些也如同其成员名称所示，其结构为今后版本升级所需的区域和Block的大小。 那么，下面我们来看看初始化含有这些结构体的__main_block_impl_0结构体的构造函数。 123456__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125; 以上就是初始化__main_block_impl_0结构体成员的源代码。我们刚刚跳过了NSConcreteStackBlock的说明。_NSConcreteStackBlock用于初始化__block_impl结构体的isa成员。虽然大家很想了解它，但在进行讲解之前，我们先来看看该构造函数的调用。 1void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); 因为转换较多，看起来不是很清楚，所以我们去掉转换的部分，具体如下： 12struct __main_block_impl_0 tmp = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);struct __main_block_impl_0 blk = &amp;tmp; 这样就容易理解了。该源代码将__main_block_impl_0结构体类型的自动变量，即栈上生成的__main_block_impl_0结构体实例的指针，赋值给__main_block_impl_0结构体指针类型的变量blk。以下为这部分代码对应的最初源代码。 1void (^blk)(void) &#x3D; ^&#123; printf(&quot;Hello, World!&quot;); &#125;; 将Block语法生成的Block 赋给Block类型变量blk。它等同于将__main_block_impl_0结构体实例的指针赋给变量blk。该源代码中的Block就是__main_block_impl_0结构体类型的自动变量，即栈上生成的__main_block_impl_0结构体实例。 下面就来看看__main_block_impl_0结构体实例构造参数。 1__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA)); 第一个参数是由Block语法转换的C语言函数指针。第二个参数是作为静态全局变量初始化的__main_block_desc_0结构体实例指针。以下为__main_block_desc_0结构体实例的初始化部分代码。 1static struct __main_block_desc_0 __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;; 由此可知，该源代码使用Block，即__main_block_impl_0结构体实例的大小，进行初始化。 下面看看栈上的__main_block_impl_0结构体实例（即Block）是如何根据这些参数进行初始化的。如果展开__main_block_impl_0结构体的__block_impl结构体，可记述为如下形式： 1234567struct __main_block_impl_0 &#123; void *isa; int Flags; int Reserved; void *FuncPtr; struct __main_block_desc_0* Desc;&#125;; 该结构体根据构造函数会像下面这样进行初始化。 12345isa = &amp;_NSConcreteStackBlock;Flags = 0;Reserved = 0;FuncPtr = __main_block_func_0;Desc = &amp;__main_block_desc_0_DATA; 可以看到将__main_block_func_0函数指针被赋给了成员变量FuncPtr。 接下来我们来看看使用该Block的部分。 1blk(); 这部分可变换为以下源代码： 1((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); 去掉转换部分： 1(*blk-&gt;impl.FuncPtr)(blk); 这就是简单地使用函数指针调用函数。正如我们刚才所确认的，由Block语法转换的__main_block_func_0函数的指针被赋值成员变量FuncPtr中。另外也说明了，__main_block_func_0函数的参数＿cself指向Block值。在调用该函数的源代码中可以看出Block正是作为参数进行了传递。 到此总算摸清了Block的实质，不过刚才跳过没有说明的＿NSConcreteStackBlock到底是什么呢？ 1isa = &amp;_NSConcreteStackBlock; 将Block指针赋给Block的结构体成员变量isa。为了理解它，首先要理解Objective-C类和对象的实质。即_NSConcreteStackBlock相当于isa_t结构体实例。在将Block作为Objective-C的对象处理时，关于该类的信息放置于_NSConcreteStackBlock中。 可见，所谓Block就是Objective-C对象。 截获自动变量值现在把main.m中的代码修改成如下： 123456789101112#import &lt;Foundation&#x2F;Foundation.h&gt;int main() &#123; int dmy &#x3D; 256; int val &#x3D; 10; const char *fmt &#x3D; &quot;val &#x3D; %d\\n&quot;; void (^blk)(void) &#x3D; ^&#123;printf(fmt, val);&#125;; blk(); return 0;&#125; clang之后，代码被转换成： 12345678910111213141516171819202122232425262728293031struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; const char *fmt; int val; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, const char *_fmt, int _val, int flags=0) : fmt(_fmt), val(_val) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; const char *fmt = __cself-&gt;fmt; // bound by copy int val = __cself-&gt;val; // bound by copyprintf(fmt, val);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main() &#123; int dmy = 256; int val = 10; const char *fmt = \"val = %d\\n\"; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val)); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 0;&#125; 这与前面转换的源代码稍有差异。下面来看看其中的不同之处。首先我们注意到，Block语法表达式中使用的自动变量被作为成员变量追加到了__main_block_impl_0结构体中。 123456struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; const char *fmt; int val;&#125;; __main_block_impl_0结构体内声明的成员变量类型与自动变量类型完全相同。请注意，Block语法表达式中没有使用的自动变量不会被追加，如此源代码中的变量dmy。Blocks的自动变量截获只针对Block中使用的自动变量。下面来看看初始化该结构体实例的构造函数的差异。 1__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, const char *_fmt, int _val, int flags=0) : fmt(_fmt), val(_val) &#123; 在初始化结构体实例时，根据传递给构造函数的参数对由自动变量追加的成员变量进行初始化。以下通过构造函数调用确认其参数。 1void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val)); 使用执行Block语法时的自动变量fmt和val来初始化__main_block_impl_0结构体实例。即在该源代码中，__main_block_impl_0结构体实例的初始化如下： 123456impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = __main_block_func_0;Desc = &amp;__main_block_desc_0_DATA;fmt = \"val = %d\\n\";val = 10; 由此可知，在__main_block_impl_0结构体实例（即Block）中，自动变量值被截获。下面再来看一下使用Block的匿名函数的实现。最初源代码的Block语法如下所示： 1^&#123;printf(fmt, val);&#125;; 该源代码可转换为以下函数： 1234static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; const char *fmt = __cself-&gt;fmt; // bound by copy int val = __cself-&gt;val; // bound by copyprintf(fmt, val);&#125; 在转换后的源代码中，截获到__main_block_impl_0结构体实例的成员变量上的自动变量，这些变量在Block语法表达式之前被声明定义。因此，原来的源代码表达式无需改动便可使用截获的自动变量值执行。 总的来说，所谓“截获自动变量值”意味着在执行Block 语法时，Block语法表达式所使用的自动变量值被保存到Block的结构体实例（即Block自身）中。 __block说明符前文已经介绍，Block中所使用的被截获自动变量就如“带有自动变量值的匿名函数”所说，仅截获自动变量的值。Block中使用自动变量后，在Block的结构体实例中重写该自动变量也不会改变原先截获的自动变量。如果试图改变Block中的自动变量值会编译报错。这样一来就无法在Block中保存值了，极为不便。解决这个问题可以通过使用“__block说明符”。更准确的表述方式为“＿block存储域类说明符”（＿block storage-class-specifier）。 __block说明符类似于static、auto和register说明符，它们用于指定将变量值设置到哪个存储域中。例如，auto表示作为自动变量存储在栈中，static表示作为静态变量存储在数据区中。 下面我们来实际使用＿block说明符，用它来指定Block中想变更值的自动变量。我们在前面编译错误的源代码的自动变量声明上追加＿block说明符。main.m中代码修改为： 12345678910#import &lt;Foundation&#x2F;Foundation.h&gt;int main() &#123; __block int val &#x3D; 10; void (^blk)(void) &#x3D; ^&#123;val &#x3D; 1;&#125;; blk(); printf(&quot;val &#x3D; %d\\n&quot;, val); return 0;&#125; 该源代码可进行编译。变换后如下： 12345678910111213141516171819202122232425262728293031323334353637383940struct __Block_byref_val_0 &#123; void *__isa;__Block_byref_val_0 *__forwarding; int __flags; int __size; int val;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_val_0 *val; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags=0) : val(_val-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref(val-&gt;__forwarding-&gt;val) = 1;&#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;val, (void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main() &#123; __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 10&#125;; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, 570425344)); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); printf(\"val = %d\\n\", (val.__forwarding-&gt;val)); return 0;&#125; 只是在自动变量上附加了block说明符，源代码量就急剧增加。 1__block int val &#x3D; 0; 这个＿block变量val是怎样转换过来的呢？ 1234567__Block_byref_val_0 val = &#123; (void*)0, (__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 10&#125;; 我们发现，它竟然变为了结构体实例。block变量也同Block一样变成__Block_byref_val_0结构体类型的自动变量，即栈上生成的__Block_byref_val_0结构体实例。该变量初始化为10，且这个值也出现在结构体实例的初始化中，这意味着该结构体持有相当于原自动变量的成员变量。该结构体声明如下： 1234567struct __Block_byref_val_0 &#123; void *__isa;__Block_byref_val_0 *__forwarding; int __flags; int __size; int val;&#125;; 如同初始化时的源代码，该结构体中最后的成员变量val是相当于原自动变量的成员变量，我们从它的名称也能看出来这一点。 下面这段给＿block变量赋值的代码又如何呢？ 1^&#123;val &#x3D; 1;&#125;; 该源代码转换如下： 123static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref(val-&gt;__forwarding-&gt;val) = 1;&#125; Block的__main_block_impl_0结构体实例持有指向＿block变量的__Block_byref_val_0结构体实例的指针。__Block_byref_val_0结构体实例的成员变量__forwarding持有指向该实例自身的指针。通过成员变量__forwarding访问成员变量val。（成员变量val是该实例自身持有的变量，它相当于原自动变量。）如下图所示。 另外，block变量的__Block_byref_val_0结构体并不在Block用__main_block_impl_0结构体中，这样做是为了在多个Block中使用＿block变量。我们看一下下面的源代码。 123__block int val&#x3D; 10;void (^blk0)(void) &#x3D;^&#123;val &#x3D; 0;&#125;;void (^blk1)(void) )&#x3D;^&#123;val &#x3D; 1;&#125;; Block类型变量blk0和blk1访问＿block变量val。我们把这两部分源代码的转换结果摘录出来。 12345__Block_byref_val_0 val = &#123;(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 10&#125;;blk0 = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;val, 570425344));blk1 = &amp;__main_block_impl_1(__main_block_func_1, &amp;__main_block_desc_1_DATA, &amp;val, 570425344)); 两个Block都使用了__Block_byref_val_0结构体实例val的指针。这样一来就可以从多个Block 中使用同一个＿block变量。当然，反过来从一个Block中使用多个＿block变量也是可以的。只要增加Block的结构体成员变量与构造函数的参数，便可对应使用多个＿block变量。 读到这里，读者可能会有疑问： Block中有无法保存值的问题，那么针对自动变量，如果将局部变量的指针传递给__main_block_impl_0中保存起来，后续通过指针修改值是否可行呢？ __Block_byref_val_0结构体中为何会有成员变量__forwarding呢，__main_block_func_0中修改val值时为何要通过__forwarding来访问呢？ 这两个问题都将在下节中进行说明。 Block 存储域通过前面说明可知，Block转换为Block的结构体类型的自动变量，block变量转换为block变量的结构体类型的自动变量。所谓结构体类型的自动变量，即栈上生成的该结构体的实例。如下表所示。 名称 实质 Block 栈上 Block的结构体实例 __block变量 栈上 __block变量的结构体实例 另外，通过之前的说明可知Block也是Objective-C对象。将Block当作Objective-C对象来看时，该Block的类为＿NSConcreteStackBlock。虽然该类并没有出现在已变换源代码中，但有很多与之类似的类，如： _NSConcreteStackBlock（该类的对象Block设置在栈上） _NSConcreteGlobalBlock（类对象设置在程序的数据区域（.data区）中） _NSConcreteMallocBlock（类对象则设置在由malloc函数分配的内存块（即堆）中） 如下图所示： 到现在为止出现的Block例子使用的都是＿NSConcreteStackBlock类，且都设置在栈上。但实际上并非全是这样，以下两种情况生成的Block为_NSConcreteGlobalBlock类对象： 在记述全局变量的地方使用Block语法时，生成的Block为_NSConcreteGlobalBlock类对象； 即使在函数内而不在记述广域变量的地方使用Block语法时，只要Block语法的表达式中不使用应截获的自动变量，就会生成的Block为_NSConcreteGlobalBlock类对象 在以上这些情况下，Block为＿NSConcreteGlobalBlock类对象。即 Block配置在程序的数据区域中。除此之外的Block语法生成的Block为＿NSConcreteStackBlock类对象，且设置在栈上。 那么将Block配置在堆上的＿NSConcreteMallocBlock类在何时使用呢？ 配置在全局变量上的Block，从变量作用域外也可以通过指针安全地使用。但设置在栈上的Block，如果其所属的变量作用域结束，该Block就被废弃。由于＿block变量也配置在栈上，同样地，如果其所属的变量作用域结束，则该＿block变量也会被废弃。如下图所示。 Blocks提供了将Block和block变量从栈上复制到堆上的方法来解决这个问题。将配置在栈上的Block复制到堆上，这样即使Block语法记述的变量作用域结束，堆上的Block还可以继续存在。如下图所示。 复制到堆上的Block将＿NSConcreteMallocBlock类对象写入Block用结构体实例的成员变量isa。 1impl.isa = &amp;_NSConcreteMallocBlock; 而block变量用结构体成员变量＿forwarding可以实现无论＿block变量配置在栈上还是堆上时都能够正确地访问＿block变量。具体做法就是，在＿block变量配置在堆上的状态下，将栈上的结构体实例成员变量＿forwarding指向堆上的结构体实例，那么不管是从栈上的＿block变量还是从堆上的＿block变量都能够正确访问。 这里就解答了前面提到的「__Block_byref_val_0结构体中为何会有成员变量__forwarding呢，__main_block_func_0中修改val值时为何要通过__forwarding来访问呢？」问题 那么Blocks提供的复制方法究竟是什么呢？实际上当ARC有效时，大多数情形下编译器会恰当地进行判断，自动生成将Block从栈上复制到堆上的代码。我们来看一下下面这个返回Block的函数。 12345typedef int (^blk_t)(int);blk_t func(int rate)&#123; return ^(int count)&#123;return rate * count;&#125;;&#125; 该源代码为返回配置在栈上的Block的函数。即程序执行中从该函数返回函数调用方时变量作用域结束，因此栈上的Block也被废弃。虽然有这样的问题，但该源代码通过对应ARC的编译器可转换如下： 1234567blk_t func(int rate)&#123; blk_t tmp = &amp; __func_block_impl_0( func_block_func_0, &amp;__func_block_desc_0_DATA, rate); tmp = objc_retainBlock(tmp); return objc_autoreleaseReturnValue(tmp);&#125; 在objc4-756.2中的NSObject.mm中，可以看到objc_retainBlock实现如下： 123id objc_retainBlock(id x) &#123; return (id)_Block_copy(x);&#125; 可以看到，objc_retainBlock函数实际是调用了_Block_copy函数，_Block_copy函数的作用就是将栈上的Block复制到堆上。 除了这里说的，将Block作为函数返回值返回时，编译器会自动生成复制到堆上的代码之外，如下场景编译器会自动生成复制到堆上的代码： Cocoa框架的方法且方法名中含有usingBlock等时 Grand Central Dispatch 的 API 将Block赋值给附有＿strong修饰符id类型的类或Block类型成员变量时 在此之外的场景，都需要手动调用copy方法，将Block从栈上复制到堆上。既然Block调用copy方法，作用是将Block从栈上复制到堆上。总结一下如下场景，栈上的Block会被复制到堆： 调用Block的copy实例方法时 Block作为函数返回值返回时 将Block赋值给附有__strong 修饰符id类型的类或Block类型成员变量时 在方法名中含有usingBlock的Cocoa框架方法或Grand Central Dispatch的API中传递Block 时 那么，对于已配置在堆上的Block以及配置在程序的数据区域上的Block，调用copy方法又会如何呢？按配置Block的存储域，copy方法进行复制的动作的效果如下： Block的类 副本源的配置存储域 复制效果 _NSConcreteStackBlock 栈 从栈复制到堆 _NSConcreteGlobalBlock 程序的数据区域 什么也不做 _NSConcreteMallocBlock 堆 引用计数增加 不管Block配置在何处，用copy方法复制都不会引起任何问题。在不确定时调用copy方法即可。 这里Block 存储域已经描述完了，最后再解答一下前面遗留的疑问。 Q: Block中有无法保存值的问题，那么针对自动变量，如果将局部变量的指针传递给__main_block_impl_0中保存起来，后续通过指针修改值是否可行呢？ A: 因为可以通过将Block从栈上复制到堆上，使Block超出变量作用域而存在，但是变量作用域结束的时候，原来的自动变量被废弃了，因此也不能通过指针访问原来的自动变量。 __block变量存储域上节只对Block进行了说明，那么对block变量又是如何处理的呢？使用＿block变量的Block 从栈复制到堆上时，＿block变量也会受到如下影响： __block变量的配置存储域 Block从栈复制到堆时的影响 栈 从栈复制到堆并被Block持有 堆 被Block持有 若一个Block中使用了＿block变量，则当该Block从栈复制到堆时，使用的所有__block变量也必定配置在栈上。这些＿block变量也全部被从栈复制到堆。如果还有其它Block中也使用了＿block变量，当其它Block从栈复制到堆时，此时堆上已经有了＿block变量，被复制的Block持有＿block变量，并增加＿block变量的引用计数。如果配置在堆上的Block被废弃，那么它所使用的＿block变量也就被释放。到这里我们可以看出，此思考方式与Objective-C的引用计数式内存管理完全相同。使用block变量的Block持有＿block变量。如果Block被废弃，它所持有的＿block变量也就被释放。 在理解了＿block变量的存储域之后，我们再回顾一下前面讲过的使用＿block变量用结构体成员变量__forwarding的原因。“无论＿block变量配置在栈上还是堆上时都能够正确地访问＿block变量”。正如这句话所述，通过Block的复制，__block变量也从栈复制到堆。此时可同时访问栈上的＿block变量和堆上的＿block变量。源代码如下： 12345__block int val &#x3D; 0;void (^blk)(void) &#x3D; [^&#123;++val;&#125; copy];++val;blk();printf(&quot;val &#x3D; %d\\n&quot;, val); 忽略部分逻辑，转换后的val相关代码如下： 1234567891011121314151617/* ... */static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref++(val-&gt;__forwarding-&gt;val);&#125;/* ... */int main() &#123; __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 10&#125;; void (*blk)(void) = (void (*)())((id (*)(id, SEL))(void *)objc_msgSend)((id)((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, 570425344)), sel_registerName(\"copy\")); ++(val.__forwarding-&gt;val); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); printf(\"val = %d\\n\", (val.__forwarding-&gt;val)); return 0;&#125; 可以看到不论Block中还是Block外val相关取值都被转换成了val.__forwarding-&gt;val。Block中变量val为复制到堆上的＿block变量用结构体实例，而Block外的变量val，为复制前栈上的＿block变量用结构体实例。 但是栈上的＿block变量用结构体实例在＿block变量从栈复制到堆上时，会将成员变量__forwarding的值替换为复制目标堆上的__block变量用结构体实例的地址。如下图所示： 通过该功能，无论是在Block语法中、Block语法外使用＿block变量，还是＿block变量配置在栈上或堆上，都可以顺利地访问同一个＿block变量。 截获变量以下源代码生成并持有NSMutableArray类的对象，由于附有＿strong修饰符的赋值目标变量的作用域立即结束，因此对象被立即释放并废弃。 1id array &#x3D; [[NSMutableArray alloc] init]; 我们来看一下在Block语法中使用该变量array的代码： 12345678910111213blk_t blk;&#123; id array &#x3D; [[NSMutableArray alloc] init]; blk &#x3D;[^(id obj)&#123; [array addObject:obj]; NSLog(@&quot;array count &#x3D; %zd&quot;, [array count]); &#125; copy];&#125;blk([[NSObject alloc] init]);blk([[NSObject alloc] init]);blk([[NSObject alloc] init]); 变量作用域结束的同时，变量array被废弃，其强引用失效，因此赋值给变量array的NSMutableArray类的对象必定被释放并废弃。但是该源代码运行正常，其执行结果如下： 123array count-1array count&#x3D;2array count-3 这一结果意味着赋值给变量array的NSMutableArray类的对象在该源代码最后Block的执行部分超出其变量作用域而存在。通过编译器转换后的源代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*Block用结构体／函数部分*/struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; id array; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id _array, int flags=0) : array(_array) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) &#123; id array = __cself-&gt;array; // bound by copy ((void (*)(id, SEL, ObjectType _Nonnull))(void *)objc_msgSend)((id)array, sel_registerName(\"addObject:\"), (id)obj); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_0b_z9zhp5nd1m31p32z0jbmyfhm0000gn_T_main_b157cd_mi_0, ((NSUInteger (*)(id, SEL))(void *)objc_msgSend)((id)array, sel_registerName(\"count\"))); &#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;array, (void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main() &#123; /* Block语法，使用Block部分 */ blk_t blk; &#123; id array = ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")); blk =(blk_t)((id (*)(id, SEL))(void *)objc_msgSend)((id)((void (*)(id))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, array, 570425344)), sel_registerName(\"copy\")); &#125; ((void (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"alloc\")), sel_registerName(\"init\"))); ((void (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"alloc\")), sel_registerName(\"init\"))); ((void (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"alloc\")), sel_registerName(\"init\"))); return 0;&#125; 请注意被赋值NSMutableArray类对象并被截获的自动变量array。我们可以发现它是Block用的结构体中附有＿strong修饰符的成员变量（因为id类型和对象类型的所有权修饰符默认为__strong修饰符，所以不需要写上__strong）。 12345struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; id array;&#125;; 在Objective-C中，C语言结构体不能含有附有＿strong修饰符的变量。因为编译器不知道应何时进行C语言结构体的初始化和废弃操作，不能很好地管理内存。 但是Objective-C的运行时库能够准确把握Block从栈复制到堆以及堆上的Block被废弃的时机，因此Block用结构体中即使含有附有＿strong修饰符或＿weak修饰符的变量，也可以恰当地进行初始化和废弃。为此需要使用在__main_block_desc_0结构体中增加的成员变量copy和dispose，以及作为指针赋值给该成员变量的__main_block_copy_0函数和__main_block_dispose_0函数。 由于在该源代码的Block用结构体中，含有附有＿strong修饰符的对象类型变量array，所以需要恰当管理赋值给变量array的对象。因此__main_block_copy_0函数使用_Block_object_assign 函数将对象类型对象赋值给Block用结构体的成员变量array中并持有该对象。 1static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;array, (void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125; _Block_object_assign函数调用相当于retain实例方法的函数，将对象赋值在对象类型的结构体成员变量中。 另外，__main_block_dispose_0函数使用_Block_object_dispose函数，释放赋值在Block用结构体成员变量array中的对象。 1static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125; __main_block_dispose_0函数调用相当于release实例方法的函数，释放赋值在对象类型的结构体成员变量中的对象。 虽然此__main_block_copy_0函数（以下简称copy函数）和__main_block_dispose_0函数（以下简称dispose函数）指针被赋值在__main_block_desc_0结构体成员变量copy和dispose中，但在转换后的源代码中，这些函数包括使用指针全都没有被调用。那么这些函数是从哪调用呢？ 在Block从栈复制到堆时以及堆上的Block被废弃时会调用这些函数。整理见下表看看： 函数 调用时机 copy函数 栈上的Block复制到堆时 dispose 函数 堆上的Block被废弃时 那么什么时候栈上的Block会复制到堆呢？ 调用Block的copy实例方法时 Block作为函数返回值返回时 将Block赋值给附有strong 修饰符id类型的类或Block类型成员变量时 在方法名中含有usingBlock的Cocoa框架方法或Grand Central Dispatch的API中传递Block时 在调用Block的copy实例方法时，如果Block配置在栈上，那么该Block会从栈复制到堆。Block作为函数返回值返回时、将Block赋值给附有strong修饰符id类型的类或Block类型成员变量时，编译器自动地将对象的Block作为参数并调用_Block_copy函数，这与调用Block的copy实例方法的效果相同。在方法名中含有usingBlock的Cocoa框架方法或Grand CentralDispatch的API中传递Block时，在该方法或函数内部对传递过来的Block调用Block的copy实例方法或者_Block_copy函数。 也就是说，虽然从源代码来看，在上面这些情况下栈上的Block被复制到堆上，但其实可归结为_Block_copy 函数被调用时Block从栈复制到堆。 相对的，在释放复制到堆上的Block后，谁都不持有Block而使其被废弃时调用dispose函数。这相当于对象的dealloc实例方法。 有了这种构造，通过使用附有＿strong修饰符的自动变量，Block中截获的对象就能够超出其变量作用域而存在。 虽然这种使用copy函数和dispose函数的方法在介绍__block说明符时没做任何说明，但实际上在使用__block变量时已经用到了。 123static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;val, (void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);&#125; 转换后的源代码在Block用结构体的部分基本相同，不同之处见下表： 对象 __block 变量 BLOCK_FIELD_IS_OBJECT BLOCK_FIELD_IS_BYREF 通过BLOCK_FIELD_IS_OBJECT 和 BLOCK_FIELD_IS_BYREF参数，区分copy函数和dispose函数的对象类型是对象还是__block变量。 但是与copy函数持有截获的对象、dispose函数释放截获的对象相同，copy函数持有所使用的＿block变量，dispose函数释放所使用的＿block变量。 由此可知，Block中使用的赋值给附有strong修饰符的自动变量的对象和复制到堆上的block变量由于被堆上的Block所持有，因而可超出其变量作用域而存在。 Block 循环引用如果在Block中使用附有__strong 修饰符的对象类型自动变量，那么当Block从栈复制到堆时，该对象为Block所持有。这样容易引起循环引用。我们来看看下面的源代码： 123456789101112131415161718192021222324252627typedef void (^blk_t)(void);@interface MyObject: NSObject&#123; blk_t blk;&#125;@end@implementation MyObject- (id)init&#123; self &#x3D; [super init]; blk &#x3D; ^&#123;NSLog(@&quot;self &#x3D; %@&quot;,self);&#125;; return self;&#125;- (void)dealloc&#123; NSLog(@&quot;dealloc&quot;);&#125;@end int main()&#123; id o &#x3D; [[MyObject alloc] init]; NSLog(@&quot;%@&quot;,o); return 0;&#125; 该源代码中 MyObject类的dealloc实例方法一定没有被调用。 MyObject类对象的Block类型成员变量blk持有赋值为Block的强引用。即MyObject类对象持有Block。init实例方法中执行的Block语法使用附有__strong 修饰符的id类型变量self。并且由于Block语法赋值在了成员变量blk中，因此通过Block语法生成在栈上的Block此时由栈复制到堆，并持有所使用的self。self持有Block，Block 持有self。这正是循环引用。如下图所示。 为避免此循环引用，可声明附有＿weak修饰符的变量，并将self赋值使用。 1234567-(id)init&#123; self &#x3D; [super init]; id __weak tmp &#x3D; self; blk &#x3D; ^&#123;NSLog(@&quot;self &#x3D; %@&quot;,tmp);&#125;; return self;&#125; 另外，还可以使用 block变量来避免循环引用。 12345678910111213141516171819202122232425262728293031323334typedef void (^blk_t)(void);@interface MyObject: NSObject&#123; blk_t blk;&#125;@end@implementation MyObject- (id)init&#123; self &#x3D; [super init]; __block id tmp &#x3D; self; blk &#x3D; ^&#123; NSLog(@&quot;self &#x3D; %@&quot;,tmp); tmp &#x3D; nil; &#125;; return self;&#125;- (void)execBlock &#123; blk();&#125;- (void)dealloc&#123; NSLog(@&quot;dealloc&quot;);&#125;@end int main()&#123; id o &#x3D; [[MyObject alloc] init]; [o execBlock]; return 0;&#125; 该源代码没有引起循环引用。但是如果不调用execBlock实例方法，即不执行赋值给成员变量blk的Block，便会循环引用并引起内存泄漏。在生成并持有MyObject类对象的状态下会引起以下循环引用，如下图所示。 MyObject类对象持有Block Block 持有__block变量 __block变量持有MyObject类对象 如果不执行execBlock实例方法，就会持续该循环引用从而造成内存泄漏。 通过执行execBlock实例方法，Block被实行，nil被赋值在__block变量tmp中。 1234blk &#x3D; ^&#123; NSLog(@&quot;self &#x3D; %@&quot;,tmp); tmp &#x3D; nil;&#125;; 因此，__block变量tmp对MyObject类对象的强引用失效。避免循环引用的过程如下所示： MyObject类对象持有Block Block持有＿block变量 使用＿block变量的优点如下： 通过＿block变量可控制对象的持有期间 在不能使用weak修饰符的环境中不使用＿unsafe＿unretained 修饰符即可（不必担心悬垂指针） 在执行Block时可动态地决定是否将nil或其他对象赋值在＿block变量中。 使用＿block变量的缺点如下： ·为避免循环引用必须执行 Block 存在执行了Block语法，却不执行Block的路径时，无法避免循环引用。 拓展：开发选择Blocks还是Delegatesblocks 和 delegates，都能实现回调。那么开发中，我们要如何选择使用哪种呢？ 通过研究Apple分别是在什么情况下使用delegate和block，就可以构建出Apple选择的规则。要找出Apple使用delegate的场景很简单，我们只要搜索官方文档中的“delegate”，就会获取到很多使用delegation的类。而当Apple的方法使用block，这个方法将会有“Handler”,“Completion”或者简单的“Block”作为selector;因此我们可以在标准的iOS API文档中搜索这些关键词，用以构建一个可信任的block用例列表。 总结一下，主要有以下几条规则。 大多数delegate protocols 都拥有几个消息源以GKMatch为例(A GKMatch object provides a peer-to-peer network between a group of devices that are connected to Game Center，是iOS API中用来提供一组设备连接到Game Center点对点网络的对象)。从这个类中可以看到消息的来源分别是：当从其他玩家那接收到数据、当玩家切换了状态、当发生错误或者当一个玩家应该被重新邀请。这些都是不同的事件。如果Apple在这里使用block，那么可能会有以下两种解决方式： 可以对应每一个事件注册相应的block，显然这种方式是不合理的。（ If someone writes a class that does this in Objective-C, they are probably an asshole.） 创建一个可以接受任何可能输入的block 1void?(^matchBlock)(GKMatchEvent?eventType,?Player?*player,?NSData?*data,?NSError?*err); 很明显这种方式既不简便又不易读，所以你可能从未看过这样的解决方案。如果你看过这样的解决方式，但是这显然是一个糟糕至极的代码行，你不会有精力去维护这个。 因此，我们可以得出一个结论：如果对象有超过一个以上不同的事件源，使用delegation。 一个对象只能有一个delegate由于一个对象只能有一个delegate，而且它只能与这个delegate通信。让我们看看CLLocationManager 这个类，当发现地理位置后，location manager 只会通知一个对象（有且只有一个）。当然，如果我们需要更多的对象去知道这个更新，我们最好创建其他的location manager。 这里有的人可能想到，如果CLLocationManager是个单例呢？如果我们不能创建CLLocationManager的其他实例，就必须不断地切换delegate指针到需要地理数据的对象上（或者创建一个只有你理解的精密的广播系统）。因此，这样看起来，delegatetion在单例上没有多大意义。 关于这点，最好的印证例子就是UIAccelerometer。在早期版本的iOS中，单例的 accelerometer 实例有一个delegate，导致我们必须偶尔切换一下。这个愚蠢的问题在之后的IOS版本被修改了，现在，任意一个对象都可以访问CMMotionManager block，而不需要阻止其他的对象来接收更新。 因此，我们可以得出另一个结论：“如果一个对象是单例，不要使用delegation”。 一般的delegate方法会有返回值如果你观察一些delegate方法（几乎所有的dataSource方法）都有一个返回值。这就意味着delegating对象在请求某些东西的state(对象的值，或者对象本身)，而一个block则可以合理地包含state或者至少是推断state，因此block真正是对象的一个属性。 让我们思考一下一个有趣的场景，如果向一个block提问：“What do you think about Bob？”。block可能会做两件事情：发送一个消息去捕获对象并询问这个对象怎么看待Bob，或者直接返回一个捕获的值。如果返回了一个对象的响应，我们应该越过这个block直接获取这个对象。如果它返回了一个捕获的值，那么这应该是一个对象的属性。 从以上的观察，我们可以得出结论：如果对象的请求带有附加信息，更应该使用delegation。 delegate面向过程 而 block面向结果如果查看NSURLConnectionDelegate 以及 NSURLConnectionDataDelegate，我们在可以protocol中看到这样的消息：我将要做什么（如： willSendRequest，将要发送请求）、到目前为止我知道的信息（如：canAuthenticateAgainstProtectionSpace）、我已经完成这些啦（ didReceiveResponse，收到请求的回复，即完成请求）。这些消息组成一个流程，而那些对流程感兴趣的delegate将会在每一步得到相应的通知。 当我们观察handler和完整的方法时，我们发现一个block包含一个响应对象和一个错误对象。显然这里没有任何有关“我在哪里，我正在做什么的”的交互。 因此我们可以这样认为，delegate的回调更多的面向过程，而block则是面向结果的。如果你需要得到一条多步进程的通知，你应该使用delegation。而当你只是希望得到你请求的信息（或者获取信息时的错误提示），你应该使用block。（如果你结合之前的3个结论，你会发现delegate可以在所有事件中维持state，而多个独立的block确不能） 从上面我们可以得出两个关键点。首先，如果你使用block去请求一个可能失败的请求，你应当只使用一个block。我们可以看到如下的代码： 12345[fetcher makeRequest:^(id result) &#123; &#x2F;&#x2F; do something with result&#96;&#96;&#125; error:^(NSError *err) &#123; &#x2F;&#x2F; Do something with error&#125;]; 上面代码的可读性明显比下面block的可读性差（作者说这个是他不谦虚的观点，其实个人认为没有那么严重） 1234567[fetcher makeRequest:^(id result, NSError *err) &#123; if(!err) &#123; &#x2F;&#x2F; handle result &#125; else&#123; &#x2F;&#x2F; handle error &#125;&#125;]; 开发该选择Blocks还是Delegates(转)","categories":[{"name":"刨根问底","slug":"刨根问底","permalink":"http://heseng91.github.io/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}],"tags":[]},{"title":"「App优化」之稳定性优化","slug":"「App优化」之稳定性优化","date":"2018-12-31T08:32:24.000Z","updated":"2022-11-02T16:53:22.843Z","comments":true,"path":"2018/12/31/「App优化」之稳定性优化/","link":"","permalink":"http://heseng91.github.io/2018/12/31/%E3%80%8CApp%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8B%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/","excerpt":"本文主要转载至如何系统性治理 iOS 稳定性问题，文章比较详细阐述了稳定性优化相关优化思路，其中有些优化本人目前在实际项目中还没有实践，有待进一步探索。","text":"本文主要转载至如何系统性治理 iOS 稳定性问题，文章比较详细阐述了稳定性优化相关优化思路，其中有些优化本人目前在实际项目中还没有实践，有待进一步探索。 本文主要分为四大章节，分别是：1.稳定性问题分类；2.稳定性问题治理方法论；3.疑难问题归因；4.总结回顾。其中第三章节「疑难问题归因」是本次分享的重点，大概会占到60%的篇幅。 一、稳定性问题分类在讲分类之前，我们先了解一下背景：大家都知道对于移动端应用而言，闪退是用户能遇到的最严重的 bug，因为在闪退之后用户无法继续使用产品，那么后续的用户留存以及产品本身的商业价值都无从谈起。 这里有一些数据想和大家分享：有 20% 的用户在使用移动端产品的时候，最无法忍受的问题就是闪退，这个比例仅次于不合时宜的广告；在因为体验问题流失的用户中，有 1/3 的用户会转而使用竞品，由此可见闪退问题是非常糟糕和严重的。 字节跳动作为拥有像抖音、头条等超大量级 App 的公司，对稳定性问题是非常重视的。过去几年，我们在这方面投入了非常多的人力和资源，同时也取得了不错的治理成果。过去两年抖音、头条、飞书等 App 的异常崩溃率都有 30% 以上的优化，个别产品的部分指标甚至有 80% 以上的优化。 通过上图中右侧的饼状图可以看出：我们以 iOS 平台为例，根据稳定性问题不同的原因，将已知稳定性问题分成了这五大类，通过占比从高到低排序：第一大类是 OOM ，就是内存占用过大导致的崩溃，这个比例能占到 50% 以上；其次是 Watchdog，也就是卡死，类比于安卓中的 ANR；再次是普通的 Crash；最后是磁盘 IO 异常和 CPU 异常。 看到这里大家心里可能会有一个疑问：字节跳动究竟做了什么，才取得了这样的成果？接下来我会将我们在稳定性治理方面沉淀的方法论分享给大家。 二、稳定性问题治理的方法论 首先我们认为在稳定性问题治理方面，从监控平台侧视角出发，最重要的就是要有完整的能力覆盖，比如针对上一章节中提到所有类型的稳定性问题，监控平台都应该能及时准确的发现。 另外是从业务研发同学的视角出发：稳定性问题治理这个课题，需要贯穿到软件研发的完整生命周期，包括需求研发、测试、集成、灰度、上线等，在上述每个阶段，研发同学都应该重视稳定性问题的发现和治理。 上图中右侧是我们总结的两条比较重要的治理原则： 第一条是控制新增，治理存量。一般来说新增的稳定性问题可能是一些容易爆发的问题，影响比较严重。存量问题相对来说疑难的问题居多，修复周期较长。 第二条比较容易理解：先急后缓，先易后难。我们应该优先修复那些爆发的问题以及相对容易解决的问题。 如果我们将软件研发周期聚焦在稳定性问题治理这个方向上，又可以抽象出以下几个环节： 首先第一个环节是问题发现：当用户在线上遇到任何类型的闪退，监控平台都应该能及时发现并上报。同时可以通过报警以及问题的自动分发，将这些问题第一时间通知给开发者，确保这些问题能够被及时的修复。 第二个阶段是归因：当开发者拿到一个稳定性问题之后，要做的第一件事情应该是排查这个问题的原因。根据一些不同的场景，我们又可以把归因分为单点归因、共性归因以及爆发问题归因。 当排查到问题的原因之后，下一步就是把这个问题修复掉，也就是问题的治理。在这里我们有一些问题治理的手段：如果是在线上阶段，我们首先可以做一些问题防护，比如网易几年前一篇文章提到的基于 OC Runtime 的线上 Crash 自动修复的方案大白，基于这种方案我们可以直接在线上做 Crash 防护；另外由于后端服务上线导致的稳定性问题爆发，我们可以通过服务的回滚来做到动态止损。除了这两种手段之外，更多的场景还是需要研发在线下修复 native 代码，再通过发版做彻底的修复。 如果我们想把稳定性问题治理做好的话，需要所有研发同学关注上述每一个环节，才能达到最终的目标。可是这么多环节我们的重点究竟在哪里呢？从字节跳动的问题治理经验来看，我们认为最重要的环节是第二个——线上的问题的归因。因为通过内部的统计数据发现：线上之所以存在长期没有结论，没有办法修复的问题，主要还是因为研发并没有定位到这些问题的根本原因。所以下一章节也是本次分享的重点：疑难问题归因。 三、疑难问题归因我们根据开发者对这些问题的熟悉程度做了一下排序，分别是：Crash、Watchdog、OOM 和 CPU&amp;Disk I/O。每一类疑难问题我都会分享这类问题的背景和对应的解决方案，并且会结合实战案例演示各种归因工具究竟是如何解决这些疑难问题的。 第一类疑难问题 —— Crash 上图中左侧这张饼状图是我们根据 Crash 不同的原因，把它细分成四大类：包括 Mach 异常、 Unix Signal 异常、OC 和 C++ 语言层面上的异常。其中比例最高的还是 Mach 异常，其次是 Signal 异常，OC 和 C++ 的异常相对比较少。 为什么是这个比例呢？ 大家可以看到右上角有两个数据。第一个数据是微软发布的一篇文章，称其发布的 70% 以上的安全补丁都是内存相关的错误，对应到 iOS 平台上就是 Mach 异常中的非法地址访问，也就是 EXC_BAD_ACCESS。内部统计数据表明，字节跳动线上 Crash 有 80% 是长期没有结论的，在这部分 Crash 当中，90% 以上都是 Mach 异常或者 Signal 异常。 看到这里，大家肯定心里又有疑问了，为什么有这么多 Crash 解决不了？究竟难在哪里？我们总结了几点这些问题归因的难点： 首先不同于 OC 和 C++ 的异常，可能开发者拿到的崩溃调用栈是一个纯系统调用栈，这类问题显然修复难度是非常大的； 另外可能有一部分Crash是偶发而不是必现的问题，研发同学想在线下复现问题是非常困难的，因为无法复现，也就很难通过 IDE 调试去排查和定位这些问题； 另外对于非法地址访问这类问题，崩溃的调用栈可能并不是第一现场。这里举一个很简单的例子：A业务的内存分配溢出，踩到了B业务的内存，这个时候我们认为 A 业务应该是导致这个问题的主要原因，但是有可能B业务在之后的某一个时机用到了这块内存，发生了崩溃。显然这种问题实际上是 A 业务导致的，最终却崩在了 B 业务的调用栈里，这就会给开发者排查和解决这个问题带来非常大的干扰。 看到这里大家可能心里又有问题：既然这类问题如此难解，是不是就完全没有办法了呢？其实也并不是，下面我会分享字节内部两个解决这类疑难问题非常好用的归因工具。 Zombie 检测 首先第一个是 Zombie 检测，大家如果用过 Xcode 的 Zombie 监控，应该对这个功能比较熟悉。如果我们在调试之前打开了 Zombie Objects 这个开关，在运行的时候如果遇到了 OC 对象野指针造成的崩溃，Xcode 控制台中会打印出一行日志，它会告诉开发者哪个对象在调用什么消息的时候崩溃了。 这里我们再解释一下 Zombie 的定义，其实非常简单，指的是已经释放的 OC 对象。 Zombie 监控的归因优势是什么呢？首先它可以直接定位到问题发生的类，而不是一些随机的崩溃调用栈；另外它可以提高偶现问题的复现概率，因为大部分偶现问题可能跟多线程的运行环境有关，如果我们能把一个偶现问题变成必现问题的话，那么开发者就可以借助 IDE 和调试器非常方便地排查问题。但是这个方案也有自己的适用范围，因为它的底层原理基于 OC 的 runtime 机制，所以它仅仅适用于 OC 对象野指针导致的内存问题。 这里再和大家一起回顾一下 Zombie 监控的原理：首先我们会 hook 基类 NSObject 的 dealloc 方法，当任意 OC 对象被释放的时候，hook 之后的那个 dealloc 方法并不会真正的释放这块内存，同时将这个对象的 ISA 指针指向一个特殊的僵尸类，因为这个特殊的僵尸类没有实现任何方法，所以这个僵尸对象在之后接收到任何消息都会 Crash，与此同时我们会将崩溃现场这个僵尸对象的类名以及当时调用的方法名上报到后台分析。 这里是字节的一个真实案例：这个问题是飞书在某个版本线上 Top 1 的 Crash，当时持续了两个月没有被解决。首先大家可以看到这个崩溃调用栈是一个纯系统调用栈，它的崩溃类型是非法地址访问，发生在视图导航控制器的一次转场动画，可能开发者一开始看到这个崩溃调用栈是毫无思路的。 那么我们再看 Zombie 功能开启之后的崩溃调用栈：这个时候报错信息会更加丰富，可以直接定位到野指针对象的类型，是 MainTabbarController 对象在调用 retain 方法的时候发生了 Crash。 看到这里大家肯定有疑问了，MainTabbarController 一般而言都是首页的根视图控制器，理论上在整个生命周期内不应该被释放。为什么它变成了一个野指针对象呢？可见这样一个简单的报错信息，有时候还并不足以让开发者定位到问题的根本原因。所以这里我们更进一步，扩展了一个功能：将 Zombie 对象释放时的调用栈信息同时上报上来。 大家看倒数第二行，实际上是一段飞书的业务代码，是视图导航控制器手势识别的代理方法，这个方法在调用的时候释放了 MainTabbarController。因为通过这个调用栈找到了业务代码的调用点，所以我们只需要对照源码去分析为什么会释放 TabbarController，就可以定位到这个问题的原因。 上图中右侧是简化之后的源码（因为涉及到代码隐私问题，所以通过一段注释代替）。历史上为了解决手势滑动返回的冲突问题，在飞书视图导航控制器的手势识别代理方法中写了一段 trick 代码，正是这个 trick 方案导致了首页视图导航控制器被意外释放。 排查到这里，我们就找到了问题的根本原因，修复的方案也就非常简单了：只要下掉这个 trick 方案，并且依赖导航控制器的原生实现来决定这个手势是否触发就解决了这个问题。 Coredump刚才也提到：Zombie 监控方案是有一些局限的，它仅适用于 OC 对象的野指针问题。大家可能又会有疑问：C 和 C++ 代码同样可能会出现野指针问题，在 Mach 异常和 Signal 异常中，除了内存问题之外，还有很多其他类型的异常比如 EXC_BAD_INSTRUCTION和SIGABRT。那么其他的疑难问题我们又该怎么解决呢？这里我们给出了另外一个解决方案 —— Coredump。 这个先解释一下什么是 Coredump：Coredump 是由 lldb 定义的一种特殊的文件格式，Coredump 文件可以还原 App 在运行到某一时刻的完整运行状态（这里的运行状态主要指的是内存状态）。大家可以简单的理解为：Coredump文件相当于在崩溃的现场打了一个断点，并且获取到当时所有线程的寄存器信息，栈内存以及完整的堆内存。 Coredump 方案它的归因优势是什么呢？首先因为它是 lldb 定义的文件格式，所以它天然支持 lldb 的指令调试，也就是说开发者无需复现问题，就可以实现线上疑难问题的事后调试。另外因为它有崩溃时现场的所有内存信息，这就为开发者提供了海量的问题分析素材。 这个方案的适用范围比较广，可以适用于任意 Mach 异常或者 Signal 异常问题的分析。 下面也带来一个线上真实案例的分析：当时这个问题出现在字节的所有产品中，而且在很多产品中的量级非常大，排名Top 1 或者 Top 2，这个问题在之前两年的时间内都没有被解决。 大家可以看到这个崩溃调用栈也全是系统库方法，最终崩溃在 libdispatch 库中的一个方法，异常类型是命中系统库断言。 我们将这次崩溃的 Coredump 文件上报之后，用前面提到的 lldb 调试指令去分析，因为拥有崩溃时的完整内存状态，所以我们可以分析所有线程的寄存器和栈内存等信息。 这里最终我们分析出：崩溃线程的 0 号栈帧(第一行调用栈)，它的 x0 寄程器实际上就是 libdispatch 中定义的队列结构体信息。在它起始地址偏移 0x48 字节的地方，也就是这个队列的 label 属性（可以简单理解为队列的名字）。这个队列的名字对我们来说是至关重要的，因为要修复这个问题，首先应该知道究竟是哪个队列出现了问题。通过 memory read 指令我们直接读取这块内存的信息，最终发现它是一个 C 的字符串，名字叫 com.apple.CFFileDescriptor，这个信息非常关键。我们在源码中全局搜索这个关键字，最终发现这个队列是在字节底层的网络库中创建的，这也就能解释为什么字节所有产品都有这个崩溃了。 最终我们和网络库的同学一起排查，同时结合 libdispatch 的源码，定位到这个问题的原因是 GCD 队列的外部引用计数小于0，存在过度释放的问题，最终命中系统库断言导致崩溃。 排查到问题之后，解决方案就比较简单了：我们只需要在这个队列创建的时候，使用 dispatch_source_create 的方式去增加队列的外部引用计数，就能解决这个问题。和维护网络库的同学沟通后，确认这个队列在整个 App 的生命周期内不应该被释放。这个问题最终解决的收益是直接让字节所有产品的 Crash 率降低了8%。 第二类疑难问题 —— Watchdog我们进入疑难问题中的第二类问题 —— Watchdog 也就是卡死。 上图中左侧是我在微博上截的两张图，是用户在遇到卡死问题之后的抱怨。可见卡死问题对用户体验的伤害还是比较大的。那么卡死问题它的危害有哪些呢？ 首先卡死问题通常发生于用户打开 App 的冷启动阶段，用户可能等待了10 秒什么都没有做，这个 App 就崩溃了，这对用户体验的伤害是非常大的。另外我们线上监控发现，如果没有对卡死问题做任何治理的话，它的量级可能是普通 Crash 的 2-3 倍。另外现在业界普遍监控 OOM 崩溃的做法是排除法，如果没有排除卡死崩溃的话，相应的就会增加 OOM 崩溃误判的概率。 卡死类问题的归因难点有哪些呢？首先基于传统的方案——卡顿监控：认为主线程无响应时间超过3秒～5秒之后就是一次卡死，这种传统的方案非常容易误报，至于为什么误报，我们下一页中会讲到。另外卡死的成因可能非常复杂，它不一定是单一的问题：主线程的死锁、锁等待、主线程 IO 等原因都有可能造成卡死。第三点是死锁问题是一类常见的导致卡死问题的原因。传统方案对于死锁问题的分析门槛是比较高的，因为它强依赖开发者的经验，开发者必须依靠人工的经验去分析主线程到底跟哪个或者哪些线程互相等待造成死锁，以及为什么发生死锁。 大家可以看到这是基于传统的卡顿方案来监控卡死，容易发生误报。为什么呢？图中绿色和红色的部分是主线程的不同耗时阶段。假如主线程现在卡顿的时间已经超过了卡死阈值，刚好发生在图中的第5个耗时阶段，我们在此时去抓取主线程调用栈，显然它并不是这次耗时的最主要的原因，问题其实主要发生在第4个耗时阶段，但是此时第4个耗时阶段已经过去了，所以会发生一次误报，这可能让开发者错过真正的问题。 针对以上提到的痛点，我们给出了两个解决方案：首先在卡死监控的时候可以多次抓取主线程调用栈，并且记录每次不同时刻主线程的线程状态，关于线程状态包括哪些信息，下一页中会提到。 另外我们可以自动识别出死锁导致的卡死问题，将这类问题标识出来，并且可以帮助开发者自动还原出各个线程之间的锁等待关系。 首先是第一个归因工具——线程状态，这张图是主线程在不同时刻调用栈的信息，在每个线程名字后面都有三个 tag ，分别指的是三种线程的状态，包括当时的线程 CPU 占用、线程运行状态和线程标志。 上图中右侧是线程的运行状态和线程标志的解释。当看到线程状态的时候，我们主要的分析思路有两种：第一种，如果看到主线程的 CPU 占用为 0，当前处于等待的状态，已经被换出，那我们就有理由怀疑当前这次卡死可能是因为死锁导致的；另外一种，特征有所区别，主线程的 CPU 占用一直很高 ，处于运行的状态，那么就应该怀疑主线程是否存在一些死循环等 CPU 密集型的任务。 第二个归因工具是死锁线程分析，这个功能比较新颖，所以首先带领大家了解一下它的原理。基于上一页提到的线程状态，我们可以在卡死时获取到所有线程的状态并且筛选出所有处于等待状态的线程，再获取每个线程当前的 PC 地址，也就是正在执行的方法，并通过符号化判断它是否是一个锁等待的方法。 上图中列举了目前我们覆盖到的一些锁等待方法，包括互斥锁、读写锁、自旋锁、 GCD 锁等等。每个锁等待的方法都会定义一个参数，传入当前锁等待的信息。我们可以从寄存器中读取到这些锁等待信息，强转为对应的结构体，每一个结构体中都会定义一个线程id的属性，表示当前这个线程正在等待哪个线程释放锁。对每一个处于等待状态的线程完成这样一系列操作之后，我们就能够完整获得所有线程的锁等待关系，并构建出锁等待关系图。 通过上述方案，我们可以自动识别出死锁线程。假如我们能判断 0 号线程在等待 3 号线程释放锁， 同时3 号线程在等待0号线程释放锁，那么显然就是两个互相等待最终造成死锁的线程。 大家可以看到这里主线程我们标记为死锁，它的 CPU 占用为 0，状态是等待状态，而且已经被换出了，和我们之前分析线程状态的方法论是吻合的。 通过这样的分析之后，我们就能够构建出一个完整的锁等待关系图，而且无论是两个线程还是更多线程互相等待造成的死锁问题，都可以自动识别和分析。 这是上图中死锁问题的一段示意的源码。它的问题就是主线程持有互斥锁，子线程持有 GCD 锁，两个线程之间互相等待造成了死锁。这里给出的解决方案是：如果子线程中可能存在耗时操作，尽量不要和主线程有锁竞争关系；另外如果在串行队列中同步执行 block 的话，一定要慎重。 上图是通过字节内部线上的监控和归因工具，总结出最常见触发卡死问题的原因，分别是死锁、锁竞争、主线程IO、跨进程通信。 第三类疑难问题 —— OOMOOM 就是 Out Of Memory，指的是应用占用的内存过高，最终被系统强杀导致的崩溃。 OOM 崩溃的危害有哪些呢？首先我们认为用户使用 App 的时间越长，就越容易发生 OOM 崩溃，所以说 OOM 崩溃对重度用户的体验伤害是比较大的；统计数据显示，如果 OOM 问题没有经过系统性的治理，它的量级一般是普通 Crash 的 3-5 倍。最后是内存问题不同于 Crash 和卡死，相对隐蔽，在快速迭代的过程中非常容易劣化。 那么 OOM 问题的归因难点有哪些呢？首先是内存的构成是非常复杂的事情，并没有非常明确的异常调用栈信息。另外我们在线下有一些排查内存问题的工具，比如 Xcode MemoryGraph 和 Instruments Allocations，但是这些线下工具并不适用于线上场景。同样是因为这个原因，如果开发者想在线下模拟和复现线上 OOM 问题是非常困难的。 这里我们给出解决线上 OOM 疑难问题的归因工具是MemoryGraph。这里的 MemoryGraph 主要指的是在线上环境中可以使用的 MemoryGraph。跟 Xcode MemoryGraph 有一些类似，但是也有不小的区别。最大的区别当然是它能在线上环境中使用，其次它可以对分散的内存节点进行统计和聚合，方便开发者定位头部的内存占用。 这里带领大家再回顾一下线上 MemoryGraph 的基本原理：首先我们会定时的去检测 App 的物理内存占用，当它超过危险阈值的时候，就会触发内存 dump，此时 SDK 会记录每个内存节点符号化之后的信息，以及他们彼此之间的引用关系，如果能判定出是强引用还是弱引用，也会把这个强弱引用关系同时上报上来，最终这些信息整体上报到后台之后，就可以辅助开发者去分析当时的大内存占用和内存泄露等异常问题。 这里我们还是用一个实战案例带领大家看一下 MemoryGraph 到底是如何解决 OOM 问题的。 分析 MemoryGraph 文件的思路一般是抽丝剥茧，逐步找到根本原因。 上图是 MemoryGraph 文件分析的一个例子，这里的红框标注了不同的区域：左上角是类列表，会把同一类型对象的数量以及它们占用的内存大小做一个汇总；右侧是这个类所有实例的地址列表，右下角区域开发者可以手动回溯对象的引用关系（当前对象被哪些其他对象引用、它引用了哪些其他对象），中间比较宽的区域是引用关系图。 因为不方便播放视频，所以这边就跟大家分享一些比较关键的结论：首先看到类列表，我们不难发现 ImageIO 类型的对象有 47 个，但是这 47 个对象居然占了 500 多 MB 内存，显然这并不是一个合理的内存占用。我们点开 ImageIO 的类列表，以第一个对象为例，回溯它的引用关系。当时我们发现这个对象只有一个引用，就是 VM Stack: Rust Client Callback ，它实际上是飞书底层的 Rust 网络库线程。 排查到这里，大家肯定会好奇：这 47 个对象是不是都存在相同的引用关系呢？这里我们就可以用到右下角路径回溯当中的 add tag 功能，自动筛选这 47 个对象是否都存在相同的引用关系。大家可以看到上图中右上角区域，通过筛选之后，我们确认这 47 个对象 100% 都有相同的引用关系。 我们再去分析 VM Stack: Rust Client Callback这个对象。发现它引用的对象中有两个名字非常敏感，一个是 ImageRequest，另外一个是 ImageDecoder ，从这两个名字我们可以很容易地推断出：应该是图片请求和图片解码的对象。 我们再用这两个关键字到类列表中搜索，可以发现 ImageRequest 对象有 48 个，ImageDecoder 对象有 47 个。如果大家还有印象的话，上一页中占用内存最大的对象 ImageIO 也是 47 个。这显然并不是一个巧合，我们再去排查这两类对象的引用关系，发现这两类对象也同样是 100% 被 VM Stack: Rust Client Callback 对象所引用。 最终我们和飞书图片库的同学一起定位到这个问题的原因：在同一时刻并发请求 47 张图片并解码，这不是一个合理的设计。问题的根本原因是飞书图片库的下载器依赖了 NSOperationQueue 做任务管理和调度，但是却没有配置最大并发数，在极端场景下就有可能造成内存占用过高的问题。与之相对应的解决方案就是对图片下载器设置最大并发数，并且根据待加载图片是否在可视区域内调整优先级。 上图是通过字节内部的线上监控和归因工具，总结出来最常见的几类触发 OOM 问题的原因，分别是：内存泄露，这个较为常见；第二个是内存堆积，主要指的是 AutoreleasePool 没有及时清理；第三是资源异常，比如加载一张超大图或者一个超大的 PDF 文件；最后一个是内存使用不当，比如内存缓存没有设计淘汰清理的机制。 第四类疑难问题 —— CPU 异常和磁盘 I/O 异常这里之所以把这两类问题合并在一起，是因为这两类问题是高度相似的：首先它们都属于资源的异常占用；另外它们也都不同于闪退，导致崩溃的原因并不是发生在一瞬间，而都是持续一段时间的资源异常占用。 异常 CPU 占用和磁盘 I/O 占用危害有哪些呢？首先我们认为，这两类问题即使最终没有导致 App 崩溃，也特别容易引发卡顿或者设备发烫等性能问题。其次这两类问题的量级也是不可以被忽视的。另外相比之前几类稳定性问题而言，开发者对这类问题比较陌生，重视程度不够，非常容易劣化。 这类问题的归因难点有哪些呢？首先是刚刚提到它的持续时间非常长，所以原因也可能并不是单一的；同样因为用户的使用环境和操作路径都比较复杂，开发者也很难在线下复现这类问题；另外如果 App 想在用户态去监控和归因这类问题的话，可能需要在一段时间内高频的采样调用栈信息，然而这种监控手段显然性能损耗是非常高的。 上图中左侧是我们从 iOS 设备中导出的一段 CPU 异常占用的崩溃日志，截取了关键部分。这部分信息的意思是：当前 App 在 3 分钟之内的 CPU 时间占用已经超过80%，也就是超过了 144 秒，最终触发了这次崩溃。 上图中右侧是我截取苹果 WWDC2020 一个 session 中的截图，苹果官方对于这类问题，给出了一些归因方案的建议：首先是 Xcode Organizer，它是苹果官方提供的问题监控后台。然后是建议开发者也可以接入 MetricKit ，新版本有关于 CPU 异常的诊断信息。 上图中左侧是磁盘异常写入的崩溃日志，也是从 iOS 设备中导出，依然只截取了关键部分：在 24 小时之内，App 的磁盘写入量已经超过了 1073 MB，最终触发了这次崩溃。 上图中右侧是苹果官方的文档，也给出了对于这类问题的归因建议。同样是两个建议：一个是依赖 Xcode Organizer，另一个是依赖 MetricKit。我们选型的时候最终确定采用 MetricKit 方案，主要考虑还是想把数据源掌握在自己手中。因为 Xcode Organizer 毕竟是一个苹果的黑盒后台，我们无法与集团内部的后台打通，更不方便建设报警、问题自动分配、issue状态管理等后续流程。 MetricKit是苹果提供的官方性能分析以及稳定性问题诊断的框架，因为是系统库，所以它的性能损耗很小。在 iOS 14 系统以上，基于Metrickit，我们可以很方便地获取 CPU 和磁盘 I/O 异常的诊断信息。它的集成也非常方便。我们只需要导入系统库的头文件，设置一个监听者，在对应的回调中把 CPU 和磁盘写入异常的诊断信息上报到后台分析就好了。 其实这两类异常的诊断信息格式也是高度类似的，都是记录一段时间内所有方法的调用以及每个方法的耗时。上报到后台之后，我们可以把这些数据可视化为非常直观的火焰图。通过这样直观的形式，可以辅助开发者轻松地定位到问题。对于上图中右侧的火焰图，我们可以简单的理解为：矩形块越长，占用的 CPU 时间就越长。那么我们只需要找到矩形块最长的 App 调用栈，就能定位到问题。图中高亮的红框，其中有一个方法的关键字是 animateForNext，看这个名字大概能猜到这是动画在做调度。 最终我们和飞书的同学一起定位到这个问题的原因：飞书的小程序业务有一个动画在隐藏的时候并没有暂停播放，造成了 CPU 占用持续比较高。解决方案也非常简单，只要在动画隐藏的时候把它暂停掉就可以了。 四、总结回顾 在第二章节稳定性问题治理方法论中，我提到“如果想把稳定性问题治理好，就需要将这件事情贯穿到软件研发周期中的每一个环节，包括问题的发现、归因、治理以及防劣化。”同时我们认为线上问题——特别是线上疑难问题的归因，是整个链路中的重中之重。针对每一类疑难问题，本次分享均给出了一些好用的归因工具：Crash 有 Zombie 监控和 Coredump；Watchdog 有线程状态和死锁线程分析；OOM 有 MemoryGraph；CPU 和磁盘 I/O 异常有 MetricKit。 本次分享提到的所有疑难问题的归因方案，除了MetricKit 之外，其余均为字节跳动自行研发，开源社区尚未有完整解决方案。这些工具和平台后续都将通过字节火山引擎应用开发套件MARS下的 APM Plus 平台提供一站式的企业解决方案。本次分享提到的所有能力均已在字节内部各大产品中验证和打磨多年，其自身的稳定性以及接入后所带来的业务效果都是有目共睹的，欢迎大家持续保持关注。","categories":[{"name":"App优化","slug":"App优化","permalink":"http://heseng91.github.io/categories/App%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"「性能优化」之Webview首屏","slug":"「性能优化」之Webview首屏","date":"2018-12-04T08:30:33.000Z","updated":"2022-11-01T16:40:17.522Z","comments":true,"path":"2018/12/04/「性能优化」之Webview首屏/","link":"","permalink":"http://heseng91.github.io/2018/12/04/%E3%80%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8BWebview%E9%A6%96%E5%B1%8F/","excerpt":"在App开发中，当遇到需要跨平台复用、动态更新、无限扩展、较小体积的场景时，内嵌H5可能是较低成本的一种实现方式。作为主流的hybrid方式，H5 + native基本在所有的App中都有使用。然而虽然内嵌H5有很多优点，但如果没针对性地做一些优化，体验会比较不好，主要体现在WebView启动白屏时间和响应流畅度两方面。","text":"在App开发中，当遇到需要跨平台复用、动态更新、无限扩展、较小体积的场景时，内嵌H5可能是较低成本的一种实现方式。作为主流的hybrid方式，H5 + native基本在所有的App中都有使用。然而虽然内嵌H5有很多优点，但如果没针对性地做一些优化，体验会比较不好，主要体现在WebView启动白屏时间和响应流畅度两方面。 WebView启动白屏时间：打开一个 H5 页面需要做一系列处理，会有一段白屏时间，体验糟糕。 响应流畅度：由于 webkit 的渲染机制，单线程，历史包袱等原因，页面刷新/交互的性能体验不如原生。 第二点的体验提升，主要依赖移动设备性能不断增强以及浏览器内核的不断优化。因此针对第二点，本文先不作讨论，仅讨论第一点，怎样减少页面启动白屏时间。对 APP 里的一些使用 H5 实现的功能模块，页面的启动速度是给人最直观感受的体验。本文将首先介绍H5页面加载过程，接着介绍针对加载各阶段要如何优化，最后给出项目实战示例。 H5页面加载过程对于一个普通用户来讲，打开一个WebView通常会经历以下几个阶段： 交互无反馈 到达新的页面，页面白屏 页面基本框架出现，但是没有数据；页面处于loading状态 出现所需的数据 如果从程序上观察，WebView启动过程大概分为以下几个阶段： 如何缩短这些过程的时间，就成了优化WebView性能的关键。 接下来我们逐一分析各个阶段的耗时情况，以及需要注意的优化点。 无反馈当App首次打开时，默认是并不初始化浏览器内核的；只有当创建WebView实例的时候，才会创建WebView的基础框架。所以与浏览器不同，App中打开WebView的第一步并不是建立连接，而是启动浏览器内核。因此相比浏览器以网络连接开始为起点计算加载时长，App中加载H5页面的时间会更长。针对这段时间的耗时，可以通过预加载 webview来优化，主要有以下几种预加载方案： 全局WebView在一个进程内首次初始化 webview 与第二次初始化不同，首次会比第二次慢很多。原因预计是 webview 首次初始化后，即使 webview 已经释放，但一些多 webview 共用的全局服务或资源对象仍没有释放，第二次初始化时不需要再生成这些对象从而变快。因此我们可以在客户端刚启动时，就初始化一个全局的WebView待用，并隐藏，当用户访问了WebView时，直接使用这个WebView加载对应网页，并展示。 这种方法可以比较有效的减少WebView在App中的首次打开时间。当用户访问页面时，不需要初始化WebView的时间。 当然这也带来了一些问题，包括： 额外的内存消耗。 页面间跳转需要清空上一个页面的痕迹，更容易内存泄露。 【参考东软专利 - 加载网页的方法及装置 CN106250434A】 webview 池另一种方案是可以用两个或多个 webview 重复使用，而不是每次打开 H5 都新建 webview。不过这种方式要解决页面跳转时清空上一个页面，另外若一个 H5 页面上 JS 出现内存泄漏，就影响到其他页面，在 APP 运行期间都无法释放了。 白屏WebView加载完成之后，就会进入白屏阶段，此时WebView会建立连接请求页面，并页面在解析到足够多的节点，且所有CSS都加载完成后进行首屏渲染。在此之前，页面保持白屏。 建立连接/服务器处理在页面请求的数据返回之前，主要有以下过程耗费时间。 DNS connection 服务器处理 针对DNS的耗时，可以通过H5采用和客户端API相同的域名或者预解析DNS等方式来优化。DNS会在系统级别进行缓存，对于WebView的地址，如果使用的域名与native的API相同，则可以直接使用缓存的DNS而不用再进行DNS解析。静态资源同理，最好与客户端的资源域名保持一致。 除此之外，同步渲染时如果后端请求时间过长，可以考虑采用chunk编码，将数据放在最后，并优先将静态内容flush。对于传统的后端渲染页面，往往都是使用的【浏览器】–&gt; 【Web API】 –&gt; 【业务 API】的加载模式，其中后端时间就指的是Web API的处理时间了。在这里Web API一般有两个作用： 确定静态资源的版本。 根据用户的请求，去业务API获取数据。 而一般确定静态资源的版本往往是直接读取代码版本，基本无耗时；而主要的后端时间都花费在了业务API请求上面。 针对业务API请求的耗时，在HTTP协议中，我们可以在header中设置 transfer-encoding:chunked 使得页面可以分块输出。如果合理设计页面，让head部分都是确定的静态资源版本相关内容，而body部分是业务数据相关内容，那么我们可以在用户请求的时候，首先将Web API可以确定的部分先输出给浏览器，然后等API完全获取后，再将API数据传输给浏览器。 下图可以直观的看出分chunk输出和一起输出的区别： 如果采用普通方式输出页面，则页面会在服务器请求完所有API并处理完成后开始传输。浏览器要在后端所有API都加载完成后才能开始解析。 如果采用chunk-encoding: chunked，并优先将页面的静态部分输出；然后处理API请求，并最终返回页面，可以让后端的API请求和前端的资源加载同时进行。 两者的总共后端时间并没有区别，但是可以提升首字节速度，从而让前端加载资源和后端加载API不互相阻塞。 页面框架渲染前面提到页面在解析到足够多的节点，且所有CSS都加载完成后就会进行首屏渲染。一般来说HTML在开始接收到返回数据的时候就开始解析HTML并构建DOM树。但是如果页面的header部分有这样的代码： 1234567891011.....&lt;link href=\"//ms0.meituan.net/css/eve.9d9eee71.css\" rel=\"stylesheet\" onload=\"MT.pageData.eveTime=Date.now()\"/&gt;&lt;script&gt;window.fk = function (callback) &#123;require(['util/native/risk.js'], function (risk) &#123; risk.getFk(callback);&#125;);&#125;&lt;/script&gt;&lt;/head&gt;.... 上面代码的link部分和script部分如果单独出现，都不会阻塞页面的解析： CSS不会阻止页面继续向下继续。 内联的JS很快执行完成，然后继续解析文档。 然而，当这两部分同时出现的时候，CSS后面有JS，则会阻塞JS的执行直到CSS加载完成（即便JS是内联的脚本），从而间接阻塞HTML的解析。 在页面框架加载这一部分，能够优化的点参照雅虎14条就够了；但注意不要犯错，一个小小的内联JS放错位置也会让性能下降很多。 CSS的加载会在HTML解析到CSS的标签时开始，所以CSS的标签要尽量靠前。 但是，CSS链接下面不能有任何的JS标签（包括很简单的内联JS），否则会阻塞HTML的解析。 如果必须要在头部增加内联脚本，一定要放在CSS标签之前。 loading在页面完全下载并解析完成之前，页面处于不完整展示状态。该阶段主要是业务数据的加载，主要有以下两个优化方向： 降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。 加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。 这里就不详细展开了。 优化HTTP 缓存协议在WebView加载过程中，对首屏启动速度影响最大的就是网络请求，所以优化的重点就是缓存，这里着重说一下前端对请求的缓存策略。我们再细分一下，分成 HTML 的缓存，JS/CSS/image 资源的缓存，以及 json 数据的缓存。 HTML 和 JS/CSS/image 资源都属于静态文件，HTTP 本身提供了缓存协议，浏览器实现了这些协议，可以做到静态文件的缓存，具体可以参考这里，总的来说，就是两种缓存： 询问是否有更新：根据 If-Modified-Since / ETag 等协议向后端请求询问是否有更新，没有更新返回304，浏览器使用本地缓存。 直接使用本地缓存：根据协议里的 Cache-Control / Expires 字段去确定多长时间内可以不去发请求询问更新，直接使用本地缓存。 前端能做的最大限度的缓存策略是：HTML 文件每次都向服务器询问是否有更新，JS/CSS/Image资源文件则不请求更新，直接使用本地缓存。那 JS/CSS 资源文件如何更新？常见做法是在在构建过程中给每个资源文件一个版本号或hash值，若资源文件有更新，版本号和 hash 值变化，这个资源请求的 URL 就变化了，同时对应的 HTML 页面更新，变成请求新的资源URL，资源也就更新了。 json 数据的缓存可以用 localStorage 缓存请求下来的数据，可以在首次显示时先用本地数据，再请求更新，这都由前端 JS 控制。 这些缓存策略可以实现 JS/CSS 等资源文件以及用户数据的缓存的全缓存，可以做到每次都直接使用本地缓存数据，不用等待网络请求。但 HTML 文件的缓存做不到，对于 HTML 文件，如果把 Expires / max-age 时间设长了，长时间只使用本地缓存，那更新就不及时，如果设短了，每次打开页面都要发网络请求询问是否有更新，再确定是否使用本地资源，一般前端在这里的策略是每次都请求，这在弱网情况下用户感受到的白屏时间仍然会很长。所以 HTML 文件的“缓存”和跟“更新”间存在矛盾。 HTML 缓存桌面时代受限于浏览器，H5 页面无法做更多的优化，现在 H5 页面是内嵌在客户端 APP 上，客户端有更多的权限，于是客户端上可以超出浏览器的范围，做更多的优化。在缓存方面，在客户端也有更自由的缓存策略，客户端可以拦截 H5 页面的所有请求，由自己管理缓存，针对上述 HTML 文件的“缓存”和“更新”之间的矛盾，我们可以用这样的策略解决： 在客户端拦截请求，首次请求 HTML 文件后缓存数据，第二次不发请求，直接使用缓存数据。 什么时候去请求更新？这个更新请求可以客户端自由控制策略，可以在使用本地缓存打开本地页面后再在后台发起请求询问更新缓存，下次打开时生效；也可以在 APP 启动时或某个时机在后台去发起请求预更新，提升用户访问最新代码的几率。 这样看起来已经比较完美了，HTML 文件在用客户端的策略缓存，其余资源和数据沿用上述前端的缓存方式，这样一个 H5 页面第二次访问从 HTML 到 JS/CSS/Image 资源，再到数据，都可以直接从本地读取，无需等待网络请求，同时又能保持尽可能的实时更新，解决了缓存问题，大大提升 H5 页面首屏启动速度。 上述方案似乎已完整解决缓存问题，但实际上还有很多问题： 没有预加载：第一次打开的体验很差，所有数据都要从网络请求。 缓存不可控：缓存的存取由系统 webview 控制，无法控制它的缓存逻辑，带来的问题包括： i. 清理逻辑不可控，缓存空间有限，可能缓存几张大图片后，重要的 HTML/JS/CSS 缓存就被清除了。 ii.磁盘 IO 无法控制，无法从磁盘预加载数据到内存。 更新体验差：后台 HTML/JS/CSS 更新时全量下载，数据量大，弱网下载耗时长。 无法防劫持：若 HTML 页面被运营商或其他第三方劫持，将长时间缓存劫持的页面。 这些问题在客户端上都是可以被解决的，只不过有点麻烦，简单描述下： 可以配置一个预加载列表，在APP启动或某些时机时提前去请求，这个预加载列表需要包含所需 H5 模块的页面和资源，还需要考虑到一个H5模块有多个页面的情况，这个列表可能会很大，也需要工具生成和管理这个预加载列表。 客户端可以接管所有请求的缓存，不走 webview 默认缓存逻辑，自行实现缓存机制，可以分缓存优先级以及缓存预加载。 可以针对每个 HTML 和资源文件做增量更新，只是实现和管理起来比较麻烦。 在客户端使用 httpdns + https 防劫持。 上面的解决方案实现起来十分繁琐，原因就是各个 HTML 和资源文件很多很分散，管理困难，有个较好的方案可以解决这些问题，就是离线包。 离线包既然很多问题都是文件分散管理困难引起，而我们这里的使用场景是使用 H5 开发功能模块，那很容易想到把一个个功能模块的所有相关页面和资源打包下发，这个压缩包可以称为功能模块的离线包。使用离线包的方案，可以相对较简单地解决上述几个问题： 可以预先下载整个离线包，只需要按业务模块配置，不需要按文件配置，离线包包含业务模块相关的所有页面，可以一次性预加载。 离线包核心文件和页面动态的图片资源文件缓存分离，可以更方便地管理缓存，离线包也可以整体提前加载进内存，减少磁盘 IO 耗时。 离线包可以很方便地根据版本做增量更新。 离线包以压缩包的方式下发，同时会经过加密和校验，运营商和第三方无法对其劫持篡改。 到这里，对于使用 H5 开发功能模块，离线包是一个挺不错的方案了，简单复述一下离线包的方案： 后端使用构建工具把同一个业务模块相关的页面和资源打包成一个文件，同时对文件加密/签名。 客户端根据配置表，在自定义时机去把离线包拉下来，做解压/解密/校验等工作。 根据配置表，打开某个业务时转接到打开离线包的入口页面。 拦截网络请求，对于离线包已经有的文件，直接读取离线包数据返回，否则走 HTTP 协议缓存逻辑。 离线包更新时，根据版本号后台下发两个版本间的 diff 数据，客户端合并，增量更新。 更多优化离线包方案在缓存上已经做得差不多了，还可以再配上一些细节优化： 公共资源包每个包都会使用相同的 JS 框架和 CSS 全局样式，这些资源重复在每一个离线包出现太浪费，可以做一个公共资源包提供这些全局文件。 预加载数据理想情况下离线包的方案第一次打开时所有 HTML/JS/CSS 都使用本地缓存，无需等待网络请求，但页面上的用户数据还是需要实时拉，这里可以做个优化，在 webview 初始化的同时并行去请求数据，webview 初始化是需要一些时间的，这段时间没有任何网络请求，在这个时机并行请求可以节省不少时间。 具体实现上，首先可以在配置表注明某个离线包需要预加载的 URL，客户端在 webview 初始化同时发起请求，请求由一个管理器管理，请求完成时缓存结果，然后 webview 在初始化完毕后开始请求刚才预加载的 URL，客户端拦截到请求，转接到刚才提到的请求管理器，若预加载已完成就直接返回内容，若未完成则等待。 Fallback如果用户访问某个离线包模块时，这个离线包还没有下载，或配置表检测到已有新版本但本地是旧版本的情况如何处理？几种方案： 简单的方案是如果本地离线包没有或不是最新，就同步阻塞等待下载最新离线包。这种用户打开的体验更差了，因为离线包体积相对较大。 也可以是如果本地有旧包，用户本次就直接使用旧包，如果没有再同步阻塞等待，这种会导致更新不及时，无法确保用户使用最新版本。 还可以对离线包做一个线上版本，离线包里的文件在服务端有一一对应的访问地址，在本地没有离线包时，直接访问对应的线上地址，跟传统打开一个在线页面一样，这种体验相对等待下载整个离线包较好，也能保证用户访问到最新。 第三种 Fallback 的方式还带来兜底的好处，在一些意外情况离线包出错的时候可以直接访问线上版本，功能不受影响，此外像公共资源包更新不及时导致版本没有对应上时也可以直接访问线上版本，是个不错的兜底方案。 上述几种方案策略也可以混着使用，看业务需求。 使用客户端接口网路和存储接口如果使用 webkit 的 ajax 和 localStorage 会有不少限制，难以优化，可以在客户端提供这些接口给 JS，客户端可以在网络请求上做像 DNS 预解析/IP直连/长连接/并行请求等更细致的优化，存储也使用客户端接口也能做读写并发/用户隔离等针对性优化。 服务端渲染早期 web 页面里，JS 只是负责交互，所有内容都是直接在 HTML 里，到现代 H5 页面，很多内容已经依赖 JS 逻辑去决定渲染什么，例如等待 JS 请求 JSON 数据，再拼接成 HTML 生成 DOM 渲染到页面上，于是页面的渲染展现就要等待这一整个过程，这里有一个耗时，减少这里的耗时也是白屏优化的范围之内。 优化方法可以是人为减少 JS 渲染逻辑，也可以是更彻底地，回归到原始，所有内容都由服务端返回的 HTML 决定，无需等待 JS 逻辑，称之为服务端渲染。是否做这种优化视业务情况而定，毕竟这种会带来开发模式变化/流量增大/服务端开销增大这些负面影响。手Q的部分页面就是使用服务端渲染的方式，称为动态直出，见文章。 实战示例实现方案整体实现方案如下（具体流程待下文详述）： APP启动时下载需要预载的资源，在WebView加载资源的时候进行拦截，符合条件（主要是md5值的校验）的则使用本地资源，否则交由webview自己处理。静态资源拦截的方案中，静载资源的来源有三处： 服务端下发的静态资源 （Server Resource） MallConfig配置的静态资源 （MallConfig Resource） 内置的静载资源 （Inner Resource） 三者的优先级递减。 注意点： CORS（Cross-origin resource sharing）问题，一般处理方式在headers里加一些配置，在这里处理header的时候需要小心，一般是request headers里包含“Origin”才会去做跨域处理，并且避免同样参数重复插入到header里，会报错的。各位开发同学处理的时候注意。 md5校验，在文件匹配的时候，一定要进行文件md5校验： 防止文件被篡改，规避安全风险； 防止文件下载失败或者不完整，直接拿来用是会出问题； 如果同样url的文件出现更新可以及时放弃老的缓存，用新的缓存。 这样，我们可以拿到一系列的需要预加载的文件列表，提前下载到本地，在webview加载的时候，针对url进行拦截，如果发现存在缓存文件，则匹配文件并以webview能够识别的形式传给webview。可以突破缓存的限制，并且基本不占用内存，作用于任何webview。当然这个方案是针对上一个优化方案的补充，叠加使用的，这样可以做到核心页面和其他页面加载的互补。 做了优化，就需要去量化效果，以便衡量方案是否真的有效果。我们从几个方面进行衡量：80/90分位渲染耗时、页面白屏率、页面drop情况。一般业界都是统计80/90分位页面耗时，这个就不多说了。关于白屏，一方面是观察页面离开的时候页面还没有加载，另一个方面也是内存的情况反应，当内存吃紧会出现内存栈内的webview被杀死的情况，在上线一个方案的时候可以观察这个指标，作为一个该方案能否在线上平稳运行的依据。页面drop情况，我们曾经做过一些数据统计，当页面超过一定时间还没有加载出来，用户会选择离开，在Android上集中在1-1.5s区间，iOS集中0.8-1.2s区间，所以优化页面速度可以以此为目标进行优化，不断尝试。 流程介绍资源下载资源下载主要流程如下： 资源清理资源清理主要流程如下： 资源拦截资源拦截主要流程如下： 接口示例MallConfig 接口app冷启动时会请求MallConfig 接口， 返回如下所示： 12345678910111213141516171819202122232425262728293031&#123; &quot;code&quot;: 0, &quot;message&quot;: &quot;success&quot;, &quot;data&quot;: &#123; &quot;codeType&quot;: 1, &quot;codeMsg&quot;: &quot;操作成功&quot;, &quot;vo&quot;: &#123;&#x2F;&#x2F;data else .... &quot;preloadH5&quot;: &#123; &quot;fileClearPeriod&quot;: 10, &quot;enable&quot;: true, &quot;internalEnable&quot;: true, &quot;serverEnable&quot;: true, &quot;resource&quot;: [&#123; &quot;link&quot;: &quot;https:&#x2F;&#x2F;x.xxx.com&#x2F;...&#x2F;xxx.js&quot;, &quot;md5&quot;: &quot;9de0e2361e885d394095abf15e5c6d5c&quot; &#125;, &#123; &quot;link&quot;: &quot;https:&#x2F;&#x2F;x.xxx.com&#x2F;...&#x2F;xxx.js&quot;, &quot;md5&quot;: &quot;2b8a626c56be87fe2cba990920a9a9ff&quot; &#125;, &#123; &quot;link&quot;: &quot;https:&#x2F;&#x2F;x.xxx.com&#x2F;...&#x2F;xxx.js&quot;, &quot;md5&quot;: &quot;17e942ea0854bd9dce2070bae6826937&quot; &#125;, &#123; &quot;link&quot;: &quot;https:&#x2F;&#x2F;x.xxx.com&#x2F;...&#x2F;xxx.js&quot;, &quot;md5&quot;: &quot;a396a5e2a16af80e2d9df3e98ae5ae1c&quot; &#125;] &#125; &#125; &#125;, &quot;errtag&quot;: 0&#125; 其中 preloadH5 字段是和 WebView 资源预载相关的配置 enable: 上述三种方式资源下载的总开关 serverEnable： 远程资源下载开关 internalEnable： 是否使用内置资源的开关 resource：config资源列表，同时也作为config资源的开关（配空即可） link： 静态资源地址 md5： 静态资源文件的md5， 客户端本地用于校验资源文件是否合法 Server Resource客户端在App冷启动之后，相关开关开启，则会下载 Server Resource 的配置文件: 1234567891011&#123; &quot;fileType&quot;: 1, &quot;resourceUrlsList&quot;: [ &#123; &quot;ids&quot;: &quot;https:&#x2F;&#x2F;www.xxx.com&#x2F;...&#x2F;xxx.html,https:&#x2F;&#x2F;www.xxx.com&#x2F;...&#x2F;xxx.html,https:&#x2F;&#x2F;www.xxx.com&#x2F;...&#x2F;xxx.html&quot;, &quot;link&quot;: &quot;https:&#x2F;&#x2F;https:&#x2F;&#x2F;www.xxx.com&#x2F;...&#x2F;xxx.css&quot;, &quot;md5&quot;: &quot;578e24f7d27587b4087e513d43abe1e0&quot; &#125; ], &quot;version&quot;: 10&#125; 其中 resourceUrlsList 表示的是需要下载的静态资源，目前fileType、version、ids 端上没有使用，link 和 md5 的使用方式同 MallConfig 接口。 内置资源文件每次发版前，通过 python 脚本抓取最新的需要内置的资源文件和配置文件。 fetch_detail_resources.py 最终生成一个配置文件： 以及根据正则匹配到的资源文件本身 上述资源内置到 assets 目录下， 在相关开关开启的情况下，按照上述优先级和拦截规则使用此内置文件 参考： WebView性能、体验分析与优化 移动 H5 首屏秒开优化方案探讨 70%以上业务由H5开发，手机QQ Hybrid 的架构如何优化演进？","categories":[{"name":"性能优化","slug":"性能优化","permalink":"http://heseng91.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"「性能优化」之启动优化","slug":"「性能优化」之启动优化","date":"2018-11-11T03:30:33.000Z","updated":"2022-11-02T16:52:52.424Z","comments":true,"path":"2018/11/11/「性能优化」之启动优化/","link":"","permalink":"http://heseng91.github.io/2018/11/11/%E3%80%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8B%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/","excerpt":"启动是 App 给用户的第一印象，启动越慢用户流失的概率就越高，良好的启动速度是用户体验不可缺少的一环。本文先梳理app构建和启动流程，并结合app构建和启动流程讲述一些可优化点。","text":"启动是 App 给用户的第一印象，启动越慢用户流失的概率就越高，良好的启动速度是用户体验不可缺少的一环。本文先梳理app构建和启动流程，并结合app构建和启动流程讲述一些可优化点。 因为启动涉及面很广，牵扯很多概念。鉴于网上相关概念定义已经比较多了，本文将通过技术的发展及实际问题来介绍这个技术 or 概念。 IPA 构建编译和链接技术发展史计算机只能处理由0和1两个二进制数组成的数据。各种用二进制编码方式表示的指令，叫做机器指令码。 在计算机早期阶段，必须用机器码写程序。具体来讲，就是先在纸上用英语写一个高层次的版本，也就是对程序的高层次描述，叫 “伪代码”，然后用”操作码表”把伪代码转成二进制机器码，再给计算机喂码。 机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，而且需要人工计算每个子程序或者跳转的目标地址，当程序修改的时候，这些位置需要重新计算，十分繁琐又耗时，并且很容易出错。 于是，先驱者发明了汇编语言。汇编语言使用使用接近人类的各种符号和标记来帮助记忆，于是程序员不再使用0和1写代码，转而使用 “jmp”这样的助记符；汇编语言还可以用符号来标记位置。比如如果一种计算机，它的每条指令是一个字节，也就是8位，我们假设有一种跳转指令，它的高4位是0001，表示这是一条跳转指令，低4位存放的是跳转目的地的绝对地址。 1234560 0001 01001 ...2 ...3 ...4 1000 01115 ... 那么以上表示的就是程序的第一条指令为一个跳转指令，它的目的地址是第5条指令。使用汇编后，如果我们把刚开始第5条指令开始的子程序命名为“foo”，那么第一条指令的汇编就是：jmp foo，相比 00010100要好记太多。 然而虽然使用汇编语言之后，方便了人类记忆和编码，但是计算机并不认识助记符和符号（symbol），于是就需要使用二进制编制”汇编器” 来转译”助记符”或者叫做”汇编语言”，形成”机器码” 这样计算机就可以读懂了。汇编器在每次汇编程序的时候，会重新计算“foo”这个符号的地址，然后把所有引用到“foo”的指令修正到这个正确的地址。整个过程不需要人工参与，极大地提高了生产力。随着生产力的提高，软件的规模也开始日渐庞大，代码量开始快速膨胀。人们开始思考将不同功能的代码以一定的方式组织起来，使得更加容易阅读和理解，以便于日后修改和重复使用。自然而然，人们开始将代码按照功能和性质划分，分别形成不同的功能模块，不同的模块之间按照层次结构或其他结构来组织。随着软件规模变大，多则数百万行，如果都放在一个模块肯定无法想象。所以大型软件往往拥有成千上万个模块，这些模块互相依赖又相对独立。在一个程序被分割成多个模块以后，这些模块之间最后如何组合形成一个单一的程序是须解决的问题。模块之间如何组合的问题可以归结为模块之间如何通信的问题，通信可分两种，一种是模块间的函数调用，另外一种是模块间的变量访问。函数访问须知道目标函数的地址，变量访问也须知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是模块间符号的引用。模块间依靠符号来通信类似于拼图版，定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域，两者一拼刚好完美组合，这个模块的拼接过程就是：链接。从原理上来讲，链接的工作无非就是把一些指令对其它符号的引用加以修正。 汇编只是修饰了一下机器码。一般来说，一条汇编指令对应一条机器指令，所以汇编码和底层硬件的连接很紧密。汇编器仍然强迫程序员思考，用什么寄存器和内存地址。所以汇编语言编写起来也不容易，阅读和理解很难。而且汇编语言的编写严格依赖于特定的机器，所以在一种计算机编写的代码在应用于另一种算机时可能需要完全重写。 为了进一步将程序员从直接使用地址编程的梦魇中解救出来，人们开始探索以一个更类似于数学定义或自然语言的简洁形式来编写程序的操作，它应与任何机器都无关，而且也可由一个程序翻译为可执行的代码。在这种背景下，以后很多人开始创作编程语言，编译器也应运而生。这些语言中就包括上世纪80年代初被发明的Objective-C，它需要编译器专门把高级语言转换成低级语言。大多数编译器由两部分组成：前端和后端。 前端负责词法分析、语法分析、生成中间代码； 后端以中间代码作为输入，进行与架构无关的代码优化，接着针对不同架构生成汇编不同的机器码。 前后端依赖统一格式的中间代码（IR），使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个 CPU 架构只需要修改后端即可。 Objective-C/C/C++ 使用的编译器前端是clang，swift 是 swiftc，后端都是 LLVM。 clang 编译源代码转化生成mach-o的大致流程如下： pipeline除了代码文件之外，现代移动软件不可避免为会有一些资源文件（如 storyboard，asset ），这些资源文件也需要编译以加快加载速度，然后，同资源文件一起打包成.app。最后出乎安全考虑，还需要对.app进行签名，防篡改。 以单 Target 为例，整个构建流程如下： 源文件(.m/.c/.swift 等)是单独编译的，输出对应的目标文件(.o) 目标文件和静态库/动态库一起，链接出最后的 Mach-O Mach-O 会被裁剪，去掉一些不必要的信息 资源文件如 storyboard，asset 也会编译，编译后加载速度会变快 Mach-O 和资源文件一起，打包出最后的.app 对.app 签名，防篡改 主要可分为如下几个阶段： 编译编译器构成如下： 编译的具体转化过程如下： 1、预处理（preprocessor）：预处理会进行头文件引入、宏替换、注释处理、条件编译（#ifdef）等操作； 2、词法分析（lexical anaysis）：词法分析器读入源文件的字符流，将它们组织成有意义的词素（lexeme）序列，对于每个词素，词法分析器产生词法单元（token）作为输出； 3、语法分析（semantic analysis）：词法分析的 Token 流会被解析成一颗抽象语法树（abstract syntax tree - AST）。有了抽象语法树，clang 就可以对这个树进行分析，找出代码中的错误。比如类型不匹配，亦或 Objective-C 中向 target 发送了一个未实现的消息。AST 是开发者编写 clang 插件主要交互的数据结构，clang 也提供很多 API 去读取 AST。更多细节：Introduction to the Clang AST； 4、CodeGen：CodeGen 遍历语法树，生成 LLVM IR 代码。LLVM IR 是前端的输出，后端的输入。Objective-C 代码在这一步会进行 runtime 的桥接：property 合成、ARC 处理等。LLVM 会对生成的 IR 进行优化，优化会调用相应的 Pass 进行处理。Pass 由多个节点组成，都是 Pass 类的子类，每个节点负责做特定的优化，更多细节：Writing an LLVM Pass； 5、生成汇编代码：LLVM 对 IR 进行优化后，会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出； 6、汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出目标文件（object file）。 链接连接器把编译产生的 .o 文件和（dylib、a、tbd）文件，生成一个 mach-o 文件。链接的过程并不产生新的代码，只会做一些移动和补丁。 tbd 的全称是 text-based stub library，是因为链接的过程中只需要符号就可以了，所以 Xcode 6 开始，像 UIKit 等系统库就不提供完整的 Mach-O，而是提供一个只包含符号等信息的 tbd 文件。 裁剪编译完 Mach-O 之后会进行裁剪(strip)，是因为里面有些信息，如调试符号，是不需要带到线上去的。裁剪有多种级别，一般的配置如下： All Symbols，主二进制 Non-Global Symbols，动态库 Debugging Symbols，二方静态库 为什么二方库在出静态库的时候要选择 Debugging Symbols 呢？是因为像 order_file 等链接期间的优化是基于符号的，如果把符号裁剪掉，那么这些优化也就不会生效了。 签名 &amp; 上传裁剪完二进制后，会和编译好的资源文件一起打包成.app 文件，接着对这个文件进行签名。签名的作用是保证文件内容不多不少，没有被篡改过。接着会把包上传到 iTunes Connect，上传后会对__TEXT段加密，加密会减弱 IPA 的压缩效果，增加包大小，也会降低启动速度（iOS 13 优化了加密过程，不会对包大小和启动耗时有影响）。 以上就是ipa构建相关，接下来重点了解一下App启动流程。 启动流程概念从appstore下载的安装包，是保存在磁盘中的，要运行就需要载入到内存。 下面介绍一下链接和装入技术的发展史： 一、静态链接、静态装入这种方法最早被采用，其特点是简单，不需要操作系统提供任何额外的支持。程序的不同模块可以并行开发，分别独立编译为相应的目标文件。在得到了所有的目标文件后，静态链接、静态装入的做法是将所有目标文件链接成一个可执行映象，随后在创建进程时将该可执行映象一次全部装入内存。 举个简单的例子，假设我们开发了两个程序Program1和Program2，Program1由main1.c、utilities.c以及errhdl1.c三部分组成，分别对应程序的主框架、一些公用的辅助函数（其作用相当于库）以及错误处理部分，这三部分代码编译后分别得到各自对应的目标文件main1.o、utilities.o以及errhdl1.o。同样，Program2由main2.c、utilities.c以及errhdl2.c三部分组成，三部分代码编译后分别得到各自对应的目标文件main2.o、utilities.o以及errhdl2.o。值得注意的是，这里Program1和Program2使用了相同的公用辅助函数utilities.o。当我们采用静态链接、静态装入的方法，同时运行这两个程序时内存和硬盘的使用情况如下图所示： 这种方式会带来如下问题： 安全问题 ：由于在内存条中使用的都是真实物理地址，而且内存条中各个应用进程都是按顺序依次排列的。 那么在 进程1 中通过地址偏移就可以访问到 其他进程 的内存。 内存空间浪费问题：假如程序在运行过程中没有出现任何错误，那么错误处理部分的代码就不应该被装入内存。但是操作系统在创建进程时将程序的可执行映象一次全部装入内存，之后进程才能开始运行。造成很大的内存浪费。 硬盘空间浪费问题：就硬盘的使用来讲，既然两个程序共享使用了utilities，那么我们只要在硬盘上保存utilities.o的一份拷贝应该就足够了，但这并没有在硬盘保存的可执行程序映象上体现出来。相反，utilities.o被链接进了每一个用到它的程序的可执行映象。 二、静态链接、动态装入前面提到，静态链接、静态装入由于直接暴露的是物理地址，所以进程可以访问到任何物理地址，地址空间缺乏保护，会有比较严重的安全问题。另外，内存紧张的问题在早期的系统中显得更加突出，因此人们首先想到的是要解决内存空间使用方面的问题。为了给进程提供独立而互不访问的内存空间同时提高内存使用效率，于是虚拟内存应运而生了。 虚拟内存工作原理虚拟内存是在物理内存之上建立的一层逻辑地址，保证内存访问安全的同时为应用提供了连续的地址空间。 引用了虚拟内存后，在进程创建时，虚拟内存管理器会为每个进程创建一个称作逻辑地址的空间，并将这些地址空间分割成了大小一致的块，这样的块称之为“页”。分页的概念，下面会详细讲述。对进程而言，它的逻辑地址空间中的地址总是可访问的。因此进程会认为自己拥有连续的可用的内存（一个连续完整的地址空间），但是实际上这个内存地址只是一个虚拟地址，虚拟地址需要经过一张映射表映射后才可以获取到真实的物理地址，这样就限制了对真实物理地址的访问。映射表是进程和它的内存管理单元（MMU）维护的一个页表，该页表将程序的逻辑内存地址空间和实际的物理内存地址空间做了映射。映射过程如下： 1、cpu通过虚拟内存地址，找到对应进程的映射表。 2、通过映射表找到其对应的真实物理地址，进而找到数据。 这个过程又被称为 地址翻译，是由操作系统以及 cpu上集成的 硬件单元 MMU 协同来完成的。找到数据后，mmap到内存。mmap的全称是 memory map，是一种内存映射技术，可以把文件映射到虚拟内存的地址空间里，这样就可以像直接操作内存那样来读写文件。 整个虚拟内存的工作原理这里用一张图来展示： 虚拟内存解决效率问题刚刚提到虚拟内存空间会被分页，实际上物理内存也会被划分为大小相同的页（page）。虚拟内存空间和物理内存空间都以页作为内存空间的最小单位，而映射表同样是以页为单位的。换句话说，映射表最小只会映射到一页，并不会映射到具体每一个地址。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。 对内存分页之后，可以对物理内存进行离散使用。由于存在映射过程，所以虚拟内存对应的物理内存可以任意存放，也不需要一一对应，这样就方便了操作系统对物理内存的管理，也能够可以最大化利用物理内存。同时，也可以采用一些页面调度（Paging）算法，利用翻译过程中也存在的局部性原理，将大概率被使用的帧地址加入到 TLB 或者页表之中，提高翻译的效率。 由于可以对物理内存进行离散使用，人们就可以采用动态装入的方式来优化内存浪费问题。其想法也非常简单，即一个函数只有当它被调用时，其所在的模块才会被装入内存。 仍然以上面提到的两个程序Program1和Program2为例，假如Program1运行过程中出现了错误而Program2在运行过程中没有出现任何错误。当我们采用静态链接、动态装入的方法，同时运行这两个程序时内存和硬盘的使用情况如下图所示： （ 上图中我们也看出，实际物理内存并不是连续以及某个进程完整的）。 当应用被加载到内存中时，并不会将整个应用加载到内存中 。只会放用到的那一部分。也就是动态载入的概念，换句话说就是应用使用多少，实际物理内存就实际存储多少。映射表左侧的 0和 1代表当前地址有没有在物理内存中。当应用访问到某个地址，映射表中为 0，也就是说并没有被加载到物理内存中时，系统就会立刻阻塞整个进程， 触发一个我们所熟知的 缺页中断 - Page Fault。当一个缺页中断被触发，操作系统会从磁盘中重新读取这页数据到物理内存上，然后将映射表中虚拟内存指向对应（如果当前内存已满，操作系统会通过置换页算法 找一页数据进行覆盖，这也是为什么开再多的应用也不会崩掉， 但是之前开的应用再打开时，就重新启动了的根本原因）。通过这种分页和覆盖机制，就完美的解决了内存浪费和效率问题。 安全问题：针对静态链接、静态装入阶段通过地址偏移就可以访问到 其他进程 的内存的安全问题，引用虚拟内存后就不存在了。因为每个进程的映射表是单独的，实际上在进程中每次进行地址翻译，都会先使用界限寄存器判断是否越界，没有越界才会加上基址寄存器的值，转换为物理内存地址。这样就能保证真实物理地址永远在规定范围内，也就不存在通过偏移获取到其他进程的内存空间的问题了。 但是随之而来的确是另外一个安全问题。当应用开发完成以后由于采用了虚拟内存 , 那么其中一个函数无论如何运行，运行多少次，都会是虚拟内存中的固定地址。假设应用有一个函数，基于首地址偏移量为 0x00a000，那么虚拟地址从 0x000000 ~ 0xffffff，基于这个，那么这个函数我无论如何只需要通过 0x00a000这个虚拟地址就可以拿到其真实实现地址。而这种机制就给了很多黑客可操作性的空间，他们可以很轻易的提前写好程序获取固定函数的实现进行修改 hook操作。 为了解决这个问题 , ASLR应运而生。 其原理就是 每次虚拟地址在映射真实地址之前，增加一个随机偏移值，以此来解决我们刚刚所提到的这个问题。 三、动态链接、动态装入采用静态链接、动态装入的方法后看似只剩下硬盘空间使用效率不高的问题了，实际上内存使用效率不高的问题仍然没有完全解决。图2中，既然两个程序用到的是相同的utilities.o，那么理想的情况是系统中只保存一份utilities.o的拷贝，无论是在内存中还是在硬盘上，于是人们想到了动态链接。 下面我们就来看看上面提到的两个程序Program1和Program2在采用动态链接、动态装入的方法，同时运行这两个程序时内存和硬盘的使用情况（见下图）。仍然假设Program1运行过程中出现了错误而Program2在运行过程中没有出现任何错误。 动态链接的这一特性对于库的升级（比如错误的修正）是至关重要的。当一个库升级到一个新版本时，所有用到这个库的程序将自动使用新的版本。如果不使用动态链接技术，那么所有这些程序都需要被重新链接才能得以访问新版的库。为了避免程序意外使用到一些不兼容的新版的库，通常在程序和库中都包含各自的版本信息。内存中可能会同时存在着一个库的几个版本，但是每个程序可以通过版本信息来决定它到底应该使用哪一个。如果对库只做了微小的改动，库的版本号将保持不变；如果改动较大，则相应递增版本号。因此，如果新版库中含有与早期不兼容的改动，只有那些使用新版库进行编译的程序才会受到影响，而在新版库安装之前进行过链接的程序将继续使用以前的库。这样的系统被称作共享库系统。 相比之前的静态链接，动态链接有以下几点好处： 代码共用：图中，无论是硬盘还是内存中都只存在一份utilities.o的拷贝。内存中，两个进程通过将地址映射到相同的utilities.o实现对其的共享。解决了共享的目标文件存在多个副本浪费磁盘和内存空间的问题； 提高载入速度：减少物理页面的换入换出，还增加了CPU的缓存命中率，因为不同进程间的数据和指令访问都集中在了同一个共享模块上； 易于维护：由于被依赖的 lib 是程序执行时才 link 的，所以这些 lib 很容易做更新。系统升级只需要替换掉对应的共享模块，当程序下次启动时新版本的共享模块会被自动装载并链接起来，程序就无感的对接到了新版本。 减少可执行文件体积：相比静态链接，动态链接在编译时不需要打进去，所以可执行文件的体积要小很多 dyld引入动态装载后，就不得不提dyld，全名 The dynamic link editor，他是苹果的平台用于加载链接库的帮助程序，主要提供动态加载的支持。APP启动的时候会把 dyld 加载到进程的地址空间里，然后把后续的启动过程交给 dyld。dyld是开源的，我们可以在官网下载它的源码来阅读理解。 dyld发展简史dyld 1.0 (1996-2004)dyld 最初是作为NeXTStep 3.3的一部分于1996年上市的，所以其实没有版本号的，为了方便追溯苹果将当时的dyld版本命名的为1.0。dyld诞生背景： dyld 1.0 发明之前NeXT使用的都是静态二进制数据 POSIX dlopen调用还没有标准化：当时人们采用的是定制拓展的方式来在Unix上支持dlopen。在NeXTStep上使用的是不同的拓展。为了在NeXTStep上运行标准的Unix软件，有人在macOS 10的早期版本上编写了第三方包装程序。问题是由于并不完全支持相同的语义，在一些奇怪的边缘情况下，会不起作用，而且也会导致程序运行的比较慢。 没有广泛使用C++动态库：很重要的一点，dyld 1.0 发布时，大多数系统还没有使用大型c++动态库。c++有一些特性，比如初始化命令，在静态系统中可以很好的运行，但是在动态系统中很难至少是性能方面很难高性能的运行。基于c++的庞大代码库会导致动态链接器需要做很多工作，而且速度相当慢。 在发布macOS 10.0(Cheetah)前，苹果为dyld增加了一个特性，即Prebinding预绑定。预绑定会尝试查找每个系统dylib和程序二进制文件中需要修正地址，然后动态加载程序会尝试加载所有这些地址中需要的文件，如果加载成功，它会编辑所有的二进制文件，使用预计算地址替换需要修正的地址。这样当下一次需要加载到相同的地址时，就不需要做任何额外的工作了。这大大加快了启动速度，但这意味着我们在每次启动时都要编辑你的二进制文件，这不仅不安全，也会有一些其它的问题。 dyld 2 (2004-2007)鉴于dyld已经不能满足软件需要，并且也会有安全问题等等的问题。dyld 2作为苹果macOS Tiger的一部分被出了。dyld 2 是对dyld的完全重写，可以正确支持C++ initializer语义，同时扩展了mach-o格式并更新dyld,以获得了高效率C++库的支持。dyld 2使用正确的语义完整实现了本地的dlopen和dlsym功能，由此苹果弃用了传统API。dyld 2 是为提升速度而设计，因此只有有限的完整性检查，当时不像今天有这么多的恶意软件。也正因为只有有限的完整性检查，dyld 2会有安全问题，为此苹果不得不重新调整一些功能，使它在今天的平台上更安全。最后由于启动速度的大幅提升，我们可以减少Prebinding的工作量。相较于dyld 1的编辑程序数据，现在仅会编辑系统库，且可以仅在软件更新时做这些事情。现在Prebinding被用于所有的优化，但那是推动力。因此在软件更新过程中，可能会看到“优化系统性能”类似的文字。这就是在更新时进行Prebinding。当今这已被用于所有的优化。 dyld 2.x (2007-2017)相较于 dyld 2，过去的几年里我们做了很多非常重要的改进。 1、首先，我们添加了大量的架构和平台。 自从dyld 2在PowerPC发布之后，增加了x86、x86_64、arm、arm64和许多的衍生平台。 还推出了iOS、tvOS和watchOS，这些都需要新的dyld功能 2、通过多种方式增加安全性 增加 codeSigning代码签名 ASLR（Address space layout randomization）地址空间配置随机加载：每次加载库时，可能位于不同的地址 bound checking边界检查：mach-o文件中增加了Header的边界检查功能，从而避免恶意二进制数据的注入 3、提升性能 用share cache共享缓存完全替代prebinding。share cache是一个包含大多数系统dylibs的单一文件，由苹果在iOS 3.1和macOS Snow Leopard中引入。由于是单一文件，我们可以以下通过多种方式优化： 重新排列二进制文件以提高加载速度 预链接dylibs 预构建dyld和obc在运行时使用的数据结构 尽管dyld 2.x已经有了比较多的改进，但是仍有一些不足： 1、首先，性能方面：针对一些不能复现的场景，我们希望能采集到启动速度全面的数据。除此之外，我们还在思考，怎样最小化或者理论上最小化app启动过程中的工作量，以及我们要怎样实现这一目标； 2、其次，安全方面：如前所述，苹果在dyld 2中通过多种方式增加了安全性。但是后面再想增加更多安全性已经很困难了，因此需要有更积极的安全检查，也需要预先为安全方面。 3、最后，可测试性和可靠性：苹果发布了大量优秀的测试框架，例如XCTest，这些框架都依赖于动态链接器的底层功能来将这些库插入到进程中，从根本上说不能用于测试现有的dyld代码，所以很难验证其安全性和性能。 dyld 3 (2017-至今)鉴于以上原因，苹果在2017年WWDC推出了全新的动态链接器，dyld 3。dyld 3是苹果对动态连接的一次全新思考。2017 年开始Apple OS平台上的所有系统程序都已经默认使用dyld 3。iOS 13 开始 Apple 对三方 App 启用了 dyld3。 那么dyld 3相比 dyld 2是怎么做优化的呢？要回答这个问题，需要先简要介绍分别介绍一下app的启动流程。 用户点击图标之后，会发送一个系统调用 execve 到内核，内核创建进程。接着会把主二进制 mmap 进来，读取 load command 中的LC_LOAD_DYLINKER，找到 dyld 的的路径。然后 mmap dyld 到虚拟内存，找到 dyld 的入口函数_dyld_start，把 PC 寄存器设置成_dyld_start，接下来启动流程交给了 dyld。 dyld 2的工作流程图如下： 1、首先，dyld 会解析mach-o header，从中找到依赖的库。然后这些库也可能依赖其它库，所以dyld会不断递归找到所有依赖的库，并形成一张动态库的依赖图。一个iOS应用平均3 到 600 动态链接库，所以这个步骤包含了较大的工作量。 2、接着dyld会把依赖的动态库映射到应用地址空间。 3、然后开始符号查找，比如，如果我们的应用使用了printf函数，dyld会从系统库中找到函数地址。 4、下一步，会对每个 Mach-O 做 fixup，包括 Rebase 和 Bind。 Rebase：修复内部指针。这是因为引入用了ASLR后， Mach-O 在 mmap 到虚拟内存的时候，起始地址会有一个随机的偏移量 slide，需要把内部的指针指向加上这个 slide。 Bind：修复外部指针。这个比较好理解，因为像 printf 等外部函数，只有运行时才知道它的地址是什么，bind 就是把指针指向第三步中找到的函数地址。 5、最后，我们可以运行所有的initializers。 LibSystem Initializer：Bind &amp; Rebase 之后，首先会执行 LibSystem 的 Initializer，做一些最基本的初始化，包括：初始化 libdispatch、初始化 objc runtime，注册 sel，加载 category Load &amp; Static Initializer：接下来会进行 main 函数之前的一些初始化，主要包括+load 和 static initializer。 dyld 2是纯粹的in-process，即在程序进程内执行的，也就意味着只有当应用程序被启动时，dyld 2才能开始执行任务。 相比dyld 2，dyld 3将安全敏感的部分和占用大量资源的部分移至进程外。 安全敏感部分：在苹果看来，最大的安全敏感部分是：Parse mach-o headers 和 Find dependencies。因为被撰改的mach-o headers存在被攻击的风险，另外如果我们项目中使用了@rpath（搜索路径），通过篡改这些篡改这些路径或在正确的地方插入库，人们可以破坏应用程序。 占用大量资源的部分：这里主要指的是symbol lookups。对于给定的库，除非执行了软件更新或更改了磁盘上的库，否则该库中的符号将始终处于相同的偏移量。所以这是可以缓存的。 以下是dyld 2 和 dyld 3流程对比： dyld 3主要被分为三个组件： 1、进程外的Mach-O分析器/编译器：负责预先处理所有可能影响启动速度的 search path、@rpaths 和环境变量，然后分析 Mach-O 的 Header 和依赖，并完成了所有符号查找的工作，最后将这些结果创建成了一个启动闭包。启动闭包是为了提升速度而生，是内存映射文件，不需要以任何复杂的方式解析，比Mach-O简单的多，它包含了启动app所需的一切。 2、一个启动闭包缓存服务：系统 App 的启动闭包被构建在前文提到的 Shared Cache 中， 我们甚至不需要打开一个单独的文件。对于第三方的 App，会系统库发生变化时，即 App 安装或者升级的时候构建启动闭包。所以默认情况下，在App运行之前，启动闭包就已经在iOS上预先构建了。 3、进程内执行启动闭包的引擎：这是进程内执行的部分，主要负责：验证启动闭包的安全性、映射 dylib 到内存、每个 Mach-O 做 fixup、以及Run initiazlizers最后跳转到 main 函数。相比dyld 2，不再需要解析 Mach-O 的 Header 和依赖，也不需要进行符号查找。因为这是启动流程中花费大部分时间的步骤，所以将会为你带来更快的应用启动。 dyld 3将安全敏感的部分和占用大量资源的部分移至进程之外，并创建一个启动闭包写到磁盘里。这样后续启动的时候，就可以直接读入缓存，不再需要调用进程外的mach-o解析器或编译器，进程内执行的操作尽可能少，从而增强应用程序安全性。这样也加快了启动速度，俗话说，最快的代码是从未编写的代码，紧随其后的是几乎从未执行的代码。mach-o解析器或编译器被移至进程外之后，就变成了是一个常规的daemon进程，苹果就可以使用测试框架来测试，也就能在未来更好地改进它。 main函数之后dyld 执行完毕之后， 会把启动流程交给 App，开始执行 main 函数。main 函数里要做的最重要的事情就是初始化 UIKit。UIKit 主要会做两个大的初始化：初始化 UIApplication 和 启动主线程的 Runloop。UIKit 初始化之后，就进入了我们熟悉的 UIApplicationDelegate 回调了。 Runloop线程在执行完代码就会退出，很明显主线程是不能退出的，那么就需要一种机制：事件来的时候执行任务，否则让线程休眠，Runloop 就是实现这个功能的。 Runloop 本质上是一个While 循环，在图中橙色部分的 mach_msg_trap 就是触发一个系统调用，让线程休眠，等待事件到来，唤醒 Runloop，继续执行这个 while循环。 Runloop 主要处理几种任务：Source0，Source1，Timer，GCD MainQueue，Block。在循环的合适时机，会以 Observer 的方式通知外部执行到了哪里。 那么，Runloop 与启动又有什么关系呢？ App 的 LifeCycle 方法是基于 Runloop 的 Source0 的 首帧渲染是基于 Runloop Block 的 Runloop 在启动上主要有几点应用： 精准统计启动时间 找到一个时机，在启动结束去执行一些预热任务 利用 Runloop 打散耗时的启动预热任务 Tips : 会有一些逻辑要在启动之后 delay 一小段时间再回到主线程上执行，对于性能较差的设备，主线程 Runloop 可能一直处于忙的状态，所以这个 delay 的任务并不一定能按时执行。 AppLifeCycleUIKit 初始化之后，就进入了我们熟悉的 UIApplicationDelegate 回调了，在这些会调里去做一些业务上的初始化： willFinishLaunch didFinishLaunch didFinishLaunchNotification 要特别提一下 didFinishLaunchNotification，是因为大家在埋点的时候通常会忽略还有这个通知的存在，导致把这部分时间算到 UI 渲染里。 First Frame Render一般会用 Root Controller 的 viewDidApper 作为渲染的终点，但其实这时候首帧已经渲染完成一小段时间了，Apple 在 MetricsKit 里对启动终点定义是第一个CA::Transaction::commit()。 什么是 CATransaction 呢？我们先来看一下渲染的大致流程。 回到过去的 CRT 显示器时期，CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。 了解了显示器的显示原理之后，我们来看下渲染的大致流程。通常来说，渲染是由计算机系统中 CPU、GPU、显示器按下图方式共同协同完成的。 1、首先，在VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。 2、app 本身并不负责渲染，渲染是在一个单独的进程 RenderServer 做的。在完成对显示内容的计算之后，app通过 IPC 将渲染任务及相关数据进行打包并发送至 Render Server。 3、Render Server 主要执行 Open GL、Core Graphics 等相关程序处理完数据后再传递至 GPU。 4、GPU 进行变换、合成、渲染，渲染完成后将渲染结果放入帧缓冲区。 5、视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。 如果上述步骤串联执行，它们执行所消耗的时间将远远超过 16.67 ms。为了满足对屏幕的 60 FPS 刷新率的支持，需要将这些步骤进行分解，通过流水线的方式并行执行，如下图所示。 整个流水线一共有下面几个步骤： Handle Events：这个过程中会先处理点击事件，这个过程中有可能会需要改变页面的布局和界面层次。 Commit Transaction：此时 app 会通过 CPU 处理显示内容的前置计算，比如视图的创建、布局计算、图片解码、文本绘制等任务。之后将计算好的图层进行打包发给 Render Server。 Decode：打包好的图层被传输到 Render Server 之后，首先会进行解码。注意完成解码之后需要等待下一个 RunLoop 才会执行下一步 Draw Calls。 Draw Calls：解码完成后，Core Animation 会调用下层渲染框架（比如 OpenGL 或者 Metal）的方法进行绘制，进而调用到 GPU。 Render：这一阶段主要由 GPU 进行渲染。 Display：显示阶段，需要等 render 结束的下一个 RunLoop 触发显示。 Commit Transaction一般开发当中能影响到的就是 Handle Events 和 Commit Transaction 这两个阶段，这也是开发者接触最多的部分。Handle Events 就是处理触摸事件，而 Commit Transaction 这部分中主要进行的是：Layout、Display、Prepare、Commit 等四个具体的操作。 Layout：构建视图 这个阶段主要处理视图的构建和布局，具体步骤包括： 调用重载的 layoutSubviews 方法 创建视图，并通过 addSubview 方法添加子视图 计算视图布局，即所有的 Layout Constraint Display：绘制视图 这个阶段主要是交给 Core Graphics 进行视图的绘制，得到三角形、线段、顶点等数据，这部分信息被叫做图元（primitives）： 根据上一阶段 Layout 的结果创建得到图元信息。 如果重写了 drawRect: 方法，那么会调用重载的 drawRect: 方法，在 drawRect: 方法中手动绘制得到 bitmap 数据，从而自定义视图的绘制。 注意正常情况下 Display 阶段只会得到图元 primitives 信息，而位图 bitmap 是在 GPU 中根据图元信息绘制得到的。但是如果重写了 drawRect: 方法，这个方法会直接调用 Core Graphics 绘制方法得到 bitmap 数据，同时系统会额外申请一块内存，用于暂存绘制好的 bitmap。 由于重写了 drawRect: 方法，导致绘制过程从 GPU 转移到了 CPU，这就导致了一定的效率损失。与此同时，这个过程会额外使用 CPU 和内存，因此需要高效绘制，否则容易造成 CPU 卡顿或者内存爆炸。 Prepare：Core Animation 额外的工作 这一步主要是：图片解码和转换 Commit：打包并发送 这一步主要是：图层打包并发送到 Render Server。 启动pipeline详细回顾下整个启动过程，以及各个阶段耗时的影响因素： 1、用户点击图标之后，会发送一个系统调用 execve 到内核，内核创建进程； 2、接着会把主二进制 mmap 进来，读取 load command 中的LC_LOAD_DYLINKER，找到 dyld 的的路径，本阶段影响启动速度的因素主要是主二进制大小，可以通过下线代码来优化； 3、然后 mmap dyld 到虚拟内存，找到 dyld 的入口函数_dyld_start，把 PC 寄存器设置成_dyld_start，接下来启动流程交给了 dyld。 4、重启手机/更新/下载 App 的第一次启动，会创建启动闭包，并存储在沙盒的 tmp/com.apple.dyld 目录。闭包包含的内容有： dependends，依赖动态库列表 fixup：bind &amp; rebase 的地址 initializer-order：初始化调用顺序 optimizeObjc: Objective C 的元数据 其他：main entry, uuid… 本阶段影响启动速度的因素主要有：依赖的动态库数量、需要修正（fix-up）的指针数量和Objective-C类的数量等，可以通过减少动态库数量、减少指针数量和下线代码的方式进行优化。 5、有了闭包之后，就可以用闭包启动 App 了。这时候很多动态库还没有加载进来，会首先对这些动态库 mmap 加载到虚拟内存里，可以通过减少动态库数量来优化启动速度； 6、接着会对每个 Mach-O 做 fixup，包括 Rebase 和 Bind； Rebase：修复内部指针。这是因为引入用了ASLR后， Mach-O 在 mmap 到虚拟内存的时候，起始地址会有一个随机的偏移量 slide，需要把内部的指针指向加上这个 slide。 Bind：修复外部指针。这个比较好理解，因为像 printf 等外部函数，只有运行时才知道它的地址是什么，bind 就是把指针指向第三步中找到的函数地址。 Rebase/Binding阶段时间主要耗费在Page In 和计算上，可以通过下线代码、二进制重排和减少指针数量来减少Page In的次数和计算量。对于单次Page In，因为App Store 会对上传的 App 的 TEXT 段加密，在发生 Page In 的时候会解密，解密的过程是很耗时的，所以可以通过 rename_section 重命名，把 TEXT 段中的内容移动到其它段来优化（这个优化方式在 iOS 13 下有效，因为 iOS 13 优化了解密流程，Page In 的时候不需要解密了，这是 iOS 13 启动速度变快的原因之一。）。 7、Bind &amp; Rebase 之后，首先会执行 LibSystem 的 Initializer，做一些最基本的初始化： 初始化 libdispatch 初始化 objc runtime，注册 sel，加载 category 这里没有初始化 objc 的类方法等信息，是因为启动闭包的缓存数据已经包含了 optimizeObjc。 本阶段主要可以通过减少Class、selector 和 category 这些元数据的数量来进行优化，即下线代码。 8、接下来会进行 main 函数之前的一些初始化，主要包括+load 和 static initializer。想要查看代码里有哪些 load 和 static initializer，可以在 Build Settings 里可以配置 write linkmap，这样在生成的 linkmap 文件里就可以找到有哪些文件里包含 load 或者 static initializer： __mod_init_func，static initializer __objc_nlclslist，实现+load 的类 __objc_nlcatlist，实现+load 的 Category 不是所有的 static 变量都会产生static initializer，对于在编译期间就能确定的变量是会直接 inline。会导致静态初始化的代码有： __attribute__((constructor)) static class object static object in global namespace 静态初始化和 +load 方法除了方法本身的耗时，还会引起大量 Page In，可以通过+load 迁移和静态初始化迁移的方式来进行优化。 9、接着，dyld 会把启动流程交给 App，开始执行 main 函数，main 函数调用了UIApplicationMain 函数来初始化 UIKit。UIKit 主要会做两个大的初始化： 初始化 UIApplication 启动主线程的 Runloop 10、UIKit 初始化之后，基于 Runloop 的 Source0 的 App LifeCycle 方法就被触发了。在这些会调里去做一些业务上的初始化： willFinishLaunch didFinishLaunch didFinishLaunchNotification 在生命周期回调里主要执行的是App自身的代码，主要可以通过Xcode里的Time Profiler、System Trace、os_signpost、Static Initializer、App Launch等来检测并发现耗时部分，并针对性优化。主要优化的方向有：使用启动器来管理任务的顺序和线程、下线或者联系提供方优化耗时的三方SDK、优化高频次方法、线程阻塞、线程数量等。 11、Layout，这个阶段主要处理视图的构建和布局。在didFinishLaunch方法中我们会初始化keyWindow 并设置 rootViewController。当第一次访问rootViewController的view时会调用view的get方法，进而调用loadView来创建UIViewController的view。view创建完毕加载到内存后会调用viewDidLoad方法，在viewDidLoad方法中进行页面布局，接着调用Layoutsubviews； 12、Display，这个阶段主要是交给 Core Graphics 进行视图的绘制，得到三角形、线段、顶点等图元数据。如果重写了 drawRect: 方法，那么会调用重载的 drawRect: 方法； 13、prepare，这个阶段主要是图片解码和转换； 14、commit，这个阶段主要是打包 Render Tree 通过 XPC 的方式发给 Render Server。这也是是Apple 在 MetricsKit 里对启动终点的定义，即第一个CA::Transaction::commit()。首帧渲染是基于 Runloop Block 的，可以基于Runloop来精准统计启动时间。11、12、13、14 四步统称为Commit Transaction。 15、随后，请求网络并更新数据，至此整个启动流程结束。 优化动态库减少动态库数量可以加减少启动闭包创建和加载动态库阶段的耗时，官方建议动态库数量小于 6 个。 推荐的方式是动态库转静态库，因为还能额外减少包大小。另外一个方式是合并动态库，但实践下来可操作性不大。最后一点要提的是，不要链接那些用不到的库（包括系统），因为会拖慢创建闭包的速度。 下线代码下线代码首先要筛选出用不到的代码，一般的无用代码筛查方式可以分为动态和静态两种方式。静态的方式主要是通过代码扫描、参与编译构建过程或者分析最终产物来确认哪些代码没有被用到。而动态的方式主要是靠插桩或者运行时信息来获取哪些代码没有执行。由于 Objc 强大的动态特性，我们在样本量足够大的场景使用动态方式会比静态方式准确率高很多。 静态筛查筛查方案： 最简单的静态扫描是基于 AppCode，但是项目大了之后 AppCode 的索引速度非常慢。另一种方式是基于 Mach-O 的的一种静态扫描方式，在 otool dump 最终产物中的 __objc_class_list &amp; __objc_class_refs 做差集找到未使用的 Objc 类。 如果代码采用 C 、C++ 等静态语言编写代码时，编译期已经确定了基本的代码逻辑，编译器会帮助我们将没有使用到的代码标记为 Dead code 最终不会打包到安装包中。但 Objc 是典型的动态语言，很多逻辑都是在运行时决议的，我们通过静态扫描的方式扫描出来的误差会比较大。 Objc 动态特性引入的的主要的问题包括： 实际用到了但被扫描成无用类： 一个类确实没有被其他地方使用， 但是本身逻辑依赖 +load、+initialize、__attribute__((constructor))在启动时调用 通过 string 动态调用 抽象基类、基类等会被认为是无用类 通过运行时动态生成的代码引用了某个类 一个类专门作为通知处理类 MTLModel 等，通过运行时消息机制 assign value 的无法通过 classref 统计 典型的 DI 场景。如果一个类声明遵循了某个 Protocol，外部使用的时候使用了这个 Protocol 进行方法调用 实际没用到但被认为有用到： 某个对象被另外一个对象引用，但是另外一个对象本身未被使用到。这时候会遗漏掉这个对象所属 Class 的检查 动态筛查方案： 基于插桩的行级别代码覆盖率 基于 GCOV 或者 LLVM Profile 二进制的插桩方案可以实现在运行时收集插桩数据来指导无用代码的删除。但插桩方案局限性也显而易见，插桩会劣化二进制本身的大小和性能，同时原生的插桩方案是无法过审上线。数据收集只能局限于线下。 基于 Runtime 的轻量级运行时「类覆盖率」方案 Objc 的类首次调用类初始化时，+initialize被执行，系统会自动标记已被调用，在 metaClass 中 data 的 flags 字段第 29 位就存着这个这个状态。可以使用 flags &amp; RW_INITIALIZED获取。iOS14 之后这个值的获取方式有变化。具体参考：WWDC：Advancements in the Objective-C runtime 1234#define RW_INITIALIZED (1&lt;&lt;29)bool isInitialized() &#123; return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;&#125; 上报的数据可以让我们了解我们线上真实的 Class 使用情况，对得到的数据不仅可以用来删减未使用的代码。还可以分辨使用率低的场景，如果是低频且必须的场景可以考虑使用跨端技术这种对原生包大小影响比较小的方案实现。而如果这些场景是某个渗透率很低的需求可以考虑直接下线为其他需求做置换。 +load 迁移和静态初始化迁移每当一个类或类别被添加到Objective-C runtime都会调用+load方法，可以通过实现此方法以在加载时执行类特定的行为。 初始化顺序如下: 主二进制中链接的所有framework中的initializers 主二进制中所有的+load方法 主二进制中所有的 C++ static initializers 和C/C++ __attribute__(constructor) 方法 链接主二进制的所有framework中的initializers 如果类或者分类实现了+load方法，那么当该类或者分类被动态加载或者静态链接的时候，+load方法就会被调用，与这个类是否被用到无关，且+load方法只会被调用一次。调用顺序为父类-&gt;子类-&gt;分类，当子类未实现+load方法时，不会显示调用父类+load方法，当有多个Category都实现了load方法，这几个load方法都会执行，但执行顺序不确定，其执行顺序与Category在Compile Sources中出现的顺序一致。 +load 和静态初始化除了方法本身的耗时，还会引起大量 Page In，另外 +load 的存在对 App 稳定性也是冲击，因为 Crash 了捕获不到。所以如果可以应尽量减少+load和静态初始化。 对+load，迁移思路有： 1、使用+initialize替代 2、将一些绑定相关代码，利用 clang attribute，这个过程可以迁移到编译期 针对静态初始化，典型的迁移思路有： 1、将std:string 转换成 const char * 2、静态变量移动到方法内部，因为方法内部的静态变量会在方法第一次调用的时候初始化 main函数之后main函数之后可以通过Xcode里的Time Profiler、System Trace、os_signpost、Static Initializer、App Launch等来检测并发现耗时部分，并针对性优化。主要优化的方向有： 使用启动器为什么需要启动器呢？ 全局并发调度：比如 AB 任务并发，C 任务等待 AB 执行完毕，框架调度还能减少线程数量和控制优先级 延迟执行：提供一些时机，业务可以做预热性质的初始化 精细化监控：所有任务的耗时都能监控到，线下自动化监控也能受益 管控：启动任务的顺序调整，新增/删除都能通过 Code Review 管控 三方 SDK针对测量发现的启动耗时很高的三方 SDK ，可以考虑下线。如果不能下线，应确认是否可以延迟，比如分享和登录的 SDK都是可以延迟。此外，在接入 SDK 之前可以先评估下对启动性能的影响，如果影响较大是可以反馈给 SDK 的提供方去修改的，尤其是付费的 SDK，他们其实很愿意配合做一些修改。 高频次方法有些方法的单个耗时不高，但是在启动路径上会调用很多次的，这种累计起来的耗时也不低。这种问题在 TimeProfiler 里时间段选长一些往往就能发现，发现之后可以针对性进行优化。 锁锁之所以会影响启动时间，是因为有时候子线程先持有了锁，主线程就需要等待子线程锁释放。还要警惕系统会有很多隐藏的全局锁，比如 dyld 和 Runtime。可以借助System Trace来及时发现。 线程数量线程的数量和优先级都会影响启动时间。可以通过设置 QoS 来配置优先级，两个高优的 QoS 是 User Interactive/Initiated，启动的时候，需要主线程等待的子线程任务都应该设置成高优的。 高优的线程数量不应该多于 CPU 核心数量，可以通过 System Trace 的 System Load 来分析这种情况。 123456/GCDdispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, -1);dispatch_queue_t queue = dispatch_queue_create(\"com.custom.utility.queue\", attr);//NSOperationQueueoperationQueue.qualityOfService = NSQualityOfServiceUtility复制代码 线程的数量也会影响启动时间，但 iOS 中是不太好全局管控线程的，比如二/三方库要起后台线程就不太好管控，不过业务上的线程可以通过启动任务管控。 线程多没关系，只要同时并发执行的不多就好，大家可以利用 System Trace 来看看上下文切换耗时，确认线程数量是否是启动的瓶颈。 图片启动难免会用到很多图，有没有办法优化图片加载的耗时呢？ 用 Asset 管理图片而不是直接放在 bundle 里。Asset 会在编译期做优化，让加载的时候更快，此外在 Asset 中加载图片是要比 Bundle 快的，因为 UIImage imageNamed 要遍历 Bundle 才能找到图。加载 Asset 中图的耗时主要在在第一次张图，因为要建立索引，可以通过把启动的图放到一个小的 Asset 里来减少这部分耗时。 每次创建 UIImage 都需要 IO，在首帧渲染的时候会解码。所以可以通过提前子线程预加载（创建 UIImage）来优化这部分耗时。 如下图，启动只有到了比较晚的阶段“RootWindow 创建”和“首帧渲染”才会用到图片，所以可以在启动的早期开预加载的子线程启动任务。 Fishhookfishhook 是一个用来 hook C 函数的库，但这个库的第一次调用耗时很高，最好不要带到线上。Fishhook 是按照下图的方式遍历 Mach-O 的多个段来找函数指针和函数符号名的映射关系，带来的副作用就是要大量的 Page In，对于大型 App 来说在 iPhone X 冷启耗时 200ms+。 如果不得不用 fishhook，请在子线程调用，且不要在在_dyld_register_func_for_add_image直接调用 fishhook。因为这个方法会持有 dyld 的一个全局互斥锁，主线程在启动的时候系统库经常会调用 dlsym和 dlopen，其内部也需要这个锁，造成上文提到的子线程阻塞主线程。 首帧渲染不同 App 的业务形态不同，首帧渲染优化方式也相差的比较多，几个常见的优化点： LottieView：lottie 是 airbnb 用来做 AE 动画的库，但是加载动画的 json 和读图是比较慢的，可以先显示一帧静态图，启动结束后再开始动画，或者子线程预先把图和 json 设置到 lottie cache 里 Lazy 初始化 View：不要先创建设置成 hidden，这是很不好的习惯 AutoLayout：AutoLayout 的耗时也是比较高的，但这块往往历史包袱比较重，可以评估 ROI 看看要不要改成 frame Loading 动画：App 一般都会有个 loading 动画表示加载中，这个动画最好不要用 gif，线下测量一个 60 帧的 gif 加载耗时接近 70ms 其他 Tips启动优化里有一些需要注意的 Tips： 不要删除tmp/com.apple.dyld目录，因为这个目录下存储着 iOS 13+ 的启动闭包，如果删除了下次启动会重新创建，创建闭包的过程是很慢的。接下来是 IO 优化，常见的方式是用 mmap让 IO 更快一些，也可以在启动的早期预加载数据。 还有一些 iPhone 6 上耗时会明显增加的点： WebView User Agent：第一次在启动时获取，之后缓存，每次启动结束后刷新 KeyChain：可以延迟获取或者预加载 VolumeView：建议直接删掉 iPhone 6 是个分水岭，性能会断崖式下跌，可以在 iPhone 6 上下掉部分用户交互来换取核心体验（记得 AB 验证）。 Page In 耗时启动路径上会触发大量 Page In，优化这部分耗时有两个方向：一个是减少Page In数量 – 二进制重排 ，一种是减少单次Page In耗时 – 段重命名。 二进制重排 启动具有局部性特征，即只有少部分函数在启动的时候用到，这些函数在中的分布是零散的，所以 Page In 读入的数据利用率并不高。如果我们可以把启动用到的函数排列到二进制的连续区间，那么就可以减少 Page In 的次数，从而优化启动时间： 以下图为例，方法 1 和方法 3 是启动的时候用到的，为了执行对应的代码，就需要两次 Page In。假如我们把方法 1 和 3 排列到一起，那么只需要一次 Page In，从而提升启动速度。 链接器 ld 有个参数-order_file 支持按照符号的方式排列二进制。 获取启动时候用到的符号主流有两种方式： 静态扫描获取 +load 和 C++静态初始化，hook objc_msgSend 获取 Objective C 符号。参考：https://mp.weixin.qq.com/s/Drmmx5JtjG3UtTFksL6Q8Q LLVM 函数插桩，灰度统计启动路径符号，用大多数用户的符号生成 order_file。参考：https://juejin.cn/post/6844904130406793224 段重命名 App Store 会对上传的 App 的 TEXT 段加密，在发生 Page In 的时候会解密，解密的过程是很耗时的。既然会 TEXT 段加密，那么直接的思路就是把 TEXT 段中的内容移动到其它段，ld 也有个参数 rename_section支持重命名： 抖音重命名方案： 1234567\"-Wl,-rename_section,__TEXT,__cstring,__RODATA,__cstring\",\"-Wl,-rename_section,__TEXT,__const,__RODATA,__const\",\"-Wl,-rename_section,__TEXT,__gcc_except_tab,__RODATA,__gcc_except_tab\",\"-Wl,-rename_section,__TEXT,__objc_methname,__RODATA,__objc_methname\",\"-Wl,-rename_section,__TEXT,__objc_classname,__RODATA,__objc_classname\",\"-Wl,-rename_section,__TEXT,__objc_methtype,__RODATA,__objc_methtype\"复制代码 这个优化方式在 iOS 13 下有效，因为 iOS 13 优化了解密流程，Page In 的时候不需要解密了，这是 iOS 13 启动速度变快的原因之一。 详情请参考：https://juejin.cn/post/6911121493573402638 参考： 抖音品质建设 - iOS启动优化《原理篇》 iOS 优化篇 - 启动优化之Clang插桩实现二进制重排 程序的链接和装入及linux下动态链接的实现 iOS 优化篇 - 启动优化之Clang插桩实现二进制重排 iOS 渲染原理解析 抖音品质建设 - iOS 安装包大小优化实践篇","categories":[{"name":"性能优化","slug":"性能优化","permalink":"http://heseng91.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"「性能优化」之包体大小","slug":"「性能优化」之包体大小","date":"2018-10-01T02:10:33.000Z","updated":"2023-02-12T09:34:06.931Z","comments":true,"path":"2018/10/01/「性能优化」之包体大小/","link":"","permalink":"http://heseng91.github.io/2018/10/01/%E3%80%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8B%E5%8C%85%E4%BD%93%E5%A4%A7%E5%B0%8F/","excerpt":"安装包大小是 App 重要的基础体验指标之一，与新用户转化直接相关。本文内容包括苹果的对包大小的限制等背景介绍、安装包分析和一些优化措施等。阅读本文之后，你将对安装包优化有一个整体的认知。","text":"安装包大小是 App 重要的基础体验指标之一，与新用户转化直接相关。本文内容包括苹果的对包大小的限制等背景介绍、安装包分析和一些优化措施等。阅读本文之后，你将对安装包优化有一个整体的认知。 背景下载大小限制App 大小有下载大小和安装大小的概念。 下载大小是指 App 压缩包（也就是 .ipa 文件）所占的空间，用户在下载 App 时，下载的是压缩包，这样做可以节省流量；当压缩包下载完成后，就会自动解压，解压过程也就是通常所说的安装过程；安装大小就是指压缩包解压后所占用的空间。 安装大小在 App Store 上就可以看见 ，通常它会影响用户的下载意愿。而下载大小只有研发人员在 App Store Connect 后台才可以看，用户看不见，它影响的是下载消耗的流量和时长。若下载大小超过限制，将无法使用蜂窝网络下载 App（ iOS 13 之前），会收到文件容量太大的提示，需通过 Wi-Fi 网络下载。如下，为苹果历年来对 App 下载大小限制的变化情况： 2008 年 7 月，搭载了 App Store 的 iPhone 3G 正式发售，下载限制仅为 10 MB 2010 年 2 月，苹果将 iPhone 3G 的下载限制从 10 MB 提升到 20 MB 2012 年 3 月，iOS 5.1 正式版后，下载限制从 20 MB 提升到 50 MB 2013 年 9 月，iOS 7 正式版后，下载限制从 50 MB 提升至 100 MB 2017 年 9 月，iOS 11 正式版后，下载限制从 100 MB 提升至 150 MB 2019 年 5 月，下载限制从 150 MB 提升至 200 MB 2019 年 9 月，iOS 13 正式版后，若下载大小超过 200 MB，用户可选择是否使用蜂窝网络下载 如今，App 下载大小超出 200 MB 时 ，会出现两种情况： iOS 13 以下的用户，无法通过蜂窝数据下载 App iOS 13 及以上的用户，需要手动设置才可以使用蜂窝网络下载 App 可见下载大小若超出 200 MB，就会对用户新增会有一定影响，因此下载大小 200 MB 是包大小的一根红线。 可执行文件大小限制根据最大构建版本文件大小描述，苹果对可执行文件大小亦有明确限制，超过该限制会导致 App 审核被拒： 12ERROR: ERROR ITMS-90122: &quot;Invalid ExecutaBe Size. The size of your app&#39;s executaBe file &#39;News.app&#x2F;News&#39; is 68534272 bytes for architecture &#39;arm64&#39;, which exceeds the maximum allowed size of 60 MB.&quot;复制代码 具体限制如下： iOS 7 之前，二进制文件中所有的 __TEXT段总和不得超过 80 MB iOS 7.X 至 iOS 8.X ，二进制文件中，每个特定架构中的 __TEXT段不得超过 60 MB iOS 9.0 之后，二进制文件中所有的 __TEXT段总和不得超过 500 MB 安装包分析本文探讨的是优化，说到优化最重要的是要做到白盒优化，知道安装包的构成，才能针对性的进行优化。 安装包构成对通过 Archieve 打包的安装包 unzip 解压之后，就能看到 payload 中 app 文件的数据，\b整理归类后其大致如下： Exectutable: 可执行文件 Resources：资源文件 图片资源：Assets.car/bundle/png/jpg 等 视频/音频资源：mp4/mp3 等 静态网页资源：html/css/js 等 视图资源：xib/storyboard 等 其他：文本/字体/证书 等 Framework：项目中使用的动态库 SwiftSupport: libSwiftxxx 等一系列 Swift 库 其他依赖库：Embeded Framework Pulgins：Application Extensions appex：其组成大致与 ipa 包组成一致 从以上结构中可以看出一个 ipa 包\b大致由 Executable, Resources, Framework,Plugins 四大模块组成，\b接下来我们就从这四个方向来探讨 App 瘦身的\b具体方案。 安装包分析通过分析安装包，了解安装包中可执行文件占用大小、资源占用大小，了解安装包的现状。才能明确从哪里入手可以获得 ROI 最高的优化手段。 而在做包大小分析过程中比较难的是，怎么样通过线下的安装包衡量对下载大小的影响。 App Slicing鉴于早期网络的不普及和比较高的流量费用，苹果对下载大小和可执行文件大小有着上文所述的限制。于此同时，为了提升用户体验和节省用户流量，苹果也为 App安装包大小提供了很多优化方式。 iOS 9 中引入的 App Thinning 中提到过 Slicing 的技术，当我们把一个完整的安装包提交给 AppStore Connect后，Apple 会为不同的设备准备不同的变体（Variant），设备的在下载 App 的时候它能根据设备的处理器架构（arm64, armv7）、屏幕分辨率（2x, 3x）、iOS 系统版本等信息，帮助我们自动选择合适的 Variant 进行下载。 可执行文件的 Slicing 技术就是对不同架构进行裁剪，只剩下单架构可执行文件。同样资源文件也是支持 Slicing 的。比如 iPhone 6 下载的安装包中就只会包含 2x 图，iPhone 6 Plus 下载的安装包就只会包含 3x 图，但是只有使用 asset catelogs(也就是 XCAssets) 管理的资源才支持 Slicing，所以尽量还是使用 XCAsset 来管理资源图片。同时 XCAsset 也支持 PDFs 矢量图，在上传到 AppStore Connect之后，会根据矢量图自动生成 1x, 2x, 3x 图，然后进行 Slicing。 加密除了上述调整之外，安装包被提交到 AppStore Connect后，出于安全考虑，苹果还会对安装包的二进制部分TEXT 段通过 FirePlay 进行加密，加密会导致 TEXT 段的压缩比为 1（ iOS 13+ 以上设备下载变体中苹果移除了这个加密 ）。 这些调整也导致了线下安装包的变化无法对应到真正的下载大小变化的变更，很难用线下构建的安装包来量化最终对下载大小的影响。想要查看不同机型的安装包下载大小，只能打包上传AppStore Connect后查看。 可执行文件瘦身安装包中的可执行文件，占了安装包中很大一部分空间，而这部分不光和代码有关还和编译、链接过程中添加的参数，编译的机器环境、Xcode 版本等等都有关系。 编译选项编译期优化参数Xcode 支持编译器层面的一些优化选项，可以让我们介于更快的编译速度和更小的二进制大小并且更快的执行速度之间自由选择想要进行的\b优化粒度。 我们都知道 Xcode 是使用 Clang 来编译 Objective-C 语言的，\bClang 的优化选项在其文档 clang - Code Generation Options 中可以查阅得到。我们Xcode 目前提供给我们 7 个等级的编译选项，在 Xcode -&gt; Build Setting -&gt; Apple clang - Code Generation -&gt; Optimization Level 中进行设置\b，每个等级的说明，可以参考\b官方文档： None[-O0]: 编译器不会优化代码，\b意味着更快的编译速度和更多的调试信息，默认在 Debug 模式下开启。 Fast[-O,O1]: 编译器会优化代码性能并且最小限度影响编译时间，此选项在编译时会\b占用更多的内存。 Faster[-O2]：编译器会开启不依赖空间/时间折衷所有优化选项。在此，编译器不会展开循环或者函数内联。此选项会增加编译时间并且提高代码执行效率。 Fastest[-O3]：编译器会开启所有的\b优化选项来提升代码执行效率。此模式\b编译器会执行函数内联使得生成的可执行文件变得更大。一般不推荐使用此模式。 Fastest Smallest[-Os]：编译器会开启除了会明显增加包大小以外的所有优化选项。默认在 Release 模式下开启。 Fastest, Aggressive Optimization[-Ofast]：启动 -O3 中的所有优化\b，可能会开启一些违反语言标准的一些优化选项。一般不推荐使用此模式。 Smallest, Aggressive Optimization[-Oz]：编译器会对单个编译单元中跨函数的相同代码序列外联成函数进行复用，和“内联函数”的原理正好相反。每个原始代码序列都被替换为调用该 Outlined 函数。会减小相同代码存在多份问题。开启此模式\b，能减小二进制的大小，但同时也会使得的函数调用存在更深的调用栈，理论上会带来执行效率的额外消耗，对性能（CPU）敏感的代码使用需要评估。WWDC 2019 《What’s New in Clang and LLVM》 中对 Oz 有过介绍。 Fastest Smallest[-Os] 极小\b限度会影响到包大小，而且也保证了\b代码的执行效率，是最佳的发布选项。一般 Xcode 会在 Release 下默认选择 Fastest Smallest[-Os] 选项，较老的项目可能没有自动勾选。 XCode 中设置的选项最终会反应在 Clang 命令上面，打开 build log 可以看到此选项最终的表现形式： 如果你还需要 clang 的其他选项来编译你的项目，可以在 Other C Flag 中直接添加其参数。\b举例来说，在 Optimization Level 中设置 Fastest Smallest[-Os] 和在 Other C Flags 中添加 -Os 效果是一样的。 对执行效率、堆栈解析、稳定性和编译速度进行综合评估后，如果可以接受，可以对部分源代码开启Oz 编译，以最大程度优化安装包效果。 需要注意的是在 ARC 场景 objc_retainAutoreleaseReturnValue 被外联之后会导致一个本来不需要被放入 autoreleasepool 中的对象被放入了 autoreleasepool。这将导致一些有问题的写法出现更坏的结果比如出现延迟释放导致 BAD_ACCESS 或者被 @autoreleasepool包裹的对象延时释放导致的内存暴涨，所以在开启的时候需要进行测试。 链接期优化参数除了编译期优化，Xcode 还支持链接器层面的一些优化选项，可以在 Xcode -&gt; Build Setting -&gt; Apple clang - Code Generation -&gt; Link-Time Optimization 中进行设置。目前Xcode提供了以下选项： No：不开启链接期优化； Monolithic：生成单个 LTO 文件，每次链接重新生成，无缓存高内存消耗，参数 LLVM_LTO=YES； Incremental：生成多个 LTO 文件，增量生成，低内存消耗，参数 LLVM_LTO=YES_THIN； 本地调试和对时间敏感的构建流程不建议开启 LTO。会增加很多的构建时间。 需要注意的是 LTO 虽然是链接期优化，但是仍然需要编译期参与，加入了 LTO 的编译出来的 .a 本质是 LLVM 的 BitCode，如果使用未开启 LTO 构建出来的的 .a 直接是机器码了。直接链接是无法完成 LTO 优化的。 开启 LTO 之后跨编译单元的重复代码会被链接器单独生成以 .lto.o为后缀的目标文件进行链接。尤其是对于 Objc Runtime 需要的一些结构 比如方法签名的 literal string， protocol 的结构等有比较大的优化。同时开启 Oz 和 LTO 可以让外联函数都只存在一份能够最大限度的优化安装包体积。如果你的项目中大量的使用了 Protocol 建议还是开启这个选项。 BitCodeBitCode 是 iOS 9 引入的新特性，官方文档解释 BitCode 是一种程序中间码，其实就是 LLVM IR 的一种编码形式 - BitCodeFormart。 上图\b表示了 IR 和 BitCode 在编译器架构中所在的位置，需要说明的是 BitCode 是以 section 形式保存在可执行文件中。上文中提到的可执行文件的 Slicing 技术就是基于BitCode。当我们把携带 BitCode 的 App 提交到 AppStore 后，苹果会提取出可执行文件中的 BitCode 段，然后针对不同的 CPU 架构编译\b和链接成不同的可执行文件变体(Variant)，不同\b CPU 架构的设备会自动选择合适的架构的变体进行下载。而在 BitCode 之前，我们都是把所有需要的 CPU 架构集合打包成一个 Fat Binary，结果就是用户最终下载的安装包之中有很多冗余的\b CPU 架构支持\b代码。 从以上\b编译器\b架构中我们也可以得出一个结论：开启 BitCode 之后编译器后端(Backend)的工作都由 Apple 接管了。所以\b假如以后苹果推出了新的 CPU 架构或者以后 LLVM 推出了一系列优化，我们也不再需要为其发布\b新的安装包了。 需要注意的是，工程开启 BitCode 之后必须要求所有打进 Bundle 的 Binary 都需要支持 BitCode，也就是说我们\b依赖的静态库\b和动态库都是含有 BitCode 的，不然就会打包失败。 符号表的裁剪可执行文件中的符号是指程序中的所有的\b变量、类、函数、枚举、变量\b和地址映射关系，以及一些在调试的时候使用到的用于定位代码在源码中的位置的调试符号，符号和断点定位以及\b堆栈符号化有很重要的关系\b。 Strip StyleStrip Style 表示的是我们需要去除的符号的类型的选项，其分为三个选择项： All Symbols: 去除所有符号，一般是在主工程中开启。 Non-Global Symbols: 去除一些非全局的 Sy\bmbol（保留全局符号，Debug Symbols 同样会被去除），链接时会被重定向的那些符号不会被去除，此选项是静态库/动态库的建议选项。 Debug Symbols: 去除调试符号，去除之后将无法断点调试。 对于 App 的主二进制而言，对外是不需要暴露符号信息的。而对外暴露的符号名称对 App 整体安全来讲也存在一些风险。通常通过设置 STRIP_STYLE= all来裁剪所有符号。对于自己构建的动态库。只需要保留未定义的符号以及全局的符号其他的都可以去除。通常设置：STRIP_STYLE=non-global。 调试\b符号（symbols）iOS 的调试\b符号是 DWARF 格式的，相关概念如下： Mach-O: 可执行文件，源文件编译链接的结果。包含映射调试信息(对象文件)具体存储位置的 Debug Map。 DWARF：一种通用的调试文件格式，支持源码级别的调试，调试信息存在于 Object_file 中，一般都比较大。Xcode 调试模式下一般都是使用 DWARF 来\b进行符号化的。 dSYM：独立的\b符号表文件，主要用来做发布产品的崩溃符号化。dSYM 是一个压缩包，里面包含了 DWARF 文件。 使用 Xcode 编译打包的时候会先通过可执行文件的 Debug Map 获取到所有对象文件的位置，然后使用 dsymutil 来将对象文件中的 DWARF 提取出来生\b成 dSYM 文件。 Strip Linked Product If enabled, the linked product of the build will be stripped of symbols when performing deployment postprocessing. 并不是所有的符号都是必须的，比如 Debug \bMap，所以 Xcode 提供给我们 Strip Linked Product 来去除不需要的符号信息(Strip Style 中选择的选项相应的符号)，去除了符号信息之后我们就只能使用 dSYM 来进行符号化了，\b所以需要\b将 Debug Information Format 修改为 DWARF with dSYM file。 那么没有 DWARF 调试信息之后 Xcode 是靠什么来生成 dSYM 的呢？答案其实还是 DWARF，\b因为 Xcode \b编译实际的操作步骤是：生成带有 DWARF 调试信息的可执行文件 -&gt; 提取可执行文件中的调试信息\b打包成 dSYM -&gt; 去除符号化信息。去除符号是单独的步骤，使用的是 strip 命令。 另外一个问题是，去除符号化信息之后我们只能使用 dSYM 来进行符号化，那我们使用 Xcode 来进行调试的时候会不会太麻烦\b了？其实我们完全不用担心这个问题：Strip Linked Product 选项在 Deployment Postprocessing \b设置为 YES 的时候才生效，而\b在 Archive 的时候 Xcode 总是会把 Deployment Postprocessing 设置为 YES 。所以我们可以打开 Strip Linked Product 并且\b把 Deployment Postprocessing 设置为 NO\b，而不用担心调试的时候会影响断点和符号化，同时打包的时候又会自动去除符号信息。这个选项也是默认打开的，较老的项目可以选择手动开启。 Strip Debug Symbols During Copy Specifies whether binary files that are copied during the build, such as in a Copy Bundle Resources or Copy Files build phase, should be stripped of debugging symbols. It does not cause the linked product of a target to be stripped—use Strip Linked Product (STRIP_INSTALLED_PRODUCT) for that. \b与 Strip Linked Product 类似，但是这个是将那些拷贝进项目包的三方库、\b资源或者 Extension 的 Debug Symbol 去除掉，同样也是使用的 strip 命令。\b\b这个选项没有前置条件，所以我们只需要在 Release 模式下开启，不然就不能对\b三方库进行断点调试和符号化了。 如果依赖的 Target 是独立签名的（比如 App Extension），\bstrip 操作就会失效，\b并伴随着 Warning：warning: skipping copy phase strip, binary is code signed: xxxx。此情况将依赖的 Target 中的 Strip Linked Product 修改为 YES，保证依赖的 Target 是\b已经去除了符号即可，Waning 忽略掉就可以了。 Cocoapods 管理的动态库(use_framework!)的情况就相对要特殊一点，因为 Cocoapods 中的的动态库是使用自己实现的脚本 Pods-xxx-frameworks.sh 来实现拷贝的，所以并不会走 Xcode 的流程，当然也就不受 Strip Debug Symbols During Copy 的影响。当然 Cocoapods 是源码管理的，所以只需要将源码 Target 中的 Strip Linked Product 设置为 YES 即可。 Strip Swift Symbols Adjust the level of symbol stripping specified by the STRIP_STYLE setting so that when the linked product of the build is stripped, all Swift symbols will be removed. 开启 Strip Swift Symbols 能\b帮助我们移除相应 Target \b中的所有的 Swift 符号，\b这个选项也是默认打开的。 补充一点：Swift ABI 稳定之前，Swift 标准库是会打进目标文件的，想要同时移除 Swift 标准库\b里面的符号的话需要在发布选项中勾选 Strip Swift symbols。 修正 Exported Symbols 配置上面说到可以通过设置 STRIP_STYLE= all来裁剪所有符号。但通过： 1objdump -exports-trie &#x2F;path&#x2F;to&#x2F;MyApp.app&#x2F;MyApp 还能获取到可执行文件中的符号，这部分可以通过设置 EXPORTED_SYMBOLS_FILE为一个空文件解决 EXPORTED_SYMBOLS_FILE=/path/to/emptyfile.txt。 Xcode Build Settings 中的 EXPORTED_SYMBOLS_FILE配置，控制着 Mach-O 中 __LINKEDIT段中 Export Info 的信息。动态链接器 dyld 在做符号绑定时，会读取被绑定的动态库或可执行文件的 Export Info 信息，得到一个符号对应的实际调用地址。如果正在被绑定的符号，在目标动态库的 Export Info 中缺失，dyld 则会抛出异常，表现为 App 崩溃。 虽然从原理上看，Export Info 中的信息不可或缺。但是，对于一个 Mach-O 文件来说，并非所有的符号都是需要暴露给其他动态库或可执行文件的。理想情况下，私有的符号应该在编码时就应该以 __attribute__((visibility(hidden)))修饰。但在历史代码难以逐个添加修饰符的情况下，Exported Symbols 配置给了工程一个维护公有符号白名单的机会。如果填写了有效的 EXPORTED_SYMBOLS_FILE配置，动态库或者可执行文件会在静态链接时去掉白名单以外的符号，起到缩减包大小、增加逆向难度的作用。 死代码裁剪在构建完成之后如果是 C、C++ 等静态的语言的代码、一些常量定义，如果发现没有被使用到将会被标记为 Dead code。开启 DEAD_CODE_STRIP = YES这些 Dead code 将不会被打包到安装包中。在 LinkMap 这些符号也会被标记为 &lt;&lt;dead&gt;&gt;。 清理无用代码扫描无用代码方式可以分为动态和静态两种方式。静态的方式主要是通过代码扫描、参与编译构建过程或者分析最终产物来确认哪些代码没有被用到。而动态的方式主要是靠插桩或者运行时信息来获取哪些代码没有执行。由于 Objc 强大的动态特性，我们在样本量足够大的场景使用动态方式会比静态方式准确率高很多。 静态筛查筛查方案： 最简单的静态扫描是基于 AppCode，但是项目大了之后 AppCode 的索引速度非常慢。另一种方式是基于 Mach-O 的的一种静态扫描方式，在 otool dump 最终产物中的 objc_class_list &amp; objc_class_refs 做差集找到未使用的 Objc 类。 上面提到，如果代码采用 C 、C++ 等静态语言编写代码时，编译期已经确定了基本的代码逻辑，编译器会帮助我们将没有使用到的代码标记为 Dead code 并裁剪，最终不会打包到安装包中。但 Objc 是典型的动态语言，很多逻辑都是在运行时决议的，我们通过静态扫描的方式扫描出来的误差会比较大。 Objc 动态特性引入的的主要的问题包括： 实际用到了但被扫描成无用类： 一个类确实没有被其他地方使用， 但是本身逻辑依赖 +load、+initialize、__attribute__((constructor))在启动时调用 通过 string 动态调用 抽象基类、基类等会被认为是无用类 通过运行时动态生成的代码引用了某个类 一个类专门作为通知处理类 MTLModel 等，通过运行时消息机制 assign value 的无法通过 classref 统计 典型的 DI 场景。如果一个类声明遵循了某个 Protocol，外部使用的时候使用了这个 Protocol 进行方法调用 实际没用到但被认为有用到： 某个对象被另外一个对象引用，但是另外一个对象本身未被使用到。这时候会遗漏掉这个对象所属 Class 的检查 动态筛查方案： 基于插桩的行级别代码覆盖率 基于 GCOV 或者 LLVM Profile 二进制的插桩方案可以实现在运行时收集插桩数据来指导无用代码的删除。但插桩方案局限性也显而易见，插桩会劣化二进制本身的大小和性能，同时原生的插桩方案是无法过审上线。数据收集只能局限于线下。 基于 Runtime 的轻量级运行时「类覆盖率」方案 Objc 的类首次调用类初始化时，+initialize被执行，系统会自动标记已被调用，在 metaClass 中 data 的 flags 字段第 29 位就存着这个这个状态。可以使用 flags &amp; RW_INITIALIZED获取。iOS14 之后这个值的获取方式有变化。具体参考：WWDC：Advancements in the Objective-C runtime 1234#define RW_INITIALIZED (1&lt;&lt;29)bool isInitialized() &#123; return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;&#125; 上报的数据可以让我们了解我们线上真实的 Class 使用情况，对得到的数据不仅可以用来删减未使用的代码。还可以分辨使用率低的场景，如果是低频且必须的场景可以考虑使用跨端技术这种对原生包大小影响比较小的方案实现。而如果这些场景是某个渗透率很低的需求可以考虑直接下线为其他需求做置换。 重构重复代码重复代码堆积太多，不仅意味着 Bad Code Smell，我们的包大小也会受到影响。如果没有开启-Oz编译选项，我们可以使用 PMD 来\b检查项目中的重复代码然后做选择性的重构。 属性动态化属性是 OC 中最常见的概念之一。然而，一个属性并没有我们想象的这么小。通过分析 Mach-O 文件，我们发现，一个属性可以分为三个部分： （1）成员变量部分：成员变量本质是一个大小 32B 的结构体，结构体中三个指针（Offset、Name、Type）指向的内容的大小分别为 8B、10B、10B，其中 Name、Type 指针指向的内容的大小和成员变量的类型、名字长度相关。总大小大约 60B。 12345@interface presentViewController ()@property (nonatomic,strong) UIImageView *imageView;@property (nonatomic,strong) UIButton *button;@property (nonatomic,strong) NSString *name;@end （2）自动生成的 set/get 方法部分：set/get 方法本质是一个大小 24B 的结构体，结构体包含三个指针 Name、Type、Implementation，指向的内容大小大概为 10B、10B、20B。一个方法大小大概是64B，set、get 两个方法就是 128B。 （3）property 部分：property 的本质仍然是个结构体，大小是 16B，结构体中两个指针指向内容的大小分别大概是 10B、10B，和属性的名字和类型相关。总大小大概 36B。 即一个属性占用的包大小大约为 224B。 如果我们用 @dynamic修饰一个属性，不生成成员变量、get/set 方法，则一个属性可以由 224B 减少到 36B，即仅包含 property 部分的大小。 同时，代码中存在大量通过脚本自动生成的 JSONModel子类，这些子类往往拥有大量属性。这里也就存在着包大小优化空间。 于是我们通过修改生成 JSONModel子类的脚本，实现了： 1、属性全部使用 @dynamic修饰，基础变量额外生成 IVAR 2、所有 JSONModel的子类继承自新的父类，新的父类实现 resolveInstanceMethod，在该方法中用 class_addMethod统一为属性添加 get/set 方法。对象类型的属性使用关联对象的方式存取，基础类型的属性使用额外生成的 IVAR 存取。 __TEXT 段迁移安装包经过压缩后的 Download Size 若超过 200 MB，在蜂窝网络下载 App 就会受到限制，这对新增会有较大影响。在 2020 年下半年，我们探索实践了 TEXT 段迁移技术：在链接阶段使用 -rename_section选项将 `TEXT,text迁移到BD_TEXT,__text`，减少苹果对可执行文件的加密范围，提升可执行文件的压缩效率，从而减少 Download Size。 使用该方案我们最终减少了 60 MB 的 Download Size 以及 2 MB 的 Install Size。详细的原理可以参考：《今日头条优化实践： iOS 包大小二进制优化，一行代码减少 60 MB 下载大小》 二进制段压缩Mach-O 文件占据了 Install Size 中很大一部分比例，但并不是文件中的每个段/节在程序启动的第一时间都要被用到。可以在构建过程中将 Mach-O 文件中的这部分段/节压缩，然后只要在这些段被使用到之前将其解压到内存中，就能达到了减少包大小的效果，同时也能保证程序正常运行。由于苹果的一些限制，推荐只压缩了 __TEXT,__gcc_except_tab与 __TEXT,__objc_methtype两个节，然后在 _dyld_register_func_for_add_image的回调中对它进行解压。 资源文件瘦身无用资源的移除未使用的资源可以使用脚本来进行删除。强烈推荐使用 FengNiao 来自动删除图片，\b因为其相对比较新，是 2017 年开始\b开发的，并且是使用 swift 语言开发的，方便进行二次开发\b。FengNiao 的基本原理是查找出项目中所有使用到的字符串和项目中所有的资源文件。两者进行匹配（完全匹配和模式匹配，模式匹配支持带数字资源的前缀/中缀/后缀匹配），计算差集就为\b未使用的资源。 相比于之前流行的 LSUnusedResources，FengNiao 支持模式匹配会更加强大：比如我们导入 image_01 image_02 image_03 这样的图片资源作为帧动画素材，使用的时候是 image_%d 或者 image_(index) 方式，FengNiao 会把这些图片资源作为使用中的资源，不会出现误删的情况。当然如果你还是用了其他 Pattern，可以考虑扩展 FengNiao。 除了这些之外，FengNiao 是命令行工具，我们可以给 Xcode 添加 Run Script，在每次构建的时候自动检测/清理未使用的资源。 由于基于源码的扫描工具结果不是百分百准确的，所以建议最好的做法是在项目编译的时候提供出显式的 Warning，然后再次确认之后\b再去删除。同时也可以配合资源命名规范来优化工具，如果你们的命名规范和工具的检测规范能够保持一致的话，搜索的结果无疑是最为准确的。 之所以要使用自动化工具来检测重复资源的原因是因为资源是\b弱类型，我们在项目迭代过程\b中手动去维护是相当麻烦的一个过程。转换一下思维，如果资源变成强类型了，\b那我们维护起来就相当容易了。目前就有这样一个工具-R.swift，\b类似于 Android \b开发中的 R 文件，有兴趣的可以去尝试。 去除重复资源这里所说的重复资源是\b资源内容相同但是命名不相同的一些资源，对于此类资源，\b我们可以使用 fdupes 来进行扫描并去除，fdupes 的原理\b\b是对比不同文件的签名，签名相同的文件就会判定为重复资源。 然后我们就\b可以在 Xcode 中添加 Run Script，对于扫描到的相同的资源，我们可以显式的报出 Warning，然后我们在开发阶段解决资源重复的问题。 资源文件动态化可以将一些低频场景下的资源放到云端，在进入 app 安装之后再去云端按需获取。 ODR 的资源获取方案Apple 提供了按需资源（On-Demand Resource）的方式来帮助减小安装包首次下载的大小, 当有一些由于审核原因必须要内置在安装包中，但又可以走下发的情况可以尝试以下这种解决方案。当然 ODR 中的资源也需要符合 App Store 的审核标准，否则也会存在拒审风险。 资源压缩当我们一定要在安装包内置某个资源的话，应该在可接受的范畴之内，尽可能的小。比如我们安装包中内置的视频、音频资源可以采用降低清晰度、码率等等方式进行压缩。iOS 原生的多语言方案比较消耗空间，可以考虑自研更加紧凑的方案。 使用 RGB with palette 压缩图片做过包体优化的话，你可能会发现，如果对 Asset Catalog 中的 png 图片做无损压缩，虽然放入 Asset Catalog 的图片大小有了明显减小，但是构建的产物的大小却几乎没有变化。这是因为，Xcode 中，构建 Asset Catalog 的工具 actool 会首先对 Asset Catalog 中的 png 图片进行解码，得到 Bitmap 数据，然后再运用 actool 的编码压缩算法进行编码压缩处理。无损压缩通过变换图片的编码压缩算法减少大小，但是不会改变 Bitmap 数据。对于 actool 来说，它接收的输入没有改变，所以无损压缩无法优化 Assets.car 的大小。所以要优化 Assets.car 的大小，做合适的有损压缩是一个思路。 有损压缩可以尝试 RGB with palette 编码方式。RGB with palette 编码的得到的字节流首先维护了一个颜色数组。颜色数组每个成员用 RGBA 四个分量维护一个颜色。图像中的每个像素点则存储颜色数组的下标代表该点的颜色。颜色数组维护的颜色种类和数量由图片决定，同时可以人为的限制颜色数组维护颜色的种类的上限，默认为最大值 256 种。这种编码方式正如它的名字：palette（调色板）。 App 中大部分图片虽然使用了很多种类的颜色，但这些颜色中大多数都非常接近，从视觉上很难分辨，比如大量扁平风格的 icon。这种类型的图片非常适合用 palette 编码且减少颜色数组大小的方式来进行有损压缩，既能减少颜色数量实现有损压缩，也能保证保留的颜色贴近原始图片，使得经过有损压缩后的也看起来质量无损。 在具体执行中，我们使用了 ImageOptim 工具改变图片的编码方式为 RGB with palette ： 1imageoptim -Q --no-imageoptim --imagealpha --number-of-colors 16 --quality 40-80 ./1.png 其中 --number-of-colors控制颜色数组维护颜色的数量；--quality控制图片的质量变为原来的百分比。我们的经验表明，当 --number-of-colors从 16 开始向上调整，--quality维持 40-80，能够在显著减少包大小的同时维持肉眼看不到的质量变化。经过 UI 同学的像素眼审查，确认优化前后的图片看起来无差别。 Asset.car 中图片的优化Assets.car 编译过程中有时会选择一些图片，拼凑成一张大图（ZZZZPackedAsset）来提高图片的加载效率。被放进这张大图的小图会变为通过偏移量的引用。 建议使用频率高且小的图片放到 Asset.car 中，Asset.car 能保证其加载和渲染的速度最优。而大的图片比如背景图之类的，长宽尺寸就有上千个像素，而这种放到 Asset.car 中会大大的增加安装包的大小。建议实践中比如页面背景图，或者其他 png 格式超过 100KB 大小的图片都使用 WebP 的方式引入。相较于 PNG 格式，WebP 具有更加优秀的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量。 当我们在构建过程中，Xcode 会通过自己的压缩算法重新对图片进行处理。这也是为什么我们通过对图片无损压缩来优化包大小没有效果的原因。对于放入 Asset.car 中的图片如果图片没有半透明效果，使用 70% 的有损压缩是一个不错的方式，既能保证图片清晰度的同时获得更小的大小。如果对于有半透明效果的图片，采用 70% 的有损压缩会导致半透明的地方出现噪点，所以压缩过后的图片最好找设计师同学再确认一次。 我们通过对 Asset.car 进行了逆向研究，同一张图片，在不同设备、iOS 系统上 Xcode 采用了不同的压缩算法这也导致了下载时候不同的设备针对图片出现大小的区别。 截止目前 Xcode 会使用的压缩算法有 lzfse、palette_img、deepmap2、deepmap_lzfse、zip。 以 iPhoneX 为例子： iOS 11.x 版本：对应的压缩算法为 lzfse、zip； iOS 12.0.x - iOS 12.4.x: 对应的压缩算法为 deepmap_lzfse、palette_img； iOS 13.x: 对应的压缩算法为deepmap2； 按照压缩比来讲 lzfse&lt; palette_img~= deepmap_lzfse&lt; deepmap2。 我们可以使用 xcrun assetutil --info Assets.car 命令检查 Assets.car 中每张图片使用的编码压缩算法。在 BuildSetting 中如果设置了 ASSETCATALOG_COMPILER_OPTIMIZATION=space那么低版本的使用 lzfse压缩算法的图片会变成 zip的算法可减少 iOS11.x 及以下的 iOS 设备图片的占用大小。其他 iOS 版本的压缩算法不受这个配置的影响。 FrameworkFramework 文件夹存放的是 Embedded Framework，它\b在打包的时候最终会被拷贝进 Target App Bundle 中的 \bFramework 文件夹中，在 App 启动的时候才会被链接\b和加载。Embedded Framework 主要分类两类： SwiftSupport：Framework 文件夹中前缀是 libSwift 的一些 framework。之前版本，由于 Swift ABI 还未稳定，\b我们发布应用的时候还需要带上一份自己应用中使用到的 Swift 标准库代码，这部分占用最终\b ipa 的大小可能在 10M 左右。 其他依赖库：使用 Cocoapods 管理依赖并且设置\b了 user_framework! 时三方库源码都会打包成 framework，然后导入到工程当中。 Framework 中的\b资源 这里所说的 Framework 表示的是: 静态库(.a) Framework(Static Library) 目前绝\b大部分的 Framework 的做法是直接将资源放进 bundle 中进行管理的，在主工程打包的时候，Xcode 会将这部分资源直接拷贝进\b App Target Bundle 中，这样做就存在2个问题： 使用 bundle 管理的资源是不会被 Xcode 优化的(图片压缩等) 使用 bundle 管理的资源不享受 App Thinning/Slicing。 所以尽量还是选择 XCAsset 进行 Framework 的资源管理，静态库和动态库的管理方式有所不同： 静态库(.a)/Framework(Static Library): 静态库的目标文件(.a/.framework) 中\b是不能包含资源文件的，所以这部分只能使用 bundle 来管理。但是由于 bundle 直拷贝的特性，我们需要把 xib/storyboard/asset catalog 编译后的产物(nib/storyboardc/Asset.car)放进 bundle 里。比较普遍的一个做法是借助 Bundle Target 来编译我们的资源文件。 \b动态库: 动态库相对来说要简单一点，因为动态库本身就是一个 bundle。所以我们直接把资源文件放在目标文件(.framework)中就可以了。 如果你是使用 Cocoapods 管理你的源码，也可以使用 XCAsset 来管理资源，参考 在 Cocoapods\b \b中使用 XCAsset。 Framework 中的可执行文件这部分可以参考以上的可执行文件瘦身。 PluginsPlugin \b内部主要存放的就是 App Extension，App Extension 是独立打包签名，然后再拷贝进 Target App Bundle 的。 Plugin 中的静态库静态库最终会打包进可执行文件内部，所以\b如果 App Extension 依赖了\b三方静态库，\b同时主工程也引用了相同的静态库的话，最终 App 包中可能会包含两份三方静态库的体积。 Plugin 中的动态库动态库是在运行的时候才进行加载链接的，所以 Plugin 的动态库是可以和主工程共享的，把动态库的加载路径 Runpath Search Paths 修改为跟主工程一致就可以共享主工程引入的动态库。 Plugin 中的 Swift Standard Library在 Swift ABI 稳定之前，Swift 标准库会被拷贝进 App 当中。Swift 标准库是动态链接库，也是可以在主工程和其他的 App Extensions \b之间共享的，前提当然是\b所有 Target 使用的 \bSwift 版本是一致的，否则就会出现意料之外的 bug。 设置共享分为两步： 设置 Extension 中的 \bAlways Embed Swift Standard Libraries 为 NO，让编译器不再为 Extension 生成 Swift 标准库 设置 Extension 中的动态库的查找路径为主工程的 Framework 文件夹 防劣化的建设在优化之后，一定要做好防劣化的建设，尤其是业务迭代迅速的团队，否则很有可能优化的速度赶不上劣化。 各业务线对包大小占用的展示和监控一般大型项目都是分多个业务线，对各业务线代码占用状况进行摸底和监控，有助于从全局的角度了解头条的代码状况，找到“性价比”较低的模块。 进行“摸底和监控”的第一步，是需要展示出各业务线代码所占的安装包大小，即获得这些业务方向的代码，分别占用了多少安装包大小。 要统计代码对包大小的贡献，基本的方法是查看link map。网络上流行着一些分析link map的工具，可以查看每个类、每个静态库所占的大小。然而，如果app业务庞大，类众多（几千个），且主要功能都在主工程而非静态库中的话，展示每个类所占的二进制文件大小依然可读性较差，无法从中看出每个业务占用的大小。 那么如何将一个类归类到某个业务线呢？一种可行的方式，就是利用现成的数据：工程的目录结构。 通常项目中各个group的命名都能表明这个group属于哪个业务线。所以结合工程的目录结构，应该可以较方便的将一个类归类到某个业务线中去。通过编写脚本，可以按照工程目录的树形结构输出各个类、各个group的大小占用。脚本可以借助开源的ruby工具Xcodeproj读取工程目录，使用开源的python脚本linkmap.py读取link map，获得类和静态库的大小，最后进行整合，输出link map分析报表。 虽然工程中的类有几千个，但group的数目显然是非常有限的。人工的对一些group进行合计，我们可以轻松的获得各个业务线占用的二进制文件大小。 这些数据也可以成为了我们推动各业务线“删除冗余代码、下线废弃业务、为包大小优化作贡献”的依据。对于安装包大小占用特别大的业务，我们会优先进行包大小优化推动。 另外，通过观察link map分析报表，可以发现一些收益较低但代码颇多的业务并推动加速这类代码的下线。 在业务方对自身业务进行优化时，link map分析报表也具有指导性意义。业务方可以查看自己业务中哪些子方向相关的代码占用最多从而优先进行优化。 对各业务线所占包大小进行盘点后，也方便推动各业务线对无用的业务和代码进行了下线。 为了便于及时的产出报告，这一脚本可以集成到工程的Run Script中去，这样在需要时只用build一下，在构建的最后一步便会执行脚本，产出分析报告。 版本差异监控在安装包大小的优化中，不仅需要优化当前的安装包大小，更需要控制包大小的增长。否则，就可能会出现业务增长造成的包大小增长快过包大小优化量的尴尬局面。 可以在自动打包平台增加了一些用于监控版本差异的脚本，用于对比各个版本间包大小的增长量。如果发现当前版本的包大小较上一版本有较大增长，则会以报警的方式通知给开发人员。 这时我们就需要排查这两个版本间包大小的增长点。为此我们编写了一个脚本辅助我们快速排查版本间的差异。 这个脚本执行的工作有： 1、从打包平台上抓去特定两个版本的安装包和linkmap文件。 2、解压两个安装包，对比安装包中的每个文件，输出每个文件的差量值 3、解压两个asset.car文件，对比安装包中的图片的差量，输出增加/减少的图片的top x 4、处理和对比两个linkmap文件，输出增长/减小的类的top x 最后它可以输出报表，帮助开发人员快速定位版本间的增长点。 TODO: 按照group展示.o大小的脚本 检查图片大小的脚本 未初始化的类的代码 linkmap统计未使用的方法 参考：iOS 安装包瘦身 （上篇） iOS 安装包瘦身（下篇） 今日头条 iOS 安装包大小优化 - 新阶段、新实践 抖音品质建设 - iOS 安装包大小优化实践篇 干货｜今日头条iOS端安装包大小优化—思路与实践 今日头条优化实践： iOS 包大小二进制优化，一行代码减少 60 MB 下载大小","categories":[{"name":"性能优化","slug":"性能优化","permalink":"http://heseng91.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]},{"title":"「刨根问底」之Runtime 关联属性","slug":"「刨根问底」之Runtime-关联属性","date":"2018-09-20T19:46:54.000Z","updated":"2023-02-08T00:45:26.737Z","comments":true,"path":"2018/09/21/「刨根问底」之Runtime-关联属性/","link":"","permalink":"http://heseng91.github.io/2018/09/21/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime-%E5%85%B3%E8%81%94%E5%B1%9E%E6%80%A7/","excerpt":"之前介绍过 Category 的实现，在 iOS 开发中我们难免需要使用分类（Category），为已经存在的类添加属性的需求，但是使用 @property 并不能在分类中正确创建实例变量和存取方法。不过，通过 Objective-C 运行时中的关联对象，也就是关联对象（Associated Object），我们可以实现上述需求。本文将从关联对象的应用并基于 objc4-756.2 进行源码解析两方面介绍关联对象。","text":"之前介绍过 Category 的实现，在 iOS 开发中我们难免需要使用分类（Category），为已经存在的类添加属性的需求，但是使用 @property 并不能在分类中正确创建实例变量和存取方法。不过，通过 Objective-C 运行时中的关联对象，也就是关联对象（Associated Object），我们可以实现上述需求。本文将从关联对象的应用并基于 objc4-756.2 进行源码解析两方面介绍关联对象。 关联对象的应用这里主要是介绍关联对象日常开发中使用，如果你对关联对象的使用非常熟悉，可以直接跳过这部分的内容，直接开始第二部分内容。 分类中的 @property@property 可以说是一个 Objective-C 编程中的“宏”，它有元编程的思想。 12345@interface HSObject : NSObject@property (nonatomic, strong) NSString *property;@end 在使用上述代码时会做三件事： 生成实例变量 _property 生成 getter 方法 - property 生成 setter 方法 - setProperty: 12345678910111213@implementation HSObject &#123; NSString *_property;&#125;- (NSString *)property &#123; return _property;&#125;- (void)setProperty:(NSString *)property &#123; _property &#x3D; property;&#125;@end 这些代码都是编译器为我们生成的，虽然你看不到它，但是它确实在这里，我们既然可以在类中使用 @property 生成一个属性，那么为什么在分类中不可以呢？ 我们来做一个小实验：创建一个 HSObject 的分类 Category，并添加一个属性 categoryProperty： 12345@interface HSObject (Category)@property (nonatomic, strong) NSString *categoryProperty;@end 看起来还是很不错的，不过 Build 一下这个 Demo，会发现有这么一个警告： 在这里的警告告诉我们 categoryProperty 属性的存取方法需要自己手动去实现，或者使用 @dynamic 在运行时实现这些方法。 换句话说，分类中的 @property 并没有为我们生成实例变量以及存取方法，而需要我们手动实现。 使用关联对象Q：我们为什么要使用关联对象？ A：因为在分类中 @property 并不会自动生成成员变量以及存取方法，所以一般使用关联对象为已经存在的类添加『属性』。 上一小节的内容已经给了我们需要使用关联对象的理由。在这里，我们会介绍 ObjC 运行时为我们提供的与关联对象有关的 API，并在分类中实现一个伪属性： 1234567891011121314#import &quot;HSObject+Category.h&quot;#import &lt;objc&#x2F;runtime.h&gt;@implementation HSObject (Category)- (NSString *)categoryProperty &#123; return objc_getAssociatedObject(self, _cmd);&#125;- (void)setCategoryProperty:(NSString *)categoryProperty &#123; objc_setAssociatedObject(self, @selector(categoryProperty), categoryProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 这里的 _cmd 代指当前方法的选择子，也就是 @selector(categoryProperty)。 我们使用了两个方法 objc_getAssociatedObject 以及 objc_setAssociatedObject 来模拟『属性』的存取方法，而使用关联对象模拟实例变量。 在这里有必要解释两个问题： 为什么向方法中传入 @selector(categoryProperty)？ OBJC_ASSOCIATION_RETAIN_NONATOMIC 是干什么的？ 关于第一个问题，我们需要看一下这两个方法的原型： 12id objc_getAssociatedObject(id object, const void *key);void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy); @selector(categoryProperty) 也就是参数中的 key，其实可以使用静态指针 static void * 类型的参数来代替，不过在这里，笔者强烈推荐使用 @selector(categoryProperty) 作为 key 传入。因为这种方法省略了声明参数的代码，并且能很好地保证 key 的唯一性。 OBJC_ASSOCIATION_RETAIN_NONATOMIC 又是什么呢？如果我们使用 Command 加左键查看它的定义： 1234567891011typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN &#x3D; 0, &#x2F;**&lt; Specifies a weak reference to the associated object. *&#x2F; OBJC_ASSOCIATION_RETAIN_NONATOMIC &#x3D; 1, &#x2F;**&lt; Specifies a strong reference to the associated object. * The association is not made atomically. *&#x2F; OBJC_ASSOCIATION_COPY_NONATOMIC &#x3D; 3, &#x2F;**&lt; Specifies that the associated object is copied. * The association is not made atomically. *&#x2F; OBJC_ASSOCIATION_RETAIN &#x3D; 01401, &#x2F;**&lt; Specifies a strong reference to the associated object. * The association is made atomically. *&#x2F; OBJC_ASSOCIATION_COPY &#x3D; 01403 &#x2F;**&lt; Specifies that the associated object is copied. * The association is made atomically. *&#x2F;&#125;; 从这里的注释我们能看到很多东西，也就是说不同的 objc_AssociationPolicy 对应了不通的属性修饰符： objc_AssociationPolicy modifier OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_RETAIN_NONATOMIC nonatomic, strong OBJC_ASSOCIATION_COPY_NONATOMIC nonatomic, copy OBJC_ASSOCIATION_RETAIN atomic, strong OBJC_ASSOCIATION_COPY atomic, copy 而我们在代码中实现的属性 categoryProperty 就相当于使用了 nonatomic 和 strong 修饰符。 关于属性修饰符的区别，并不是这篇文章的主要内容，如果你需要了解它们的区别，Google 是一个很好的选择。 到这里，我们已经完成了对关联对象应用的介绍，再来回顾一下小节的内容。 @property 其实有元编程的思想，它能够为我们自动生成实例变量以及存取方法，而这三者构成了属性这个类似于语法糖的概念，为我们提供了更便利的点语法来访问属性： 12self.property &lt;&#x3D;&gt; [self property]self.property &#x3D; value &lt;&#x3D;&gt; [self setProperty:value] 在分类中，因为类的实例变量的布局已经固定，使用 @property 已经无法向固定的布局中添加新的实例变量（这样做可能会覆盖子类的实例变量），所以我们需要使用关联对象以及两个方法来模拟构成属性的三个要素。 关联对象源码解析这一部分会从三个 objc 运行时的方法为入口来对关联对象的实现一探究竟，其中两个方法是上一部分使用到的方法： 123void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);id objc_getAssociatedObject(id object, const void *key);void objc_removeAssociatedObjects(id object); 三个方法的作用分别是： 以键值对形式添加关联对象 根据 key 获取关联对象 移除所有关联对象 而接下来的内容自然就是围绕这三个方法进行的，我们会对它们的实现进行分析。 objc_setAssociatedObject首先是 objc_setAssociatedObject 方法，这个方法的源码如下： 123void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123; _object_set_associative_reference(object, (void *)key, value, policy);&#125; 调用栈中的 _object_set_associative_reference 方法实际完成了设置关联对象的任务： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; // This code used to work when nil was passed for object and key. Some code // probably relies on that to not crash. Check and handle it explicitly. // rdar://problem/44094390 // 方法首先判断如果对象和属性值都为空则直接return if (!object &amp;&amp; !value) return; assert(object); if (object-&gt;getIsa()-&gt;forbidsAssociatedObjects()) _objc_fatal(\"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects\", object, object_getClassName(object)); // retain the new value (if any) outside the lock. // 创建一个临时的 ObjcAssociation 对象（用于持有原有的关联对象，方便在方法调用的最后释放值） ObjcAssociation old_association(0, nil); // 调用 acquireValue 对 new_value 进行 retain 或者 copy 操作 id new_value = value ? acquireValue(value, policy) : nil; &#123; // 初始化一个 AssociationsManager，并获取唯一的保存关联对象的哈希表 AssociationsHashMap AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); // 对对象指针进行逐位取反作为key，用于后续查找对象对应的所有关联属性 disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) &#123; // 如果属性值不为空 // break any existing association. // 查找保存当前对象所有关联对象的AssociationsHashMap AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123;// 如果查找到了 // secondary table exists // 在保存对象所有关联对象的AssociationsHashMap中查找 key 是否存在 ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123;// 如果属性存在 // 保存旧属性值并更新原有的关联对象 old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123;// 如果属性不存在，则增加一个 (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123;//如果没有找到 // create the new association (first time). // 初始化一个 ObjectAssociationMap ObjectAssociationMap *refs = new ObjectAssociationMap; // 实例化 ObjcAssociation 对象添加到 Map 中 associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); // 表明当前对象含有关联对象 object-&gt;setHasAssociatedObjects(); &#125; &#125; else &#123; // setting the association to nil breaks the association. // 查找保存当前对象所有关联对象的AssociationsHashMap AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123;// 如果查找到了 // 在保存对象所有关联对象的AssociationsHashMap中查找 key 是否存在 ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123;// 如果属性存在 // 保存旧的属性值 old_association = j-&gt;second; // 擦除 ObjectAssociationMap 中 key 对应的节点 refs-&gt;erase(j); &#125; &#125; &#125; &#125; // release the old value (outside of the lock). // 释放旧属性值 if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 我们需要注意其中的几个类和数据结构，因为在具体分析这个方法的实现之前，我们需要了解其中它们的作用： AssociationsManager AssociationsHashMap ObjcAssociationMap ObjcAssociation AssociationsManagerAssociationsManager 在源代码中的定义是这样的： 123456789101112131415161718192021// class AssociationsManager manages a lock / hash table singleton pair.// Allocating an instance acquires the lock, and calling its assocations()// method lazily allocates the hash table.spinlock_t AssociationsManagerLock;class AssociationsManager &#123; // associative references: object pointer -&gt; PtrPtrHashMap. static AssociationsHashMap *_map;public: AssociationsManager() &#123; AssociationsManagerLock.lock(); &#125; ~AssociationsManager() &#123; AssociationsManagerLock.unlock(); &#125; AssociationsHashMap &amp;associations() &#123; if (_map == NULL) _map = new AssociationsHashMap(); return *_map; &#125;&#125;;AssociationsHashMap *AssociationsManager::_map = NULL; 它维护了 spinlock_t 和 AssociationsHashMap 的单例，初始化它的时候会调用 lock.lock() 方法，在析构时会调用 lock.unlock()，而 associations 方法用于取得一个全局的 AssociationsHashMap 单例。 也就是说 AssociationsManager 通过持有一个自旋锁 spinlock_t 保证对 AssociationsHashMap 的操作是线程安全的，即每次只会有一个线程对 AssociationsHashMap 进行操作。 AssociationsHashMap其中AssociationsHashMap的定义如下： 12345class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;public: void *operator new(size_t n) &#123; return ::malloc(n); &#125; void operator delete(void *ptr) &#123; ::free(ptr); &#125;&#125;; 关联对象是以对象为维度存在的，一个对象又可能存在多个关联对象，AssociationsHashMap 中保存的是对象的 disguised_ptr_t 到 ObjectAssociationMap 的映射。 ObjectAssociationMap而 ObjectAssociationMap 则保存了从 key 到关联对象 ObjcAssociation 的映射，这个数据结构保存了当前对象对应的所有关联对象： 12345class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;public: void *operator new(size_t n) &#123; return ::malloc(n); &#125; void operator delete(void *ptr) &#123; ::free(ptr); &#125;&#125;; ObjcAssociationObjcAssociation 是真正的关联对象的类，包含了 policy 以及 value，上面的所有数据结构只是为了更好的存储它： 123456789101112class ObjcAssociation &#123; uintptr_t _policy; id _value; public: ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) &#123;&#125; ObjcAssociation() : _policy(0), _value(nil) &#123;&#125; uintptr_t policy() const &#123; return _policy; &#125; id value() const &#123; return _value; &#125; bool hasValue() &#123; return _value != nil; &#125; &#125;; 举一个简单的例子来说明关联对象在内存中以什么形式存储的，以下面的代码为例： 123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *obj &#x3D; [NSObject new]; objc_setAssociatedObject(obj, @selector(hello), @&quot;Hello&quot;, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; return 0;&#125; 这里的关联对象 ObjcAssociation(OBJC_ASSOCIATION_RETAIN_NONATOMIC, @&quot;Hello&quot;) 在内存中是这么存储的： 逻辑分析接下来我们可以重新回到对 objc_setAssociatedObject 方法的分析了，主要逻辑如下： 方法首先判断如果对象和属性值都为空则直接return； 使用 old_association(0, nil) 创建一个临时的 ObjcAssociation 对象（用于持有原有的关联对象，方便在方法调用的最后释放值）； 调用 acquireValue 对 new_value 进行 retain 或者 copy， acquireValue 实现如下： 123456789static id acquireValue(id value, uintptr_t policy) &#123; switch (policy &amp; 0xFF) &#123; case OBJC_ASSOCIATION_SETTER_RETAIN: return objc_retain(value); case OBJC_ASSOCIATION_SETTER_COPY: return ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy); &#125; return value;&#125; 初始化一个 AssociationsManager，并获取唯一的保存关联对象的哈希表 AssociationsHashMap 12AssociationsManager manager;AssociationsHashMap &amp;associations(manager.associations()); 调用 DISGUISE(object) 对对象指针进行位操作来作为 key ，DISGUISE 相关源码如下： 1234567typedef uintptr_t disguised_ptr_t;inline disguised_ptr_t DISGUISE(id value) &#123; return ~uintptr_t(value); &#125;#ifndef _UINTPTR_T#define _UINTPTR_Ttypedef unsigned long uintptr_t;#endif /* _UINTPTR_T */ disguised_ptr_t实际上是一个unsigned long，它的长度与指针相同，所以被当做指针使用。 ~uintptr_t(value)：value本身也是个对象指针，将它包装成unsigned long类型，载逐位取反后返回。 判断如果新的属性值不为nil，则进行如下操作： 使用第5步获取的key来寻找对应的 AssociationsHashMap (保存对象中所有关联属性) 如果找到了对应的 AssociationsHashMap，就要看 key 是否存在了，由此来决定是更新原有的关联对象，还是增加一个 12345678ObjectAssociationMap *refs = i-&gt;second;ObjectAssociationMap::iterator j = refs-&gt;find(key);if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value);&#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value);&#125; 如果没有找到，初始化一个 ObjectAssociationMap，再实例化 ObjcAssociation 对象添加到 Map 中，并调用 setHasAssociatedObjects 方法，表明当前对象含有关联对象 1234ObjectAssociationMap *refs = new ObjectAssociationMap;associations[disguised_object] = refs;(*refs)[key] = ObjcAssociation(policy, new_value);object-&gt;setHasAssociatedObjects(); 否则如果新的属性值为nil，则删除对应 key 的关联对象： 使用第5步获取的key来寻找对应的 AssociationsHashMap (保存对象中所有关联属性) 如果AssociationsHashMap则进一步查找key对应的ObjectAssociationMap 如果成功查找到key对应的ObjectAssociationMap，则调用 erase 方法，擦除 ObjectAssociationMap 中 key 对应的节点 12345678910// setting the association to nil breaks the association.AssociationsHashMap::iterator i = associations.find(disguised_object);if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125;&#125; 最后的最后，如果就关联对象有值的话，会调用 ReleaseValue() 释放关联对象的值 1234567891011static void releaseValue(id value, uintptr_t policy) &#123; if (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) &#123; return objc_release(value); &#125;&#125;struct ReleaseValue &#123; void operator() (ObjcAssociation &amp;association) &#123; releaseValue(association.value(), association.policy()); &#125;&#125;; setHasAssociatedObjects()上面已经将 objc_setAssociatedObject 方法的实现分析得很透彻了，不过，这里还有一个小问题来等待我们解决，setHasAssociatedObjects() 方法的作用是什么呢？ 123456789101112131415inline voidobjc_object::setHasAssociatedObjects()&#123; if (isTaggedPointer()) return; retry: isa_t oldisa = LoadExclusive(&amp;isa.bits); isa_t newisa = oldisa; if (!newisa.nonpointer || newisa.has_assoc) &#123; ClearExclusive(&amp;isa.bits); return; &#125; newisa.has_assoc = true; if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;&#125; 它会将 isa 结构体中的标记位 has_assoc 标记为 true，也就是表示当前对象有关联对象，在这里我还想祭出这张图来介绍 isa 中的各个标记位都是干什么的呢？ 更多 isa 的知识，请移步Runtime类和对象的定义 objc_getAssociatedObject前面已经分析了 objc_setAssociatedObject 的实现，接下来我们一起来看看 objc_getAssociatedObject 的实现： 123id objc_getAssociatedObject(id object, const void *key) &#123; return _object_get_associative_reference(object, (void *)key);&#125; objc_getAssociatedObject 也只是调用了 _object_get_associative_reference ： 1234567891011121314151617181920212223242526id _object_get_associative_reference(id object, void *key) &#123; id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; ObjcAssociation &amp;entry = j-&gt;second; value = entry.value(); policy = entry.policy(); if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123; objc_retain(value); &#125; &#125; &#125; &#125; if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123; objc_autorelease(value); &#125; return value;&#125; 代码中寻找关联对象的逻辑和 objc_setAssociatedObject 差不多： 获取静态变量 AssociationsHashMap 以 DISGUISE(object) 为 key 查找 AssociationsHashMap 以 void *key 为 key 查找 ObjcAssociation 根据 policy 调用相应的方法 12345if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123; ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);&#125; 返回关联对象 ObjcAssociation 的值 objc_removeAssociatedObjects关于最后的 objc_removeAssociatedObjects 方法，其实现也相对简单，源码如下： 123456void objc_removeAssociatedObjects(id object) &#123; if (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123; _object_remove_assocations(object); &#125;&#125; 为了加速移除对象的关联对象的速度，我们会通过标记位 has_assoc 来避免不必要的方法调用，在确认了对象和关联对象的存在之后，才会调用 _object_remove_assocations 方法移除对象上所有的关联对象： 12345678910111213141516171819202122void _object_remove_assocations(id object) &#123; vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); if (associations.size() == 0) return; disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // copy all of the associations that need to be removed. ObjectAssociationMap *refs = i-&gt;second; for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123; elements.push_back(j-&gt;second); &#125; // remove the secondary table. delete refs; associations.erase(i); &#125; &#125; // the calls to releaseValue() happen outside of the lock. for_each(elements.begin(), elements.end(), ReleaseValue());&#125; 方法会将对象包含的所有关联对象加入到一个 vector 中，然后对所有的 ObjcAssociation 对象调用 ReleaseValue() 方法，释放不再被需要的值。 小结关于应用本来在这个系列的文章中并不会涉及关联对象这个话题，不过，有人问过我这么一个问题：在分类中到底能否实现属性？其实在回答这个问题之前，首先要知道到底属性是什么？而属性的概念决定了这个问题的答案。 如果你把属性理解为通过方法访问的实例变量，我相信这个问题的答案是不能，因为分类不能为类增加额外的实例变量。 不过如果属性只是一个存取方法以及存储值的容器的集合，那么分类是可以实现属性的。 分类中对属性的实现其实只是实现了一个看起来像属性的接口而已。 关于实现关联对象又是如何实现并且管理的呢： 关联对象其实就是 ObjcAssociation 对象 关联对象由 AssociationsManager 管理并在 AssociationsHashMap 存储 对象的指针以及其对应 ObjectAssociationMap 以键值对的形式存储在 AssociationsHashMap 中 ObjectAssociationMap 则是用于存储关联对象的数据结构 每一个对象都有一个标记位 has_assoc 指示对象是否含有关联对象 参考： 关联对象 AssociatedObject 完全解析","categories":[{"name":"刨根问底","slug":"刨根问底","permalink":"http://heseng91.github.io/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}],"tags":[]},{"title":"「刨根问底」之Runtime Category","slug":"「刨根问底」之Runtime-Category","date":"2018-09-13T19:43:39.000Z","updated":"2023-02-07T18:32:59.887Z","comments":true,"path":"2018/09/14/「刨根问底」之Runtime-Category/","link":"","permalink":"http://heseng91.github.io/2018/09/14/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime-Category/","excerpt":"关于Category，在美团的技术博客 深入理解Objective-C：Category 中已经有了非常详细的解释，然而可能由于时间原因，其中的不少内容已经过时，本文基于 objc4-756.2 对Category重新做一个简单分析，为了便于阅读，在不影响代码逻辑的前提下有可能删除部分无关紧要的内容。","text":"关于Category，在美团的技术博客 深入理解Objective-C：Category 中已经有了非常详细的解释，然而可能由于时间原因，其中的不少内容已经过时，本文基于 objc4-756.2 对Category重新做一个简单分析，为了便于阅读，在不影响代码逻辑的前提下有可能删除部分无关紧要的内容。 阅读本文需要对Runtime类和对象的定义有一定了解。为了阅读的连贯性，这里再简要介绍一下NSObject 和 Category相关的基础数据结构。 NSObject 和 Category 相关的基础数据结构NSObject 相关的基础数据结构NSObject在OC的世界中，除了NSProxy类以外，所有的类都是NSObject的子类。NSObject类的定义如下： 123456789101112131415OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ROOT_CLASSOBJC_EXPORT@interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125;+ (void)load;+ (void)initialize;...// 省略其他方法@end objc_classNSObject类除了一个Class类型的isa成员之外，其它的都是方法。而Class 其实是一个指向 objc_class 结构体的指针： 1typedef struct objc_class *Class; objc_class 的定义如下： 123456789101112struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125; ...// 省略其他方法&#125; objc_objectobjc_class 继承于 objc_object，那objc_object又是啥呢，参考 objc-private.h 文件部分源码： 12345678910111213struct objc_object &#123;private: isa_t isa;public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // getIsa() allows this to be a tagged pointer object Class getIsa(); ... 此处省略其他方法声明&#125; objc_object 结构体包含一个 isa 指针，类型为 isa_t 联合体。根据 isa 就可以顺藤摸瓜找到对象所属的类。 isa_tobjc_object 中的 isa 是一个 isa_t 类型的共用体（union），在objc-private.h 文件中定义如下： 123456789101112union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 其中 ISA_BITFIELD在 isa.h文件中定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#if SUPPORT_PACKED_ISA // extra_rc must be the MSB-most field (so it matches carry/overflow flags) // nonpointer must be the LSB (fixme or get rid of it) // shiftcls must occupy the same bits that a real class pointer would // bits + RC_ONE is equivalent to extra_rc + 1 // RC_HALF is the high bit of extra_rc (i.e. half of its range) // future expansion: // uintptr_t fast_rr : 1; // no r/r overrides // uintptr_t lock : 2; // lock for atomic property, @synch // uintptr_t extraBytes : 1; // allocated with extra bytes# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18)# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 8# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7)# else# error unknown architecture for packed isa# endif SUPPORT_PACKED_ISA 用于标记是否支持优化的 isa 指针，其字面含义意思是 isa 的内容不再是类的指针了，而是包含了更多信息，比如引用计数，析构状态，被其他 weak 变量引用情况。判断方法也是根据设备类型： 12345678// Define SUPPORT_PACKED_ISA=1 on platforms that store the class in the isa // field as a maskable pointer with other data around it.#if (!__LP64__ || TARGET_OS_WIN32 || \\ (TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_IOSMAC))# define SUPPORT_PACKED_ISA 0#else# define SUPPORT_PACKED_ISA 1#endif 综合看来目前只有 arm64 架构的设备支持，下面列出了 isa 指针中变量对应的含义： 变量名 含义 nonpointer 0 表示普通的 isa 指针，1 表示使用优化，存储引用计数 has_assoc 表示该对象是否包含 associated object，如果没有，则析构时会更快 has_cxx_dtor 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls 类的指针 magic 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。 weakly_referenced 表示该对象是否有被弱引用指向过，如果没有，则析构时更快 deallocating 表示该对象是否正在析构 has_sidetable_rc 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_rc 存储引用计数值减一后的结果 介绍完objc_class 的父类 objc_object，我们再来逐个介绍一下，objc_class 的成员。 cache_t1234567struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;... //省略其他方法&#125; 其中，bucket_t *_buckets 是一个散列表，用来存储 Method 方法列表，而 bucket_t 结构体定义如下，包含了一个 unsigned long 类型的 _key 和一个 IMP 类型的 _imp，存储了指针与 IMP 的键值对。IMP 是一个函数指针，指向了一个方法的具体实现。 1234567891011121314struct bucket_t &#123;private: // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64.#if __arm64__ uintptr_t _imp; SEL _sel;#else SEL _sel; uintptr_t _imp;#endif... 省略其他方法&#125;; cache_t 中另外两个变量 _mask 和 _occupied，它们的类型为 mask_t，定义如下，其实是一个 unsigned int。 12345#if __LP64__typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t;#endif _mask 和 _occupied 对应于 vtable： _mask：分配用来缓存 bucket 的总数。 _occupied：表明目前实际占用的缓存 bucket 的个数。 cache 的作用主要是对方法调用的性能进行优化。通俗地讲，每当实例对象接收到一个消息时，它不会直接在其 isa 指向的类（或类的 isa 指向的父类）的方法列表中遍历查找能够响应消息的方法实现，因为这样效率太低了，而是优先在 cache 中查找。Runtime 系统会把被调用过的方法存到该类对象的 cache 中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。 有关缓存的实现细节，可以查看 objc-cache.mm 文件。 class_data_bits_tobjc_class 中最复杂的是 bits，class_data_bits_t 结构体所包含的信息太多了，主要包含 class_rw_t, retain/release/autorelease/retainCount 和 alloc 等信息，很多存取方法也是围绕它展开。查看 objc-runtime-new.h 源码如下： 123456789101112131415161718struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;private: bool getBit(uintptr_t bit) &#123; return bits &amp; bit; &#125;...public: class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;...省略其他方法&#125; 注意 objc_class 的 data 方法直接将 class_data_bits_t 的data 方法返回，最终是返回 class_rw_t，包了好几层。 可以看到 class_data_bits_t 里又包了一个 bits，这个指针跟不同的 FAST_ 前缀的 flag 掩码做按位与操作，就可以获取不同的数据。bits 在内存中每个位的含义有三种排列顺序： 32 位： 0 1 2 - 31 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_DATA_MASK 64 位兼容版： 0 1 2 3 - 46 47 - 63 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_HAS_DEFAULT_RR FAST_DATA_MASK 空闲 64 位不兼容版： 0 1 2 3 - 46 47 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_ALLOC FAST_DATA_MASK FAST_HAS_CXX_CTOR 48 49 50 51 52 - 63 FAST_HAS_DEFAULT_AWZ FAST_HAS_DEFAULT_RR FAST_REQUIRES_RAW_ISA FAST_HAS_CXX_DTOR 空闲 其中 64 位不兼容版每个宏对应的含义如下： 1234567891011121314151617181920212223242526// class is a Swift class from the pre-stable Swift ABI#define FAST_IS_SWIFT_LEGACY (1UL&lt;&lt;0)// class is a Swift class from the stable Swift ABI#define FAST_IS_SWIFT_STABLE (1UL&lt;&lt;1)// summary bit for fast alloc path: !hasCxxCtor and // !instancesRequireRawIsa and instanceSize fits into shiftedSize#define FAST_ALLOC (1UL&lt;&lt;2)// data pointer#define FAST_DATA_MASK 0x00007ffffffffff8UL// class or superclass has .cxx_construct implementation#define FAST_HAS_CXX_CTOR (1UL&lt;&lt;47)// class or superclass has default alloc/allocWithZone: implementation// Note this is is stored in the metaclass.#define FAST_HAS_DEFAULT_AWZ (1UL&lt;&lt;48)// class or superclass has default retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference#define FAST_HAS_DEFAULT_RR (1UL&lt;&lt;49)// class's instances requires raw isa// This bit is aligned with isa_t-&gt;hasCxxDtor to save an instruction.#define FAST_REQUIRES_RAW_ISA (1UL&lt;&lt;50)// class or superclass has .cxx_destruct implementation#define FAST_HAS_CXX_DTOR (1UL&lt;&lt;51)// instance size in units of 16 bytes// or 0 if the instance size is too big in this field// This field must be LAST#define FAST_SHIFTED_SIZE_SHIFT 52 这里面除了 FAST_DATA_MASK 是用一段空间存储数据外，其他宏都是只用 1 bit 存储 bool 值。class_data_bits_t 提供了三个方法用于位操作：getBit, setBits 和 clearBits，对应到存储 bool 值的掩码也有封装函数，比如： 123456bool hasCxxCtor() &#123; return getBit(FAST_HAS_CXX_CTOR);&#125;void setHasCxxCtor() &#123; setBits(FAST_HAS_CXX_CTOR);&#125; 重头戏在于最大的那块存储区域FAST_DATA_MASK，它其实就存储了指向 class_rw_t 的指针： 123class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK);&#125; 对这片内存读写处于并发环境，但并不需要加锁，因为会通过对一些状态（realization or construction）判断来决定是否可读写。 class_data_bits_t 甚至还包含了一些对 class_rw_t 中 flags 成员存取的封装函数。 class_rw_tobjc_class 包含了 class_data_bits_t，class_data_bits_t 存储了 class_rw_t 的指针。 1234567891011121314151617181920212223struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;#if SUPPORT_INDEXED_ISA uint32_t index;#endif...省略操作 flags 的相关方法&#125; class_rw_t 中使用的 method_array_t, property_array_t, protocol_array_t 都继承自 list_array_tt&lt;Element, List&gt;, 它可以不断扩张，因为它可以存储 list 指针，内容有三种： 空 一个 entsize_list_tt 指针 entsize_list_tt 指针数组 class_rw_t 的内容是可以在运行时被动态修改的，可以说运行时对类的拓展大都是存储在这里的。 class_rw_t-&gt;flags 存储的值并不是编辑器设置的，其中有些值可能将来会作为 ABI 的一部分。下面这些 RW_ 前缀的宏标记了 flags 一些位置的含义。这些 bool 值标记了类的一些状态，涉及到声明周期和内存管理。有些位目前甚至还空着。 12345678910111213141516171819202122232425262728293031// Values for class_rw_t-&gt;flags// These are not emitted by the compiler and are never used in class_ro_t. // Their presence should be considered in future ABI versions.// class_t-&gt;data is class_rw_t, not class_ro_t#define RW_REALIZED (1&lt;&lt;31)// class is unresolved future class#define RW_FUTURE (1&lt;&lt;30)// class is initialized#define RW_INITIALIZED (1&lt;&lt;29)// class is initializing#define RW_INITIALIZING (1&lt;&lt;28)// class_rw_t-&gt;ro is heap copy of class_ro_t#define RW_COPIED_RO (1&lt;&lt;27)// class allocated but not yet registered#define RW_CONSTRUCTING (1&lt;&lt;26)// class allocated and registered#define RW_CONSTRUCTED (1&lt;&lt;25)// available for use; was RW_FINALIZE_ON_MAIN_THREAD// #define RW_24 (1&lt;&lt;24)// class +load has been called#define RW_LOADED (1&lt;&lt;23)#if !SUPPORT_NONPOINTER_ISA// class instances may have associative references#define RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS (1&lt;&lt;22)#endif// class has instance-specific GC layout#define RW_HAS_INSTANCE_SPECIFIC_LAYOUT (1 &lt;&lt; 21)// class does not allow associated objects on its instances#define RW_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;20)// class has started realizing but not yet completed it#define RW_REALIZING (1&lt;&lt;19) demangledName 是计算机语言用于解决实体名称唯一性的一种方法，做法是向名称中添加一些类型信息，用于从编译器中向链接器传递更多语义信息。 class_ro_tclass_rw_t 提供了运行时对类拓展的能力，而 class_ro_t 存储的大多是类在编译时就已经确定的信息。二者都存有类的方法、属性（成员变量）、协议等信息，不过存储它们的列表实现方式不同。 class_ro_t 中的 method_list_t, ivar_list_t, property_list_t 结构体都继承自 entsize_list_tt&lt;Element, List, FlagMask&gt;。结构为 xxx_list_t 的列表元素结构为 xxx_t，命名很工整。protocol_list_t 与前三个不同，它存储的是 protocol_t * 指针列表，实现比较简单。 entsize_list_tt 实现了 non-fragile 特性的数组结构。假如苹果在新版本的 SDK 中向 NSObject 类增加了一些内容，NSObject 的占据的内存区域会扩大，开发者以前编译出的二进制中的子类就会与新的 NSObject 内存有重叠部分。于是在编译期会给 instanceStart 和 instanceSize 赋值，确定好编译时每个类的所占内存区域起始偏移量和大小，这样只需将子类与基类的这两个变量作对比即可知道子类是否与基类有重叠，如果有，也可知道子类需要挪多少偏移量。 123456789101112131415161718192021222324struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; // This field exists only when RO_HAS_SWIFT_INITIALIZER is set. _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0];...省略其他方法&#125;; class_ro_t-&gt;flags 存储了很多在编译时期就确定的类的信息，也是 ABI 的一部分。下面这些 RO_ 前缀的宏标记了 flags 一些位置的含义。其中后三个并不需要被编译器赋值，是预留给运行时加载和初始化类的标志位，涉及到与 class_rw_t 的类型强转。运行时会用到它做判断，后面会讲解。 1234567891011121314151617181920212223242526272829303132333435// class_data_bits_t is the class_t-&gt;data field (class_rw_t pointer plus flags)// The extra bits are optimized for the retain/release and alloc/dealloc paths.// Values for class_ro_t-&gt;flags// These are emitted by the compiler and are part of the ABI.// Note: See CGObjCNonFragileABIMac::BuildClassRoTInitializer in clang// class is a metaclass#define RO_META (1&lt;&lt;0)// class is a root class#define RO_ROOT (1&lt;&lt;1)// class has .cxx_construct/destruct implementations#define RO_HAS_CXX_STRUCTORS (1&lt;&lt;2)// class has +load implementation// #define RO_HAS_LOAD_METHOD (1&lt;&lt;3)// class has visibility=hidden set#define RO_HIDDEN (1&lt;&lt;4)// class has attribute(objc_exception): OBJC_EHTYPE_$_ThisClass is non-weak#define RO_EXCEPTION (1&lt;&lt;5)// class has ro field for Swift metadata initializer callback#define RO_HAS_SWIFT_INITIALIZER (1&lt;&lt;6)// class compiled with ARC#define RO_IS_ARC (1&lt;&lt;7)// class has .cxx_destruct but no .cxx_construct (with RO_HAS_CXX_STRUCTORS)#define RO_HAS_CXX_DTOR_ONLY (1&lt;&lt;8)// class is not ARC but has ARC-style weak ivar layout #define RO_HAS_WEAK_WITHOUT_ARC (1&lt;&lt;9)// class does not allow associated objects on instances#define RO_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;10)// class is in an unloadable bundle - must never be set by compiler#define RO_FROM_BUNDLE (1&lt;&lt;29)// class is unrealized future class - must never be set by compiler#define RO_FUTURE (1&lt;&lt;30)// class is realized - must never be set by compiler#define RO_REALIZED (1&lt;&lt;31) 总结我们可以用如下这张图来分别表示 Objective-C 2.0 版本中类和对象的定义，及相关数据结构的关系： Category 相关的数据结构本文中要介绍的 Category 其实是 category_t 结构体的指针。 1#if __OBJC2__typedef struct category_t *Category; category_t 存储了类别中可以拓展的实例方法、类方法、协议、实例属性和类属性。类属性是 Objective-C 2016 年新增的特性，沾 Swift 的光。所以 category_t 中有些成员变量是为了兼容 Swift 的特性，Objective-C 暂没提供接口，仅做了底层数据结构上的兼容。 1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; 在 App 启动加载镜像文件时，会在 _read_images 函数间接调用到 attachCategories 函数，完成向类中添加 Category 的工作。原理就是向 class_rw_t 中的 method_array_t, property_array_t, protocol_array_t 数组中分别添加 method_list_t, property_list_t, protocol_list_t 指针。之前讲过 xxx_array_t 可以存储对应 xxx_list_t 的指针数组。 在调用 attachCategories 函数之前，会先使用 unattachedCategoriesForClass 函数获取类中还未添加的类别列表。这个列表类型为 category_list，相关定义如下： 1234567891011121314typedef locstamped_category_list_t category_list;struct locstamped_category_t &#123; category_t *cat; struct header_info *hi;&#125;;struct locstamped_category_list_t &#123; uint32_t count;#if __LP64__ uint32_t reserved;#endif locstamped_category_t list[0];&#125;; 它封装了 category_t 以及对应的 header_info。header_info 存储了实体在镜像中的加载和初始化状态，以及一些偏移量，在加载 Mach-O 文件相关函数中经常用到。 所以更具体来说 attachCategories 做的就是将 locstamped_category_list_t.list 列表中每个 locstamped_category_t.cat 中的那方法、协议和属性分别添加到类的 class_rw_t 对应列表中。header_info 中的信息决定了是否是元类，从而选择应该是添加实例方法还是类方法、实例属性还是类属性等。源码在 objc-runtime-new.mm 文件中，下面我们就来通过源码详细了解一下，Category是如何加载的。 追本溯源-Category如何加载我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。 对于OC运行时，入口方法如下（在objc-os.mm文件中）： 123456789101112131415161718192021/************************************************************************ _objc_init* Bootstrap initialization. Registers our image notifier with dyld.* Called by libSystem BEFORE library initialization time**********************************************************************/void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);&#125; category被附加到类上面是在map_images的时候发生的，该方法实现如下： 1234567891011121314/************************************************************************ map_images* Process the given images which are being mapped in by dyld.* Calls ABI-agnostic code after taking ABI-specific locks.** Locking: write-locks runtimeLock**********************************************************************/voidmap_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[])&#123; mutex_locker_t lock(runtimeLock); return map_images_nolock(count, paths, mhdrs);&#125; 方法调用了map_images_nolock来实现主要的逻辑： 1234567891011121314151617181920212223242526272829/************************************************************************ map_images_nolock* Process the given images which are being mapped in by dyld.* All class registration and fixups are performed (or deferred pending* discovery of missing superclasses etc), and +load methods are called.** info[] is in bottom-up order i.e. libobjc will be earlier in the * array than any library that links to libobjc.** Locking: loadMethodLock(old) or runtimeLock(new) acquired by map_images.**********************************************************************/#if __OBJC2__#include \"objc-file.h\"#else#include \"objc-file-old.h\"#endifvoid map_images_nolock(unsigned mhCount, const char * const mhPaths[], const struct mach_header * const mhdrs[])&#123; /* ... */ if (hCount &gt; 0) &#123; _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses); &#125; firstTime = NO;&#125; 方法末尾调用了_read_images方法，在 _read_images 方法中有如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/************************************************************************ _read_images* Perform initial processing of the headers in the linked * list beginning with headerList. ** Called by: map_images_nolock** Locking: runtimeLock acquired by map_images**********************************************************************/void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)&#123; /* ... */ #define EACH_HEADER \\ hIndex = 0; \\ hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \\ hIndex++ /* ... */ // Discover categories. for (EACH_HEADER) &#123; // 获取分类列表 category_t **catlist = _getObjc2CategoryList(hi, &amp;count); // 读取header_info中的信息，记录是否是元类标识 bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties(); // 遍历前面获取到的分类列表 for (i = 0; i &lt; count; i++) &#123; // 根据下标获取当前的分类 category_t *cat = catlist[i]; // 对分类关联的cls进行修正来获取分类管理的class Class cls = remapClass(cat-&gt;cls); if (!cls) &#123;// 如果分类关联的类为nil // Category's target class is missing (probably weak-linked). // Disavow any knowledge of this category. // 将分类列表当前下标置成nil catlist[i] = nil; if (PrintConnecting) &#123; _objc_inform(\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \" \"missing weak-linked target class\", cat-&gt;name, cat); &#125; continue; &#125; // Process this category. // First, register the category with its target class. // Then, rebuild the class's method lists (etc) if // the class is realized. bool classExists = NO; // 如果分类中包含实例方法列表、协议列表或者属性列表 if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; // 将分类添加到类的还未关联的类别列表 addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) &#123; // 向 `class_rw_t` 中的 `method_array_t`, `property_array_t`, `protocol_array_t` 数组中分别添加 `method_list_t`, `property_list_t`, `protocol_list_t` 指针 remethodizeClass(cls); classExists = YES; &#125; if (PrintConnecting) &#123; _objc_inform(\"CLASS: found category -%s(%s) %s\", cls-&gt;nameForLogging(), cat-&gt;name, classExists ? \"on existing class\" : \"\"); &#125; &#125; // 如果分类中包含类方法列表、协议列表或者是元类且有类属性列表 if (cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123; // 将分类添加到类的还未关联的类别列表 addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) &#123; // 向元类的 `class_rw_t` 中的 `method_array_t`, `property_array_t`, `protocol_array_t` 数组中分别添加 `method_list_t`, `property_list_t`, `protocol_list_t` 指针 remethodizeClass(cls-&gt;ISA()); &#125; if (PrintConnecting) &#123; _objc_inform(\"CLASS: found category +%s(%s)\", cls-&gt;nameForLogging(), cat-&gt;name); &#125; &#125; &#125; &#125; /* ... */&#125; isRealized()方法获取到是类是否被初始化。 1234// Locking: To prevent concurrent realization, hold runtimeLock.bool isRealized() &#123; return data()-&gt;flags &amp; RW_REALIZED;&#125; 在某个类初始化之前，objc_class-&gt;data() 返回的指针指向的其实是个 class_ro_t 结构体。等到 static Class realizeClass(Class cls) 静态方法在类第一次初始化时被调用，它会: 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针 初始化一个 class_rw_t 结构体 设置结构体 ro 的值以及 flag 最后设置正确的 data。 将 class_ro_t 指针赋值给 class_rw_t-&gt;ro。这种偷天换日的行为是靠 RO_FUTURE 标志位来记录的： 123456789101112131415161718192021222324252627/************************************************************************ realizeClassWithoutSwift* Performs first-time initialization on class cls, * including allocating its read-write data.* Does not perform any Swift-side initialization.* Returns the real class structure for the class. * Locking: runtimeLock must be write-locked by the caller**********************************************************************/static Class realizeClassWithoutSwift(Class cls)&#123;... ro = (const class_ro_t *)cls-&gt;data(); if (ro-&gt;flags &amp; RO_FUTURE) &#123; // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro; cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE); &#125; else &#123; // Normal class. Allocate writeable class data. rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); rw-&gt;ro = ro; rw-&gt;flags = RW_REALIZED|RW_REALIZING; cls-&gt;setData(rw); &#125;...省略逻辑实现&#125; 注意之前 RO 和 RW flags 宏标记的一个细节： 12345#define RO_FUTURE (1&lt;&lt;30)#define RO_REALIZED (1&lt;&lt;31)#define RW_REALIZED (1&lt;&lt;31)#define RW_FUTURE (1&lt;&lt;30) 也就是说 ro = (const class_ro_t *)cls-&gt;data(); 这种强转对于接下来的 ro-&gt;flags &amp; RO_FUTURE 操作完全是 OK 的，两种结构体第一个成员都是 flags，RO_FUTURE 与 RW_FUTURE 值一样的。 经过 realizeClass 函数处理的类才是『真正的』类，调用它时不能对类做写操作。 代码片段中remapClass方法主要是对分类关联的cls进行修正来获取分类管理的class，源码实现如下： 123456789101112131415161718192021222324252627/************************************************************************ remapClass* Returns the live class pointer for cls, which may be pointing to * a class struct that has been reallocated.* Returns nil if cls is ignored because of weak linking.* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static Class remapClass(Class cls)&#123; runtimeLock.assertLocked(); Class c2; if (!cls) return nil; NXMapTable *map = remappedClasses(NO); if (!map || NXMapMember(map, cls, (void**)&amp;c2) == NX_MAPNOTAKEY) &#123; return cls; &#125; else &#123; return c2; &#125;&#125;static Class remapClass(classref_t cls)&#123; return remapClass((Class)cls);&#125; addUnattachedCategoryForClass 的作用是将分类添加到类的还未关联的类别列表，方法实现如下: 12345678910111213141516171819202122232425/************************************************************************ addUnattachedCategoryForClass* Records an unattached category.* Locking: runtimeLock must be held by the caller.**********************************************************************/static void addUnattachedCategoryForClass(category_t *cat, Class cls, header_info *catHeader)&#123; runtimeLock.assertLocked(); // DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead NXMapTable *cats = unattachedCategories(); category_list *list; list = (category_list *)NXMapGet(cats, cls); if (!list) &#123; list = (category_list *) calloc(sizeof(*list) + sizeof(list-&gt;list[0]), 1); &#125; else &#123; list = (category_list *) realloc(list, sizeof(*list) + sizeof(list-&gt;list[0]) * (list-&gt;count + 1)); &#125; list-&gt;list[list-&gt;count++] = (locstamped_category_t)&#123;cat, catHeader&#125;; NXMapInsert(cats, cls, list);&#125; remethodizeClass是真正将分类和类关联的函数，会修正类的方法列表、协议列表和属性列表，并更新缓存。源码如下： 123456789101112131415161718192021222324252627/************************************************************************ remethodizeClass* Attach outstanding categories to an existing class.* Fixes up cls's method list, protocol list, and property list.* Updates method caches for cls and its subclasses.* Locking: runtimeLock must be held by the caller**********************************************************************/static void remethodizeClass(Class cls)&#123; category_list *cats; bool isMeta; runtimeLock.assertLocked(); isMeta = cls-&gt;isMetaClass(); // Re-methodizing: check for more categories if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123; if (PrintConnecting) &#123; _objc_inform(\"CLASS: attaching categories to class '%s' %s\", cls-&gt;nameForLogging(), isMeta ? \"(meta)\" : \"\"); &#125; attachCategories(cls, cats, true /*flush caches*/); free(cats); &#125;&#125; 方法会调用unattachedCategoriesForClass获取类中还未添加的类别列表 12345678910111213/************************************************************************ unattachedCategoriesForClass* Returns the list of unattached categories for a class, and * deletes them from the list. * The result must be freed by the caller. * Locking: runtimeLock must be held by the caller.**********************************************************************/static category_list *unattachedCategoriesForClass(Class cls, bool realizing)&#123; runtimeLock.assertLocked(); return (category_list *)NXMapRemove(unattachedCategories(), cls);&#125; 如果列表不为空，则会调用attachCategories将所有未关联的分类进行关联处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Attach method lists and properties and protocols from categories to a class.// Assumes the categories in cats are all loaded and sorted by load order, // oldest categories first.static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); bool isMeta = cls-&gt;isMetaClass(); // fixme rearrange to remove these intermediate allocations method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; int propcount = 0; int protocount = 0; int i = cats-&gt;count; bool fromBundle = NO; while (i--) &#123; auto&amp; entry = cats-&gt;list[i]; method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; auto rw = cls-&gt;data(); prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);&#125; 方法会通过 while 循环，遍历所有的 category，并将 category 中的 list 属性拼接成一个大的二维数组，数组的每一个元素都是装有一个 category 所有方法、协议或者属性的容器，最后再通过 attachLists 将二维数组添加到类的 class_rw_t 中的 method_array_t, property_array_t, protocol_array_t 中。","categories":[{"name":"刨根问底","slug":"刨根问底","permalink":"http://heseng91.github.io/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}],"tags":[]},{"title":"「刨根问底」之Runtime消息发送和转发","slug":"「刨根问底」之Runtime消息发送和转发","date":"2018-09-08T18:10:09.000Z","updated":"2023-02-04T19:48:58.801Z","comments":true,"path":"2018/09/09/「刨根问底」之Runtime消息发送和转发/","link":"","permalink":"http://heseng91.github.io/2018/09/09/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/","excerpt":"上篇文章Runtime类和对象的定义 中提到了源代码到可执行文件需要需要经过编译和链接。其中编译通常会先预处理，再编译。iOS中预编译是使用Clang完成的。","text":"上篇文章Runtime类和对象的定义 中提到了源代码到可执行文件需要需要经过编译和链接。其中编译通常会先预处理，再编译。iOS中预编译是使用Clang完成的。 下面新建一个工程并修改一下main.m文件如下： 12345678910#import &lt;UIKit&#x2F;UIKit.h&gt;#import &quot;AppDelegate.h&quot;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; UIViewController *vc &#x3D; [[UIViewController alloc] init]; [vc viewDidLoad]; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 打开终端，cd到工程目录，然后执行如下命令，对源文件进行clang rewrite， 1xcrun -sdk iphonesimulator13.2 clang -rewrite-objc -F &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneOS13.2.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneOS.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks SecondViewController.m iphonesimulator13.2中 13.2 为当前xcode SDK版本号（指令xcodebuild -showsdks即可查看），在得到的main.cpp文件末尾，可以找到源代码clang后的代码： 1234567int main(int argc, char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; UIViewController *vc = ((UIViewController *(*)(id, SEL))(void *)objc_msgSend)((id)((UIViewController *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"UIViewController\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")); ((void (*)(id, SEL))(void *)objc_msgSend)((id)vc, sel_registerName(\"viewDidLoad\")); return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AppDelegate\"), sel_registerName(\"class\")))); &#125;&#125; 从中可以得知: [receiver message] 其实会被编译器转化为： 1objc_msgSend(receiver, selector) 本篇就来详细分析一下Objective-C消息发送和转发机制。 消息发送和转发流程可以概括为： 消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现； 消息转发（Message Forwarding）是在查找 IMP 失败后执行一系列转发流程的慢速通道，如果不作转发处理，则会打日志和抛出异常。 本文将从源码角度分析消息发送和转发的原理。能够很好地阅读本文的前提是你对 Objective-C Runtime 已经有一定的了解，关于什么是消息，Class 的结构，selector、IMP、元类等概念将不再赘述。本文用到的源码为 objc4-756.2，汇编语言架构为 arm64。 objc_msgSend函数简介此函数是消息发送必经之路。objc_msgSend函数究竟会干什么事情呢？从这篇「objc_msgSend() Tour」文章里面可以得到一个比较详细的结论。 1234567891. Check for ignored selectors (GC) and short-circuit.2. Check for nil target. If nil &amp; nil receiver handler configured, jump to handler If nil &amp; no handler (default), cleanup and return.3. Search the class’s method cache for the method IMP(use hash to find&amp;store method in cache) -1. If found, jump to it. -2. Not found: lookup the method IMP in the class itself corresponding its hierarchy chain. If found, load it into cache and jump to it. If not found, jump to forwarding mechanism. 总结一下objc_msgSend会做以下几件事情： 检测这个 selector是不是要忽略的。 检查target是不是为nil。 如果这里有相应的nil的处理函数，就跳转到相应的函数中。如果没有处理nil的函数，就自动清理现场并返回。这一点就是为何在OC中给nil发送消息不会崩溃的原因。 确定不是给nil发消息之后，在该class的缓存中查找方法对应的IMP实现。 如果找到，就跳转进去执行。如果没有找到，就在方法分发表里面继续查找，一直找到NSObject为止。 如果还没有找到，那就需要开始消息转发阶段了。至此，发送消息Messaging阶段完成。这一阶段主要完成的是通过selecter快速查找IMP的过程。 源码解析在这篇文章Obj-C Optimization: The faster objc_msgSend中看到了这样一段C版本的objc_msgSend的源码。 Objective-C 123456789101112131415161718192021222324252627282930313233#include &lt;objc/objc-runtime.h&gt;id c_objc_msgSend( struct objc_class /* ahem */ *self, SEL _cmd, ...)&#123; struct objc_class *cls; struct objc_cache *cache; unsigned int hash; struct objc_method *method; unsigned int index; if( self) &#123; cls = self-&gt;isa; cache = cls-&gt;cache; hash = cache-&gt;mask; index = (unsigned int) _cmd &amp; hash; do &#123; method = cache-&gt;buckets[ index]; if( ! method) goto recache; index = (index + 1) &amp; cache-&gt;mask; &#125; while( method-&gt;method_name != _cmd); return( (*method-&gt;method_imp)( (id) self, _cmd)); &#125; return( (id) self);recache: /* ... */ return( 0);&#125; 该源码中有一个do-while循环，这个循环就是前面提到的在方法分发表里面查找method的过程。 _objc_msgSend源码分析不过在 objc4-756.2里面objc_msgSend 是用汇编语言写的，针对不同架构有不同的实现。objc-msg-arm64.s文件中实现是如下一段汇编代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&#x2F;&#x2F; objc_msgSend 汇编入口 ENTRY _objc_msgSend &#x2F;&#x2F; 无窗口 UNWIND _objc_msgSend, NoFrame&#x2F;&#x2F; p0：objc_msgSend的第一个参数，即消息接受者&#x2F;&#x2F; cmp: 比较&#x2F;&#x2F; #0：nil&#x2F;&#x2F; 判断p0是否为空 cmp p0, #0 &#x2F;&#x2F; nil check and tagged pointer check&#x2F;&#x2F; 支持taggedpointer的流程#if SUPPORT_TAGGED_POINTERS&#x2F;&#x2F; b.le: 执行标号，判断上面cmp值是小于等于，如果receiver为nil或taggedpointer，则执行LNilOrTagged b.le LNilOrTagged &#x2F;&#x2F; (MSB tagged pointer looks negative)#else&#x2F;&#x2F; b.eq: 执行标号，判断上面cmp值是等于，如果receiver为nil，则执行LReturnZero&#x2F;&#x2F; p0为空，返回空 b.eq LReturnZero#endif&#x2F;&#x2F; p0不为空，即receiver 存在的流程&#x2F;&#x2F; ldr 把数据从内存中某处读取到寄存器&#x2F;&#x2F; p13 &#x3D; x0栈内存中的值，从x0寄存器指向的地址中取出 isa，并把isa赋值给p13 ldr p13, [x0] &#x2F;&#x2F; p13 &#x3D; isa&#x2F;&#x2F; 在64位架构下通过 p16 &#x3D; isa（p13） &amp; ISA_MASK，获取shiftcls，从而得到class信息 GetClassFromIsa_p16 p13 &#x2F;&#x2F; p16 &#x3D; classLGetIsaDone:&#x2F;&#x2F; 如果isa存在，调用CacheLookup，开始cache查找流程(快速查找流程sel-&gt;imp)&#x2F;&#x2F; 找到就返回imp，没找到就返回objc_msgSend_uncached CacheLookup NORMAL &#x2F;&#x2F; calls imp or objc_msgSend_uncached&#x2F;&#x2F; 支持taggedpointer#if SUPPORT_TAGGED_POINTERS&#x2F;&#x2F; LNilOrTagged条件判断逻辑LNilOrTagged:&#x2F;&#x2F; 等于空，返回空 b.eq LReturnZero &#x2F;&#x2F; nil check &#x2F;&#x2F; tagged &#x2F;&#x2F; adrp 计算指定的数据地址到当前pc寄存器值相对偏移 &#x2F;&#x2F; 得到包含_objc_debug_taggedpointer_classes地址的page的基址，arm64架构中page大小为16kb。 &#x2F;&#x2F; 并将该page的基址存到寄存器X10中； adrp x10, _objc_debug_taggedpointer_classes@PAGE &#x2F;&#x2F; add 加 &#x2F;&#x2F; x10 &#x3D; x10 + _objc_debug_taggedpointer_classes@PAGEOFF（偏移量） &#x2F;&#x2F; 即计算出_objc_debug_taggedpointer_classes的地址，并存到寄存器X10中 add x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF &#x2F;&#x2F; ubfx 无符号位段提取（ubfx Xd, Xn, #lsb, #width。表示从Wn寄存器的第lsb位开始，提取width位到Wd寄存器，剩余高位用0填充） &#x2F;&#x2F; 从x0寄存器的第60位开始，提取4位到x11寄存器，剩余高位用0填充，即提取指针的最后四位（标记tagged pointer的位）存到x11寄存器 ubfx x11, x0, #60, #4 &#x2F;&#x2F; ldr 加载字到寄存器 &#x2F;&#x2F; lsl 逻辑或算术左移 &#x2F;&#x2F; x16 &#x3D; x10 + (x11&lt;&lt;3)， 获取taggedpointer标识位，并存到x16寄存器 ldr x16, [x10, x11, LSL #3] adrp x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE add x10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF cmp x10, x16 &#x2F;&#x2F; b.ne 判断上面cmp的值是不等于 执行标号，否则直接往下走 b.ne LGetIsaDone &#x2F;&#x2F; ext tagged adrp x10, _objc_debug_taggedpointer_ext_classes@PAGE add x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF ubfx x11, x0, #52, #8 ldr x16, [x10, x11, LSL #3] b LGetIsaDone&#x2F;&#x2F; SUPPORT_TAGGED_POINTERS#endifLReturnZero: &#x2F;&#x2F; x0 is already zero &#x2F;&#x2F; 1、首先先把 x1 清空，x0 这里是 self，已经是0，所以不需要清空 mov x1, #0 &#x2F;&#x2F; 2、清空 v 寄存器 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 ret END_ENTRY _objc_msgSend 主要有以下几步 【第一步】判断objc_msgSend方法的第一个参数receiver是否为空 判断receiver如果为空，则直接返回空，即LReturnZero； 如果支持tagged pointer对象，判断如果为tagged pointer对象，跳转至【第二步】 否则，如果receiver不为tagged pointer对象且不为空，从receiver中取出isa存入p13寄存器， 通过 GetClassFromIsa_p16中，arm64架构下通过 isa &amp; ISA_MASK 获取shiftcls位域的类信息，即class，GetClassFromIsa_p16的汇编实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&#x2F;&#x2F; .macro 汇编宏定义.macro GetClassFromIsa_p16 &#x2F;* src *&#x2F;#if SUPPORT_INDEXED_ISA&#x2F;&#x2F; mov指令是数据传送指令，用于将一个数据从源地址传送到目标地址，其特点是不破坏源地址单元的内容。&#x2F;&#x2F; 把传入的值src赋值给p16寄存器，p16 &#x3D; class &#x2F;&#x2F; Indexed isa mov p16, $0 &#x2F;&#x2F; optimistically set dst &#x3D; src&#x2F;&#x2F; # define ISA_INDEX_IS_NPI_BIT 0&#x2F;&#x2F; tbz 条件执行&#x2F;&#x2F; 判断p16寄存器中存储的class指针最后一位如果不为0，即如果是tagged pointer，则直接跳转到1，直接结束 tbz p16, #ISA_INDEX_IS_NPI_BIT, 1f &#x2F;&#x2F; done if not non-pointer isa&#x2F;&#x2F; adrp 计算指定的数据地址到当前pc寄存器值相对偏移 &#x2F;&#x2F; 得到包含_objc_indexed_classes地址的page的基址，arm64架构中page大小为16kb。 &#x2F;&#x2F; 并将该page的基址存到寄存器X10中； &#x2F;&#x2F; isa in p16 is indexed adrp x10, _objc_indexed_classes@PAGE&#x2F;&#x2F; x10 &#x3D; x10 + _objc_indexed_classes@PAGEOFF（_objc_indexed_classes在page中的偏移量），即计算出_objc_debug_taggedpointer_classes的地址，并存到寄存器X10中 add x10, x10, _objc_indexed_classes@PAGEOFF&#x2F;&#x2F; ubfx:有符号和无符号位域提取。 将一个寄存器中相邻的位复制到另一个寄存器的最低有效位，并用符号或零扩展到 32 位。&#x2F;&#x2F; 从p16的第ISA_INDEX_SHIFT位开始，提取 ISA_INDEX_BITS 位 到 p16寄存器，剩余的高位用0补充&#x2F;&#x2F; # define ISA_INDEX_SHIFT 2&#x2F;&#x2F; # define ISA_INDEX_BITS 15&#x2F;&#x2F; 从p16寄存器的第2位开始，提取15位到p16寄存器，剩余高位用0填充 ubfx p16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS &#x2F;&#x2F; extract index&#x2F;&#x2F; #define PTRSHIFT 3 &#x2F;&#x2F; 1&lt;&lt;PTRSHIFT &#x3D;&#x3D; PTRSIZE&#x2F;&#x2F; #define UXTP UXTX ldr p16, [x10, p16, UXTP #PTRSHIFT] &#x2F;&#x2F; load class from array1:&#x2F;&#x2F; 如果是64位#elif __LP64__ &#x2F;&#x2F; 64-bit packed isa&#x2F;&#x2F; p16 &#x3D; class &#x3D; isa &amp; ISA_MASK(位运算 &amp; 即获取isa中的shiftcls信息) and p16, $0, #ISA_MASK#else &#x2F;&#x2F; 32-bit raw isa mov p16, $0#endif&#x2F;&#x2F; 宏定义结束.endmacro 然后走到【第二步】 【第二步】获取isa完毕，调用CacheLookup NORMAL在缓存中查找方法。 CacheLookup源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&#x2F;&#x2F; 定义CacheLookup宏.macro CacheLookup &#x2F;&#x2F; ldp:从栈取&#x2F;存数据 &#x2F;&#x2F; #define CACHE (2 * __SIZEOF_POINTER__)，其中 __SIZEOF_POINTER__表示pointer的大小 ，即 2*8 &#x3D; 16 &#x2F;&#x2F; p11 &#x3D; mask|buckets，从x16（即isa）中平移16字节，获取cache地址。isa距离cache 正好16字节：isa（8字节）+ superClass（8字节） &#x2F;&#x2F; 从cache中分别取出 buckets 和 occupied|mask 存入 p10（存储buckets） 和 p11（存储occupied|mask） &#x2F;&#x2F; p1 &#x3D; SEL, p16 &#x3D; isa ldp p10, p11, [x16, #CACHE] &#x2F;&#x2F; p10 &#x3D; buckets, p11 &#x3D; occupied|mask#if !__LP64__ and w11, w11, 0xffff &#x2F;&#x2F; p11 &#x3D; mask#endif &#x2F;&#x2F; and 按位“与”操作，key &amp; mask得到cache_hash and w12, w1, w11 &#x2F;&#x2F; x12 &#x3D; _cmd &amp; mask add p12, p10, p12, LSL #(1+PTRSHIFT) &#x2F;&#x2F; p12 &#x3D; buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT)) &#x2F;&#x2F; 从x12（即p12）中取出 bucket 分别将imp和sel 存入 p17（存储imp） 和 p9（存储sel） ldp p17, p9, [x12] &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket&#x2F;&#x2F; 比较 sel 与 p1（传入的参数cmd）1: cmp p9, p1 &#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd) &#x2F;&#x2F; 如果不相等，即没有找到，跳转至 2f b.ne 2f &#x2F;&#x2F; scan more &#x2F;&#x2F; 如果相等，即缓存命中，执行cacheHit直接调用或返回imp CacheHit $0 &#x2F;&#x2F; call or return imp 2: &#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket &#x2F;&#x2F; 如果一直都找不到，因为是normal，跳转至__objc_msgSend_uncached CheckMiss $0 &#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0 &#x2F;&#x2F; 判断p12（当前的bucket）是否 是 p10（buckets数组第一个元素，） cmp p12, p10 &#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets &#x2F;&#x2F; 如果想等，跳转至 3f b.eq 3f &#x2F;&#x2F; 从x12（即p12 buckets首地址）- 实际需要平移的内存大小BUCKET_SIZE，得到得到第二个bucket元素，imp-sel分别存入p17-p9，即向前查找 ldp p17, p9, [x12, #-BUCKET_SIZE]! &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket &#x2F;&#x2F; 跳转至第1步，继续对比 sel 与 cmd b 1b &#x2F;&#x2F; loop3: &#x2F;&#x2F; wrap: p12 &#x3D; first bucket, w11 &#x3D; mask &#x2F;&#x2F; mask左移4位，直接定位到buckets的最后一个元素，缓存查找顺序是向前查找 add p12, p12, w11, UXTW #(1+PTRSHIFT) &#x2F;&#x2F; p12 &#x3D; buckets + (mask &lt;&lt; 1+PTRSHIFT) &#x2F;&#x2F; Clone scanning loop to miss instead of hang when cache is corrupt. &#x2F;&#x2F; The slow path may detect any corruption and halt later. ldp p17, p9, [x12] &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket1: cmp p9, p1 &#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd) b.ne 2f &#x2F;&#x2F; scan more CacheHit $0 &#x2F;&#x2F; call or return imp 2: &#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket &#x2F;&#x2F; 判断p12（当前遍历到的bucket）是否等于 p10（buckets数组第一个元素）即前面已经没有了 CheckMiss $0 &#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0 cmp p12, p10 &#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets b.eq 3f &#x2F;&#x2F; 偏移获取前一个bucket，并取出imp和sel分别存入p17、p9，即向前查找 ldp p17, p9, [x12, #-BUCKET_SIZE]! &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket &#x2F;&#x2F; 跳转至第1步，继续对比 sel 与 cmd b 1b &#x2F;&#x2F; loop3: &#x2F;&#x2F; double wrap &#x2F;&#x2F; 跳转至JumpMiss 因为是normal ，跳转至__objc_msgSend_uncached JumpMiss $0 .endmacro 主要分为以下几步 【第一步】通过isa首地址平移16字节（因为在objc_class中，首地址距离cache正好16字节，即isa首地址 占8字节，superClass占8字节），获取cahce，并将cache中的buckets存放到p10寄存器中，将cache中的occupied|mask存放到p11寄存器中 【第二步】由mask根据哈希算法计算出下标 将objc_msgSend的参数p1（即第二个参数_cmd）和p11中存放的msak进行&amp;运算，得到需要查找存储sel-imp的bucket下标index，即p12 = index = _cmd &amp; mask。 【第三步】根据所得的哈希下标index 和 buckets首地址，取出哈希下标对应的bucket，并存放到p12寄存器中p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT)) 其中PTRSHIFT等于3，左移4位（即2^4 = 16字节）即是一个bucket实际占用的大小,结构体bucket_t中sel占8字节，imp占8字节 根据计算的哈希下标index 乘以单个bucket占用的内存大小，得到bucket相当于buckets首地址的偏移量 通过首地址 + 实际偏移量，获取哈希下标index对应的bucket 【第四步】根据获取的bucket，取出其中的imp和sel分别存入p17和p9寄存器 【第五步】遍历buckets查找缓存的方法 比较sel和传入的参数cmd是否相等，如果不相等，即没找到，执行下一步，否则如果相等，即缓存命中，执行CacheHit函数返回imp 123456789101112131415161718&#x2F;&#x2F; CacheHit: x17 &#x3D; cached IMP, x12 &#x3D; address of cached IMP, x1 &#x3D; SEL.macro CacheHit.if $0 &#x3D;&#x3D; NORMAL TailCallCachedImp x17, x12, x1 &#x2F;&#x2F; authenticate and call imp.elseif $0 &#x3D;&#x3D; GETIMP mov p0, p17 cbz p0, 9f &#x2F;&#x2F; don&#39;t ptrauth a nil imp AuthAndResignAsIMP x0, x12, x1 &#x2F;&#x2F; authenticate imp and re-sign as IMP9: ret &#x2F;&#x2F; return IMP.elseif $0 &#x3D;&#x3D; LOOKUP &#x2F;&#x2F; No nil check for ptrauth: the caller would crash anyway when they &#x2F;&#x2F; jump to a nil IMP. We don&#39;t care if that jump also fails ptrauth. AuthAndResignAsIMP x17, x12, x1 &#x2F;&#x2F; authenticate imp and re-sign as IMP ret &#x2F;&#x2F; return imp via x17.else.abort oops.endif.endmacro 这里传入的$0是normal会调用TailCallCachedImp执行imp 12345.macro TailCallCachedImp &#x2F;&#x2F; $0 &#x3D; cached imp, $1 &#x3D; address of cached imp, $2 &#x3D; SEL eor $1, $1, $2 &#x2F;&#x2F; mix SEL into ptrauth modifier brab $0, $1.endmacro 调用CheckMiss，判断是否一直找不到（bucket-&gt;sel == 0），即遇到空通，说明cache中没有该method。因此可见cache解决hash冲突的方式为开放寻址法（线性探测）。 123456789101112.macro CheckMiss &#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0.if $0 &#x3D;&#x3D; GETIMP cbz p9, LGetImpMiss.elseif $0 &#x3D;&#x3D; NORMAL cbz p9, __objc_msgSend_uncached.elseif $0 &#x3D;&#x3D; LOOKUP cbz p9, __objc_msgLookup_uncached.else.abort oops.endif.endmacro 因为$0是normal，如果一直都找不到，会跳转至__objc_msgSend_uncached，即进入慢速查找流程。否则执行下一步 如果根据index获取的bucket 等于 buckets的第一个元素，则将当前bucket设置为buckets的最后一个元素（通过buckets首地址+mask*16（等同于左移4位）直接定位到buckets的最后一个元素），并读取bucket的imp和sel`分别存入p17和p9寄存器，然后执行【第六步】；否则执行下一步 通过地址偏移，得到前一个bucket元素，并读取bucket的imp和sel`分别存入p17和p9寄存器，然后重复1 【第六步】第二次遍历查找：重复【第五步】的操作，与【第五步】中唯一区别是，如果当前的bucket还是等于 buckets的第一个元素，则直接跳转至JumpMiss， 1234567891011.macro JumpMiss.if $0 &#x3D;&#x3D; GETIMP b LGetImpMiss.elseif $0 &#x3D;&#x3D; NORMAL b __objc_msgSend_uncached.elseif $0 &#x3D;&#x3D; LOOKUP b __objc_msgLookup_uncached.else.abort oops.endif.endmacro 此时的$0是normal，也是直接跳转至__objc_msgSend_uncached，即进入慢速查找流程。 __objc_msgSend_uncached源码分析__objc_msgSend_uncached源码实现如下 12345678910STATIC_ENTRY __objc_msgSend_uncachedUNWIND __objc_msgSend_uncached, FrameWithNoSaves&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION&#x2F;&#x2F; Out-of-band p16 is the class to searchMethodTableLookupTailCallFunctionPointer x17END_ENTRY __objc_msgSend_uncached 该方法中主要调用了MethodTableLookup方法。 123456789101112131415161718192021222324252627282930313233343536373839404142.macro MethodTableLookup &#x2F;&#x2F; push frame SignLR stp fp, lr, [sp, #-16]! mov fp, sp &#x2F;&#x2F; save parameter registers: x0..x8, q0..q7 sub sp, sp, #(10*8 + 8*16) stp q0, q1, [sp, #(0*16)] stp q2, q3, [sp, #(2*16)] stp q4, q5, [sp, #(4*16)] stp q6, q7, [sp, #(6*16)] stp x0, x1, [sp, #(8*16+0*8)] stp x2, x3, [sp, #(8*16+2*8)] stp x4, x5, [sp, #(8*16+4*8)] stp x6, x7, [sp, #(8*16+6*8)] str x8, [sp, #(8*16+8*8)] &#x2F;&#x2F; receiver and selector already in x0 and x1 mov x2, x16 bl __class_lookupMethodAndLoadCache3 &#x2F;&#x2F; IMP in x0 mov x17, x0 &#x2F;&#x2F; restore registers and return ldp q0, q1, [sp, #(0*16)] ldp q2, q3, [sp, #(2*16)] ldp q4, q5, [sp, #(4*16)] ldp q6, q7, [sp, #(6*16)] ldp x0, x1, [sp, #(8*16+0*8)] ldp x2, x3, [sp, #(8*16+2*8)] ldp x4, x5, [sp, #(8*16+4*8)] ldp x6, x7, [sp, #(8*16+6*8)] ldr x8, [sp, #(8*16+8*8)] mov sp, fp ldp fp, lr, [sp], #16 AuthenticateLR.endmacro MethodTableLookup 可以算是个接口层宏，主要用于保存环境与准备参数，来调用 __class_lookupMethodAndLoadCache3函数（在objc-class-new.mm中）。 1234567891011/************************************************************************ _class_lookupMethodAndLoadCache.* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().* This lookup avoids optimistic cache scan because the dispatcher * already tried that.**********************************************************************/IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)&#123; return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/);&#125; __class_lookupMethodAndLoadCache3函数也是个接口层（C编写），此函数提供相应参数配置，实际功能在lookUpImpOrForward函数中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154/************************************************************************ lookUpImpOrForward.* The standard IMP lookup. * initialize==NO tries to avoid +initialize (but sometimes fails)* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)* Most callers should use initialize==YES and cache==YES.* inst is an instance of cls or a subclass thereof, or nil if none is known. * If cls is an un-initialized metaclass then a non-nil inst is faster.* May return _objc_msgForward_impcache. IMPs destined for external use * must be converted to _objc_msgForward or _objc_msgForward_stret.* If you don't want forwarding at all, use lookUpImpOrNil() instead.**********************************************************************/IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = nil; bool triedResolver = NO; // runtimeLock 本质上是对 Darwin 提供的线程读写锁 pthread_rwlock_t 的一层封装，提供了一些便捷的方法。 runtimeLock.assertUnlocked(); // Optimistic cache lookup // 如果使用缓存（cache 参数为 YES），那就调用 cache_getImp 方法从缓存查找 IMP。cache_getImp 是用汇编语言写的，也可以在 objc-msg-arm64.s 找到，其依然用了前文中说过的 CacheLookup 宏。因为 _class_lookupMethodAndLoadCache3 调用 lookUpImpOrForward 时 cache 参数为 NO，这步直接略过。 if (cache) &#123; imp = cache_getImp(cls, sel); if (imp) return imp; &#125; // runtimeLock is held during isRealized and isInitialized checking // to prevent races against concurrent realization. // runtimeLock is held during method search to make // method-lookup + cache-fill atomic with respect to method addition. // Otherwise, a category could be added but ignored indefinitely because // the cache was re-filled with the old value after the cache flush on // behalf of the category. runtimeLock.lock(); // 判断是否是一个已知的类：判断当前类是否是已经被认可的类，即已经加载的类。 checkIsKnownClass(cls); // 判断类是否已经Realized，如果没有，需要先Realized if (!cls-&gt;isRealized()) &#123; cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock); // runtimeLock may have been dropped but is now locked again &#125; // 判断如果入参传入的initialize为true，且类未实例化，需要先实例化 if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; cls = initializeAndLeaveLocked(cls, inst, runtimeLock); // runtimeLock may have been dropped but is now locked again // If sel == initialize, class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won't happen. 2778172 &#125; retry: // runtimeLock 上锁 runtimeLock.assertLocked(); // Try this class's cache. // 调用 cache_getImp 方法从缓存查找 IMP。 imp = cache_getImp(cls, sel); // 如果找到直接返回imp。 if (imp) goto done; // Try this class's method lists. &#123; // 在当前类中的方法列表（method list）中进行查找，也就是根据 selector 查找 Method Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123; // 如果在当前类的方法列表成功找到了Method// 获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。 log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); // 将找到的IMP直接返回imp imp = meth-&gt;imp; goto done; &#125; &#125; // 如果在当前类中的方法列表（method list）中没有找到Method，尝试在逐级在父类的缓存和方法列表中查找 // Try superclass caches and method lists. &#123; unsigned attempts = unreasonableClassCount(); // 在继承层级中递归向父类中查找，和上一步类似，也是先查找缓存，缓存没中就查找方法列表 for (Class curClass = cls-&gt;superclass; curClass != nil; curClass = curClass-&gt;superclass) &#123; // Halt if there is a cycle in the superclass chain. if (--attempts == 0) &#123; _objc_fatal(\"Memory corruption in class list.\"); &#125; // Superclass cache. // 调用 cache_getImp 方法从父类的缓存查找 IMP。 imp = cache_getImp(curClass, sel); if (imp) &#123; // 如果找到的imp不是_objc_msgForward_impcache if (imp != (IMP)_objc_msgForward_impcache) &#123; // Found the method in a superclass. Cache it in this class. // 将父类链中查找到的imp并填充到当前类的缓存中。 log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; &#125; else &#123; // 如果找到的imp是_objc_msgForward_impcache，退出循环 // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; &#125; &#125; // 在当前父类中的方法列表（method list）中进行查找，也就是根据 selector 查找到 Method 后，获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。 // Superclass method list. Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done; &#125; &#125; &#125; // No implementation found. Try method resolver once. // 参数 resolver 为 YES且是第一次执行到这里的时侯，进行动态方法解析 if (resolver &amp;&amp; !triedResolver) &#123; // 释放锁 runtimeLock.unlock(); // 间接地发送 +resolveInstanceMethod 或 +resolveClassMethod 消息。函数中实现了方法解析逻辑。如果 cls 是元类则会发送 +resolveClassMethod，然后根据 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 函数的结果来判断是否发送 +resolveInstanceMethod；如果不是元类，则只需要发送 +resolveInstanceMethod 消息。这里调用 +resolveInstanceMethod 或 +resolveClassMethod 时再次用到了 objc_msgSend，而且第三个参数正是传入 lookUpImpOrForward 的那个 sel。在发送方法解析消息之后还会调用 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 来判断是否已经添加上 sel 对应的 IMP 了，打印出结果。 resolveMethod(cls, sel, inst); // 读入锁加锁 runtimeLock.lock(); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; &#125; // No implementation found, and method resolver didn't help. // Use forwarding. // 将 _objc_msgForward_impcache 当做 IMP 并写入缓存 imp = (IMP)_objc_msgForward_impcache; cache_fill(cls, sel, imp, inst); done: runtimeLock.unlock(); return imp;&#125; 首先了lookUpImpOrForward方法，对 assert 进行 unlock： 1runtimeLock.assertUnlocked(); runtimeLock 本质上是对 Darwin 提供的线程读写锁 pthread_rwlock_t 的一层封装，提供了一些便捷的方法。 接着，lookUpImpOrForward做了如下两件事： 如果使用缓存（cache 参数为 YES），那就调用 cache_getImp 方法从缓存查找 IMP。cache_getImp 是用汇编语言写的，实现如下 12345678910STATIC_ENTRY _cache_getImp GetClassFromIsa_p16 p0 CacheLookup GETIMPLGetImpMiss: mov p0, #0 ret END_ENTRY _cache_getImp 其依然用了之前说过的 CacheLookup 宏。因为 _class_lookupMethodAndLoadCache3 调用 lookUpImpOrForward 时 cache 参数为 NO，这步直接略过。 如果是第一次用到这个类且 initialize 参数为 YES（initialize &amp;&amp; !cls-&gt;isInitialized()），需要进行初始化工作，也就是开辟一个用于读写数据的空间。先对 runtimeLock 加锁，然后调用 cls 的 initialize 方法，并将cls-&gt;isInitialized()置为true。 然后，会继续在类的继承体系中查找： 考虑到运行时类中的方法可能会增加，需要先加锁，使得方法查找和缓存填充成为原子操作。 1runtimeLock.assertLocked(); 之后的逻辑如下： 查找当前类中的缓存，跟之前一样，使用 cache_getImp 汇编程序入口。如果命中缓存获取到了 IMP，则直接跳到第 6 步；否则执行下一步。 在当前类的方法列表（method list）中进行查找，也就是根据 selector 查找到 Method 后，获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。查找过程如下： 首先调用 getMethodNoSuper_nolock()方法， 1234567891011121314151617181920static method_t *getMethodNoSuper_nolock(Class cls, SEL sel)&#123; runtimeLock.assertLocked(); assert(cls-&gt;isRealized()); // fixme nil cls? // fixme nil sel? for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(), end = cls-&gt;data()-&gt;methods.endLists(); mlists != end; ++mlists) &#123; method_t *m = search_method_list(*mlists, sel); if (m) return m; &#125; return nil;&#125; 在getMethodNoSuper_nolock方法中，会遍历methodList。遍历过程中会调用search_method_list函数。 1234567891011121314151617181920212223242526272829303132/************************************************************************ getMethodNoSuper_nolock* fixme* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static method_t *search_method_list(const method_list_t *mlist, SEL sel)&#123; int methodListIsFixedUp = mlist-&gt;isFixedUp(); int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t); if (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, 1)) &#123; return findMethodInSortedMethodList(sel, mlist); &#125; else &#123; // Linear search of unsorted method list for (auto&amp; meth : *mlist) &#123; if (meth.name == sel) return &amp;meth; &#125; &#125;#if DEBUG // sanity-check negative results if (mlist-&gt;isFixedUp()) &#123; for (auto&amp; meth : *mlist) &#123; if (meth.name == sel) &#123; _objc_fatal(\"linear search worked when binary search did not\"); &#125; &#125; &#125;#endif return nil;&#125; 在search_method_list函数中，会去判断当前methodList是否有序，如果有序，会调用findMethodInSortedMethodList方法，这个方法里面的实现是一个二分搜索。 123456789101112131415161718192021222324252627282930313233343536373839static method_t *findMethodInSortedMethodList(SEL key, const method_list_t *list)&#123; assert(list); const method_t * const first = &amp;list-&gt;first; const method_t *base = first; const method_t *probe; uintptr_t keyValue = (uintptr_t)key; uint32_t count; // base相当于low，count是max，probe是middle for (count = list-&gt;count; count != 0; count &gt;&gt;= 1) &#123; // probe = 从首地址 + count/2 probe = base + (count &gt;&gt; 1); uintptr_t probeValue = (uintptr_t)probe-&gt;name; // 如果查找的sel == 中间位置（probe）的probeValue if (keyValue == probeValue) &#123; // `probe` is a match. // Rewind looking for the *first* occurrence of this value. // This is required for correct category overrides. // -- while 平移 -- 排除分类重名方法 // 循环在methodlist中查找第一个满足(keyValue == probeValue)的元素。因为在methodlist中分类方法会插入在本类方法之前 while (probe &gt; first &amp;&amp; keyValue == (uintptr_t)probe[-1].name) &#123; probe--; &#125; return (method_t *)probe; &#125; // 如果keyValue 大于 probeValue，就往probe即中间位置的右边查找 if (keyValue &gt; probeValue) &#123; base = probe + 1; count--; &#125; &#125; return nil;&#125; 如果成功查找到 Method 对象，则调用log_and_fill_cache()，将获取到的 Method 中的 IMP（也就是 method_imp 属性），填充到缓存中， 1234567891011121314151617181920/************************************************************************ log_and_fill_cache* Log this method call. If the logger permits it, fill the method cache.* cls is the method whose cache should be filled. * implementer is the class that owns the implementation in question.**********************************************************************/static voidlog_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)&#123;#if SUPPORT_MESSAGE_LOGGING if (objcMsgLogEnabled) &#123; bool cacheIt = logMessageSend(implementer-&gt;isMetaClass(), cls-&gt;nameForLogging(), implementer-&gt;nameForLogging(), sel); if (!cacheIt) return; &#125;#endif cache_fill (cls, sel, imp, receiver);&#125; 忽略debug的log逻辑，方法仅仅是调用cache_fill。 12345678910void cache_fill(Class cls, SEL sel, IMP imp, id receiver)&#123;#if !DEBUG_TASK_THREADS mutex_locker_t lock(cacheUpdateLock); cache_fill_nolock(cls, sel, imp, receiver);#else _collecting_in_critical(); return;#endif&#125; cache_fill又会来到cache_fill_nolock，这个函数的作用是将方法的SEL和IMP写入_buckets，同时更新_mask和_occupied。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)&#123; cacheUpdateLock.assertLocked(); // 如果类未初始化，直接return // Never cache before +initialize is done if (!cls-&gt;isInitialized()) return; // Make sure the entry wasn't added to the cache by some other thread // before we grabbed the cacheUpdateLock. // 在获取cacheUpdateLock之前，确保其他线程没有将该方法写入缓存 if (cache_getImp(cls, sel)) return; // 获取 cls 的 cache_t指针 cache_t *cache = getCache(cls); // Use the cache as-is if it is less than 3/4 full // newOccupied为新的方法缓存数，等于 当前方法缓存数+1 mask_t newOccupied = cache-&gt;occupied() + 1; // 获取当前cache_t的总容量，为 mask+1 mask_t capacity = cache-&gt;capacity(); if (cache-&gt;isConstantEmptyCache()) &#123; // 当第一次调用类的实例方法时（如`init`） // Cache is read-only. Replace it. cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE); &#125; else if (newOccupied &lt;= capacity / 4 * 3) &#123; // 新的方法缓存数 不大于 总容量的3/4，按原样使用，无需扩容 // Cache is less than 3/4 full. Use it as-is. &#125; else &#123; // Cache is too full. Expand it. // 新的方法缓存数 大于 总容量的3/4，需要扩容 cache-&gt;expand(); &#125; // Scan for the first unused slot and insert there. // There is guaranteed to be an empty slot because the // minimum size is 4 and we resized at 3/4 full. // 根据sel获取bucket，此bucket的sel一般为0（说明这个位置还没缓存方法）， // 也可能与实参sel相等（hash冲突，可能性很低） bucket_t *bucket = cache-&gt;find(sel, receiver); // 当且仅当bucket的sel为0时，执行_occupied++ if (bucket-&gt;sel() == 0) cache-&gt;incrementOccupied(); // 更新bucket的sel和imp bucket-&gt;set&lt;Atomic&gt;(sel, imp);&#125; 从上面的源码不难看出，cache_fill_nolock主要是cache_t缓存方法的调度中心，在这里会： 决定执行_buckets的哪一种缓存策略（初始化后缓存、直接缓存、扩容后缓存，三者取一）； 然后通过方法的sel找到一个bucket，并更新这个bucket的sel和imp。（如果这个bucket的sel为0，说明是个空桶，正好可以缓存方法，于是执行_occupied++）。 缓存填充完成，然后就直接跳到第 6 步；否则如果当前类的method list没有找到method，则执行下一步。 在继承层级中递归向父类中查找，情况跟上一步类似，也是先查找缓存，缓存没中就查找方法列表。这里跟上一步不同的地方在于缓存策略，有个 _objc_msgForward_impcache 汇编程序入口作为缓存中消息转发的标记。也就是说如果在缓存中找到了 IMP，但如果发现其内容是 _objc_msgForward_impcache，那就终止在类的继承层级中递归查找，进入下一步；否则跳到第 7 步。 当传入 lookUpImpOrForward 的参数 resolver 为 YES 并且是第一次进入第 5 步时，时进入动态方法解析；否则进入下一步。这步消息转发前的最后一次机会。此时释放读入锁（runtimeLock.unlock()），接着调用resolveMethod()进行动态方法解析 1234567891011121314151617181920212223242526/************************************************************************ resolveMethod* Call +resolveClassMethod or +resolveInstanceMethod.* Returns nothing; any result would be potentially out-of-date already.* Does not check if the method already exists.**********************************************************************/static void resolveMethod(Class cls, SEL sel, id inst)&#123; runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); if (! cls-&gt;isMetaClass()) &#123; // try [cls resolveInstanceMethod:sel] resolveInstanceMethod(cls, sel, inst); &#125; else &#123; // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; resolveInstanceMethod(cls, sel, inst); &#125; &#125;&#125; 该方法中会判断，如果 cls 是元类则会发送 +resolveClassMethod。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/************************************************************************ resolveClassMethod* Call +resolveClassMethod, looking for a method to be added to class cls.* cls should be a metaclass.* Does not check if the method already exists.**********************************************************************/static void resolveClassMethod(Class cls, SEL sel, id inst)&#123; runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); assert(cls-&gt;isMetaClass()); if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; // Resolver not implemented. return; &#125; Class nonmeta; &#123; mutex_locker_t lock(runtimeLock); nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst); // +initialize path should have realized nonmeta already if (!nonmeta-&gt;isRealized()) &#123; _objc_fatal(\"nonmeta class %s (%p) unexpectedly not realized\", nonmeta-&gt;nameForLogging(), nonmeta); &#125; &#125; BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(nonmeta, SEL_resolveClassMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); if (resolved &amp;&amp; PrintResolving) &#123; if (imp) &#123; _objc_inform(\"RESOLVE: method %c[%s %s] \" \"dynamically resolved to %p\", cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); &#125; else &#123; // Method resolver didn't add anything? _objc_inform(\"RESOLVE: +[%s resolveClassMethod:%s] returned YES\" \", but no new implementation of %c[%s %s] was found\", cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); &#125; &#125;&#125; 然后根据 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 函数的结果来判断是否发送 +resolveInstanceMethod 12345678910111213141516171819202122232425262728293031323334353637383940414243/************************************************************************ resolveInstanceMethod* Call +resolveInstanceMethod, looking for a method to be added to class cls.* cls may be a metaclass or a non-meta class.* Does not check if the method already exists.**********************************************************************/static void resolveInstanceMethod(Class cls, SEL sel, id inst)&#123; runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; // Resolver not implemented. return; &#125; BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(cls, SEL_resolveInstanceMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveInstanceMethod adds to self a.k.a. cls IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); if (resolved &amp;&amp; PrintResolving) &#123; if (imp) &#123; _objc_inform(\"RESOLVE: method %c[%s %s] \" \"dynamically resolved to %p\", cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); &#125; else &#123; // Method resolver didn't add anything? _objc_inform(\"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES\" \", but no new implementation of %c[%s %s] was found\", cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); &#125; &#125;&#125; 如果不是元类，则只需要发送 +resolveInstanceMethod 消息。这里调用 +resolveInstanceMethod 或 +resolveClassMethod 时再次用到了 objc_msgSend，而且第三个参数正是传入 lookUpImpOrForward 的那个 sel。在发送方法解析消息之后还会调用 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 来判断是否已经添加上 sel 对应的 IMP 了，打印出结果。 lookUpImpOrNil 跟 lookUpImpOrForward 的功能很相似，只是将 lookUpImpOrForward 实现中的 _objc_msgForward_impcache 替换成了 nil: 1234567891011/************************************************************************ lookUpImpOrNil.* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache**********************************************************************/IMP lookUpImpOrNil(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver); if (imp == _objc_msgForward_impcache) return nil; else return imp;&#125; 此时不仅没查找到 IMP，动态方法解析也不奏效，只能将 _objc_msgForward_impcache 当做 IMP 并写入缓存。这也就是之前第 3 步中为何查找到 _objc_msgForward_impcache 就表明了要进入消息转发了。 解锁 runtimeLock.unlock()，并将之前找到的 IMP 返回。。 消息转发前面说到如果没有找到方法，会将 _objc_msgForward_impcache 当成imp写入缓存。_objc_msgForward_impcache 只是个内部的函数指针，只存储于类的方法缓存中，需要被转化为 _objc_msgForward 和 _objc_msgForward_stret 才能被外部调用。转换的方式也很简单，就是增加个静态入口 __objc_msgForward_impcache。 _objc_msgForward_impcache 在objc-msg-arm64.s中汇编的实现如下： 123456STATIC_ENTRY __objc_msgForward_impcache&#x2F;&#x2F; No stret specialization.b __objc_msgForwardEND_ENTRY __objc_msgForward_impcache _objc_msgForward_impcache只是入口。实际的实现函数是 objc_msgForward 1234567ENTRY __objc_msgForwardadrp x17, __objc_forward_handler@PAGEldr p17, [x17, __objc_forward_handler@PAGEOFF]TailCallFunctionPointer x17END_ENTRY __objc_msgForward objc_msgForward 函数中会调用__objc_forward_handler函数。 12345678910// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel)&#123; _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \" \"(no message forward handler is installed)\", class_isMetaClass(object_getClass(self)) ? '+' : '-', object_getClassName(self), sel_getName(sel), self);&#125;void *_objc_forward_handler = (void*)objc_defaultForwardHandler; 在Objc2.0中会有一个objc_defaultForwardHandler，看源码实现我们可以看到熟悉的语句。当我们给一个对象发送一个没有实现的方法的时候，如果其父类也没有这个方法，则会崩溃，报错信息类似于这样：unrecognized selector sent to instance，然后接着会跳出一些堆栈信息。这些信息就是从这里而来。 123456789101112131415161718192021222324252627282930313233343536373839404142/************************************************************************ objc_setForwardHandler**********************************************************************/#if !__OBJC2__// Default forward handler (nil) goes to forward:: dispatch.void *_objc_forward_handler = nil;void *_objc_forward_stret_handler = nil;#else// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel)&#123; _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \" \"(no message forward handler is installed)\", class_isMetaClass(object_getClass(self)) ? '+' : '-', object_getClassName(self), sel_getName(sel), self);&#125;void *_objc_forward_handler = (void*)objc_defaultForwardHandler;#if SUPPORT_STRETstruct stret &#123; int i[100]; &#125;;__attribute__((noreturn)) struct stret objc_defaultForwardStretHandler(id self, SEL sel)&#123; objc_defaultForwardHandler(self, sel);&#125;void *_objc_forward_stret_handler = (void*)objc_defaultForwardStretHandler;#endif#endifvoid objc_setForwardHandler(void *fwd, void *fwd_stret)&#123; _objc_forward_handler = fwd;#if SUPPORT_STRET _objc_forward_stret_handler = fwd_stret;#endif&#125; 要设置转发只要重写_objc_forward_handler方法即可。在objc_setForwardHandler方法中，可以设置ForwardHandler。 当你想要弄清objc_setForwardHandler的调用，以及之后的消息转发调用栈的时候，会发现在objc4-756.2找不到源码。这是因为objc_setForwardHandler的实现是在 Core Foundation（CoreFoundation.framework）中。虽然 CF 是开源的，但是苹果在这里做了点手脚。关于objc_setForwardHandler的调用，以及之后的消息转发调用栈的问题，需要用到逆向的知识。推荐大家看这篇文章就会明白其中的原理。 Objective-C 消息发送与转发机制原理iOS会在 CF runtime 连接到进程时初始化调用__CFInitialize() 函数，把 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 作为参数调用 objc_setForwardHandler 方法。 从函数调用栈可以看出 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 这两个 Forward Handler 做了啥： 122021-09-05 21:05:39.018585+0800 Test[46006:16033328] -[Person eat]: unrecognized selector sent to instance 0x600000db81002021-09-05 21:05:39.023782+0800 Test[46006:16033328] *** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[Person eat]: unrecognized selector sent to instance 0x600000db8100&#39;*** First throw call stack:( 0 CoreFoundation 0x00007fff23c7127e __exceptionPreprocess + 350 1 libobjc.A.dylib 0x00007fff513fbb20 objc_exception_throw + 48 2 CoreFoundation 0x00007fff23c91fd4 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132 3 CoreFoundation 0x00007fff23c75c4c ___forwarding___ + 1436 4 CoreFoundation 0x00007fff23c77f78 _CF_forwarding_prep_0 + 120 5 Test 0x000000010ba3e226 main + 54 6 libdyld.dylib 0x00007fff5227ec25 start + 1)libc++abi.dylib: terminating with uncaught exception of type NSException 这个日志场景熟悉得不能再熟悉了，可以看出 _CF_forwarding_prep_0 函数调用了 ___forwarding___ 函数，接着又调用了 doesNotRecognizeSelector 方法，最后抛出异常。 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 函数都调用了 ___forwarding___，只是传入参数不同。 消息转发的逻辑几乎都写在 ___forwarding___ 函数中了，实现比较复杂，反编译出的伪代码也不是很直观。Objective-C 消息发送与转发机制原理 的结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485int __forwarding__(void *frameStackPointer, int isStret) &#123; id receiver = *(id *)frameStackPointer; SEL sel = *(SEL *)(frameStackPointer + 8); const char *selName = sel_getName(sel); Class receiverClass = object_getClass(receiver); // 调用 forwardingTargetForSelector: if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123; id forwardingTarget = [receiver forwardingTargetForSelector:sel]; if (forwardingTarget &amp;&amp; forwarding != receiver) &#123; if (isStret == 1) &#123; int ret; objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...); return ret; &#125; return objc_msgSend(forwardingTarget, sel, ...); &#125; &#125; // 僵尸对象 const char *className = class_getName(receiverClass); const char *zombiePrefix = \"_NSZombie_\"; size_t prefixLen = strlen(zombiePrefix); // 0xa if (strncmp(className, zombiePrefix, prefixLen) == 0) &#123; CFLog(kCFLogLevelError, @\"*** -[%s %s]: message sent to deallocated instance %p\", className + prefixLen, selName, receiver); &lt;breakpoint-interrupt&gt; &#125; // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123; NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel]; if (methodSignature) &#123; BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct; if (signatureIsStret != isStret) &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'. Signature thinks it does%s return a struct, and compiler thinks it does%s.\", selName, signatureIsStret ? \"\" : not, isStret ? \"\" : not); &#125; if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123; NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer]; [receiver forwardInvocation:invocation]; void *returnValue = NULL; [invocation getReturnValue:&amp;value]; return returnValue; &#125; else &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message\", receiver, className); return 0; &#125; &#125; &#125; SEL *registeredSel = sel_getUid(selName); // selector 是否已经在 Runtime 注册过 if (sel != registeredSel) &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort\", sel, selName, registeredSel); &#125; // doesNotRecognizeSelector else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123; [receiver doesNotRecognizeSelector:sel]; &#125; else &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort\", receiver, className); &#125; // The point of no return. kill(getpid(), 9);&#125; 这么一大坨代码就是整个消息转发路径的逻辑，概括如下： 先调用 forwardingTargetForSelector 方法获取新的 target 作为 receiver 重新执行 selector，如果返回的内容不合法（为 nil 或者跟旧 receiver 一样），那就进入第二步。 调用 methodSignatureForSelector 获取方法签名后，判断返回类型信息是否正确，再调用 forwardInvocation 执行 NSInvocation 对象，并将结果返回。如果对象没实现 methodSignatureForSelector 方法，进入第三步。 调用 doesNotRecognizeSelector 方法。 doesNotRecognizeSelector 之前其实还有个判断 selector 在 Runtime 中是否注册过的逻辑，但在我们正常发消息的时候不会出此问题。但如果手动创建一个 NSInvocation 对象并调用 invoke，并将第二个参数设置成一个不存在的 selector，那就会导致这个问题，并输入日志 “does not match selector known to Objective C runtime”。较真儿的读者可能会有疑问：何这段逻辑判断干脆用不到却还存在着？难道除了 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 函数还有其他函数也调用 ___forwarding___ 么？莫非消息转发还有其他路径？其实并不是！原因是 ___forwarding___ 调用了 ___invoking___ 函数，所以上面的伪代码直接把 ___invoking___ 函数的逻辑也『翻译』过来了。除了 ___forwarding___ 函数，以下方法也会调用___invoking___ 函数: 123-[NSInvocation invoke]-[NSInvocation invokeUsingIMP:]-[NSInvocation invokeSuper] doesNotRecognizeSelector 方法其实在 libobj.A.dylib 中已经废弃了，而是在 CF 框架中实现，而且也不是开源的。从函数调用栈可以发现 doesNotRecognizeSelector 之后会抛出异常，而 Runtime 中废弃的实现只是打日志后直接杀掉进程（__builtin_trap()）。下面是 CF 中实现的伪代码： 123456789101112131415161718192021222324void -[NSObject doesNotRecognizeSelector:](void * self, void * _cmd, void * arg2) &#123; r14 = ___CFFullMethodName([self class], self, arg2); _CFLog(0x3, @\"%@: unrecognized selector sent to instance %p\", r14, self, r8, r9, stack[2048]); rbx = _CFMakeCollectable(_CFStringCreateWithFormat(___kCFAllocatorSystemDefault, 0x0, @\"%@: unrecognized selector sent to instance %p\")); if (*(int8_t *)___CFOASafe != 0x0) &#123; ___CFRecordAllocationEvent(); &#125; rax = _objc_rootAutorelease(rbx); rax = [NSException exceptionWithName:@\"NSInvalidArgumentException\" reason:rax userInfo:0x0]; objc_exception_throw(rax); return;&#125;void +[NSObject doesNotRecognizeSelector:](void * self, void * _cmd, void * arg2) &#123; r14 = ___CFFullMethodName([self class], self, arg2); _CFLog(0x3, @\"%@: unrecognized selector sent to class %p\", r14, self, r8, r9, stack[2048]); rbx = _CFMakeCollectable(_CFStringCreateWithFormat(___kCFAllocatorSystemDefault, 0x0, @\"%@: unrecognized selector sent to class %p\")); if (*(int8_t *)___CFOASafe != 0x0) &#123; ___CFRecordAllocationEvent(); &#125; rax = _objc_rootAutorelease(rbx); rax = [NSException exceptionWithName:@\"NSInvalidArgumentException\" reason:rax userInfo:0x0]; objc_exception_throw(rax); return;&#125; 也就是说我们可以 override doesNotRecognizeSelector 或者捕获其抛出的异常。 总结过滤了部分不会进入的分支路径和跟主题无关的细节，整体流程如下： 参考： iOS-底层原理 12：消息流程分析之快速查找 Objc-msg-arm64源码深入分析 OC底层原理11-objc_msgSend源码分析(方法查找快流程 OC底层原理12-lookUpImpOrForward源码分析(方法查找慢流程 objc_msgSend 源码跟踪 深入解构objc_msgSend函数的实现 Objective-C 消息发送与转发机制原理","categories":[{"name":"刨根问底","slug":"刨根问底","permalink":"http://heseng91.github.io/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}],"tags":[]},{"title":"「刨根问底」之Objective-C 2.0 中类与对象的定义","slug":"「刨根问底」之Runtime类和对象的定义","date":"2018-08-18T00:18:38.000Z","updated":"2023-02-09T13:10:46.242Z","comments":true,"path":"2018/08/18/「刨根问底」之Runtime类和对象的定义/","link":"","permalink":"http://heseng91.github.io/2018/08/18/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/","excerpt":"runtime简介依照苹果文档的说法，runtime是： 12The Objective-C language defers as many decisions as it can from compile time and link time to runtime. （尽量将决定放到运行的时候，而不是在编译和链接过程） 如何理解这段话呢，我们首先要知道，一段代码从写完到最终执行的过程中发生了什么。","text":"runtime简介依照苹果文档的说法，runtime是： 12The Objective-C language defers as many decisions as it can from compile time and link time to runtime. （尽量将决定放到运行的时候，而不是在编译和链接过程） 如何理解这段话呢，我们首先要知道，一段代码从写完到最终执行的过程中发生了什么。 从代码到可执行文件的过程具体过程见下图： 主要过程可以简化成三个： 123- 编译- 链接- 运行 编译：将代码转换成底层可执行的语言（如汇编），简单来讲，就是把你能看懂的语言，转换成系统底层可以看懂的东西，这中间通常会有优化，先预处理，再编译。 链接：在编译的过程中，如果有调用其他的类的方法等，是不会检查或者报警的，编译的时候会默认你已经实现了。而链接就是去检查调用的方法或者类等是否确实存在。 运行：执行最终的可执行文件 如果是普通的C语言代码，我们使用的是传统的编译运行，那么一个函数的执行内容，在编译阶段其实就确定了，执行的时候只要去执行对应的内存地址的程序就好。 因为Objc是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个 Objc 运行框架的一块基石。 Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 maxOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime之发送消息（objc_msgSend）还记得刚学 Objective-C 时把 [receiver message] 当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。其实 [receiver message] 会被编译器转化为： 1objc_msgSend(receiver, selector) 如果消息含有参数，则为： 1objc_msgSend(receiver, selector, arg1, arg2, ...) 如果消息的接收者能够找到对应的 selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个 selector 对应的实现内容，要么就干脆玩完崩溃掉。 消息发送等下章详细表述。本文基于源码为 objc4-756.2，先来介绍一下 Objective-C 2.0 中类与对象的相关定义，仅作为参考，暂不做深入的分析。 Runtime 基础数据结构前面提到的objc_msgSend:的真身是这样的： 1id objc_msgSend ( id self, SEL op, ... ); 下面将会逐渐展开介绍一些术语，其实它们都对应着数据结构。 SELobjc_msgSend函数第二个参数类型为SEL，它是selector在Objc中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL: 1typedef struct objc_selector *SEL; 其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获得一个 SEL 类型的方法选择器。 不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(参见：NSNumber 一堆抽象工厂方法)，Cocoa 中也有好多长长的方法。 idobjc_msgSend 第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针： 1typedef struct objc_object *id; 那objc_object又是啥呢，参考 objc-private.h 文件部分源码： 12345678910111213struct objc_object &#123;private: isa_t isa;public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // getIsa() allows this to be a tagged pointer object Class getIsa(); ... 此处省略其他方法声明&#125; objc_object 结构体包含一个 isa 指针，类型为 isa_t 联合体。根据 isa 就可以顺藤摸瓜找到对象所属的类。 PS: isa 指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用 class 方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见官方文档 isa_tobjc_object 中的 isa 是一个 isa_t 类型的共用体（union），在objc-private.h 文件中定义如下： 123456789101112union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 其中 ISA_BITFIELD在 isa.h文件中定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#if SUPPORT_PACKED_ISA // extra_rc must be the MSB-most field (so it matches carry/overflow flags) // nonpointer must be the LSB (fixme or get rid of it) // shiftcls must occupy the same bits that a real class pointer would // bits + RC_ONE is equivalent to extra_rc + 1 // RC_HALF is the high bit of extra_rc (i.e. half of its range) // future expansion: // uintptr_t fast_rr : 1; // no r/r overrides // uintptr_t lock : 2; // lock for atomic property, @synch // uintptr_t extraBytes : 1; // allocated with extra bytes# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18)# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 8# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7)# else# error unknown architecture for packed isa# endif SUPPORT_PACKED_ISA 用于标记是否支持优化的 isa 指针，其字面含义意思是 isa 的内容不再是类的指针了，而是包含了更多信息，比如引用计数，析构状态，被其他 weak 变量引用情况。判断方法也是根据设备类型： 12345678// Define SUPPORT_PACKED_ISA=1 on platforms that store the class in the isa // field as a maskable pointer with other data around it.#if (!__LP64__ || TARGET_OS_WIN32 || \\ (TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_IOSMAC))# define SUPPORT_PACKED_ISA 0#else# define SUPPORT_PACKED_ISA 1#endif 综合看来目前只有 arm64 架构的设备支持，下面列出了 isa 指针中变量对应的含义： 变量名 含义 nonpointer 0 表示普通的 isa 指针，1 表示使用优化，存储引用计数 has_assoc 表示该对象是否包含 associated object，如果没有，则析构时会更快 has_cxx_dtor 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls 类的指针 magic 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。 weakly_referenced 表示该对象是否有被弱引用指向过，如果没有，则析构时更快 deallocating 表示该对象是否正在析构 has_sidetable_rc 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_rc 存储引用计数值减一后的结果 ClassClass 其实是一个指向 objc_class 结构体的指针： 1typedef struct objc_class *Class; 而 objc_class 包含很多方法，主要都为围绕它的几个成员做文章： 123456789101112struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125; ...// 省略其他方法&#125; objc_class 继承于 objc_object，也就是说一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似 [NSObject alloc] 的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 [NSObject alloc] 这条消息发给类对象的时候，objc_msgSend() 会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。 上图实线是 superclass 指针，虚线是isa指针。 有趣的是根元类的超类是 NSObject，而 isa 指向了自己，而 NSObject的超类为 nil，也就是它没有超类。 cache_t1234567struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;... //省略其他方法&#125; 其中，bucket_t *_buckets 是一个散列表，用来存储 Method 方法列表，而 bucket_t 结构体定义如下，包含了一个 unsigned long 类型的 _key 和一个 IMP 类型的 _imp，存储了指针与 IMP 的键值对。IMP 是一个函数指针，指向了一个方法的具体实现。 1234567891011121314struct bucket_t &#123;private: // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64.#if __arm64__ uintptr_t _imp; SEL _sel;#else SEL _sel; uintptr_t _imp;#endif... 省略其他方法&#125;; cache_t 中另外两个变量 _mask 和 _occupied，它们的类型为 mask_t，定义如下，其实是一个 unsigned int。 12345#if __LP64__typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t;#endif _mask 和 _occupied 对应于 vtable： _mask：分配用来缓存 bucket 的总数。 _occupied：表明目前实际占用的缓存 bucket 的个数。 cache 的作用主要是对方法调用的性能进行优化。通俗地讲，每当实例对象接收到一个消息时，它不会直接在其 isa 指向的类（或类的 isa 指向的父类）的方法列表中遍历查找能够响应消息的方法实现，因为这样效率太低了，而是优先在 cache 中查找。Runtime 系统会把被调用过的方法存到该类对象的 cache 中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。 有关缓存的实现细节，可以查看 objc-cache.mm 文件。 class_data_bits_tobjc_class 中最复杂的是 bits，class_data_bits_t 结构体所包含的信息太多了，主要包含 class_rw_t, retain/release/autorelease/retainCount 和 alloc 等信息，很多存取方法也是围绕它展开。查看 objc-runtime-new.h 源码如下： 123456789101112131415161718struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;private: bool getBit(uintptr_t bit) &#123; return bits &amp; bit; &#125;...public: class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;...省略其他方法&#125; 注意 objc_class 的 data 方法直接将 class_data_bits_t 的data 方法返回，最终是返回 class_rw_t，保了好几层。 可以看到 class_data_bits_t 里又包了一个 bits，这个指针跟不同的 FAST_ 前缀的 flag 掩码做按位与操作，就可以获取不同的数据。bits 在内存中每个位的含义有三种排列顺序： 32 位： 0 1 2 - 31 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_DATA_MASK 64 位兼容版： 0 1 2 3 - 46 47 - 63 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_HAS_DEFAULT_RR FAST_DATA_MASK 空闲 64 位不兼容版： 0 1 2 3 - 46 47 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_ALLOC FAST_DATA_MASK FAST_HAS_CXX_CTOR 48 49 50 51 52 - 63 FAST_HAS_DEFAULT_AWZ FAST_HAS_DEFAULT_RR FAST_REQUIRES_RAW_ISA FAST_HAS_CXX_DTOR 空闲 其中 64 位不兼容版每个宏对应的含义如下： 1234567891011121314151617181920212223242526// class is a Swift class from the pre-stable Swift ABI#define FAST_IS_SWIFT_LEGACY (1UL&lt;&lt;0)// class is a Swift class from the stable Swift ABI#define FAST_IS_SWIFT_STABLE (1UL&lt;&lt;1)// summary bit for fast alloc path: !hasCxxCtor and // !instancesRequireRawIsa and instanceSize fits into shiftedSize#define FAST_ALLOC (1UL&lt;&lt;2)// data pointer#define FAST_DATA_MASK 0x00007ffffffffff8UL// class or superclass has .cxx_construct implementation#define FAST_HAS_CXX_CTOR (1UL&lt;&lt;47)// class or superclass has default alloc/allocWithZone: implementation// Note this is is stored in the metaclass.#define FAST_HAS_DEFAULT_AWZ (1UL&lt;&lt;48)// class or superclass has default retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference#define FAST_HAS_DEFAULT_RR (1UL&lt;&lt;49)// class's instances requires raw isa// This bit is aligned with isa_t-&gt;hasCxxDtor to save an instruction.#define FAST_REQUIRES_RAW_ISA (1UL&lt;&lt;50)// class or superclass has .cxx_destruct implementation#define FAST_HAS_CXX_DTOR (1UL&lt;&lt;51)// instance size in units of 16 bytes// or 0 if the instance size is too big in this field// This field must be LAST#define FAST_SHIFTED_SIZE_SHIFT 52 这里面除了 FAST_DATA_MASK 是用一段空间存储数据外，其他宏都是只用 1 bit 存储 bool 值。class_data_bits_t 提供了三个方法用于位操作：getBit, setBits 和 clearBits，对应到存储 bool 值的掩码也有封装函数，比如： 123456bool hasCxxCtor() &#123; return getBit(FAST_HAS_CXX_CTOR);&#125;void setHasCxxCtor() &#123; setBits(FAST_HAS_CXX_CTOR);&#125; 重头戏在于最大的那块存储区域FAST_DATA_MASK，它其实就存储了指向 class_rw_t 的指针： 123class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK);&#125; 对这片内存读写处于并发环境，但并不需要加锁，因为会通过对一些状态（realization or construction）判断来决定是否可读写。 class_data_bits_t 甚至还包含了一些对 class_rw_t 中 flags 成员存取的封装函数。 class_rw_tobjc_class 包含了 class_data_bits_t，class_data_bits_t 存储了 class_rw_t 的指针。 1234567891011121314151617181920212223struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;#if SUPPORT_INDEXED_ISA uint32_t index;#endif...省略操作 flags 的相关方法&#125; class_rw_t 中使用的 method_array_t, property_array_t, protocol_array_t 都继承自 list_array_tt&lt;Element, List&gt;, 它可以不断扩张，因为它可以存储 list 指针，内容有三种： 空 一个 entsize_list_tt 指针 entsize_list_tt 指针数组 class_rw_t 的内容是可以在运行时被动态修改的，可以说运行时对类的拓展大都是存储在这里的。 class_rw_t-&gt;flags 存储的值并不是编辑器设置的，其中有些值可能将来会作为 ABI 的一部分。下面这些 RW_ 前缀的宏标记了 flags 一些位置的含义。这些 bool 值标记了类的一些状态，涉及到声明周期和内存管理。有些位目前甚至还空着。 12345678910111213141516171819202122232425262728293031// Values for class_rw_t-&gt;flags// These are not emitted by the compiler and are never used in class_ro_t. // Their presence should be considered in future ABI versions.// class_t-&gt;data is class_rw_t, not class_ro_t#define RW_REALIZED (1&lt;&lt;31)// class is unresolved future class#define RW_FUTURE (1&lt;&lt;30)// class is initialized#define RW_INITIALIZED (1&lt;&lt;29)// class is initializing#define RW_INITIALIZING (1&lt;&lt;28)// class_rw_t-&gt;ro is heap copy of class_ro_t#define RW_COPIED_RO (1&lt;&lt;27)// class allocated but not yet registered#define RW_CONSTRUCTING (1&lt;&lt;26)// class allocated and registered#define RW_CONSTRUCTED (1&lt;&lt;25)// available for use; was RW_FINALIZE_ON_MAIN_THREAD// #define RW_24 (1&lt;&lt;24)// class +load has been called#define RW_LOADED (1&lt;&lt;23)#if !SUPPORT_NONPOINTER_ISA// class instances may have associative references#define RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS (1&lt;&lt;22)#endif// class has instance-specific GC layout#define RW_HAS_INSTANCE_SPECIFIC_LAYOUT (1 &lt;&lt; 21)// class does not allow associated objects on its instances#define RW_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;20)// class has started realizing but not yet completed it#define RW_REALIZING (1&lt;&lt;19) demangledName 是计算机语言用于解决实体名称唯一性的一种方法，做法是向名称中添加一些类型信息，用于从编译器中向链接器传递更多语义信息。 class_ro_tclass_rw_t 提供了运行时对类拓展的能力，而 class_ro_t 存储的大多是类在编译时就已经确定的信息。二者都存有类的方法、属性（成员变量）、协议等信息，不过存储它们的列表实现方式不同。 class_ro_t 中的 method_list_t, ivar_list_t, property_list_t 结构体都继承自 entsize_list_tt&lt;Element, List, FlagMask&gt;。结构为 xxx_list_t 的列表元素结构为 xxx_t，命名很工整。protocol_list_t 与前三个不同，它存储的是 protocol_t * 指针列表，实现比较简单。 entsize_list_tt 实现了 non-fragile 特性的数组结构。假如苹果在新版本的 SDK 中向 NSObject 类增加了一些内容，NSObject 的占据的内存区域会扩大，开发者以前编译出的二进制中的子类就会与新的 NSObject 内存有重叠部分。于是在编译期会给 instanceStart 和 instanceSize 赋值，确定好编译时每个类的所占内存区域起始偏移量和大小，这样只需将子类与基类的这两个变量作对比即可知道子类是否与基类有重叠，如果有，也可知道子类需要挪多少偏移量。更多细节可以参考后面的章节 Non Fragile ivars。 123456789101112131415161718192021222324struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; // This field exists only when RO_HAS_SWIFT_INITIALIZER is set. _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0];...省略其他方法&#125;; class_ro_t-&gt;flags 存储了很多在编译时期就确定的类的信息，也是 ABI 的一部分。下面这些 RO_ 前缀的宏标记了 flags 一些位置的含义。其中后三个并不需要被编译器赋值，是预留给运行时加载和初始化类的标志位，涉及到与 class_rw_t 的类型强转。运行时会用到它做判断，后面会讲解。 1234567891011121314151617181920212223242526272829303132333435// class_data_bits_t is the class_t-&gt;data field (class_rw_t pointer plus flags)// The extra bits are optimized for the retain/release and alloc/dealloc paths.// Values for class_ro_t-&gt;flags// These are emitted by the compiler and are part of the ABI.// Note: See CGObjCNonFragileABIMac::BuildClassRoTInitializer in clang// class is a metaclass#define RO_META (1&lt;&lt;0)// class is a root class#define RO_ROOT (1&lt;&lt;1)// class has .cxx_construct/destruct implementations#define RO_HAS_CXX_STRUCTORS (1&lt;&lt;2)// class has +load implementation// #define RO_HAS_LOAD_METHOD (1&lt;&lt;3)// class has visibility=hidden set#define RO_HIDDEN (1&lt;&lt;4)// class has attribute(objc_exception): OBJC_EHTYPE_$_ThisClass is non-weak#define RO_EXCEPTION (1&lt;&lt;5)// class has ro field for Swift metadata initializer callback#define RO_HAS_SWIFT_INITIALIZER (1&lt;&lt;6)// class compiled with ARC#define RO_IS_ARC (1&lt;&lt;7)// class has .cxx_destruct but no .cxx_construct (with RO_HAS_CXX_STRUCTORS)#define RO_HAS_CXX_DTOR_ONLY (1&lt;&lt;8)// class is not ARC but has ARC-style weak ivar layout #define RO_HAS_WEAK_WITHOUT_ARC (1&lt;&lt;9)// class does not allow associated objects on instances#define RO_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;10)// class is in an unloadable bundle - must never be set by compiler#define RO_FROM_BUNDLE (1&lt;&lt;29)// class is unrealized future class - must never be set by compiler#define RO_FUTURE (1&lt;&lt;30)// class is realized - must never be set by compiler#define RO_REALIZED (1&lt;&lt;31) realizeClass在某个类初始化之前，objc_class-&gt;data() 返回的指针指向的其实是个 class_ro_t 结构体。等到 static Class realizeClass(Class cls) 静态方法在类第一次初始化时被调用，它会: 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针 初始化一个 class_rw_t 结构体 设置结构体 ro 的值以及 flag 最后设置正确的 data。 将 class_ro_t 指针赋值给 class_rw_t-&gt;ro。这种偷天换日的行为是靠 RO_FUTURE 标志位来记录的： 123456789101112131415161718192021222324252627/************************************************************************ realizeClassWithoutSwift* Performs first-time initialization on class cls, * including allocating its read-write data.* Does not perform any Swift-side initialization.* Returns the real class structure for the class. * Locking: runtimeLock must be write-locked by the caller**********************************************************************/static Class realizeClassWithoutSwift(Class cls)&#123;... ro = (const class_ro_t *)cls-&gt;data(); if (ro-&gt;flags &amp; RO_FUTURE) &#123; // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro; cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE); &#125; else &#123; // Normal class. Allocate writeable class data. rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); rw-&gt;ro = ro; rw-&gt;flags = RW_REALIZED|RW_REALIZING; cls-&gt;setData(rw); &#125;...省略逻辑实现&#125; 注意之前 RO 和 RW flags 宏标记的一个细节： 12345#define RO_FUTURE (1&lt;&lt;30)#define RO_REALIZED (1&lt;&lt;31)#define RW_REALIZED (1&lt;&lt;31)#define RW_FUTURE (1&lt;&lt;30) 也就是说 ro = (const class_ro_t *)cls-&gt;data(); 这种强转对于接下来的 ro-&gt;flags &amp; RO_FUTURE 操作完全是 OK 的，两种结构体第一个成员都是 flags，RO_FUTURE 与 RW_FUTURE 值一样的。 经过 realizeClass 函数处理的类才是『真正的』类，调用它时不能对类做写操作。 Ivar在 objc-private.h 中，Ivar 被定义为一个指向 ivar_t 结构体的指针： 1#if __OBJC2__typedef struct ivar_t *Ivar; ivar_t 结构体在 objc-runtime-new.h 中定义： 123456789101112131415161718192021struct ivar_t &#123;#if __x86_64__ // *offset was originally 64-bit on some x86_64 platforms. // We read and write only 32 bits of it. // Some metadata provides all 64 bits. This is harmless for unsigned // little-endian values. // Some code uses all 64 bits. class_addIvar() over-allocates the // offset for their benefit.#endif int32_t *offset; const char *name; const char *type; // alignment is sometimes -1; use alignment() instead uint32_t alignment_raw; uint32_t size; uint32_t alignment() const &#123; if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT; return 1 &lt;&lt; alignment_raw; &#125;&#125;; Ivar 用于表示类中实例变量（成员变量）的类型，ivar_t 中定义了实例变量的名字和类型。而ivar 的修饰信息存放在了 Class 的 Ivar Layout 中。ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型。 举个例子说明，若类定义为： 123456@interface Foo : NSObject &#123; __strong id ivar0; __weak id ivar1; __weak id ivar2;&#125;@end 则储存 strong ivar 的 ivarLayout 的值为 0x012000 储存 weak ivar 的 weakIvarLayout 的值为 0x1200 一个 uint8_t 在 16 进制下是两位，所以编码的值每两位一对儿，以上面的 ivarLayout 为例： 前两位 01 表示有 0 个非 strong 对象和 1 个 strong 对象 之后两位 20 表示有 2 个非 strong 对象和 0 个 strong 对象 最后两位 00 为结束符，就像 cstring 的 \\0 一样 同理，上面的 weakIvarLayout： 前两位 12 表示有 1 个非 weak 对象和接下来连续 2 个 weak 对象 00 结束符 这样，用两个 layout 编码值就可以排查出一个 ivar 是属于 strong 还是 weak 的，若都没有找到，就说明这个对象是 unsafe_unretained. Property我们知道，@property 用于声明类中的属性，在 Runtime 系统中，objc_property_t 是一个指向objc_property 结构体的指针，在 objc-private.h 中定义： 1#if __OBJC2__typedef struct property_t *objc_property_t; property_t 结构体在 objc-runtime-new.h 中定义： 1234struct property_t &#123; const char *name; const char *attributes;&#125;; MethodMethod是一种代表类中的某个方法的类型。 1#if __OBJC2__typedef struct method_t *Method; 而 objc_method 在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现： 1234567891011121314struct method_t &#123; SEL name; const char *types; MethodListIMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;; 方法名类型为 SEL，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。 方法类型 types 是个char指针，其实存储着方法的参数类型和返回值类型。 imp 指向了方法的实现，本质上是一个函数指针，后面会详细讲到。 CategoryCategory 为现有的类提供了拓展性，它是 category_t 结构体的指针。 1#if __OBJC2__typedef struct category_t *Category; category_t 存储了类别中可以拓展的实例方法、类方法、协议、实例属性和类属性。类属性是 Objective-C 2016 年新增的特性，沾 Swift 的光。所以 category_t 中有些成员变量是为了兼容 Swift 的特性，Objective-C 暂没提供接口，仅做了底层数据结构上的兼容。 1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; 在 App 启动加载镜像文件时，会在 _read_images 函数间接调用到 attachCategories 函数，完成向类中添加 Category 的工作。原理就是向 class_rw_t 中的 method_array_t, property_array_t, protocol_array_t 数组中分别添加 method_list_t, property_list_t, protocol_list_t 指针。之前讲过 xxx_array_t 可以存储对应 xxx_list_t 的指针数组。 在调用 attachCategories 函数之前，会先使用 unattachedCategoriesForClass 函数获取类中还未添加的类别列表。这个列表类型为 locstamped_category_list_t，它封装了 category_t 以及对应的 header_info。header_info 存储了实体在镜像中的加载和初始化状态，以及一些偏移量，在加载 Mach-O 文件相关函数中经常用到。 123456789101112struct locstamped_category_t &#123; category_t *cat; struct header_info *hi;&#125;;struct locstamped_category_list_t &#123; uint32_t count;#if __LP64__ uint32_t reserved;#endif locstamped_category_t list[0];&#125;; 所以更具体来说 attachCategories 做的就是将 locstamped_category_list_t.list 列表中每个 locstamped_category_t.cat 中的那方法、协议和属性分别添加到类的 class_rw_t 对应列表中。header_info 中的信息决定了是否是元类，从而选择应该是添加实例方法还是类方法、实例属性还是类属性等。源码在 objc-runtime-new.mm 文件中，很好理解。 protocol_t虽然 Objective-C 的 Category 和 protocol 拓展能力有限，但也得为了将就 Swift 的感受，充个胖子。 flags 32 位指针最后两位是给加载 Mach-O 的 fix-up 阶段使用的，前 16 位预留给 Swift 用的。 protocol 主要内容其实是（可选）方法，其次就是继承其他 protocol。Swift 还支持 protocol 多继承，所以需要 protocols 数组来做兼容。 123456789101112131415161718192021222324struct protocol_t : objc_object &#123; const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; const char *demangledName(); const char *nameForLogging() &#123; return demangledName(); &#125;... 省略一些封装的便捷 get 方法&#125;; IMPIMP在objc.h中的定义是： 1typedef void (*IMP)(void /* id, SEL, ... */ ); 它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。既然得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面会提到。 你会发现 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址；反之亦然。 总结我们可以用如下这张图来分别表示 Objective-C 2.0 版本中类和对象的定义，及相关数据结构的关系： 拓展Tagged Pointerisa 这里还涉及到 Tagged Pointer 等概念。因为 isa_t 使用 union 实现，所以可能表示多种形态，既可以当成是指针，也可以存储标志位。 Tagged Pointer：一种特殊标记的对象，Tagged Pointer 通过在其最后一个 bit 位设置为特殊标记位，并且把数据直接保存在指针本身中。Tagged Pointer 是一个”伪”对象，使用 Tagged Pointer 有 3 倍的访问速度提升，100 倍的创建、销毁速度提升。 Tips：Advances in Objective-C 在我们查看对象指针时，在 64 位系统中，我们会看到 16 进制地址如0x00000001003041e0，我们把它转换为二进制表示如下图 在 64 位系统中，我们有 64 位可以表示一个对象指针，但是我们通常没有真正使用到所有这些位。由于内存对齐要求的存在，低位始终为0，对象必须始终位于指针大小倍数的地址中。由于地址空间有限，所以高位也始终为0。所以实际上我们只在一个真正的对象指针中使用了中间的这些位，而不会用到用到2^64，这些高位和低位总是0。 苹果从这些始终为0的位中选择了低位并把它设置为1。以标识这不是一个真正的对象指针，然后就可以给其他位赋予一些其他的意义，苹果称这种指针为tagged pointer。 例如：NSNumber指针，苹果在其它位中塞入的是一个数值。（PS：这些值实际上是通过与进程启动时初始化的随机值相结合而被混淆的）。 在设置为 1 表示为 Tagged Pointer 对象之后，在最低位之后的 3 位，苹果给他赋予类型意义，由于只有 3 位，所以它可以表示 7 种数据类型 12345678OBJC_TAG_NSAtom = 0, OBJC_TAG_1 = 1, OBJC_TAG_NSString = 2, OBJC_TAG_NSNumber = 3, OBJC_TAG_NSIndexPath = 4, OBJC_TAG_NSManagedObjectID = 5, OBJC_TAG_NSDate = 6, OBJC_TAG_7 = 7 在剩余的字段中，我们可以赋予他所包含的数据。在 Intel 中，我们 Tagged Pointer 对象的表示如下 OBJC_TAG_7类型的 Tagged Pointer 是个例外，它可以将接下来后 8 位作为它的扩展类型字段，基于此我们可以多支持 256 中类型的 Tagged Pointer，如 UIColors 或 NSIndexSets 之类的对象。 OC对象占用的大小初始OC对象占用内存OC中对象大部分继承至NSObject。NSObject类的定义如下： 123456789101112131415OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ROOT_CLASSOBJC_EXPORT@interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125;+ (void)load;+ (void)initialize;...// 省略其他方法@end 上文中提到Class其实就是一个指向 struct objc_class 结构体类型的指针.。那么也就是说 NSObject 对象对应的结构体只包含一个 isa 指针变量 ，一个指针变量在 64 位的机器上大小是 8 个字节。 那是不是说一个 NSObject 对象就占用8个字节大小的内存呢？实际上不是的. 答案其实是: 所有的OC对象至少为16字节. 我们先来验证一下。 12345678910#import &lt;Foundation&#x2F;Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; &#x2F;&#x2F; insert code here... NSObject *obj &#x3D; [[NSObject alloc] init]; NSLog(@&quot;Hello, World! %@&quot;,obj); &#125; return 0;&#125; 打印语句加个断点。 lldb中打印得出：对象实际占用的内存大小为8，实际分配的内存大小为16。 lldb查看布情况，可以看出创建的对象后面几个字节全部为 00。 我们可以通过阅读 objc4 的源码来找到答案。通过查看跟踪 obj4 中 alloc 和 allocWithZone 两个函数的实现，会发现这个连个函数都会调用一个 instanceSize 的函数： 123456size_t instanceSize(size_t extraBytes) &#123; size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16bytes. if (size &lt; 16) size = 16; return size; &#125; 上面源码中我们看出了答案, 最少会开辟16个字节. 那么为什么非要用 16 个字节来存储 8 个字节的内容呢? 这里简单解释一下 . 其实这里主要是涉及到硬件问题, 因为不同厂商之间需要一套标准化方案来解决不同厂商之间规则不同导致内存读取使用出现不统一的情况.为了解决这种问题而产生的 字节对齐. 讲到这里,我还想继续看下 当这个对象包含多个属性时使用内存情况. 以便我们彻底搞明白 OC 对象使用内存情况. 包含其他属性占用内存情况创建一个 Person 类,继承与 NSObject , 其包含三个 int 属性。修改main.m 文件如下： 12345678910111213141516171819202122#import &lt;Foundation&#x2F;Foundation.h&gt;@interface Person : NSObject@property (nonatomic, assign) int age;@property (nonatomic, assign) int height;@property (nonatomic, assign) int row;@end@implementation Person@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *obj &#x3D; [[Person alloc] init]; obj.age &#x3D; 4; obj.height &#x3D; 5; obj.row &#x3D; 6; NSLog(@&quot;Hello, World! %@&quot;,obj); &#125; return 0;&#125; lldb打印对象内存情况如下 对象实际占用内存大小为24，实际分配的内存大小为32。 这里就出现一个比较奇怪的现象 , 实际需要内存大小 24, 为什么呢 ? 其实这里就是 结构体内存分配的原理了. 结构体每个成员相对于结构体首地址的偏移量都是这个成员大小的整数倍，如果有需要，编译器会在成员之间加上填充字节 结构体的总大小为结构体最宽成员大小的整数倍。 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。 对于结构体成员属性中包含结构体变量的复合型结构体，在确定最宽基本类型成员时，应当包括复合类型成员的子成员。但在确定复合类型成员的偏移位置时则是将复合类型作为整体看待。 由于原本结构体 isa指针占用8个 , age属性占用4个, height占用 4个, row属性再占用4个 , 这中间由于满足整除并没有自动偏移补充. 而由于 : 结构体的总大小为结构体最宽成员大小的整数倍 , 而且对线开辟满足 16 字节对齐原则 ( 可以在 libmaclloc 源码查找到 ) , 因此实际总占用内存为24. 而实际开辟则满足对齐标准开辟为 32. 在 libmaclloc 源码 , nano_malloc.c 中 1234567891011121314static MALLOC_INLINE size_tsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)&#123; size_t k, slot_bytes; if (0 == size) &#123; size = NANO_REGIME_QUANTA_SIZE; // Historical behavior &#125; k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // round up and shift for number of quanta slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; // multiply by power of two quanta size *pKey = k - 1; // Zero-based! return slot_bytes;&#125; 其中NANO_REGIME_QUANTA_SIZE 和 SHIFT_NANO_QUANTUM在nano_zone_common.h中定义如下： 12#define SHIFT_NANO_QUANTUM 4#define NANO_REGIME_QUANTA_SIZE (1 &lt;&lt; SHIFT_NANO_QUANTUM) // 16 所以16字节对齐算法为：size + (2^4 - 1) &gt;&gt; 4 &lt;&lt; 4。 总结 (只考虑64位): OC对象 最少占用 16个字节内存 . 当对象中包含属性, 会按属性占用内存开辟空间. 在结构体内存分配原则下自动偏移和补齐 . 对象最终满足 16字节对齐标准 . 属性最终满足 8字节对齐标准 . 可以通过 #pragma pack() 自定义对齐方式 . 更新在2020年WWDC中，Runtime又有了一些更新。详见：2020 – Advancements in the Objective-C runtime主要更新内容如下: 数据结构的变化在介绍更新之前，先了解一下二进制类在磁盘中的表示。 首先是类对象本身，包含最常访问的信息：指向元类，超类和方法缓存的指针，在类结构之中有指向包含更多数据的结构体class_ro_t的指针，包含了类的名称，方法，协议，实例变量等等编译期确定的信息。 当类被 Runtime 加载之后，类的结构会发生一些变化，在了解这些变化之前，我们需要知道2个概念： Clean Memory：加载后不会发生更改的内存块，class_ro_t属于Clean Memory，因为它是只读的。 Dirty Memory：运行时会进行更改的内存块，类一旦被加载，就会变成Dirty Memory，例如，我们可以在 Runtime 给类动态的添加方法。 这里要明确，Dirty Memory比Clean Memory要昂贵得多。因为它需要更多的内存信息，并且只要进程正在运行，就必须保留它。对于我们来说，越多的Clean Memory显然是更好的，因为它可以节约更多的内存。我们可以通过分离出永不更改的数据部分，将大多数类数据保留为Clean Memory，如何怎么做的呢？ 在介绍优化方法之前，我们先来看一下，在类加载之后，类的结构会变成如何呢？ 在类加载到 Runtime 中后会被分配用于读取/写入数据的结构体class_rw_t。 Tips：class_ro_t是只读的，存放的是编译期间就确定的字段信息；而class_rw_t是在 runtime 时才创建的，它会先将class_ro_t的内容拷贝一份，再将类的分类的属性、方法、协议等信息添加进去，之所以要这么设计是因为 Objective-C 是动态语言，你可以在运行时更改它们方法，属性等，并且分类可以在不改变类设计的前提下，将新方法添加到类中。 事实证明，class_rw_t会占用比class_ro_t占用更多的内存，在 iPhone 中，我们在系统测量了大约 30MB 的这些class_rw_t结构。应该如何优化这些内存呢？通过测量实际设备上的使用情况，我们发现大约 10％ 的类实际会存在动态的更改行为，如动态添加方法，使用 Category 方法等。因此，我们能可以把这部分动态的部分提取出来，我们称之为class_rw_ext_t，所以，结构会变成这个样子。 经过拆分，可以把 90% 的类优化为Clean Memory，在系统层面，取得效果是节省了大约 14MB 的内存，使内存可用于更有效的用途。 Tips：head xxxxx | egrep &#39;class_rw|COUNT’ 你可以使用此命令来查看 class_rw_t 消耗的内存。xxxx可以替换为需要测量的 App 名称。如：head Mail | egrep &#39;class_rw|COUNT’\\&#39;查看 Mail 应用的使用情况。 Tagged pointer格式的变化相比于之前的Tagged pointer，在 ARM64 中格式有些变化。 不同于以往，苹果使用最高位代表 Tagged Pointer 标识位，低位 3 位标识 Tagged Pointer 的类型，接下去的位来表示包含的数据（可能包含扩展类型字段），为什么我们使用高位指示 ARM上 的 Tagged Pointer，而不是像 Intel 一样使用低位标记？ 它实际是对 objc_msgSend 的微小优化。我们希望 msgSend 中最常用的路径尽可能快。最常用的路径表示普通对象指针。我们有两种不常见的情况：Tagged Pointer 指针和 nil。事实证明，当我们使用最高位时，可以通过一次比较来检查两者。与分别检查 nil 和 Tagged Pointer 指针相比，这会为 msgSend 中的节省了条件分支。 应用判断类有没有初始化很多技术博客里都提到了，ObjC类的meta class里，自带了一个标记自己有没有初始化过的flag，即class_rw_t–&gt;flags里的RW_INITIALIZED。objc_class类中有提供了封装的函数供外部快速获取该flag值。调用相关代码如下： 12345678910111213141516171819202122// objc_class 代码片段struct objc_class : objc_object &#123;... class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125;... bool isInitialized() &#123; return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED; &#125; void setInitialized();... // NOT identical to this-&gt;ISA when this is a metaclass Class getMeta() &#123; if (isMetaClass()) return (Class)this; else return this-&gt;ISA(); &#125;...&#125; 123456789101112struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;...public: class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;...&#125; 12345struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags;...&#125; 可惜的是，这些方法对我们app来说，是不可见的，没办法直接调用。所以如果想要在运行过程中获取类的初始化状态，只能另想办法。从方法的调用情况看到方法的过程大概分为4步： 我们要先找到类的meta class。 获取objc_class的成员变量bits（class_data_bits_t结构体） 调用class_data_bits_t结构体的data()方法，对结构体的bits属性进行位运算，获取class_rw_t结构体 最后获取class_rw_t结构体的成员变量flags并进行位运算 因为runtime源代码是用C++来写的，所以我们可以通过偏移地址获取到用到的变量，直接用指针来搞定问题。 针对第一步，获取类的meta class，是个runtime里可见的方法，直接调用objc_getMetaClass()方法就能拿到。 第二步获取objc_class的成员变量bits。回到objc_class的头部几行： 1234567891011struct objc_class : objc_object &#123; objc_class(const objc_class&amp;) = delete;// 0 bytes objc_class(objc_class&amp;&amp;) = delete;// 0 bytes void operator=(const objc_class&amp;) = delete;// 0 bytes void operator=(objc_class&amp;&amp;) = delete;// 0 bytes // Class ISA; Class superclass; // 8 bytes cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags...&#125; 首先objc_class 继承至 objc_object，对于子结构体来说，是需要继承父结构体的成员变量的。runtime源代码是用C++来写的，函数都不会占用类meta信息（或者说实例）的内存地址，只有成员变量会占用地址。objc_object父结构如前表述，仅包含isa这个成员变量，占用类实例的头8个bytes，也就是64位CPU的一个指针的长度；而下面的一堆方法，在实例里面一点内存都不占用。然后看完整个结构体，只有这么一个成员变量，所以总长度也就8个bytes。 objc_class内前面几行那几个函数禁用语句，不会产生内存地址的偏移，先不管它们。 superclass作为一个指针（对，Class类型实际上是一个指向结构体的指针），长度为8 bytes。 接下来是cache_t类型的变量cache，它占用了多少bytes我们就要展开看看了。 123456789101112131415161718192021#if __LP64__typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t;#endif...struct cache_t &#123;private: explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;// 8 bytes union &#123; struct &#123; explicit_atomic&lt;mask_t&gt; _maybeMask;//4 bytes#if __LP64__ uint16_t _flags;//2 bytes#endif uint16_t _occupied;//2 bytes &#125;; explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;// 8 bytes &#125;;...&#125; 首先说一下explicit_atomic&lt;T&gt;，它只是负责把模板里的类型包成atomic的，不会对变量占用的内存长度产生影响。 然后要说一下union，C++的老朋友了，联合体内部的成员取最长的一个内存长度，就是联合体的内存长度，这里就是8 bytes。 mask_t的定义在文件头就能找到，其实在64位CPU下就是一个uint32_t而已。 基于上面的介绍，可以推断出整个cache_t结构体的长度就是8 bytes + 8 bytes = 16 bytes。 综上，bits 偏移量为：父结构体objc_object的isa成员变量（8 bytes）+ objc_class结构体的superclass成员变量（8 bytes）+ objc_class结构体的cache成员变量（16 bytes） = 32 bytes。 第三步、第四步，很凑巧的是bits和flags都是两个结构体里的第一个成员变量，那么我们就不需要继续计算偏移了，只需要关注data()函数的具体取值方法即可。 最终我们从一个Class类型，取到它有没有被初始化过的代码大致如下： 1234567Class metaCls &#x3D; objc_getMetaClass(class_getName(cls));if (metaCls) &#123; uint64_t *bits &#x3D; (__bridge void *)metaCls + 32; &#x2F;&#x2F; 在 metaClass 基地址上加上 32 bits 的偏移 uint32_t *data &#x3D; (uint32_t *)(*bits &amp; FAST_DATA_MASK); &#x2F;&#x2F; 模拟 data() 函数取值 return (*data &amp; RW_INITIALIZED); &#x2F;&#x2F; 模拟 isInitialized() 函数最后一步与操作&#125;return NO;","categories":[{"name":"刨根问底","slug":"刨根问底","permalink":"http://heseng91.github.io/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}],"tags":[]},{"title":"「刨根问底」之RunLoop","slug":"「刨根问底」之Runloop","date":"2018-08-10T00:10:01.000Z","updated":"2022-11-02T16:44:21.558Z","comments":true,"path":"2018/08/10/「刨根问底」之Runloop/","link":"","permalink":"http://heseng91.github.io/2018/08/10/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRunloop/","excerpt":"RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，与自动释放池、延迟回调、触摸事件、屏幕刷新等功能的实现密切相关。理解RunLoop可以帮助开发者了解很多技术的实现细节，加深理解，并在实际工作中加以灵活运用以解决特定场景的问题。","text":"RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，与自动释放池、延迟回调、触摸事件、屏幕刷新等功能的实现密切相关。理解RunLoop可以帮助开发者了解很多技术的实现细节，加深理解，并在实际工作中加以灵活运用以解决特定场景的问题。 本文将从RunLoop源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。最后介绍RunLoop的一些实际应用。前两部分网上相关文章已经很多了，珠玉在前，因此本文就基于深入理解RunLoop适当补充一些当时拜读文章时疑惑的点，来做个介绍。 RunLoop 的概念以及底层实现原理RunLoop 的概念一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的： 1234567function loop() &#123; initialize(); do &#123; var message &#x3D; get_next_message(); process_message(message); &#125; while (message !&#x3D; quit);&#125; 这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 CFRunLoopRef 的代码是开源的，你可以在这里 http://opensource.apple.com/tarballs/CF/ 下载到整个 CoreFoundation 的源码来查看。 (Update: Swift 开源后，苹果又维护了一个跨平台的 CoreFoundation 版本：https://github.com/apple/swift-corelibs-foundation/，这个版本的源码可能和现有 iOS 系统中的实现略不一样，但更容易编译，而且已经适配了 Linux/Windows。) CFRunLoopRefCFRunLoopRef 其实是 __CFRunLoop 结构体的别名，可在 CFRunLoop.h 找到如下代码： 1typedef struct __CFRunLoop * CFRunLoopRef; __CFRunLoop 结构体在 CFRunLoop.c 中定义如下： 123456789101112131415161718struct __CFRunLoop &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* locked for accessing mode list */ __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData; // reset for runs of the run loop pthread_t _pthread; // RunLoop对应的线程 uint32_t _winthread; CFMutableSetRef _commonModes; // set CFMutableSetRef _commonModeItems; // set CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFAbsoluteTime _runTime; CFAbsoluteTime _sleepTime; CFTypeRef _counterpart;&#125;; 结构体中包含一个pthread_mutex_t类型的锁，来保证获取 RunLoop mode list时的线程安全，所以说 CFRunLoopRef API是线程安全的。 除此之外结构体还包含一个 pthread_t 类型变量，那么RunLoop 与线程是什么关系呢？另外结构体的_commonModes、_commonModeItems、 _currentMode 和 _modes 分别代表什么含义呢？带着这些问题，我们来逐步解答。 RunLoop 与线程的关系首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份[文档](http://www.fenestrated.net/~macman/mirrors/Apple Technotes (As of 2002)/tn/tn2028.html)标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。 苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样: 123456789101112131415161718192021222324252627282930313233343536373839/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock; /// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) &#123; /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125; CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125; CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; 从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 RunLoop 对外的接口在RunLoop结构体中包含了一个CFRunLoopModeRef 类型的变量 。CFRunLoopModeRef 在 CFRunLoop.c 文件中的定义如下： 1234567891011121314151617181920212223242526272829303132typedef struct __CFRunLoopMode *CFRunLoopModeRef;struct __CFRunLoopMode &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* must have the run loop locked before locking this */ CFStringRef _name; // Mode Name, 例如 @\"kCFRunLoopDefaultMode\" Boolean _stopped; char _padding[3]; CFMutableSetRef _sources0; // set CFMutableSetRef _sources1; // set CFMutableArrayRef _observers; // array CFMutableArrayRef _timers; // array CFMutableDictionaryRef _portToV1SourceMap; __CFPortSet _portSet; CFIndex _observerMask;#if USE_DISPATCH_SOURCE_FOR_TIMERS dispatch_source_t _timerSource; dispatch_queue_t _queue; Boolean _timerFired; // set to true by the source when a timer has fired Boolean _dispatchTimerArmed;#endif#if USE_MK_TIMER_TOO mach_port_t _timerPort; Boolean _mkTimerArmed;#endif#if DEPLOYMENT_TARGET_WINDOWS DWORD _msgQMask; void (*_msgPump)(void);#endif uint64_t _timerSoftDeadline; /* TSR */ uint64_t _timerHardDeadline; /* TSR */&#125;; CFRunLoopSourceRef： 结构体中 _sources0 和 _sources1 变量的元素类型是 CFRunLoopSourceRef。CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 CFRunLoopTimerRef： 结构体中 _timers 变量的元素类型是 CFRunLoopTimerRef。CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef： 结构体中 _observers 变量的元素类型是CFRunLoopObserverRef。 CFRunLoopObserverRef是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 这里提到的CFRunLoopModeRef、CFRunLoopSourceRef、CFRunLoopTimerRef 和 CFRunLoopObserverRef 四个类和前面说的 CFRunLoopRef 共同构成了CoreFoundation 里面关于 RunLoop 有5个类。其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下: 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 Source/Timer/Observer 被统称为 mode item，即 CFRunLoopRef 结构体中的 commonModeItems变量中存放的元素。一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoop 的 Mode上文中 CFRunLoopRef 结构体中有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。 CFRunLoop对外暴露的管理 Mode 接口只有下面2个: 12CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);CFRunLoopRunInMode(CFStringRef modeName, ...); Mode 暴露的管理 mode item 的接口有下面几个： 123456CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 RunLoop的退出方式启动一个runloop有以下三种方法： 12345- (void)run; - (void)runUntilDate:(NSDate *)limitDate；- (void)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate; 第一种方式，runloop会一直运行下去，在此期间会处理来自输入源的数据，并且会在NSDefaultRunLoopMode模式下重复调用runMode:beforeDate:方法； 第二种方式，可以设置超时时间，在超时时间到达之前，runloop会一直运行，在此期间runloop会处理来自输入源的数据，并且也会在NSDefaultRunLoopMode模式下重复调用runMode:beforeDate:方法； 第三种方式，runloop会运行一次，超时时间到达或者第一个input source被处理，则runloop就会退出。 前两种启动方式会重复调用runMode:beforeDate:方法。 与之对应的退出方式分别为： 第一种启动方式的退出方法：如果想退出runloop，不应该使用第一种启动方式来启动runloop。如果runloop没有input sources或者附加的timer，runloop就会退出。 虽然这样可以将runloop退出，但是苹果并不建议我们这么做，因为系统内部有可能会在当前线程的runloop中添加一些输入源，所以通过手动移除input source或者timer这种方式，并不能保证runloop一定会退出。 第二种启动方式的退出方法：可以通过设置超时时间来退出runloop。 **第三种启动方式的退出方法：通过这种方式启动，runloop会运行一次，当超时时间到达或者第一个输入源被处理，runloop就会退出。如果我们想控制runloop的退出时机，而不是在处理完一个输入源事件之后就退出，那么就要重复调用runMode:beforeDate:，具体可以参考苹果文档给出的方案，如下： 12345678 NSRunLoop *myLoop = [NSRunLoop currentRunLoop]; myPort = (NSMachPort *)[NSMachPort port]; [myLoop addPort:_port forMode:NSDefaultRunLoopMode];BOOL isLoopRunning = YES; // globalwhile (isLoopRunning &amp;&amp; [myLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]); 123456//关闭runloop的地方- (void)quitLoop &#123; isLoopRunning = NO; CFRunLoopStop(CFRunLoopGetCurrent());&#125; 总之： 如果不想退出runloop可以使用第一种方式启动runloop；使用第二种方式启动runloop，可以通过设置超时时间来退出；使用第三种方式启动runloop，可以通过设置超时时间或者使用CFRunLoopStop方法来退出。 RunLoop 的内部逻辑根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下: 第七步按照官方文档的描述，会有4种情况唤醒RunLoop：An event arrives for a port-based input source.A timer fires.The timeout value set for the run loop expires.The run loop is explicitly woken up. 其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/// 用DefaultMode启动void CFRunLoopRun(void) &#123; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125; /// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123; return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125; /// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123; /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; /// 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); /// 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123; Boolean sourceHandledThisLoop = NO; int retVal = 0; do &#123; /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 4. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; &#125; /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); &#125; /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 /// • 一个基于 port 的Source 的事件。 /// • 一个 Timer 到时间了 /// • RunLoop 自身的超时时间到了 /// • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg &#125; /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); /// 收到消息，处理消息。 handle_msg: /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) &#125; /// 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123; mach_msg(reply, MACH_SEND_MSG, reply); &#125; &#125; /// 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout) &#123; /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(runloop)) &#123; /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123; /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; &#125; /// 如果没超时，mode里没空，loop也没被停止，那继续loop。 &#125; while (retVal == 0); &#125; /// 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop 的底层实现从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。 苹果官方将整个系统大致划分为上述4个层次：应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。应用框架层即开发人员接触到的 Cocoa 等框架。核心框架层包括各种核心框架、OpenGL 等内容。Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 opensource.apple.com 里找到。 我们在深入看一下 Darwin 这个核心的架构： 其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。 Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。 Mach 的消息定义是在 &lt;mach/message.h&gt; 头文件的，很简单： 12345678910111213typedef struct &#123; mach_msg_header_t header; mach_msg_body_t body;&#125; mach_msg_base_t; typedef struct &#123; mach_msg_bits_t msgh_bits; mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; mach_port_t msgh_local_port; mach_port_name_t msgh_voucher_port; mach_msg_id_t msgh_id;&#125; mach_msg_header_t; 一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向： 12345678mach_msg_return_t mach_msg( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify); 为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图： 这些概念可以参考维基百科: System_call、Trap_(computing)。 RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。 关于具体的如何利用 mach port 发送信息，可以看看 NSHipster 这一篇文章，或者这里的中文翻译 。 关于Mach的历史可以看看这篇很有趣的文章：Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian。 苹果用 RunLoop 实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CFRunLoop &#123; current mode = kCFRunLoopDefaultMode common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0 (manual) CFRunLoopSource &#123;order =-1, &#123; callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventSignalCallback &#125;&#125; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach port) CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1b03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125; CFRunLoopSource &#123;order = 1, &#123;port = 1903, callout = __IOMIGMachPortPortCallback&#125;&#125; // Ovserver CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver&#125; CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // Timer CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125; &#125;, modes ＝ &#123; CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, sources1 = (null), observers = &#123; CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; )&#125;, timers = (null), &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;, sources1 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventCallback&#125;&#125; &#125;, observers = (null), timers = (null), &#125;, CFRunLoopMode &#123; sources0 = (null), sources1 = (null), observers = (null), timers = (null), &#125; &#125;&#125; kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。 你可以在这里看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。 当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; /// 1. 通知Observers，即将进入RunLoop /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry); do &#123; /// 2. 通知 Observers: 即将触发 Timer 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers); /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 4. 触发 Source0 (非基于port的) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 6. 通知Observers，即将进入休眠 /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting); /// 7. sleep to wait msg. mach_msg() -&gt; mach_msg_trap(); /// 8. 通知Observers，线程被唤醒 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting); /// 9. 如果是被Timer唤醒的，回调Timer __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer); /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block); /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1); &#125; while (...); /// 10. 通知Observers，即将退出RunLoop /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);&#125; AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。接着会在UIWindow为根节点的整颗视图树上通过hitTest:withEvent:和pointInside:withEvent:这两个方法递归查找到合适响应这个触摸事件的视图。找到合适的子节点视图后，调用touches方法，判断是否实现touches方法，没有实现默认会将事件传递给上一个响应者。如果最终找到上一个响应者则调用，否则方法作废。响应链的整体流程如下： 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： 1234567891011_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD实际上 RunLoop 底层也会用到 GCD 的东西，但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 关于网络请求iOS 中，关于网络请求的接口自下至上有如下几层: 1234CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire • CFSocket 是最底层的接口，只负责 socket 通信。• CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。• NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。• NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。 下面主要介绍下 NSURLConnection 的工作过程。 通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 RunLoop 的实际应用AFNetworkingAFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop &#x3D; [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125; + (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread &#x3D; nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread &#x3D; [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start &#123; [self.lock lock]; if ([self isCancelled]) &#123; [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; else if ([self isReady]) &#123; self.state &#x3D; AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; [self.lock unlock];&#125; 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 AsyncDisplayKitAsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下： UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。 排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。 为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。具体的代码可以看这里：_ASAsyncTransactionGroup。 FDTemplateLayoutCellFDTemplateLayoutCell 的高度预缓存是一个优化功能，它只会在页面处于空闲状态时才执行计算，当用户正在滑动列表时显然不应该执行计算任务影响滑动体验。前面提到了当用户正在滑动 UIScrollView 时，RunLoop 将切换到 UITrackingRunLoopMode 接受滑动手势和处理滑动事件（包括减速和弹簧效果），而此时其它Mode（除了具有 “Common” 标记的Mode外）下的事件将全部暂停执行，来保证滑动事件的优先处理。当 UI 没在滑动时，默认的 Mode 是 kCFRunLoopDefaultMode，同时也是 CF 中定义的 “空闲状态 Mode”。 高度预缓存的实现思路就是将未展示或者缓存的高度，分解成多个RunLoop Source任务，在RunLoop 处于“空闲”状态 Mode下分散到多个RunLoop 迭代中执行，避免计算任务在同一个 RunLoop 迭代中同步执行造成的卡顿。 为此，FDTemplateLayoutCell 获取当前RunLoop并在kCFRunLoopDefaultMode mod下添加一个Observer，监听kCFRunLoopBeforeWaiting状态的时候，执行一次预计算，待所有任务执行完成的时候，移除监听者，核心代码如下： 123456789101112131415161718CFRunLoopRef runLoop = CFRunLoopGetCurrent();CFStringRef runLoopMode = kCFRunLoopDefaultMode;NSMutableArray *mutableIndexPathsToBePrecached = self.fd_allIndexPathsToBePrecached.mutableCopy;CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) &#123; if (mutableIndexPathsToBePrecached.count == 0) &#123; CFRunLoopRemoveObserver(runLoop, observer, runLoopMode); CFRelease(observer); // 注意释放，否则会造成内存泄露 return; &#125; NSIndexPath *indexPath = mutableIndexPathsToBePrecached.firstObject; [mutableIndexPathsToBePrecached removeObject:indexPath]; [self performSelector:@selector(fd_precacheIndexPathIfNeeded:) onThread:[NSThread mainThread] withObject:indexPath waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];&#125;);CFRunLoopAddObserver(runLoop, observer, runLoopMode); 此思路也可用于其它场景的优化。 RunLoop 监控 app 卡顿上文介绍了，Runloop的六个状态，Runloop 真正处理事务的状态区间是：kCFRunloopBeforeSources-&gt;kCFRunLoopBeforeWaitingkCFRunLoopAfterWaiting-&gt; kCFRunLoopBeforeTimers 要监控app 卡顿的思路如下： 创建一个 CFRunLoopObserverContext 观察者， 将创建好的观察者 runLoopObserver 添加到主线程 RunLoop 的 common mode下监听 kCFRunLoopBeforeWaiting 和 kCFRunLoopBeforeWaiting 状态 创建一个Dispatch Semaphore来监控主线程的 RunLoop 状态并设置等待时间 过等待时间内子线程还没有被唤醒，则认为发生了卡顿 核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738dispatchSemaphore = dispatch_semaphore_create(0); //Dispatch Semaphore保证同步 //创建一个观察者 CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;; runLoopObserver = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); //将观察者添加到主线程runloop的common模式下的观察中 CFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes); //创建子线程监控 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; //子线程开启一个持续的loop用来进行监控 while (YES) &#123; long semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC)); // semaphoreWait 的值不为 0， 说明线程被堵塞 if (semaphoreWait != 0) &#123; if (!runLoopObserver) &#123; timeoutCount = 0; dispatchSemaphore = 0; runLoopActivity = 0; return; &#125; // BeforeSources和 AfterWaiting 这两个 runloop 状态的区间时间能够检测到是否卡顿 if (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) &#123; // 将堆栈信息上报服务器的代码放到这里 if (++ timeoutCount &lt; 5) &#123; //连续5次就是250毫秒 continue; &#125; else &#123; NSLog(@\"卡顿了\"); &#125; &#125; //end activity &#125;// end semaphore wait timeoutCount = 0; &#125;// end while &#125;); runLoopObserverCallBack 回调实现如下： 1234567static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; SMLagMonitor *lagMonitor = (__bridge SMLagMonitor*)info; lagMonitor-&gt;runLoopActivity = activity; dispatch_semaphore_t semaphore = lagMonitor-&gt;dispatchSemaphore; dispatch_semaphore_signal(semaphore);&#125; 使用runloop阻塞线程前文中说到，runloop其实就是一个while循环，所以可以使用runloop来阻塞线程。 1234567891011121314151617181920212223242526272829@implementation ViewController&#123; BOOL end;&#125;– (void)viewDidLoad&#123; [super viewDidLoad]; NSLog(@”start new thread …”); [NSThread detachNewThreadSelector:@selector(runOnNewThread) toTarget:self withObject:nil]; while (!end) &#123; NSLog(@”runloop…”); [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; NSLog(@”runloop end.”); &#125; NSLog(@”ok”);&#125;-(void)runOnNewThread&#123; NSLog(@”run for new thread …”); sleep(1); [self performSelectorOnMainThread:@selector(setEnd) withObject:nil waitUntilDone:NO]; NSLog(@”end.”);&#125;-(void)setEnd&#123; end=YES;&#125; 参考： 深入理解RunLoop 优化UITableViewCell高度计算的那些事 如何利用 RunLoop 监控 app 卡顿 使用runloop阻塞线程的正确写法 RunLoop的退出方式","categories":[{"name":"刨根问底","slug":"刨根问底","permalink":"http://heseng91.github.io/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}],"tags":[]},{"title":"「刨根问底」之内存管理","slug":"「刨根问底」之内存管理","date":"2018-08-02T00:02:00.000Z","updated":"2022-11-02T16:43:49.517Z","comments":true,"path":"2018/08/02/「刨根问底」之内存管理/","link":"","permalink":"http://heseng91.github.io/2018/08/02/%E3%80%8C%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"应用程序内存管理是在程序运行时分配内存，使用它并在使用完后释放它的过程。编写良好的程序将使用尽可能少的内存。在 Objective-C 中，它也可以看作是在许多数据和代码之间分配有限内存资源所有权的一种方式。掌握内存管理知识，我们就可以很好地管理对象生命周期并在不再需要它们时释放它们，从而管理应用程序的内存。本文从内存管理概念开始，介绍内存管理的思想、方式和系统实现，阅读本文后你将对内存管理有一个整体认知。","text":"应用程序内存管理是在程序运行时分配内存，使用它并在使用完后释放它的过程。编写良好的程序将使用尽可能少的内存。在 Objective-C 中，它也可以看作是在许多数据和代码之间分配有限内存资源所有权的一种方式。掌握内存管理知识，我们就可以很好地管理对象生命周期并在不再需要它们时释放它们，从而管理应用程序的内存。本文从内存管理概念开始，介绍内存管理的思想、方式和系统实现，阅读本文后你将对内存管理有一个整体认知。 什么是内存管理Objective-C 中的内存管理，也就是引用计数。 引用计数机制可以用开关房间的灯为例来说明。假设办公室里的照明设备只有一个。上班进入办公室的人需要照明，所以要把灯打开。而对于下班离开办公室的人来说，已经不需要照明了，所以要把灯关掉。 若是很多人上下班，每个人都开灯或者关灯，那么办公室的情况又将如何呢？最早下班的人如果关了灯，那就会像下图那样，办公室里还没走的所有人都将处于一片黑暗之中。 解决这一问题的办法就是使办公室在还有至少一人的情况下保持开灯状态，而在无人时保持关灯状态。 （1）最早进入办公室的人开灯。 （2）之后进入办公室的人，需要照明。 （3）下班离开办公室的人，不需要照明。 （4）最后离开办公室的人关灯（此时已无人需要照明）。 为判断是否还有人在办公室里，这里导入计数功能来计算 “需要照明的人数”。下面让我们来看看这一功能是如何运作的吧。 （1）第一个人进入办公室，“需要照明的人数” 加 1。计数值从 0 变成了 1，因此要开灯。 （2）之后每当有人进入办公室，“需要照明的人数” 就加 1。如计数值从 1 变成 2。 （3）每当有人下班离开办公室，“需要照明的人数” 就减 1。如计数值从 2 变成 1。 （4）最后一个人下班离开办公室，“需要照明的人数” 减 1。计数值从 1 变成了 0，因此要关灯。 这样就能在不需要照明的时候保持关灯状态。办公室中仅有的照明设备得到了很好的管理，如下图所示： 在 Objective-C 中，“对象” 相当于办公室里的照明设备。在现实世界中办公室里的照明设备只有一个，但在 Objective-C 的世界里，虽然计算机的资源有限，但一台计算机可以同时处理好几个对象。 此外，“对象的使用环境” 相当于上班进入办公室的人。虽然这里的 “环境” 有时也指在运行中的程序代码、变量、变量作用域、对象等，但在概念上就是使用对象的环境。上班进入办公室的人对办公室照明设备发出的动作，与 Objective-C 中的对应关系则如下表所示： 对照明设备所做的动作 对 Objective-C 对象所做的动作 开灯 生成对象 需要照明 持有对象 不需要照明 释放对象 关灯 废弃对象 使用计数功能计算需要照明的人数，使办公室的照明得到了很好的管理。同样，使用引用计数功能，对象也就能够得到很好的管理，这就是 Objective-C 的内存管理。如下图所示： 内存管理实现看到引用计数，我们便会不自觉地将注意力放到计数上。但这往往会适得其反，因为这样是在从实现细节而非实现目标角度来理解内存管理。其实，更加客观、正确的思考内存管理方式应该是从对象所有权和对象图的角度。 对象图：在面向对象编程中，一组组的对象根据彼此之间直接或者间接的持有关系形成一个网络。这样的一组组数据就称为对象图。对象图或大或小，或简单或复杂，多种多样。 例如，一个包含单一字符串对象的数组表示一个小而简单的对象图。而持有application对象的一组对象，可能表示的就是一个大的而复杂的对象图，因为application对象会持有多个windows、menus、视图以及其它其他支持对象。有时，您可能希望将对象图(通常只是应用程序中整个对象图的一部分)转换为一种可以保存到文件或传输到另一个进程或机器的形式，然后重新构建。这个过程被称为“归档”。有些对象图可能是不完整的——这些通常被称为部分对象图。 部分对象图包含有占位符对象，这些占位符对象表示图的边界，便于在后续阶段进行填充。例如：包含文件所有者占位符的nib文件。 内存管理模型是基于对象所有权的。任何对象都可能有一个或多个持有者。只要一个对象至少有一个持有者，它就会继续存在。如果对象没有持有者，运行时系统会自动销毁它。为了确保清楚地知道什么时候持有一个对象，什么时候不持有，苹果设置了以下内存管理策略: 自己生成的对象，自己持有 非自己生成的对象自己也能持有 不再需要自己持有的对象时释放 非自己持有的对象无法释放 上述生成、持有、释放等内存管理的相关操作，实际上不包括在 Objective-C 语言中，而是包含在Cocoa框架中，由NSObject类负责。内存管理的相关方法定义在NSObject协议中。NSObject类还定义了一个方法dealloc，当一个对象被销毁时，它会自动调用。另外，Cocoa还使用了一个简单的命名约定来指示何时应持有一个由方法返回的对象。对象操作与 Objective-C 方法的对应关系如下： 对象操作 Objective-C 方法 生成并持有对象 alloc/new/copy/mutableCopy 等方法和以它们驼峰命名开头的方法 持有对象 retain 方法 释放对象 release方法 销毁对象 dealloc方法 虽然通常在单个对象级别上考虑内存管理，但实际上我们的目标是管理对象图，要保证在内存中只保留需要用到的对象，确保没有发生内存泄漏。 Objective-C 在iOS中提供了两种内存管理方法：MRC 和 ARC。MRC时期，iOS 开发需要通过跟踪自己持有的对象来显式管理内存。这是使用一个称为 “引用计数” 的模型来实现的，由 Foundation 框架的 NSObject 类与运行时环境一起提供。为了降低程序崩溃、内存泄露等风险的同时，比较大程度减少开发程序的工作量，苹果在iOS 5时推出了ARC。ARC，全称 Automatic Reference Counting，就是让编译器进行内存管理，这样就无需再次键入retain或release代码。编译器完全清楚目标对象，并能立即释放哪些不再被使用的对象，从而提高应用程序的可预测性，保证程序能流畅运行，速度也将大幅提高。 内存管理源码探究上文提到Objective-C 中的内存管理，也就是引用计数管理。下面我们围绕引用计数源码来探究一下内存管理，本次探索基于objc4-756.2，使用Xcode 11.3.1 (11C504)。阅读之前需要对类和对象的结构有所了解。 引用计数存储对象引用计数存储上文中提到在iOS中，内存管理的相关操作是由NSObject类负责。NSObject在NSObject.h中的定义如下： 123456@interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125; NSObject类只包含一个Class类型成员变量。Class 其实是一个指向 objc_class 结构体的指针： 1typedef struct objc_class *Class; objc_class结构体定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125; /*...*/ // 对象是否重写了以下内存管理方法：retain/release/autorelease/retainCount/_tryRetain/_isdealocation /retainWeakReference/allowsWeakReference bool hasCustomRR() &#123; return ! bits.hasDefaultRR(); &#125; // 设置类或父类以下内存管理方法是否有默认实现：retain/release/autorelease/retainCount/_tryRetain/_isdealocation /retainWeakReference/allowsWeakReference void setHasDefaultRR() &#123; assert(isInitializing()); bits.setHasDefaultRR(); &#125; void setHasCustomRR(bool inherited = false); void printCustomRR(bool inherited); // 对象是否自定义实现了 alloc/allocWithZone: 方法 bool hasCustomAWZ() &#123; return ! bits.hasDefaultAWZ(); &#125; // 类或父类有默认的 alloc/allocWithZone: 方法实现，信息存储在元类中 void setHasDefaultAWZ() &#123; assert(isInitializing()); bits.setHasDefaultAWZ(); &#125; void setHasCustomAWZ(bool inherited = false); void printCustomAWZ(bool inherited); /*...*/ // 类或父类具有有c++ 构造函数 bool hasCxxCtor() &#123; // addSubclass() propagates this flag from the superclass. assert(isRealized()); return bits.hasCxxCtor(); &#125; void setHasCxxCtor() &#123; bits.setHasCxxCtor(); &#125; // 类或父类具有有c++ 析构函数 bool hasCxxDtor() &#123; // addSubclass() propagates this flag from the superclass. assert(isRealized()); return bits.hasCxxDtor(); &#125; void setHasCxxDtor() &#123; bits.setHasCxxDtor(); &#125; /*...*/&#125; objc_class结构体拥有 superclass、cache 和 bits三个成员变量，以及封装了获取和更改bits数据的一些函数、计算等实力大小等的函数。 cache成员变量的类型为cache_t，用于对方法调用的性能进行优化。cache_t定义如下： 1234567struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied; /*...*/&#125; 其中，bucket_t *_buckets 是一个散列表，用来存储 Method 方法列表；_mask：分配用来缓存 bucket 的总数；_occupied：表明目前实际占用的缓存 bucket 的个数。 bits是objc_class 中最复杂的，类型为class_data_bits_t，用于存储属性、方法等类的源数据。class_data_bits_t结构体定义如下： 123456789101112struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;private: bool getBit(uintptr_t bit) &#123; return bits &amp; bit; &#125;/*...*/&#125;; bits 在内存中每个位的含义定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// Values for class_rw_t-&gt;flags or class_t-&gt;bits// These flags are optimized for retain/release and alloc/dealloc// 64-bit stores more of them in class_t-&gt;bits to reduce pointer indirection.#if !__LP64__// class or superclass has .cxx_construct implementation#define RW_HAS_CXX_CTOR (1&lt;&lt;18)// class or superclass has .cxx_destruct implementation#define RW_HAS_CXX_DTOR (1&lt;&lt;17)// class or superclass has default alloc/allocWithZone: implementation// Note this is is stored in the metaclass.#define RW_HAS_DEFAULT_AWZ (1&lt;&lt;16)// class's instances requires raw isa#if SUPPORT_NONPOINTER_ISA#define RW_REQUIRES_RAW_ISA (1&lt;&lt;15)#endif// class or superclass has default retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference#define RW_HAS_DEFAULT_RR (1&lt;&lt;14)// class is a Swift class from the pre-stable Swift ABI#define FAST_IS_SWIFT_LEGACY (1UL&lt;&lt;0)// class is a Swift class from the stable Swift ABI#define FAST_IS_SWIFT_STABLE (1UL&lt;&lt;1)// data pointer#define FAST_DATA_MASK 0xfffffffcUL#elif 1// Leaks-compatible version that steals low bits only.// class or superclass has .cxx_construct implementation#define RW_HAS_CXX_CTOR (1&lt;&lt;18)// class or superclass has .cxx_destruct implementation#define RW_HAS_CXX_DTOR (1&lt;&lt;17)// class or superclass has default alloc/allocWithZone: implementation// Note this is is stored in the metaclass.#define RW_HAS_DEFAULT_AWZ (1&lt;&lt;16)// class's instances requires raw isa#define RW_REQUIRES_RAW_ISA (1&lt;&lt;15)// class is a Swift class from the pre-stable Swift ABI#define FAST_IS_SWIFT_LEGACY (1UL&lt;&lt;0)// class is a Swift class from the stable Swift ABI#define FAST_IS_SWIFT_STABLE (1UL&lt;&lt;1)// class or superclass has default retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference#define FAST_HAS_DEFAULT_RR (1UL&lt;&lt;2)// data pointer#define FAST_DATA_MASK 0x00007ffffffffff8UL#else// Leaks-incompatible version that steals lots of bits.// class is a Swift class from the pre-stable Swift ABI#define FAST_IS_SWIFT_LEGACY (1UL&lt;&lt;0)// class is a Swift class from the stable Swift ABI#define FAST_IS_SWIFT_STABLE (1UL&lt;&lt;1)// summary bit for fast alloc path: !hasCxxCtor and // !instancesRequireRawIsa and instanceSize fits into shiftedSize#define FAST_ALLOC (1UL&lt;&lt;2)// data pointer#define FAST_DATA_MASK 0x00007ffffffffff8UL// class or superclass has .cxx_construct implementation#define FAST_HAS_CXX_CTOR (1UL&lt;&lt;47)// class or superclass has default alloc/allocWithZone: implementation// Note this is is stored in the metaclass.#define FAST_HAS_DEFAULT_AWZ (1UL&lt;&lt;48)// class or superclass has default retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference#define FAST_HAS_DEFAULT_RR (1UL&lt;&lt;49)// class's instances requires raw isa// This bit is aligned with isa_t-&gt;hasCxxDtor to save an instruction.#define FAST_REQUIRES_RAW_ISA (1UL&lt;&lt;50)// class or superclass has .cxx_destruct implementation#define FAST_HAS_CXX_DTOR (1UL&lt;&lt;51)// instance size in units of 16 bytes// or 0 if the instance size is too big in this field// This field must be LAST#define FAST_SHIFTED_SIZE_SHIFT 52// FAST_ALLOC means// FAST_HAS_CXX_CTOR is set// FAST_REQUIRES_RAW_ISA is not set// FAST_SHIFTED_SIZE is not zero// FAST_ALLOC does NOT check FAST_HAS_DEFAULT_AWZ because that // bit is stored on the metaclass.#define FAST_ALLOC_MASK (FAST_HAS_CXX_CTOR | FAST_REQUIRES_RAW_ISA)#define FAST_ALLOC_VALUE (0)#endif 这里面除了 FAST_DATA_MASK 是用一段空间存储数据外，其他宏都是只用 1 bit 存储 bool 值。class_data_bits_t 提供了三个方法用于位操作：getBit, setBits 和 clearBits，对应到存储 bool 值的掩码也有封装函数，比如： 123456bool hasCxxCtor() &#123; return getBit(FAST_HAS_CXX_CTOR);&#125;void setHasCxxCtor() &#123; setBits(FAST_HAS_CXX_CTOR);&#125; objc_class结构体继承至 object_object， object_object定义如下： 12345678910111213struct objc_object &#123;private: isa_t isa;public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // getIsa() allows this to be a tagged pointer object Class getIsa(); /*...*/&#125; objc_object 结构体包含一个 isa 指针，类型为 isa_t 联合体。根据 isa 就可以顺藤摸瓜找到对象所属的类。 isa_t 类型的共用体（union），在objc-private.h 文件中定义如下： 123456789101112union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 其中 ISA_BITFIELD在 isa.h文件中定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#if SUPPORT_PACKED_ISA // extra_rc must be the MSB-most field (so it matches carry/overflow flags) // nonpointer must be the LSB (fixme or get rid of it) // shiftcls must occupy the same bits that a real class pointer would // bits + RC_ONE is equivalent to extra_rc + 1 // RC_HALF is the high bit of extra_rc (i.e. half of its range) // future expansion: // uintptr_t fast_rr : 1; // no r/r overrides // uintptr_t lock : 2; // lock for atomic property, @synch // uintptr_t extraBytes : 1; // allocated with extra bytes# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18)# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 8# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7)# else# error unknown architecture for packed isa# endif SUPPORT_PACKED_ISA 用于标记是否支持优化的 isa 指针，其字面含义意思是 isa 的内容不再是类的指针了，而是包含了更多信息，比如引用计数，析构状态，被其他 weak 变量引用情况。判断方法也是根据设备类型： 12345678// Define SUPPORT_PACKED_ISA=1 on platforms that store the class in the isa // field as a maskable pointer with other data around it.#if (!__LP64__ || TARGET_OS_WIN32 || \\ (TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_IOSMAC))# define SUPPORT_PACKED_ISA 0#else# define SUPPORT_PACKED_ISA 1#endif 综合看来目前只有 arm64 架构的设备支持，下面列出了 isa 指针中变量对应的含义： 变量名 含义 nonpointer 0 表示普通的 isa 指针，1 表示使用优化，存储引用计数 has_assoc 表示该对象是否包含 associated object，如果没有，则析构时会更快 has_cxx_dtor 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls 类的指针 magic 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。 weakly_referenced 表示该对象是否有过 weak 对象，如果没有，则析构时更快 deallocating 表示该对象是否正在析构 has_sidetable_rc 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_rc 存储引用计数值减一后的结果 在 64 位环境下，优化的 isa 指针并不是就一定会存储引用计数，毕竟用 19bit （iOS 系统）保存引用计数不一定够。需要注意的是这 19 位保存的是引用计数的值减一。has_sidetable_rc 的值如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中。SideTable 定义如下： 1234567struct SideTable &#123; spinlock_t slock;//保证原子操作的自选锁 RefcountMap refcnts;//引用计数表，保存引用计数的散列表 weak_table_t weak_table;//保存 weak 引用的全局散列表 /*...*/&#125;; SideTable 用于管理引用计数表和 weak 表，并使用 spinlock_lock 自旋锁来防止操作表结构时可能的竞态条件。它用一个 64*128 大小的 uint8_t 静态数组作为 buffer 来保存所有的 SideTable 实例。RefcountMap定义如下： 1typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap; DenseMap 类中包含好多映射实例到其引用计数的键值对，并支持用 DenseMapIterator 迭代器快速查找遍历这些键值对。键的类型为 DisguisedPtr&lt;objc_object&gt;，DisguisedPtr 类是对 objc_object * 指针及其一些操作进行的封装，目的就是为了让它给人看起来不会有内存泄露的样子，其内容可以理解为对象的内存地址；值的类型为 size_t，size_t 是为了方便系统之间的移植而定义的，在32位系统上定义为 unsigned int，在64位系统上定义为 unsigned long。其实这里保存的值也是等于引用计数减一。使用散列表保存引用计数的设计很好，即使出现故障导致对象的内存块损坏，只要引用计数表没有被破坏，依然可以顺藤摸瓜找到内存块的位置。 Tagged Pointerisa 这里还涉及到 Tagged Pointer 等概念。因为 isa_t 使用 union 实现，所以可能表示多种形态，既可以当成是指针，也可以存储标志位。 Tagged Pointer 是一种特殊标记的对象，Tagged Pointer 通过在其最后一个 bit 位设置为特殊标记位，并且把数据直接保存在指针本身中。Tagged Pointer 是一个”伪”对象，使用 Tagged Pointer 有 3 倍的访问速度提升，100 倍的创建、销毁速度提升。 Tips：Advances in Objective-C 在我们查看对象指针时，在 64 位系统中，我们会看到 16 进制地址如0x00000001003041e0，我们把它转换为二进制表示如下图 在 64 位系统中，我们有 64 位可以表示一个对象指针，但是我们通常没有真正使用到所有这些位。由于内存对齐要求的存在，低位始终为0，对象必须始终位于指针大小倍数的地址中。由于地址空间有限，所以高位也始终为0。所以实际上我们只在一个真正的对象指针中使用了中间的这些位，而不会用到用到2^64，这些高位和低位总是0。 苹果从这些始终为0的位中选择了低位并把它设置为1。以标识这不是一个真正的对象指针，然后就可以给其他位赋予一些其他的意义，苹果称这种指针为tagged pointer。 例如：NSNumber指针，苹果在其它位中塞入的是一个数值。（PS：这些值实际上是通过与进程启动时初始化的随机值相结合而被混淆的）。 在设置为 1 表示为 Tagged Pointer 对象之后，在最低位之后的 3 位，苹果给他赋予类型意义，由于只有 3 位，所以它可以表示 7 种数据类型 12345678OBJC_TAG_NSAtom = 0, OBJC_TAG_1 = 1, OBJC_TAG_NSString = 2, OBJC_TAG_NSNumber = 3, OBJC_TAG_NSIndexPath = 4, OBJC_TAG_NSManagedObjectID = 5, OBJC_TAG_NSDate = 6, OBJC_TAG_7 = 7 在剩余的字段中，我们可以赋予他所包含的数据。在 Intel 中，我们 Tagged Pointer 对象的表示如下： OBJC_TAG_7类型的 Tagged Pointer 是个例外，它可以将接下来后 8 位作为它的扩展类型字段，基于此我们可以多支持 256 中类型的 Tagged Pointer，如 UIColors 或 NSIndexSets 之类的对象。 对象如果支持使用 TaggedPointer，苹果会直接将其指针值作为引用计数返回。 获取引用计数在非 ARC 环境可以使用 retainCount 方法获取某个对象的引用计数，其会调用 objc_object 的 rootRetainCount() 方法： 123- (NSUInteger)retainCount &#123; return ((id)self)-&gt;rootRetainCount();&#125; 在 ARC 时代除了使用 Core Foundation 库的 CFGetRetainCount() 方法，也可以使用 Runtime 的 _objc_rootRetainCount(id obj) 方法来获取引用计数，此时需要引入 &lt;objc/runtime.h&gt; 头文件。这个函数也是调用 objc_object 的 rootRetainCount() 方法： 1234567891011121314151617181920212223242526272829inline uintptr_t objc_object::rootRetainCount()&#123; // 如果是 tagged pointer，直接返回 this if (isTaggedPointer()) return (uintptr_t)this; // sidetable加锁 sidetable_lock(); // 获取 isa isa_t bits = LoadExclusive(&amp;isa.bits); ClearExclusive(&amp;isa.bits); // 如果 isa 是 nonpointer if (bits.nonpointer) &#123; // 获取extra_rc中保存的引用计数并+1 uintptr_t rc = 1 + bits.extra_rc; // 如果sidetable中存储有对象的引用计数值 if (bits.has_sidetable_rc) &#123; // 获取sidetable中保存的引用计数值并和前面获取到的引用计数相加 rc += sidetable_getExtraRC_nolock(); &#125; // sidetable解锁 sidetable_unlock(); // 返回获取到的引用计数 return rc; &#125; // sidetable解锁 sidetable_unlock(); // 从sidetable中查找保存的对象引用计数值+1之后返回 return sidetable_retainCount();&#125; rootRetainCount() 方法对引用计数存储逻辑进行了判断， 如果是 tagged pointer，直接返回对象本身； isTaggedPointer()定义在 objc-object.h文件中，实现如下： 12345inline bool objc_object::isTaggedPointer() &#123; return _objc_isTaggedPointer(this);&#125; 方法只是调用了_objc_isTaggedPointer()方法，对对象指针进行位运算，获取标识位的值并返回。 12345static inline bool _objc_isTaggedPointer(const void * _Nullable ptr)&#123; return ((uintptr_t)ptr &amp; _OBJC_TAG_MASK) &#x3D;&#x3D; _OBJC_TAG_MASK;&#125; _OBJC_TAG_MASK定义如下： 1234567891011121314151617181920212223#if OBJC_MSB_TAGGED_POINTERS# define _OBJC_TAG_MASK (1UL&lt;&lt;63)# define _OBJC_TAG_INDEX_SHIFT 60# define _OBJC_TAG_SLOT_SHIFT 60# define _OBJC_TAG_PAYLOAD_LSHIFT 4# define _OBJC_TAG_PAYLOAD_RSHIFT 4# define _OBJC_TAG_EXT_MASK (0xfUL&lt;&lt;60)# define _OBJC_TAG_EXT_INDEX_SHIFT 52# define _OBJC_TAG_EXT_SLOT_SHIFT 52# define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 12# define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12#else# define _OBJC_TAG_MASK 1UL# define _OBJC_TAG_INDEX_SHIFT 1# define _OBJC_TAG_SLOT_SHIFT 0# define _OBJC_TAG_PAYLOAD_LSHIFT 0# define _OBJC_TAG_PAYLOAD_RSHIFT 4# define _OBJC_TAG_EXT_MASK 0xfUL# define _OBJC_TAG_EXT_INDEX_SHIFT 4# define _OBJC_TAG_EXT_SLOT_SHIFT 4# define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 0# define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12#endif 其中OBJC_MSB_TAGGED_POINTERS定义如下，根据设备类型不同，标识位的位置也会有所不同 1234567#if (TARGET_OS_OSX || TARGET_OS_IOSMAC) &amp;&amp; __x86_64__ // 64-bit Mac - tag bit is LSB# define OBJC_MSB_TAGGED_POINTERS 0#else // Everything else - tag bit is MSB# define OBJC_MSB_TAGGED_POINTERS 1#endif sidetable加锁； 调用 LoadExclusive，获取 isa； 123456static ALWAYS_INLINEuintptr_tLoadExclusive(uintptr_t *src)&#123; return __c11_atomic_load((_Atomic(uintptr_t) *)src, __ATOMIC_RELAXED);&#125; __c11_atomic_load() 函数是以原子方式加载并返回指向的原子变量的当前值obj。该操作是原子读取操作。 调用 ClearExclusive() 在独占访问结束时，清除cpu中本地处理器针对某块内存区域的独占访问标志（核中的某个状态寄存器），以防在未清除时的其他操作，对系统产生影响。对于是否同时清除全局的独占访问标志，需要在设计cpu时的架构师决定。ClearExclusive() 在只针对arm64架构生效，其它架构下为空实现。arm64架构下ClearExclusive() 在函数只是简单调用__builtin_arm_clrex()来实现实际功能； 12345678910111213141516171819202122#if __arm64__ &amp;&amp; !__arm64e__/*...*/static ALWAYS_INLINEvoidClearExclusive(uintptr_t *dst __unused)&#123; __builtin_arm_clrex();&#125;#else/*...*/static ALWAYS_INLINEvoidClearExclusive(uintptr_t *dst __unused)&#123;&#125;#endif 如果是 nonpointer isa，获取前文说的isa_t结构体的 extra_rc 中保存的引用计数并在此基础上 +1 ，这也就是为什么之前说引用计数存储的值为实际引用计数减一。然后判断如果has_sidetable_rc 的值为 1，即引用计数还有部分存储在side table。调用sidetable_getExtraRC_nolock() 12345678910111213size_t objc_object::sidetable_getExtraRC_nolock()&#123; assert(isa.nonpointer); // 查找到对象所在的SideTable SideTable&amp; table = SideTables()[this]; // 在SideTables的引用计数表（RefcountMap）中查找对象的应用计数值 RefcountMap::iterator it = table.refcnts.find(this); // 如果没有查找到，则返回0 if (it == table.refcnts.end()) return 0; // 否则对查找到的值进行向右移位操作获取保存的引用计数并返回 else return it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;&#125; 获取当前实例对应的 SideTable 对象，其 refcnts 属性就是存储引用计数的散列表，这里将其类型简写为 RefcountMap： 1typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap; 然后在引用计数表中用迭代器查找当前实例对应的键值对，获取引用计数值，并和之前获取的引用计数相加，然后返回； 需要注意的是为什么这里把键值对的值做了向右移位操作（it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT）: 12345678// The order of these bits is important.#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)#define SIDE_TABLE_DEALLOCATING (1UL&lt;&lt;1) // MSB-ward of weak bit#define SIDE_TABLE_RC_ONE (1UL&lt;&lt;2) // MSB-ward of deallocating bit#define SIDE_TABLE_RC_PINNED (1UL&lt;&lt;(WORD_BITS-1))#define SIDE_TABLE_RC_SHIFT 2#define SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1) 可以看出值的第一个 bit 表示该对象是否有过 weak 对象，如果没有，在析构释放内存时可以更快，原因请看后面对象销毁部分；第二个 bit 表示该对象是否正在析构。从第三个 bit 开始才是存储引用计数数值的地方。所以这里要做向右移两位的操作，而对引用计数的 +1 和 -1 可以使用 SIDE_TABLE_RC_ONE，还可以用 SIDE_TABLE_RC_PINNED 来判断是否引用计数值有可能溢出。 sidetable解锁； 调用 sidetable_retainCount() 方法： 123456789101112131415161718192021uintptr_tobjc_object::sidetable_retainCount()&#123; // 查找到对象所在的SideTable SideTable&amp; table = SideTables()[this]; // 设置的引用计数为1 size_t refcnt_result = 1; // sidetable加锁 table.lock(); // 在SideTables的引用计数表（RefcountMap）中查找对象的应用计数值 RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) &#123;// 如果查找到了 // this is valid for SIDE_TABLE_RC_PINNED too // 将查找到的值进行向右移位操作获取保存的引用计数并+1 refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; &#125; // sidetable解锁 table.unlock(); // 返回引用计数 return refcnt_result;&#125; 逻辑和前面sidetable_getExtraRC_nolock方法类似，获取当前实例对应的 SideTable 对象，其 refcnts 属性就是之前说的存储引用计数的散列表，然后在引用计数表中用迭代器查找当前实例对应的键值对，一样向右移位操作（it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT）获取引用计数值，+1然后返回。所以说引用计数表存储的值也为实际引用计数减一。 生成对象前文说到，生成对象对应的Objective-C方法为 alloc/new/copy/mutableCopy 等。下面我们逐个解析源码实现。 alloc在objc4-756.2源码中，新建一个target，在对象alloc的地方下一个端点，调用栈如下图： 通过调用栈发现，[Person alloc]首先会调用objc_alloc()。objc_alloc()实现如下： 123456// Calls [cls alloc].idobjc_alloc(Class cls)&#123; return callAlloc(cls, true/*checkNil*/, false/*allocWithZone*/);&#125; 该方法只是调用了callAlloc()，callAlloc()实现如下： 12345678910111213141516171819202122232425262728293031323334353637// Call [cls alloc] or [cls allocWithZone:nil], with appropriate // shortcutting optimizations.// 调用 [cls alloc] or [cls allocWithZone:nil] 会来到这个函数static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123; // 如果 (checkNil &amp;&amp; !cls)，直接返回 nil if (slowpath(checkNil &amp;&amp; !cls)) return nil;#if __OBJC2__ // 判断是否是 Objective-C 2.0 // 如果 cls 没有重写 alloc/allocWithZone: 方法 if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123; // No alloc/allocWithZone implementation. Go straight to the allocator. // fixme store hasCustomAWZ in the non-meta class and // add it to canAllocFast's summary // canAllocFast()函数返回false，所以只会执行else中的代码 if (fastpath(cls-&gt;canAllocFast())) &#123; // No ctors, raw isa, etc. Go straight to the metal. bool dtor = cls-&gt;hasCxxDtor(); id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize()); if (slowpath(!obj)) return callBadAllocHandler(cls); obj-&gt;initInstanceIsa(cls, dtor); return obj; &#125; else &#123; // Has ctor or raw isa or something. Use the slower path. id obj = class_createInstance(cls, 0); if (slowpath(!obj)) return callBadAllocHandler(cls); return obj; &#125; &#125;#endif // No shortcuts available. if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc];&#125; 该方法主要以下几步： 如果入参传入的checkNil为true，且class为nil，则直接return；这里牵扯到 fastpath &amp;&amp; slowpath 的概念。 fastpath &amp;&amp; slowpath 是定义在 objc-os.h中的两个宏： 12#define fastpath(x) (__builtin_expect(bool(x), 1))#define slowpath(x) (__builtin_expect(bool(x), 0)) fastpath 和 slowpath 其实就是为了告诉编译器，if 中的判断条件是大概率 ( fastpath ) 还是小概率 ( slowpath ) 事件，从而让编译器对代码进行优化。举个例子： 1234if (x) return 1;else return 39; 由于计算机并非一次只读取一条指令，而是读取多条指令，所以在读到 if 语句时也会把 return 1读取进来。如果 x 为 0，那么会重新读取 return 39，重读指令相对来说比较耗时。 如过 x 有非常大的概率是 0，那么 return 1这条指令每次不可避免的会被读取，并且实际上几乎没有机会执行， 造成了不必要的指令重读。当然，最简单的优化就是: 1234if (!x) return 39;else return 1; 然而对程序员来说，每次都做这样的判断非常不友好，而且容易出错。于是 GCC 提供了一个内置函数 __builtin_expect: 1long __builtin_expect (long EXP, long C) 它的返回值就是整个函数的返回值，参数 C 代表预计的值，表示程序员知道 EXP 的值很可能就是 C。比如上文中的例子可以这样写: 1234if (__builtin_expect(x, 0)) return 1;else return 39; 虽然写法逻辑不变，但是编译器会把汇编代码优化成 if(!x) 的形式。 因此，在苹果定义的两个宏中，fastpath(x)依然返回 x，只是告诉编译器 x 的值一般不为 0，从而编译器可以进行优化。同理，slowpath(x)表示 x 的值很可能为 0，希望编译器进行优化。 这里因为传入的 checkNil 为false，所以这一步忽略； 接着判断如果没有自己实现 alloc/allocWithZone:方法，接着判断是否 canAllocFast 然后执行相关的初始化方法; 判断有没有自己实现 alloc/allocWithZone: 方法，是通过调用类的结构体 objc_class 中的hasCustomAWZ() 方法判断的。 hasCustomAWZ()方法，定义在 objc-runtime-new.h文件的 objc_class 结构体中。 123bool hasCustomAWZ() &#123; return ! bits.hasDefaultAWZ();&#125; hasDefaultAWZ() 实现如下 : 123456789bool hasDefaultAWZ() &#123; return getBit(FAST_HAS_DEFAULT_AWZ);&#125;void setHasDefaultAWZ() &#123; setBits(FAST_HAS_DEFAULT_AWZ);&#125;void setHasCustomAWZ() &#123; clearBits(FAST_HAS_DEFAULT_AWZ);&#125; 其实是位运算获取 bits 中用来标识用户是否自己实现了 alloc/allocWithZone: 的标记位，该标记位保存在metaclass中。 由于类是有懒加载概念的，当第一次给该类发消息之前，类并没有被加载，因此，当类第一次调用 alloc，进入到 hasCustomAWZ时，并没有 DefaultAWZ，所以 hasCustomAWZ则为 true，因此会直接调用 [cls alloc]。 [cls alloc] 是通过消息机制触发，向对象发送消息的时候，会判断如果对象没有没有实例化则进行处理： 123456789101112131415161718192021222324252627IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = nil; bool triedResolver = NO; /*...*/ // 判断类是否已经Realized，如果没有，需要先Realized if (!cls-&gt;isRealized()) &#123; cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock); // runtimeLock may have been dropped but is now locked again &#125; // 判断如果入参传入的initialize为true，且类未实例化，需要先实例化 if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; cls = initializeAndLeaveLocked(cls, inst, runtimeLock); // runtimeLock may have been dropped but is now locked again // If sel == initialize, class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won't happen. 2778172 &#125;/*...*/&#125; 实例化之后，Person类的DefaultAWZ 为 true 。 alloc 在 NSObject.mm 文件中的定义如下： 123+ (id)alloc &#123; return _objc_rootAlloc(self);&#125; 方法只是调用了_objc_rootAlloc()方法： 1234567// Base class implementation of +alloc. cls is not nil.// Calls [cls allocWithZone:nil].id_objc_rootAlloc(Class cls)&#123; return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);&#125; _objc_rootAlloc()也只是做了转发，又一次调用callAlloc()，不过入参不同。此时 DefaultAWZ 为 true，那么 hasCustomAWZ 则为 false，因此(fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ()))判断为true。执行if 判断中的代码。首先会判断canAllocFast，相关源码如下： 1234567891011121314bool canAllocFast() &#123; assert(!isFuture()); return bits.canAllocFast();&#125;#if FAST_ALLOC bool canAllocFast() &#123; return bits &amp; FAST_ALLOC; &#125;#else bool canAllocFast() &#123; return false; &#125;#endif 参见前文中bits 在内存中每个位的含义定义，FAST_ALLOC 的定义是在最后一个 else 中，但前面是 #elif 1，这个条件是恒真的，因此永远不会走到最后一个 else，也就是说，FAST_ALLOC永远不会被赋值，所以canAllocFast 返回 false。因此 callAlloc 会进入上面 else 分之。执行 class_createInstance() 12345id class_createInstance(Class cls, size_t extraBytes)&#123; return _class_createInstanceFromZone(cls, extraBytes, nil);&#125; class_createInstance() 调用了 _class_createInstanceFromZone()来真正创建对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/************************************************************************ class_createInstance* fixme* Locking: none**********************************************************************/static __attribute__((always_inline)) id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil)&#123; // 如果入参 cls 为nil，直接返回nil if (!cls) return nil; // 校验对象是否已经Realized assert(cls-&gt;isRealized()); // Read class's info bits all at once for performance // 读取 class 中的bits信息中标识信息 bool hasCxxCtor = cls-&gt;hasCxxCtor(); bool hasCxxDtor = cls-&gt;hasCxxDtor(); bool fast = cls-&gt;canAllocNonpointer(); size_t size = cls-&gt;instanceSize(extraBytes); if (outAllocatedSize) *outAllocatedSize = size; id obj; if (!zone &amp;&amp; fast) &#123; obj = (id)calloc(1, size); if (!obj) return nil; obj-&gt;initInstanceIsa(cls, hasCxxDtor); &#125; else &#123; if (zone) &#123; obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size); &#125; else &#123; obj = (id)calloc(1, size); &#125; if (!obj) return nil; // Use raw pointer isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); &#125; if (cxxConstruct &amp;&amp; hasCxxCtor) &#123; obj = _objc_constructOrFree(obj, cls); &#125; return obj;&#125; 方法包含如下几步： 判断如果入参 cls 为nil，直接返回nil； 断言校验对象是否已经Realized realizeClass：在某个类初始化之前，objc_class-&gt;data() 返回的指针指向的其实是个 class_ro_t 结构体。等到 static Class realizeClass(Class cls) 静态方法在类第一次初始化时被调用，它会: 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针 初始化一个 class_rw_t 结构体 设置结构体 ro 的值以及 flag 最后设置正确的 data。 class_rw_t 的内容是可以在运行时被动态修改的，可以说运行时对类的拓展大都是存储在这里的，而 class_ro_t 存储的大多是类在编译时就已经确定的信息。 经过 realizeClass 函数处理的类才是『真正的』类，调用它时不能对类做写操作。 读取 class 中的bits信息中标识信息，此处hasCxxCtor = false, hasCxxDtor = false, fast = true； hasCxxCtor() 用于获取类或父类是否有c++ 构造函数，相关源码如下： 123456789101112131415161718192021bool hasCxxCtor() &#123; // addSubclass() propagates this flag from the superclass. assert(isRealized()); return bits.hasCxxCtor();&#125;#if FAST_HAS_CXX_CTOR bool hasCxxCtor() &#123; return getBit(FAST_HAS_CXX_CTOR); &#125; void setHasCxxCtor() &#123; setBits(FAST_HAS_CXX_CTOR); &#125;#else bool hasCxxCtor() &#123; return data()-&gt;flags &amp; RW_HAS_CXX_CTOR; &#125; void setHasCxxCtor() &#123; data()-&gt;setFlags(RW_HAS_CXX_CTOR); &#125;#endif hasCxxDtor()函数用于获取类或父类是否有c++ 析构函数，相关源码如下： 123456789101112131415161718192021bool hasCxxDtor() &#123; // addSubclass() propagates this flag from the superclass. assert(isRealized()); return bits.hasCxxDtor();&#125;#if FAST_HAS_CXX_DTOR bool hasCxxDtor() &#123; return getBit(FAST_HAS_CXX_DTOR); &#125; void setHasCxxDtor() &#123; setBits(FAST_HAS_CXX_DTOR); &#125;#else bool hasCxxDtor() &#123; return data()-&gt;flags &amp; RW_HAS_CXX_DTOR; &#125; void setHasCxxDtor() &#123; data()-&gt;setFlags(RW_HAS_CXX_DTOR); &#125;#endif canAllocNonpointer() 用于获取类的实例是否需要raw isa，相关源码如下： 12345678910111213141516171819202122232425262728293031bool canAllocNonpointer() &#123; assert(!isFuture()); return !instancesRequireRawIsa();&#125;bool instancesRequireRawIsa() &#123; return bits.instancesRequireRawIsa();&#125;#if FAST_REQUIRES_RAW_ISA bool instancesRequireRawIsa() &#123; return getBit(FAST_REQUIRES_RAW_ISA); &#125; void setInstancesRequireRawIsa() &#123; setBits(FAST_REQUIRES_RAW_ISA); &#125;#elif SUPPORT_NONPOINTER_ISA bool instancesRequireRawIsa() &#123; return data()-&gt;flags &amp; RW_REQUIRES_RAW_ISA; &#125; void setInstancesRequireRawIsa() &#123; data()-&gt;setFlags(RW_REQUIRES_RAW_ISA); &#125;#else bool instancesRequireRawIsa() &#123; return true; &#125; void setInstancesRequireRawIsa() &#123; // nothing &#125;#endif 其中 SUPPORT_NONPOINTER_ISA 宏定义和含义如下： 1234567891011121314151617181920212223242526// Define SUPPORT_INDEXED_ISA=1 on platforms that store the class in the isa // field as an index into a class table.// Note, keep this in sync with any .s files which also define it.// Be sure to edit objc-abi.h as well.#if __ARM_ARCH_7K__ &gt;= 2 || (__arm64__ &amp;&amp; !__LP64__)# define SUPPORT_INDEXED_ISA 1#else# define SUPPORT_INDEXED_ISA 0#endif// Define SUPPORT_PACKED_ISA=1 on platforms that store the class in the isa // field as a maskable pointer with other data around it.#if (!__LP64__ || TARGET_OS_WIN32 || \\ (TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_IOSMAC))# define SUPPORT_PACKED_ISA 0#else# define SUPPORT_PACKED_ISA 1#endif// Define SUPPORT_NONPOINTER_ISA=1 on any platform that may store something// in the isa field that is not a raw pointer.#if !SUPPORT_INDEXED_ISA &amp;&amp; !SUPPORT_PACKED_ISA# define SUPPORT_NONPOINTER_ISA 0#else# define SUPPORT_NONPOINTER_ISA 1#endif 如果是64位设备，canAllocNonpointer()函数返回值为true。 计算所需开辟内存空间，这里涉及到了经常被提及的 内存对齐； 一样通过源码来解读一下，objc_class 中有获取实例占用内存大小的函数 instanceSize 1234567891011size_t instanceSize(size_t extraBytes) &#123; size_t size = alignedInstanceSize() + extraBytes; // CF 要求 all objects 需要最少为 16 bytes. if (size &lt; 16) size = 16; return size;&#125;// Class's ivar size 四舍五入 to a pointer-size boundary.uint32_t alignedInstanceSize() &#123; return word_align(unalignedInstanceSize());&#125; 12345678910111213static inline uint32_t word_align(uint32_t x) &#123; return (x + WORD_MASK) &amp; ~WORD_MASK;&#125;#ifdef __LP64__# define WORD_SHIFT 3UL# define WORD_MASK 7UL# define WORD_BITS 64#else# define WORD_SHIFT 2UL# define WORD_MASK 3UL# define WORD_BITS 32#endif instanceSize传入参数 extraBytes为 0，从上面源码我们首先可以看到，属性64位下满足 8字节对齐，32位下满足 4字节对齐。 使用的是 (x + WORD_MASK) &amp; ~WORD_MASK ;。跟位运算左移三位右移三位是同样的效果，类结构体 RO中的信息在编译期就已经确定了 ( data()-&gt;ro-&gt;instanceSize，也就是 unalignedInstanceSize) 。 同时，满足最小 16字节 ( if (size &lt; 16) size = 16) 。 因为入参zone 为 nil，且如果是64位设备，fast为true，所以 if 判断为true； 执行如下代码块： 123456id obj;if (!zone &amp;&amp; fast) &#123; obj &#x3D; (id)calloc(1, size); if (!obj) return nil; obj-&gt;initInstanceIsa(cls, hasCxxDtor);&#125; 首先调用calloc() 函数在内存中分配1个长度为size的连续空间。calloc() 函数分配的对象内存是按 16 字节对齐标准的。 calloc() 开辟了内存空间后返回一个指向该内存地址的指针。如果内存分配不成功，则直接返回 nil。否则执行initInstanceIsa() 12345678inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)&#123; assert(!cls-&gt;instancesRequireRawIsa()); assert(hasCxxDtor &#x3D;&#x3D; cls-&gt;hasCxxDtor()); initIsa(cls, true, hasCxxDtor);&#125; 方法调用initIsa() 12345678910111213141516171819202122232425262728293031323334353637inline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) &#123; assert(!isTaggedPointer()); if (!nonpointer) &#123; isa.cls &#x3D; cls; &#125; else &#123; assert(!DisableNonpointerIsa); assert(!cls-&gt;instancesRequireRawIsa()); isa_t newisa(0);#if SUPPORT_INDEXED_ISA assert(cls-&gt;classArrayIndex() &gt; 0); newisa.bits &#x3D; ISA_INDEX_MAGIC_VALUE; &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor &#x3D; hasCxxDtor; newisa.indexcls &#x3D; (uintptr_t)cls-&gt;classArrayIndex();#else newisa.bits &#x3D; ISA_MAGIC_VALUE; &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor &#x3D; hasCxxDtor; newisa.shiftcls &#x3D; (uintptr_t)cls &gt;&gt; 3;#endif &#x2F;&#x2F; This write must be performed in a single store in some cases &#x2F;&#x2F; (for example when realizing a class because other threads &#x2F;&#x2F; may simultaneously try to use the class). &#x2F;&#x2F; fixme use atomics here to guarantee single-store and to &#x2F;&#x2F; guarantee memory order w.r.t. the class index table &#x2F;&#x2F; ...but not too atomic because we don&#39;t want to hurt instantiation isa &#x3D; newisa; &#125;&#125; 这里就是初始化 isa，并将 isa 的 bits 赋值为 ISA_MAGIC_VALUE。ISA_MAGIC_VALUE初始化了 isa 的 magic 和 nonpointer 字段，并绑定指向 cls：newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3。参考前面 ISA_BITFIELD介绍，前三位分别是nonpointer、has_assoc和has_cxx_dtor，各占一位。后面就是固定位数为shiftcls。在初始化 isa 的时候，并没有对extra_rc 进行操作。也就是说 alloc 方法实际上并没有设置对象的引用计数值为 1。 问题：1、从调用栈中可以看到 NSObject 是有 alloc 类方法的，那么我们外部所写的 [NSObject alloc] 为什么不调用 alloc 类方法 , 反而来到了 objc_alloc 中呢？对于OC运行时，入口方法如下 123456789101112131415161718192021/************************************************************************ _objc_init* Bootstrap initialization. Registers our image notifier with dyld.* Called by libSystem BEFORE library initialization time**********************************************************************/void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);&#125; 方法中调用的 map_images 会调用 map_images_nolock 方法： 1234567891011121314/************************************************************************ map_images* Process the given images which are being mapped in by dyld.* Calls ABI-agnostic code after taking ABI-specific locks.** Locking: write-locks runtimeLock**********************************************************************/voidmap_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[])&#123; mutex_locker_t lock(runtimeLock); return map_images_nolock(count, paths, mhdrs);&#125; map_images_nolock 方法会调用 _read_images 1234567891011121314151617181920212223242526272829/************************************************************************ map_images_nolock* Process the given images which are being mapped in by dyld.* All class registration and fixups are performed (or deferred pending* discovery of missing superclasses etc), and +load methods are called.** info[] is in bottom-up order i.e. libobjc will be earlier in the * array than any library that links to libobjc.** Locking: loadMethodLock(old) or runtimeLock(new) acquired by map_images.**********************************************************************/#if __OBJC2__#include \"objc-file.h\"#else#include \"objc-file-old.h\"#endifvoid map_images_nolock(unsigned mhCount, const char * const mhPaths[], const struct mach_header * const mhdrs[])&#123; /*...*/ if (hCount &gt; 0) &#123; _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses); &#125; firstTime = NO;&#125; _read_images 方法中会调用 123456789101112131415161718192021222324252627282930313233/************************************************************************ _read_images* Perform initial processing of the headers in the linked * list beginning with headerList. ** Called by: map_images_nolock** Locking: runtimeLock acquired by map_images**********************************************************************/void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)&#123;/*...*/#if SUPPORT_FIXUP // Fix up old objc_msgSend_fixup call sites for (EACH_HEADER) &#123; message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count); if (count == 0) continue; if (PrintVtables) &#123; _objc_inform(\"VTABLES: repairing %zu unsupported vtable dispatch \" \"call sites in %s\", count, hi-&gt;fname()); &#125; for (i = 0; i &lt; count; i++) &#123; fixupMessageRef(refs+i); &#125; &#125; ts.log(\"IMAGE TIMES: fix up objc_msgSend_fixup\");#endif /*...*/&#125; fixupMessageRef 方法中 alloc 对应符号会被设置为 objc_alloc 123456789101112131415161718192021222324252627282930/************************************************************************ fixupMessageRef* Repairs an old vtable dispatch call site. * vtable dispatch itself is not supported.**********************************************************************/static void fixupMessageRef(message_ref_t *msg)&#123; msg-&gt;sel = sel_registerName((const char *)msg-&gt;sel); if (msg-&gt;imp == &amp;objc_msgSend_fixup) &#123; if (msg-&gt;sel == SEL_alloc) &#123; msg-&gt;imp = (IMP)&amp;objc_alloc; &#125; else if (msg-&gt;sel == SEL_allocWithZone) &#123; msg-&gt;imp = (IMP)&amp;objc_allocWithZone; &#125; else if (msg-&gt;sel == SEL_retain) &#123; msg-&gt;imp = (IMP)&amp;objc_retain; &#125; else if (msg-&gt;sel == SEL_release) &#123; msg-&gt;imp = (IMP)&amp;objc_release; &#125; else if (msg-&gt;sel == SEL_autorelease) &#123; msg-&gt;imp = (IMP)&amp;objc_autorelease; &#125; else &#123; msg-&gt;imp = &amp;objc_msgSend_fixedup; &#125; &#125; /*...*/&#125;// SUPPORT_FIXUP#endif 2、为什么 alloc 没有设置引用计数值为 1呢？前文说到，引用计数存储的值为实际引用计数减一，在获取对象的引用计数时，会对存储的值进行+1操作，因此这里就不需要设置引用计数值为 1。 initalloc 执行完之后，则会调用 init 方法： 12345678910111213141516// Replaced by CF (throws an NSException)+ (id)init &#123; return (id)self;&#125;- (id)init &#123; return _objc_rootInit(self);&#125;id_objc_rootInit(id obj)&#123; // In practice, it will be hard to rely on this function. // Many classes do not properly chain -init calls. return obj;&#125; init 默认返回方法调用者。这个设计其实是为了方便工程设计，以便于在初始化对象时做一些初始化或者赋值操作。 new123+ (id)new &#123; return [callAlloc(self, false/*checkNil*/) init];&#125; new相当于 alloc + init。但是使用 new 并不能调用我们所重写的各种 init工厂方法 。 copy 和 mutableCopy1234567- (id)copy &#123; return [(id)self copyWithZone:nil];&#125;- (id)mutableCopy &#123; return [(id)self mutableCopyWithZone:nil];&#125; copy 和 mutableCopy 都是基于 NSCopying 和 NSMutableCopying 方法约定，分别调用各类自己实现的 copyWithZone: 和 mutableCopyWithZone: 方法。这些方法无论实现方式是深拷贝还是浅拷贝，都会增加引用计数。（有些类的策略是懒拷贝，只增加引用计数但并不真的拷贝，等对象内容发生变化时再拷贝一份出来，比如 NSArray）。 持有对象在非 ARC 环境下可以使用 retain 方法对引用计数进行+1操作。上文中提到，runtime 初始化的时候，会进行符号绑定。 retain 对应符号会被设置为 objc_retain 。所以我们从objc_retain 方法开始探究： 123456789101112131415161718192021222324252627/************************************************************************ Optimized retain/release/autorelease entrypoints**********************************************************************/#if __OBJC2____attribute__((aligned(16)))id objc_retain(id obj)&#123; if (!obj) return obj; if (obj-&gt;isTaggedPointer()) return obj; return obj-&gt;retain();&#125;/*...*/// OBJC2#else// not OBJC2id objc_retain(id obj) &#123; return [obj retain]; &#125;/*...*/#endif 如果是__OBJC2__，则调用objc_object::retain函数；否则调用retain方法。objc_object::retain函数实现如下： 1234567891011// Equivalent to calling [this retain], with shortcuts if there is no overrideinline id objc_object::retain()&#123; assert(!isTaggedPointer()); if (fastpath(!ISA()-&gt;hasCustomRR())) &#123; return rootRetain(); &#125; return ((id(*)(objc_object *, SEL))objc_msgSend)(this, SEL_retain);&#125; 如果以下内存管理方法：retain/release/autorelease/retainCount/_tryRetain/_isdealocation /retainWeakReference/allowsWeakReference 没有被重写，直接调用 objc_object::rootRetain，这是快捷方式；否则调用 retain 方法。 retain 方法实现如下 12345678+ (id)retain &#123; return (id)self;&#125;// Replaced by ObjectAlloc- (id)retain &#123; return ((id)self)-&gt;rootRetain();&#125; 如果是类对象，则直接返回自身，否则调用 rootRetain() 12345ALWAYS_INLINE id objc_object::rootRetain()&#123; return rootRetain(false, false);&#125; 方法只是做了转发，实际负责修改引用计数的是objc_object::rootRetain() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465ALWAYS_INLINE id objc_object::rootRetain(bool tryRetain, bool handleOverflow)&#123; // 如果是 tagged pointer，直接返回 this if (isTaggedPointer()) return (id)this; bool sideTableLocked = false; bool transcribeToSideTable = false; // 是否需要将部分引用计数迁移到 sideTable 中 isa_t oldisa; isa_t newisa; do &#123; transcribeToSideTable = false; // 获取 isa oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; // 如果不是 nonpointer isa if (slowpath(!newisa.nonpointer)) &#123; ClearExclusive(&amp;isa.bits); if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock(); // tryRetain == false，调用 sidetable_retain，获取 SideTable 的引用计数表中保存的对象引用计数值，并判断如果没有溢出，更新引用计数值为原来的值+1 if (tryRetain) return sidetable_tryRetain() ? (id)this : nil; else return sidetable_retain(); &#125; // don't check newisa.fast_rr; we already called any RR overrides if (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123; ClearExclusive(&amp;isa.bits); if (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock(); return nil; &#125; uintptr_t carry; // 用于判断 isa 的 extra_rc 是否溢出 // 将 `extra_rc` 中的引用计数值 +1 newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry); // extra_rc++ // 如果 extra_rc 溢出 if (slowpath(carry)) &#123; // newisa.extra_rc++ overflowed // 如果 handleOverflow == false，调用 rootRetain_overflow if (!handleOverflow) &#123; ClearExclusive(&amp;isa.bits); return rootRetain_overflow(tryRetain); &#125; // Leave half of the retain counts inline and // prepare to copy the other half to the side table. // 保留一半的引用计数在 extra_rc 中 // 准备把另一半引用计数存储到 Sidetable 中 if (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock(); sideTableLocked = true; transcribeToSideTable = true; // 设置 transcribeToSideTable 为 true newisa.extra_rc = RC_HALF; // 设置 extra_rc 的值为 RC_HALF # define RC_HALF (1ULL&lt;&lt;18) newisa.has_sidetable_rc = true; // 设置 has_sidetable_rc 为 true &#125; &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits))); // 更新 isa.bits 成功 // 如果需要将溢出的引用计数存储到 sidetable 中 if (slowpath(transcribeToSideTable)) &#123; // Copy the other half of the retain counts to the side table. // 将 `extra_rc` 中引用计数值的一半，迁移至 side table sidetable_addExtraRC_nolock(RC_HALF); &#125; if (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock(); return (id)this;&#125; 忽略部分细节和不会执行的代码，方法主要包含以下几步： 【第一步】校验如果是 tagged pointer，直接返回 this 【第二步】定义局部变量 【第三步】进入 do-while 循环 获取isa并保存在局部变量中 如果 isa 不是 nonpointer 判断如果入参 tryRetain 为false 且 sidetable上锁了，解锁sidetable； 执行 sidetable_retain()，获取 SideTable 的引用计数表中保存的对象引用计数值，并判断如果没有溢出，更新引用计数值为原来的值+1； 12345678910111213141516171819202122idobjc_object::sidetable_retain()&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.nonpointer);#endif // 根据对象查找到SideTable SideTable&amp; table = SideTables()[this]; // SideTable 上锁 table.lock(); // 获取 SideTable 的引用计数表中保存的对象引用计数值 size_t&amp; refcntStorage = table.refcnts[this]; // 如果获取到的对象引用计数值没有溢出 if (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123; // 更新对象引用计数表中对象的引用计数值为原来的值+1 refcntStorage += SIDE_TABLE_RC_ONE; &#125; // SideTable 上锁 table.unlock(); // 返回对象本身 return (id)this;&#125; 其中 SIDE_TABLE_RC_PINNED 和 SIDE_TABLE_RC_ONE定义如下： 123456789101112131415// The order of these bits is important.#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)#define SIDE_TABLE_DEALLOCATING (1UL&lt;&lt;1) // MSB-ward of weak bit#define SIDE_TABLE_RC_ONE (1UL&lt;&lt;2) // MSB-ward of deallocating bit#define SIDE_TABLE_RC_PINNED (1UL&lt;&lt;(WORD_BITS-1))#ifdef __LP64__# define WORD_SHIFT 3UL# define WORD_MASK 7UL# define WORD_BITS 64#else# define WORD_SHIFT 2UL# define WORD_MASK 3UL# define WORD_BITS 32#endif 如果 isa 是 nonpointer，就会调用 addc 将 extra_rc 中的引用计数值 +1 12345static ALWAYS_INLINE uintptr_t addc(uintptr_t lhs, uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout)&#123; return __builtin_addcl(lhs, rhs, carryin, carryout);&#125; 这个函数的作用就是增加引用计数。 判断如果 extra_rc 溢出 判断如果入参 handleOverflow 为false，就会调用rootRetain_overflow并返回； 12345NEVER_INLINE id objc_object::rootRetain_overflow(bool tryRetain)&#123; return rootRetain(tryRetain, true);&#125; 该函数又调用了 rootRetain，但参数 handleOverflow 传 true。 否则，将 extra_rc 中保存的引用计数值的一半迁移到 sideTable，并更新isa的 extra_rc 和 has_sidetable_rc 循环退出条件为 StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits) == true，即成功更新isa.bits 123456static ALWAYS_INLINEboolStoreExclusive(uintptr_t *dst, uintptr_t oldvalue, uintptr_t value)&#123; return __c11_atomic_compare_exchange_weak((_Atomic(uintptr_t) *)dst, &amp;oldvalue, value, __ATOMIC_RELAXED, __ATOMIC_RELAXED);&#125; __c11_atomic_compare_exchange_weak() 函数是将 dst 与 oldvalue进行原子比较，如果相等，则用value替换 dst（执行读取 - 修改 - 写入操作）。否则，将 dst 的值修改为 oldvalue（进行负载操作） 。返回值：true如果dst等于oldvalue，否则false； 【第四步】如果上一步循环中判断extra_rc中溢出了，则执行 sidetable_addExtraRC_nolock()将 extra_rc 中的引用计数值的一半，迁移至 side table 12345678910111213141516171819202122232425262728293031323334353637// Move some retain counts to the side table from the isa field.// Returns true if the object is now pinned.bool objc_object::sidetable_addExtraRC_nolock(size_t delta_rc)&#123; assert(isa.nonpointer); // 根据对象查找到SideTable SideTable&amp; table = SideTables()[this]; // 获取 SideTable 的引用计数表中保存的对象引用计数值 size_t&amp; refcntStorage = table.refcnts[this]; size_t oldRefcnt = refcntStorage; // isa-side bits should not be set here assert((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == 0); assert((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == 0); // 如果获取到的对象引用计数值溢出了，返回true if (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) return true; uintptr_t carry; // 调用 addc 将前面获取到的 SideTable 的引用计数表中保存的对象引用计数值加上 `extra_rc` 中的引用计数值的一半 size_t newRefcnt = addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, 0, &amp;carry); // 如果相加之后溢出了 if (carry) &#123; // 更新对象引用计数表中对象的引用计数值标记为溢出 refcntStorage = SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK); // 返回true return true; &#125; else &#123; // 更新对象引用计数表中对象的引用计数值相加之后的值 refcntStorage = newRefcnt; // 返回false return false; &#125;&#125; 如果 extra_rc 溢出了，就会调用 sidetable_addExtraRC_nolock 将 extra_rc 的一半引用计数转移到 sidetable 中存储，也是调用 addc 对 refcnt 引用计数表进行引用计数增加操作，进行相应容错处理后，更新引用计数表中的引用计数值。 释放对象当我们在不需要使用（持有）对象的时候，需要调用一下release方法进行释放。release方法会将对象的引用计数 -1。同样的，由于runtime 初始化的时候，会进行符号绑定。 release 对应符号会被设置为 objc_release 。所以我们从 objc_release 方法开始探究： 1234567891011121314151617181920212223242526272829/************************************************************************ Optimized retain/release/autorelease entrypoints**********************************************************************/#if __OBJC2__/*...*/__attribute__((aligned(16)))void objc_release(id obj)&#123; if (!obj) return; if (obj-&gt;isTaggedPointer()) return; return obj-&gt;release();&#125;/*...*/// OBJC2#else// not OBJC2/*...*/void objc_release(id obj) &#123; [obj release]; &#125;/*...*/#endif 如果是 __OBJC2__，则调用 objc_object::release 函数；否则调用 release 方法。 12345678910111213// Equivalent to calling [this release], with shortcuts if there is no overrideinline voidobjc_object::release()&#123; assert(!isTaggedPointer()); if (fastpath(!ISA()-&gt;hasCustomRR())) &#123; rootRelease(); return; &#125; ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_release);&#125; 如果以下内存管理方法：retain/release/autorelease/retainCount/_tryRetain/_isdealocation /retainWeakReference/allowsWeakReference 没有被重写，直接调用objc_object::rootRelease；否则调用release方法。release方法实现如下： 1234567+ (oneway void)release &#123;&#125;&#x2F;&#x2F; Replaced by ObjectAlloc- (oneway void)release &#123; ((id)self)-&gt;rootRelease();&#125; 如果是实例对象调用 objc_object::rootRelease() 123456789101112131415// Base release implementation, ignoring overrides.// Does not call -dealloc.// Returns true if the object should now be deallocated.// This does not check isa.fast_rr; if there is an RR override then // it was already called and it chose to call [super release].// // handleUnderflow=false is the frameless fast path.// handleUnderflow=true is the framed slow path including side table borrow// The code is structured this way to prevent duplication.ALWAYS_INLINE bool objc_object::rootRelease()&#123; return rootRelease(true, false);&#125; 方法只是做了转发，实际负责修改引用计数的是objc_object::rootRelease()，该方法实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147ALWAYS_INLINE bool objc_object::rootRelease(bool performDealloc, bool handleUnderflow)&#123; // 如果是 tagged pointer，直接返回 false if (isTaggedPointer()) return false; bool sideTableLocked = false; isa_t oldisa; isa_t newisa; retry: do &#123; // 获取 isa oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; // 如果不是 nonpointer isa if (slowpath(!newisa.nonpointer)) &#123; ClearExclusive(&amp;isa.bits); if (sideTableLocked) sidetable_unlock(); // 调用 sidetable_release return sidetable_release(performDealloc); &#125; // don't check newisa.fast_rr; we already called any RR overrides uintptr_t carry; newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry); // extra_rc-- // 如果发现 extra_rc 中的引用计数已经为 0 了 if (slowpath(carry)) &#123; // don't ClearExclusive() // 跳转到 underflow goto underflow; &#125; &#125; while (slowpath(!StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits))); // 保存更新后的 isa.bits if (slowpath(sideTableLocked)) sidetable_unlock(); return false; underflow: // newisa.extra_rc-- underflowed: borrow from side table or deallocate // abandon newisa to undo the decrement // 如果引用计数为0，丢弃对extra_rc--操作 newisa = oldisa; // 如果 isa 的 has_sidetable_rc 字段值为 1 if (slowpath(newisa.has_sidetable_rc)) &#123; // 如果 handleUnderflow == false，调用 rootRelease_underflow if (!handleUnderflow) &#123; ClearExclusive(&amp;isa.bits); return rootRelease_underflow(performDealloc); &#125; // Transfer retain count from side table to inline storage. // 将引用计数从 sidetable 中转到 extra_rc 中存储 if (!sideTableLocked) &#123; ClearExclusive(&amp;isa.bits); sidetable_lock(); sideTableLocked = true; // Need to start over to avoid a race against // the nonpointer -&gt; raw pointer transition. goto retry; &#125; // Try to remove some retain counts from the side table. // 尝试从 sidetable 中删除（借出）一些引用计数，传入 RC_HALF // borrowed 为 sidetable 实际删除（借出）的引用计数 size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF); // To avoid races, has_sidetable_rc must remain set // even if the side table count is now zero. // 为了避免竞争，has_sidetable_rc 必须保持设置 // 即使 sidetable 中的引用计数现在是 0 if (borrowed &gt; 0) &#123; // Side table retain count decreased. // Try to add them to the inline count. // 将它进行 -1，赋值给 extra_rc newisa.extra_rc = borrowed - 1; // redo the original decrement too // 存储更改后的 isa.bits bool stored = StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits); // 如果存储失败，立刻重试一次 if (!stored) &#123; // Inline update failed. // Try it again right now. This prevents livelock on LL/SC // architectures where the side table access itself may have // dropped the reservation. isa_t oldisa2 = LoadExclusive(&amp;isa.bits); isa_t newisa2 = oldisa2; if (newisa2.nonpointer) &#123; uintptr_t overflow; newisa2.bits = addc(newisa2.bits, RC_ONE * (borrowed-1), 0, &amp;overflow); if (!overflow) &#123; stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, newisa2.bits); &#125; &#125; &#125; // 如果还是存储失败，把引用计数再重新保存到 sidetable 中 if (!stored) &#123; // Inline update failed. // Put the retains back in the side table. sidetable_addExtraRC_nolock(borrowed); goto retry; &#125; // Decrement successful after borrowing from side table. // This decrement cannot be the deallocating decrement - the side // table lock and has_sidetable_rc bit ensure that if everyone // else tried to -release while we worked, the last one would block. sidetable_unlock(); return false; &#125; else &#123; // Side table is empty after all. Fall-through to the dealloc path. &#125; &#125; // 如果引用计数为 0，dealloc 对象 // Really deallocate. // 如果当前 newisa 处于 deallocating 状态，保证对象只会 dealloc 一次 if (slowpath(newisa.deallocating)) &#123; ClearExclusive(&amp;isa.bits); if (sideTableLocked) sidetable_unlock(); // 调用 overrelease_error return overrelease_error(); // does not actually return &#125; // 设置 newisa 为 deallocating 状态 newisa.deallocating = true; // 如果存储失败，继续重试 if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry; if (slowpath(sideTableLocked)) sidetable_unlock(); __sync_synchronize(); // 如果 performDealloc == true，给对象发送一条 dealloc 消息 if (performDealloc) &#123; ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc); &#125; return true;&#125; 忽略部分细节和不会执行的代码，方法主要包含以下几步： 【第一步】校验如果是 tagged pointer，直接返回 false 【第二步】定义局部变量 【第三步】进入 do-while 循环 获取isa并保存在局部变量中 如果不是 nonpointer isa 判断如果sidetable上锁了，则进行解锁； 执行 sidetable_retain()，找到对象所在的引用计数表，并将引用计数 -1； 12345678910111213141516171819202122232425262728293031323334353637383940414243// rdar://20206767// return uintptr_t instead of bool so that the various raw-isa // -release paths all return zero in eaxuintptr_tobjc_object::sidetable_release(bool performDealloc)&#123;#if SUPPORT_NONPOINTER_ISA assert(!isa.nonpointer);#endif // 根据对象查找到所在的SideTable SideTable&amp; table = SideTables()[this]; // 标识是否需要销毁对象 bool do_dealloc = false; // SideTable 上锁 table.lock(); // 在SideTables的引用计数表（RefcountMap）中查找对象的应用计数 RefcountMap::iterator it = table.refcnts.find(this); if (it == table.refcnts.end()) &#123;// 如果没有查找到 // 标识对象需要销毁 do_dealloc = true; // 将正在销毁标识（1UL&lt;&lt;1）保存为对象在引用计数表中的引用计数值 table.refcnts[this] = SIDE_TABLE_DEALLOCATING; &#125; else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;// 如果查找到了，但是引用计数值为 0 // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it. // 标识对象需要销毁 do_dealloc = true; // 将对象标记正在销毁 it-&gt;second |= SIDE_TABLE_DEALLOCATING; &#125; else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;// 如果对象没有溢出 // 将引用计数值-1 it-&gt;second -= SIDE_TABLE_RC_ONE; &#125; // SideTable 解锁 table.unlock(); // 如果对象需要销毁 且 入参为true if (do_dealloc &amp;&amp; performDealloc) &#123; // 发送dealloc消息，销毁对象 ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc); &#125; // 返回是否需要销毁对象标识 return do_dealloc;&#125; 方法会查找对象所在的SideTable并从引用计数表中查找对象的引用计数。如果引用计数表中没有查找到对象的引用计数（it == table.refcnts.end()），则标记对象为正在销毁；如果对象的引用计数值为 0（it-&gt;second &lt; SIDE_TABLE_DEALLOCATING），将对象标记为正在销毁（it-&gt;second |= SIDE_TABLE_DEALLOCATING）；否则就将引用计数减一（it-&gt;second -= SIDE_TABLE_RC_ONE）。 这也解释了为什么在存储引用计数时总是真正的引用计数值减一。因为 release 本来是要将引用计数-1，所以存储引用计数时先预留了-1，在-1之前会先判断引用计数值是否为 0 ，如果是，那就将对象标记为正在销毁，否则才进行-1，这样就避免了负数的产生。 针对nonpointer isa，执行 subc()，对extra_rc进行-1 12345static ALWAYS_INLINE uintptr_t subc(uintptr_t lhs, uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout)&#123; return __builtin_subcl(lhs, rhs, carryin, carryout);&#125; 判断如果此时 extra_rc 中存储的引用计数为0 a. 撤消 extra_rc-- 操作 b. 如果 SideTable 中存储有对象引用计数， 如果入参 handleUnderflow 为 false，调用 rootRelease_underflow() 并返回； 12345NEVER_INLINE bool objc_object::rootRelease_underflow(bool performDealloc)&#123; return rootRelease(performDealloc, true);&#125; 函数又调用了rootRelease，但参数handleUnderflow传true。 判断如果当前sideTable 不在加锁状态，为了保证线程安全，将sideTable 加锁，并跳转到【第三步】从头开始执行； 调用 sidetable_subExtraRC_nolock() 将 sidetable 中存储的一些引用计数值转移到isa中 1234567891011121314151617181920212223242526272829// Move some retain counts from the side table to the isa field.// Returns the actual count subtracted, which may be less than the request.size_t objc_object::sidetable_subExtraRC_nolock(size_t delta_rc)&#123; assert(isa.nonpointer); // 根据对象查找到SideTable SideTable&amp; table = SideTables()[this]; RefcountMap::iterator it = table.refcnts.find(this); // 如果引用计数表中没有查找到对象的引用计数值或者查找到的引用计数值为0，直接返回0 if (it == table.refcnts.end() || it-&gt;second == 0) &#123; // Side table retain count is zero. Can't borrow. return 0; &#125; // 取出引用计数表中查找到的引用计数值 size_t oldRefcnt = it-&gt;second; // isa-side bits should not be set here assert((oldRefcnt &amp; SIDE_TABLE_DEALLOCATING) == 0); assert((oldRefcnt &amp; SIDE_TABLE_WEAKLY_REFERENCED) == 0); // 将对象的引用计数值减去入参传入的要迁移的值 size_t newRefcnt = oldRefcnt - (delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT); assert(oldRefcnt &gt; newRefcnt); // shouldn't underflow // 更新引用计数表中对象的引用计数值为新值 it-&gt;second = newRefcnt; // 返回入参 return delta_rc;&#125; 函数会查询 SideTables 中对象的引用计数，如果引用计数表中没有查找到该对象会查找到的引用计数为0，则直接返回0；否则，将查找到的引用计数值减去对入参进行向右移位操作（it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT）获取到的引用计数值，获取到新的引用计数值，校验之后用新的引用计数值更新引用计数表中对象的引用计数并返回。 如果实际迁移的值大于0 1）将迁移值减一之后存入isa bits的 extra_rc中。 2）然后调用 StoreReleaseExclusive() 存储更改后的 isa.bits 123456static ALWAYS_INLINEboolStoreReleaseExclusive(uintptr_t *dst, uintptr_t oldvalue, uintptr_t value)&#123; return __c11_atomic_compare_exchange_weak((_Atomic(uintptr_t) *)dst, &amp;oldvalue, value, __ATOMIC_RELEASE, __ATOMIC_RELAXED);&#125; 函数和前文中 retain 一样调用 __c11_atomic_compare_exchange_weak() 。 3）如果存储不成功，立即重试更新：重新获取isa，判断如果是 nonpointer isa，调用 addc 将 extra_rc 中的引用计数加上迁移的值减一，然后判断如果 extra_rc 没有溢出，则调用 StoreReleaseExclusive() 存储更改后的 isa.bits 如果还是没有保存成功，则执行 sidetable_addExtraRC_nolock()将迁移的引用计数值，重新存储在引用计数表中，并跳转到【第三步】从头开始执行 SideTable 解锁，并返回false 判断如果对象正在销毁，SideTable如果正在上锁状态则解锁，然后执行 overrelease_error() 12345678NEVER_INLINEbool objc_object::overrelease_error()&#123; _objc_inform_now_and_on_crash(\"%s object %p overreleased while already deallocating; break on objc_overrelease_during_dealloc_error to debug\", object_getClassName((id)this), this); objc_overrelease_during_dealloc_error(); return false; // allow rootRelease() to tail-call this&#125; 如果当前对象处于deallocating状态，再次release就会执行overrelease_error，该函数就是用来在过度调用release的时候报错用的。其中 objc_overrelease_during_dealloc_error()实现如下： 123BREAKPOINT_FUNCTION( void objc_overrelease_during_dealloc_error(void)); 将对象标记为“正在析构” 如果调用 StoreExclusive() 存储更改后的 isa.bits 失败。跳转到【第三步】从头开始执行 SideTable如果正在上锁状态则解锁 调用 __sync_synchronize() 设置内存屏障 调用 dealloc方法销毁对象 返回 true 循环退出条件为 StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits) == true，即更新 isa.bit 成功则退出循环； SideTable如果正在上锁状态则解锁 返回 false 销毁对象在 release 相关逻辑里，如果对象的引用计数为 0，则标记为正在销毁，并调用 dealloc 方法，销毁对象。 dealloc 方法实现如下： 1234// Replaced by NSZombies- (void)dealloc &#123; _objc_rootDealloc(self);&#125; _objc_rootDealloc 函数实现如下： 1234567void_objc_rootDealloc(id obj)&#123; assert(obj); obj-&gt;rootDealloc();&#125; _objc_rootDealloc 函数除了断言外，也只是调用了rootDealloc 12345678910111213141516171819202122inline voidobjc_object::rootDealloc()&#123; // 判断如果是 tagged pointer，直接返回 if (isTaggedPointer()) return; // fixme necessary? if (fastpath(isa.nonpointer &amp;&amp; // 如果是 nonpointer isa !isa.weakly_referenced &amp;&amp; // 没有被弱引用指向过 !isa.has_assoc &amp;&amp; // 对象没有关联对象 !isa.has_cxx_dtor &amp;&amp; // 没有 C++ 的析构函数 !isa.has_sidetable_rc)) // 没有额外采用 SideTabel 进行引用计数存储 &#123; // 断言校验对象不在 side table（应用计数表 和 弱引用表）中 assert(!sidetable_present()); // 释放对象内存空间 free(this); &#125; else &#123; // 析构对象并释放对象内存空间 object_dispose((id)this); &#125;&#125; 方法逻辑如下： 【第一步】判断如果是 tagged pointer，直接返回； 【第二步】判断如果满足如下条件：是nonpointer isa 且 没有被弱引用指向过 且 对象没有关联对象 且 对象没有 C++ 或 ARC 的析构函数 且 对象的引用计数值有在side table存储 调用 sidetable_present 断言校验对象不在 side table（应用计数表 和 弱引用表）中 1234567891011121314151617181920#if DEBUG// Used to assert that an object is not present in the side table.boolobjc_object::sidetable_present()&#123; bool result = false; SideTable&amp; table = SideTables()[this]; table.lock(); RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) result = true; if (weak_is_registered_no_lock(&amp;table.weak_table, (id)this)) result = true; table.unlock(); return result;&#125;#endif 仅在 DEBUG 有效 调用 free 释放对象内存空间 【第三步】如果【第二步】判断条件没有满足，调用 object_dispose 123456789101112131415/************************************************************************ object_dispose* fixme* Locking: none**********************************************************************/id object_dispose(id obj)&#123; if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;&#125; 函数首先判断如果对象已经不存在了，直接返回nil，否则调用 objc_destructInstance 析构对象，然后调用 free 释放对象并返回nil，objc_destructInstance 实现如下： 1234567891011121314151617181920212223/************************************************************************ objc_destructInstance* Destroys an instance without freeing memory. * Calls C++ destructors.* Calls ARC ivar cleanup.* Removes associative references.* Returns `obj`. Does nothing if `obj` is nil.**********************************************************************/void *objc_destructInstance(id obj) &#123; if (obj) &#123; // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); // This order is important. if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); obj-&gt;clearDeallocating(); &#125; return obj;&#125; 如果对象存在，则判断对象是否有 C++ 析构函数，如果有则调用 object_cxxDestruct 从对象继承树中查找C++ 析构函数并调用，相关源代码如下： 1234567891011/************************************************************************ object_cxxDestruct.* Call C++ destructors on obj, if any.* Uses methodListLock and cacheUpdateLock. The caller must hold neither.**********************************************************************/void object_cxxDestruct(id obj)&#123; if (!obj) return; if (obj-&gt;isTaggedPointer()) return; object_cxxDestructFromClass(obj, obj-&gt;ISA());&#125; 1234567891011121314151617181920212223242526/************************************************************************ object_cxxDestructFromClass.* Call C++ destructors on obj, starting with cls's * dtor method (if any) followed by superclasses' dtors (if any), * stopping at cls's dtor (if any).* Uses methodListLock and cacheUpdateLock. The caller must hold neither.**********************************************************************/static void object_cxxDestructFromClass(id obj, Class cls)&#123; void (*dtor)(id); // Call cls's dtor first, then superclasses's dtors. for ( ; cls; cls = cls-&gt;superclass) &#123; if (!cls-&gt;hasCxxDtor()) return; dtor = (void(*)(id)) lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct); if (dtor != (void(*)(id))_objc_msgForward_impcache) &#123; if (PrintCxxCtors) &#123; _objc_inform(\"CXX: calling C++ destructors for class %s\", cls-&gt;nameForLogging()); &#125; (*dtor)(obj); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334/************************************************************************ lookupMethodInClassAndLoadCache.* Like _class_lookupMethodAndLoadCache, but does not search superclasses.* Caches and returns objc_msgForward if the method is not found in the class.**********************************************************************/IMP lookupMethodInClassAndLoadCache(Class cls, SEL sel)&#123; Method meth; IMP imp; // fixme this is incomplete - no resolver, +initialize - // but it's only used for .cxx_construct/destruct so we don't care assert(sel == SEL_cxx_construct || sel == SEL_cxx_destruct); // Search cache first. imp = cache_getImp(cls, sel); if (imp) return imp; // Cache miss. Search method list. mutex_locker_t lock(runtimeLock); meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123; // Hit in method list. Cache it. cache_fill(cls, sel, meth-&gt;imp, nil); return meth-&gt;imp; &#125; else &#123; // Miss in method list. Cache objc_msgForward. cache_fill(cls, sel, _objc_msgForward_impcache, nil); return _objc_msgForward_impcache; &#125;&#125; 判断对象是否有管理对象，如果有则调用 _object_remove_assocations 函数，移除关联对象 调用 clearDeallocating 清理side table 中对象相关数据 1234567891011121314inline void objc_object::clearDeallocating()&#123; if (slowpath(!isa.nonpointer)) &#123; // Slow path for raw pointer isa. sidetable_clearDeallocating(); &#125; else if (slowpath(isa.weakly_referenced || isa.has_sidetable_rc)) &#123; // Slow path for non-pointer isa with weak refs and/or side table data. clearDeallocating_slow(); &#125; assert(!sidetable_present());&#125; 主要调用两个方法，针对不是 nonpointer 的 isa 调用 sidetable_clearDeallocating()，针对 nonpointer isa 判断如果有被弱引用指向过 或者 对象的引用计数值有在side table存储则调用 clearDeallocating_slow()，修改弱引用表 及 从引用计数表中清除对象相关数据。 sidetable_clearDeallocating() 函数实现如下： 123456789101112131415161718void objc_object::sidetable_clearDeallocating()&#123; SideTable&amp; table = SideTables()[this]; // clear any weak table items // clear extra retain count and deallocating bit // (fixme warn or abort if extra retain count == 0 ?) table.lock(); RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) &#123; if (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123; weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; table.refcnts.erase(it); &#125; table.unlock();&#125; clearDeallocating_slow() 函数实现如下： 12345678910111213141516171819// Slow path of clearDeallocating() // for objects with nonpointer isa// that were ever weakly referenced // or whose retain count ever overflowed to the side table.NEVER_INLINE voidobjc_object::clearDeallocating_slow()&#123; assert(isa.nonpointer &amp;&amp; (isa.weakly_referenced || isa.has_sidetable_rc)); SideTable&amp; table = SideTables()[this]; table.lock(); if (isa.weakly_referenced) &#123; weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; if (isa.has_sidetable_rc) &#123; table.refcnts.erase(this); &#125; table.unlock();&#125; autoreleasepool在前面内存管理策略部分有提到，通过alloc/new/copy/mutableCopy 等方法和以它们驼峰命名开头的方法会生成并持有对象。那么调用如 [NSMutableArray array] 等不以 alloc/new/copy/mutableCopy 开头的方法使取得的对象存在，但自己不持有对象，要怎么实现呢？这里就要引入另一个概念autoreleasepool。MRC 环境中，可以通过通过调用 autorelease 可以将对象注册到autoreleasepool中，使对象在超出指定的生存范围时能够自动并正确地释放。如下图所示加入autoreleasepool中的对象可以做到延迟释放： @autoreleasepool众所周知，iOS项目都是以main函数为入口。新建一个iOS项目，可以看到main.m文件中代码如下： 12345678#import &lt;UIKit&#x2F;UIKit.h&gt;#import &quot;AppDelegate.h&quot;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 可以看到函数中使用 @autoreleasepool 包裹了实现语句，那么@autoreleasepool 到底是什么？ 打开命令行，cd到工程目录，执行 clang -rewrite-objc main.m 让编译器重新改写main.m文件: 1clang -rewrite-objc main.m 如遇如下报错： 1234main.m:9:9: fatal error: &#39;UIKit&#x2F;UIKit.h&#39; file not found#import &lt;UIKit&#x2F;UIKit.h&gt; ^~~~~~~~~~~~~~~1 error generated. 可将上面的命令替换成如下命令： 1clang -x objective-c -rewrite-objc -isysroot &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneSimulator.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneSimulator.sdk main.m 就会在当前目录下生成一个 main.cpp 文件。在文件末尾可以看到函数变成了这样： 12345int main(int argc, char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AppDelegate\"), sel_registerName(\"class\")))); &#125;&#125; 原先的@autoreleasepool没有了，取而代之的是一个 __AtAutoreleasePool 结构体。前面的注释写到 /* @autoreleasepopl */。也就是说 @autoreleasepool {} 被转换为一个 __AtAutoreleasePool 结构体： 1__AtAutoreleasePool __autoreleasepool; 在 main.cpp 中查找 __AtAutoreleasePool 结构体定义如下： 12345struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; 这个结构体会在初始化时调用 objc_autoreleasePoolPush() 方法，会在析构时调用 objc_autoreleasePoolPop 方法。 因此 main 函数在实际工作时其实是这样的： 123456789int main(int argc, char * argv[]) &#123; &#123; void * atautoreleasepoolobj = objc_autoreleasePoolPush(); return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AppDelegate\"), sel_registerName(\"class\")))); objc_autoreleasePoolPop(atautoreleasepoolobj); &#125;&#125; objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 方法在 NSObject.mm 中定义如下： 1234567891011void *objc_autoreleasePoolPush(void)&#123; return AutoreleasePoolPage::push();&#125;voidobjc_autoreleasePoolPop(void *ctxt)&#123; AutoreleasePoolPage::pop(ctxt);&#125; 可以看到上述方法只是对 AutoreleasePoolPage 类对应静态方法 push 和 pop 的封装。 AutoreleasePoolPage AutoreleasePoolPage 类也定义在NSObject.mm中，包含如下成员变量： 123456789101112131415161718192021222324class AutoreleasePoolPage &#123; // EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is // pushed and it has never contained any objects. This saves memory // when the top level (i.e. libdispatch) pushes and pops pools but // never uses them./*...*/ static size_t const SIZE = #if PROTECT_AUTORELEASEPOOL PAGE_MAX_SIZE; // must be multiple of vm page size#else PAGE_MAX_SIZE; // size and alignment, power of 2#endif static size_t const COUNT = SIZE / sizeof(id); magic_t const magic;// 16字节 id *next;// 8字节 pthread_t const thread;// 8字节 AutoreleasePoolPage * const parent;// 8字节 AutoreleasePoolPage *child;// 8字节 uint32_t const depth;// 4字节 uint32_t hiwat;// 4字节 /*...*/&#125;; SIZE 表示每个page占用大小。相关宏定义如下： 123456// Set this to 1 to mprotect() autorelease pool contents#define PROTECT_AUTORELEASEPOOL 0#define PAGE_MAX_SIZE PAGE_SIZE#define PAGE_SIZE I386_PGBYTES#define I386_PGBYTES 4096 /* bytes per 80386 page */ 可知每个page占用 4096 字节。 类中包含的变量对应的含义如下： magic：magic 用于对当前 AutoreleasePoolPage 完整性的校验 thread：AutoreleasePool是按线程一一对应的，thread指针指向当前线程 parrent &amp; child：AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成的，parent指针和child指针分别指向上下节点 next：作为游标指向栈顶最新add进来的autorelease对象的下一个位置 depth：page的深度，首次为0，以后每次初始化一个page都加1，4字节 thread：用来计算pool中最多存放的对象个数 自动释放池中的栈如果我们的一个 AutoreleasePoolPage 被初始化在内存的 0x100816000 ~ 0x100817000 中，它在内存中的结构如下： 其中有 56 bit 用于存储 AutoreleasePoolPage 的成员变量，剩下的 0x100816038 ~ 0x100817000 都是用来存储加入到自动释放池中的对象。 begin() 和 end() 这两个类的实例方法帮助我们快速获取 0x100816038 ~ 0x100817000 这一范围的边界地址。 next 指向了下一个为空的内存地址，如果 next 指向的地址加入一个 object，它就会如下图所示移动到下一个为空的内存地址中： POOL_SENTINEL（哨兵对象）细心的朋友可能会发现栈里有个陌生的东西 POOL_SENTINEL ， POOL_SENTINEL 只是 nil 的别名。 1# define POOL_BOUNDARY nil Objective-C 在每个自动释放池初始化调用 objc_autoreleasePoolPush 的时候，都会把一个 POOL_SENTINEL push 到自动释放池的栈顶，并且返回这个 POOL_SENTINEL哨兵对象。 12345678910int main(int argc, const char * argv[]) &#123; &#123; void * atautoreleasepoolobj = objc_autoreleasePoolPush(); // do whatever you want objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; Objective-C 上面的 atautoreleasepoolobj 就是一个 POOL_SENTINEL。 而当方法 objc_autoreleasePoolPop 调用时，就会向自动释放池中的对象发送 release 消息，直到第一个 POOL_SENTINEL： AutoreleasePoolPage双向链表上面讲到的都是单个AutoreleasePoolPage。当对象比较多，一个AutoreleasePoolPage如果满了，会新建一个AutoreleasePoolPage对象，与原来页链表连接完成后，后来的autorelease对象在新的page加入。 AutoreleasePoolPage 是以双向链表的形式连接起来的： 介绍完 AutoreleasePoolPage 之后，我们接下来来看两个关键方法。 objc_autoreleasePoolPush 方法objc_autoreleasePoolPush() 方法前文中有提到，只是调用了 AutoreleasePoolPage 结构体的 push() 方法。该方法实现如下： 123456789101112static inline void *push() &#123; id *dest; if (DebugPoolAllocation) &#123; // Each autorelease pool starts on a new pool page. dest = autoreleaseNewPage(POOL_BOUNDARY); &#125; else &#123; dest = autoreleaseFast(POOL_BOUNDARY); &#125; assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY); return dest;&#125; 忽略debug相关代码，方法其实也只是调用了 autoreleaseFast 方法，并传入哨兵对象 POOL_SENTINEL： 1234567891011static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123; return autoreleaseNoPage(obj); &#125;&#125; 方法分以下几步： 一、调用 hotPage() 方法获取当前正在操作的页，hotPage() 方法实现及相关变量定义如下： 123456789101112# define EMPTY_POOL_PLACEHOLDER ((id*)1)static pthread_key_t const key = AUTORELEASE_POOL_KEY;static inline AutoreleasePoolPage *hotPage() &#123; AutoreleasePoolPage *result = (AutoreleasePoolPage *) tls_get_direct(key); if ((id *)result == EMPTY_POOL_PLACEHOLDER) return nil; if (result) result-&gt;fastcheck(); return result;&#125; 从线程局部存储（TLS）中根据key获取页对象，TLS 全称Thread Local Storage，是某个线程专有的存储内存空间，以key-value的形式进行读写。 判断获取到的页为占位对象返回nil 判断如果页存在，调用 fastcheck() 通过页的magic对完整性进行校验 返回获取到的页 二、如果成功获取到 AutoreleasePoolPage 且 页没有满，则调用 add 方法添加对象 123456789id *add(id obj)&#123; assert(!full()); unprotect(); id *ret = next; // faster than `return next-1` because of aliasing *next++ = obj; protect(); return ret;&#125; 这个方法其实就是一个压栈的操作，将对象加入 AutoreleasePoolPage 然后移动栈顶的指针。 三、判断如果成功获取到 AutoreleasePoolPage 但 页已满，则调用 autoreleaseFullPage()，从传入的 page 开始向后遍历整个双向链表查找未满的 AutoreleasePoolPage，如果没有查找到，创建一个新的 AutoreleasePoolPage 并将page连接到链表。最后将查找到或者新建的page设置为hotpage。 1234567891011121314151617181920212223static __attribute__((noinline)) id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)&#123; // The hot page is full. // Step to the next non-full page, adding a new page if necessary. // Then add the object to that page. assert(page == hotPage()); assert(page-&gt;full() || DebugPoolAllocation); do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page); &#125; while (page-&gt;full()); setHotPage(page); return page-&gt;add(obj);&#125;static inline void setHotPage(AutoreleasePoolPage *page) &#123; if (page) page-&gt;fastcheck(); tls_set_direct(key, (void *)page);&#125; 四、如果当前内存中不存在 hotPage，就会调用 autoreleaseNoPage 方法初始化一个 AutoreleasePoolPage 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162BREAKPOINT_FUNCTION(void objc_autoreleaseNoPool(id obj)); static inline bool haveEmptyPoolPlaceholder()&#123; id *tls = (id *)tls_get_direct(key); return (tls == EMPTY_POOL_PLACEHOLDER);&#125;static inline id* setEmptyPoolPlaceholder()&#123; assert(tls_get_direct(key) == nil); tls_set_direct(key, (void *)EMPTY_POOL_PLACEHOLDER); return EMPTY_POOL_PLACEHOLDER;&#125; static __attribute__((noinline))id *autoreleaseNoPage(id obj)&#123; // \"No page\" could mean no pool has been pushed // or an empty placeholder pool has been pushed and has no contents yet assert(!hotPage()); bool pushExtraBoundary = false; if (haveEmptyPoolPlaceholder()) &#123; // We are pushing a second pool over the empty placeholder pool // or pushing the first object into the empty placeholder pool. // Before doing that, push a pool boundary on behalf of the pool // that is currently represented by the empty placeholder. pushExtraBoundary = true; &#125; else if (obj != POOL_BOUNDARY &amp;&amp; DebugMissingPools) &#123; // We are pushing an object with no pool in place, // and no-pool debugging was requested by environment. _objc_inform(\"MISSING POOLS: (%p) Object %p of class %s \" \"autoreleased with no pool in place - \" \"just leaking - break on \" \"objc_autoreleaseNoPool() to debug\", pthread_self(), (void*)obj, object_getClassName(obj)); objc_autoreleaseNoPool(obj); return nil; &#125; else if (obj == POOL_BOUNDARY &amp;&amp; !DebugPoolAllocation) &#123; // We are pushing a pool with no pool in place, // and alloc-per-pool debugging was not requested. // Install and return the empty pool placeholder. return setEmptyPoolPlaceholder(); &#125; // We are pushing an object or a non-placeholder'd pool. // Install the first page. AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); // Push a boundary on behalf of the previously-placeholder'd pool. if (pushExtraBoundary) &#123; page-&gt;add(POOL_BOUNDARY); &#125; // Push the requested object or pool. return page-&gt;add(obj);&#125; 第一次调用这个方法时，haveEmptyPoolPlaceholder()返回的是false，会执行 setEmptyPoolPlaceholder。这个方法调用完之后，再次进入autoreleaseNoPage()时，就会进入第一个if判断中了。接着就会走到这个方法的最后那部分，从头开始构建这个自动释放池的双向链表。初始化之后，将当前页标记为 hotPage，然后会先向这个 page 中添加一个 POOL_SENTINEL 对象，来确保在 pop 调用的时候，不会出现异常。最后，将 obj 添加到自动释放池中。 objc_autoreleasePoolPop 方法和objc_autoreleasePoolPush() 一样，objc_autoreleasePoolPop也只是调用了 AutoreleasePoolPage 结构体的 pop() 方法。该方法实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static inline void pop(void *token) &#123; AutoreleasePoolPage *page; id *stop; // ********** part1 ********** if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123; // Popping the top-level placeholder pool. if (hotPage()) &#123; // Pool was used. Pop its contents normally. // Pool pages remain allocated for re-use as usual. pop(coldPage()-&gt;begin()); &#125; else &#123; // Pool was never used. Clear the placeholder. setHotPage(nil); &#125; return; &#125; page = pageForPointer(token); // ********** part2 ********** stop = (id *)token; if (*stop != POOL_BOUNDARY) &#123; if (stop == page-&gt;begin() &amp;&amp; !page-&gt;parent) &#123; // Start of coldest page may correctly not be POOL_BOUNDARY: // 1. top-level pool is popped, leaving the cold page in place // 2. an object is autoreleased with no pool &#125; else &#123; // Error. For bincompat purposes this is not // fatal in executables built with old SDKs. return badPop(token); &#125; &#125; // ********** part3 ********** if (PrintPoolHiwat) printHiwat(); page-&gt;releaseUntil(stop); // memory: delete empty children if (DebugPoolAllocation &amp;&amp; page-&gt;empty()) &#123; // special case: delete everything during page-per-pool debugging AutoreleasePoolPage *parent = page-&gt;parent; page-&gt;kill(); setHotPage(parent); &#125; else if (DebugMissingPools &amp;&amp; page-&gt;empty() &amp;&amp; !page-&gt;parent) &#123; // special case: delete everything for pop(top) // when debugging missing autorelease pools page-&gt;kill(); setHotPage(nil); &#125; else if (page-&gt;child) &#123; // hysteresis: keep one empty child if page is more than half full if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 方法大致可以分为如下3个部分： 判断token是否是EMPTY_POOL_PLACEHOLDER，这是autoreleasepool首次push的时候返回的，也就是最顶层的page调用pop会执行这一部分 在非ARC情况下，在新创建的子线程中不使用autoreleasepool，直接调用autorelease方法时会出现自动释放池page双向链表表头page栈最底部不是哨兵对象的情况，这里针对这种情况进行处理。 多数情况下，都会进入到这一部分。重点说一下这个部分: 第一步，调用 page = pageForPointer(token) 根据token获取 AutoreleasePoolPage 1234567891011121314151617static AutoreleasePoolPage *pageForPointer(const void *p) &#123; return pageForPointer((uintptr_t)p);&#125;static AutoreleasePoolPage *pageForPointer(uintptr_t p) &#123; AutoreleasePoolPage *result; uintptr_t offset = p % SIZE; assert(offset &gt;= sizeof(AutoreleasePoolPage)); result = (AutoreleasePoolPage *)(p - offset); result-&gt;fastcheck(); return result;&#125; 获取page的地址之后，接下来就调用 releaseUntil 方法来release对象，该方法实现如下： 1234567891011121314151617181920212223242526272829303132333435void releaseUntil(id *stop) &#123; // Not recursive: we don't want to blow out the stack // if a thread accumulates a stupendous amount of garbage while (this-&gt;next != stop) &#123; // Restart from hotPage() every time, in case -release // autoreleased more objects AutoreleasePoolPage *page = hotPage(); // fixme I think this `while` can be `if`, but I can't prove it while (page-&gt;empty()) &#123; page = page-&gt;parent; setHotPage(page); &#125; page-&gt;unprotect(); id obj = *--page-&gt;next; memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next)); page-&gt;protect(); if (obj != POOL_BOUNDARY) &#123; objc_release(obj); &#125; &#125; setHotPage(this);#if DEBUG // we expect any children to be completely empty for (AutoreleasePoolPage *page = child; page; page = page-&gt;child) &#123; assert(page-&gt;empty()); &#125;#endif&#125; 从next指针开始，一个一个向前调用release方法，直到碰到push时压入的token为止。 在释放完对象之后，接下来就是kill 空的 AutoreleasePoolPage 12345678if (page-&gt;child) &#123; if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125;&#125; 判断如果child page存在，调用 lessThanHalfFull() 方法 123bool lessThanHalfFull() &#123; return (next - begin() &lt; (end() - begin()) / 2);&#125; 判断当前page小于一半满，则调用 kill 方法将当前页的所有孩子都释放掉。 12345678910111213141516171819void kill() &#123; // Not recursive: we don't want to blow out the stack // if a thread accumulates a stupendous amount of garbage AutoreleasePoolPage *page = this; while (page-&gt;child) page = page-&gt;child; AutoreleasePoolPage *deathptr; do &#123; deathptr = page; page = page-&gt;parent; if (page) &#123; page-&gt;unprotect(); page-&gt;child = nil; page-&gt;protect(); &#125; delete deathptr; &#125; while (deathptr != this);&#125; 否则，留下一个child，从孙子page开始杀。正是因为这一步，在autoreleaseFullPage()方法中才会有如下步骤 1234do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page);&#125; while (page-&gt;full()); objc_autoreleaseReturnValue优化上文中提到，如 [NSMutableArray array] 等不以 alloc/new/copy/mutableCopy 开头的方法创建的对象。秉着谁创建谁释放的原则，返回值需要是一个autorelease对象才能配合调用方正确管理内存。比如如下一个工厂方法： 123456+ (instancetype)person &#123; return [[Person alloc] init];&#125;&#x2F;&#x2F; 调用Person *person &#x3D; [Person person]; 会被编译器改写成如下代码： 12345678910+ (instancetype)person &#123; id obj = objc_msgSend(Person, @selector(alloc)); objc_msgSend(obj, @selector(init)); return objc_autoreleaseReturnValue(obj);&#125;// 调用id obj = objc_msgSend(Person, @selector(person));objc_retainAutoreleasedReturnValue(obj);objc_release)(objc); objc_retainAutoreleasedReturnValue函数主要用于最优化程序运行。顾名思义，它是用于自己持有（retain）对象的函数，但它持有的对象应为返回注册在autoreleasepool中对象的方法，或是函数的返回值，在调用 alloc/new/copy/mutableCopy 以外的方法，有编译器插入该函数。 这种 objc_retainAutoreleasedReturnValue 函数是成对的，与之相对的函数是 objc_autoreleaseReturnValue。它用于 alloc/new/copy/mutableCopy 方法以外的，如 NSMutableArray 类的 array 类方法等返回对象的实现上。该方法会返回注册到autoreleasepool中的对象。但是 objc_autoreleaseReturnValue 函数同 objc_autorelease函数不同，一般不仅限于注册对象到 autoreleasepool中。 objc_autoreleaseReturnValue 函数会检查使用该函数的方法或函数调用方的执行命令列表，如果方法或函数的调用方在调用了方法或函数后紧接着调用 objc_retainAutoreleasedReturnValue() 函数，那么就不将返回的对象注册到 autoreleasepool中，而是直接传递到方法或函数的调用方。objc_retainAutoreleasedReturnValue 函数与 objc_retain 函数不同，它即便不注册到 autoreleasepool 而返回对象，也能够正确地获取对象。通过 objc_autoreleaseReturnValue 函数和 objc_retainAutoreleasedReturnValue 函数的协作，可以不将对象注册到 autoreleasepool 中而直接传递，这一过程达到了最优化。 Autorelease 释放时机有runloop的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop。 autoreleasepool在没有runloop的情况下何时释放呢？ 局部autoreleasepool drain的时候，就是常规的page push以及对应的page pop； 线程退出的时候；那么线程退出释放是如何确定的呢？ 在runtime初始化的过程中，会调用AutoReleasePoolPage::init方法注册tls_dealloc， AutoreleasePoolPage 类的初始化方法如下： 123456static void init()&#123; int r __unused = pthread_key_init_np(AutoreleasePoolPage::key, AutoreleasePoolPage::tls_dealloc); assert(r == 0);&#125; 而 tls_dealloc 方法实现如下： 12345678910111213141516171819202122static void tls_dealloc(void *p) &#123; if (p == (void*)EMPTY_POOL_PLACEHOLDER) &#123; // No objects or pool pages to clean up here. return; &#125; // reinstate TLS value while we work setHotPage((AutoreleasePoolPage *)p); if (AutoreleasePoolPage *page = coldPage()) &#123; if (!page-&gt;empty()) pop(page-&gt;begin()); // pop all of the pools if (DebugMissingPools || DebugPoolAllocation) &#123; // pop() killed the pages already &#125; else &#123; page-&gt;kill(); // free all of the pages &#125; &#125; // clear TLS value so TLS destruction doesn't loop setHotPage(nil);&#125; 结合这两段代码，我们大致可以猜测下phtread_key_init_np是将tls_dealloc注册给某个回调使用。那具体是干嘛的？ 实际上phtread_key_init_np时给thread注册了线程销毁时的自定义析构函数，这里我们可以一起来看看darwin-apple的libpthread代码，这里我直接简化掉流程，输出大致的过程： _pthread_exit 在线程销毁时调用 -&gt; _pthread_tsd_cleanup -&gt; _pthread_tsd_cleanup_new -&gt; _pthread_tsd_cleanup_key。 在最终的函数里，会遍历所有的自定义销毁函数，逐个触发： 123456789101112131415static void_pthread_tsd_cleanup_key(pthread_t self, pthread_key_t key)&#123; void (*destructor)(void *); if (_pthread_key_get_destructor(key, &amp;destructor)) &#123; void **ptr = &amp;self-&gt;tsd[key]; void *value = *ptr; if (value) &#123; *ptr = NULL; if (destructor) &#123; destructor(value); &#125; &#125; &#125;&#125; 问题案例NSAttributedString的autorelease内存风暴: http://wereadteam.github.io/2020/11/11/AttributeString/ Autorelease 之不经意间可能被影响的优化: http://satanwoo.github.io/2019/07/02/RevisitAutorelease/#disqus_thread 属性Property所有权修饰符ARC有效时，id类型和对象类型上必须附加所有权修饰符。所有权修饰符一共有4种。 __strong 修饰符：__strong 修饰符是id类型和对象类型默认的所有权修饰符。id和对象类型在没有明确指定所有权修饰符时，默认是 __strong 修饰符。附有 __strong 修饰符的变量 obj 在超出其变量作用域时，即在该变量被废弃时，会释放其被赋予的对象。 __strong 和 __weak、__autorelease修饰符一起，可以保证附有这些修饰符的自动变量初始化为nil。 __weak 修饰符： 为了解决仅使用 __strong 修饰符编译器所不能解决的重大问题–引用计数式内存管理中必然会发生的”循环引用”问题，可以使用与 __strong 对应的 __weak。也就是说使用 __weak 可以避免循环引用。 __weak 修饰符与 __strong 修饰符相反，提供弱引用，弱引用不能持有对象实例。 __weak 修饰符还有另一优点。在持有对象的弱引用时，若该对象被废弃，则此弱引用将自动失效并被置为nil。 __unsafe_unretained 修饰符： __weak 修饰符只能用于 iOS 5 以上及 OS X Lion 以上版本的应用程序。在 iOS 4以及OS X Snow Leopard的应用程序中可使用 __unsafe_unretained 修饰符来代替。__unsafe_unretained 修饰符正如其名 unsafe所示，是不安全的所有权修饰符。尽管 ARC 式的内存管理时编译器的工作，但附有 __unsafe_unretained 修饰符的变量不属于编译器的内存管理对象。附有 __unsafe_unretained 修饰符的变量同附有 __weak 修饰符的变量一样，不会改变对象的引用计数。同时因为附有 __unsafe_unretained 修饰符的变量不属于编译器的内存管理对象，所以弱引用不会被自动置为nil，所以在使用附有 __unsafe_unretained 修饰符的变量是，需要确保其确实存在，否则程序会崩溃。 __autoreleasing 修饰符： ARC有效时，不能使用 autorelease方法，而是通过将对象赋值给附加了__autoreleasing 修饰符的变量来替代。对象赋值给附有 __autoreleasing 修饰符的变量等价于在ARC无效时调用对象的 autorelease 方法，即对象被注册到 autorelease。前文中提到，编译器会检查如果方法名不是以alloc/new/copy/mutableCopy 和以它们驼峰命名开头的，会自动将返回值的对象注册到 autoreleasepool。另外虽然 __weak 修饰符是为了避免循环引用而使用的，但在访问附有 __weak 修饰符的变量是，实际上必定要访问注册到 autoreleasepool 的对象。这是因为 __weak 修饰符只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果把要访问的对象注册到 autoreleasepool 中，那么在 @autoreleasepool 块结束之前都能确保该对象存在。因此，在使用附有 __weak 修饰符的变量时，就必定要使用注册到 autoreleasepool 中的对象。 属性我们知道，在声明属性的时候，是可以指定内存管理特性的。property属性的内存管理特性包含如下几种： 属性声明的属性 所有权修饰符 assign __unsafe_unretained 修饰符 copy __strong 修饰符（但是赋值的是被复制的对象） retain __strong 修饰符 strong __strong 修饰符 unsafe_unretained __unsafe_unretained 修饰符 weak __weak 修饰符 只有copy属性不是简单的赋值，它赋值的是通过 NSCopying 接口的 copyWithZone: 方法复制赋值源所生成的对象。 assign（默认参数）：setter方法直接赋值，不进行任何retain操作，不改变引用计数。该方法只会针对“纯量类型”(CGFloat或NSInteger等)和C数据类型（int, float, double, char, 等等）的简单赋值操作。基础数据类型： 如short、int、double、long等他们不在【堆】中，可能在【全局区】也可能在【栈】中，根据他们定义的位置而定，而这些内存都是由系统自动管理的，所以基本数据类型可以使用assign来生成set方法直接进行赋值。 retain：生成符合内存管理的set方法（release旧值，retain新值），适用于OC对象的成员变量。 copy：生成符合内存管理的set方法（release旧值，copy新值），适用于NSString、NSArray等不可变对象。和strong类似，不过该属性会被复制一个新的副本。很多时候使用copy是为了防止Mutable（可变类型）在我们不知道的情况下修改了属性值，而用copy可以生成一个不可变的副本防止被修改。如果我们自己实现setter方法的话，需要手动copy。 strong：强引用，其存亡直接决定了所指向对象的存亡。使用该特性实例变量在赋值时，会释放旧值同时设置新值，对对象产生一个强引用，即引用计数+1。如果不存在指向一个对象的引用，并且此对象不再显示在列表中，则此对象会被从内存中释放。适用于一般OC对象。 weak：表示的是一个弱引用，这个引用不会增加对象的引用计数，并且在所指向的对象被释放之后，weak指针会被置为nil。weak引用通常是用于处理循环引用的问题，如代理及block的使用中，相对会较多的使用到weak。即使一个对象被持有无数个弱引用，只要没有强引用指向它，那么还是会被清除。相比于assign，声明为weak的指针，指针指向的地址一旦被释放，这些指针都将被赋值为 nil。这样的好处能有效的防止野指针。因为ViewController对控件强引用，如果delegate声明为strong，UI控件代理一般指向ViewController本身，那么就会造成循环引用。不过非UI控件的delegate的属性声明是weak还是strong就要视情况而定。一般iOS的ARC中的代理delegate属性都会用weak，有时候也用于UI控件(如果是懒加载则必须用strong)。 Property源码探究新建一个项目，在ViewController.m中添加如下代码： 123456789101112131415161718192021222324252627282930#import &quot;ViewController.h&quot;@interface ViewController ()@property (nonatomic, copy) NSString *str;@property (nonatomic, strong) NSMutableArray *arr;@property (nonatomic, copy) NSDictionary *dic;@property (nonatomic, weak) id delegate;@property (nonatomic, assign) NSInteger num;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _str &#x3D; [NSString new]; _arr &#x3D; [NSMutableArray array]; _dic &#x3D; [[NSDictionary alloc] init]; NSObject *obj &#x3D; [NSObject new]; _delegate &#x3D; obj; _num &#x3D; 1;&#125;@end 和前文一样，打开命令行，cd到工程目录，执行前文中的命令让编译器重新改写ViewController.m文件: 1clang -x objective-c -rewrite-objc -isysroot &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneSimulator.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneSimulator.sdk ViewController.m 如遇如下报错： 1234&#x2F;var&#x2F;folders&#x2F;0b&#x2F;z9zhp5nd1m31p32z0jbmyfhm0000gn&#x2F;T&#x2F;ViewController-d731ff.mi:60126:1: error: cannot synthesize weak property because the current deployment target does not support weak references@implementation ViewController 可执行如下命令： 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime&#x3D;ios-8.0.0 ViewController.m -o ViewController.cpp 找到生成的 ViewController.cpp 文件，在文件最下方找到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#ifndef _REWRITER_typedef_ViewController#define _REWRITER_typedef_ViewController// 编译器将struct objc_object重命名为 ViewController类typedef struct objc_object ViewController;typedef struct &#123;&#125; _objc_exc_ViewController;#endif// 定义了属性的偏移量，指实例变量在内存中存储的偏移量，通过这两个值就能够在内存中定位到这实例变量的位置。值是运行时计算出偏移量硬编码(hard code)写入的，是non-fragile 特性的一种体现extern \"C\" unsigned long OBJC_IVAR_$_ViewController$_str;extern \"C\" unsigned long OBJC_IVAR_$_ViewController$_arr;extern \"C\" unsigned long OBJC_IVAR_$_ViewController$_dic;extern \"C\" unsigned long OBJC_IVAR_$_ViewController$_delegate;extern \"C\" unsigned long OBJC_IVAR_$_ViewController$_num;// 该结构体就是ViewController类实现，struct ViewController_IMPL结构体只有一个Class isa结构体指针变量，指向类对象，用于获取ViewController类的方法列表、实例变量列表、属性列表、版本等信息。struct ViewController_IMPL &#123; struct UIViewController_IMPL UIViewController_IVARS; NSString *__strong _str; NSMutableArray *__strong _arr; NSDictionary *__strong _dic; __weak id _delegate; NSInteger _num;&#125;;/* @end */// @interface ViewController ()// @property (nonatomic, copy) NSString *str;// @property (nonatomic, strong) NSMutableArray *arr;// @property (nonatomic, copy) NSDictionary *dic;// @property (nonatomic, weak) id delegate;// @property (nonatomic, assign) NSInteger num;/* @end */// @implementation ViewControllerstatic void _I_ViewController_viewDidLoad(ViewController * self, SEL _cmd) &#123; ((void (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(\"ViewController\"))&#125;, sel_registerName(\"viewDidLoad\")); (*(NSString *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_str)) = ((NSString *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSString\"), sel_registerName(\"new\")); (*(NSMutableArray *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_arr)) = ((NSMutableArray * _Nonnull (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"array\")); (*(NSDictionary *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_dic)) = ((NSDictionary *(*)(id, SEL))(void *)objc_msgSend)((id)((NSDictionary *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSDictionary\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")); NSObject *obj = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"new\")); (*(__weak id *)((char *)self + OBJC_IVAR_$_ViewController$_delegate)) = obj; (*(NSInteger *)((char *)self + OBJC_IVAR_$_ViewController$_num)) = 1;&#125;static void _I_ViewController_didReceiveMemoryWarning(ViewController * self, SEL _cmd) &#123; ((void (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(\"ViewController\"))&#125;, sel_registerName(\"didReceiveMemoryWarning\"));&#125;// 属性的 setter 和 getter 方法static NSString * _I_ViewController_str(ViewController * self, SEL _cmd) &#123; return (*(NSString *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_str)); &#125;extern \"C\" __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);static void _I_ViewController_setStr_(ViewController * self, SEL _cmd, NSString *str) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct ViewController, _str), (id)str, 0, 1); &#125;static NSMutableArray * _I_ViewController_arr(ViewController * self, SEL _cmd) &#123; return (*(NSMutableArray *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_arr)); &#125;static void _I_ViewController_setArr_(ViewController * self, SEL _cmd, NSMutableArray *arr) &#123; (*(NSMutableArray *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_arr)) = arr; &#125;static NSDictionary * _I_ViewController_dic(ViewController * self, SEL _cmd) &#123; return (*(NSDictionary *__strong *)((char *)self + OBJC_IVAR_$_ViewController$_dic)); &#125;static void _I_ViewController_setDic_(ViewController * self, SEL _cmd, NSDictionary *dic) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct ViewController, _dic), (id)dic, 0, 1); &#125;static id _I_ViewController_delegate(ViewController * self, SEL _cmd) &#123; return (*(__weak id *)((char *)self + OBJC_IVAR_$_ViewController$_delegate)); &#125;static void _I_ViewController_setDelegate_(ViewController * self, SEL _cmd, id delegate) &#123; (*(__weak id *)((char *)self + OBJC_IVAR_$_ViewController$_delegate)) = delegate; &#125;static NSInteger _I_ViewController_num(ViewController * self, SEL _cmd) &#123; return (*(NSInteger *)((char *)self + OBJC_IVAR_$_ViewController$_num)); &#125;static void _I_ViewController_setNum_(ViewController * self, SEL _cmd, NSInteger num) &#123; (*(NSInteger *)((char *)self + OBJC_IVAR_$_ViewController$_num)) = num; &#125;// @end/*...*/// #define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)，member对于(结构体类型)type起始的偏移，type一般为一个结构体类型// 这两句代码是使用__OFFSETOFIVAR__(TYPE, MEMBER)宏定义来计算偏移量，并存储在上文提到的偏移量中extern \"C\" unsigned long int OBJC_IVAR_$_ViewController$_str __attribute__ ((used, section (\"__DATA,__objc_ivar\"))) = __OFFSETOFIVAR__(struct ViewController, _str);extern \"C\" unsigned long int OBJC_IVAR_$_ViewController$_arr __attribute__ ((used, section (\"__DATA,__objc_ivar\"))) = __OFFSETOFIVAR__(struct ViewController, _arr);extern \"C\" unsigned long int OBJC_IVAR_$_ViewController$_dic __attribute__ ((used, section (\"__DATA,__objc_ivar\"))) = __OFFSETOFIVAR__(struct ViewController, _dic);extern \"C\" unsigned long int OBJC_IVAR_$_ViewController$_delegate __attribute__ ((used, section (\"__DATA,__objc_ivar\"))) = __OFFSETOFIVAR__(struct ViewController, _delegate);extern \"C\" unsigned long int OBJC_IVAR_$_ViewController$_num __attribute__ ((used, section (\"__DATA,__objc_ivar\"))) = __OFFSETOFIVAR__(struct ViewController, _num);// 成员变量列表static struct /*_ivar_list_t*/ &#123; unsigned int entsize; // sizeof(struct _prop_t) unsigned int count; struct _ivar_t ivar_list[5];&#125; _OBJC_$_INSTANCE_VARIABLES_ViewController __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_ivar_t), 5, &#123;&#123;(unsigned long int *)&amp;OBJC_IVAR_$_ViewController$_str, \"_str\", \"@\\\"NSString\\\"\", 3, 8&#125;, &#123;(unsigned long int *)&amp;OBJC_IVAR_$_ViewController$_arr, \"_arr\", \"@\\\"NSMutableArray\\\"\", 3, 8&#125;, &#123;(unsigned long int *)&amp;OBJC_IVAR_$_ViewController$_dic, \"_dic\", \"@\\\"NSDictionary\\\"\", 3, 8&#125;, &#123;(unsigned long int *)&amp;OBJC_IVAR_$_ViewController$_delegate, \"_delegate\", \"@\", 3, 8&#125;, &#123;(unsigned long int *)&amp;OBJC_IVAR_$_ViewController$_num, \"_num\", \"q\", 3, 8&#125;&#125;&#125;;// 方法列表static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[12];&#125; _OBJC_$_INSTANCE_METHODS_ViewController __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 12, &#123;&#123;(struct objc_selector *)\"viewDidLoad\", \"v16@0:8\", (void *)_I_ViewController_viewDidLoad&#125;, &#123;(struct objc_selector *)\"didReceiveMemoryWarning\", \"v16@0:8\", (void *)_I_ViewController_didReceiveMemoryWarning&#125;, &#123;(struct objc_selector *)\"str\", \"@16@0:8\", (void *)_I_ViewController_str&#125;, &#123;(struct objc_selector *)\"setStr:\", \"v24@0:8@16\", (void *)_I_ViewController_setStr_&#125;, &#123;(struct objc_selector *)\"arr\", \"@16@0:8\", (void *)_I_ViewController_arr&#125;, &#123;(struct objc_selector *)\"setArr:\", \"v24@0:8@16\", (void *)_I_ViewController_setArr_&#125;, &#123;(struct objc_selector *)\"dic\", \"@16@0:8\", (void *)_I_ViewController_dic&#125;, &#123;(struct objc_selector *)\"setDic:\", \"v24@0:8@16\", (void *)_I_ViewController_setDic_&#125;, &#123;(struct objc_selector *)\"delegate\", \"@16@0:8\", (void *)_I_ViewController_delegate&#125;, &#123;(struct objc_selector *)\"setDelegate:\", \"v24@0:8@16\", (void *)_I_ViewController_setDelegate_&#125;, &#123;(struct objc_selector *)\"num\", \"q16@0:8\", (void *)_I_ViewController_num&#125;, &#123;(struct objc_selector *)\"setNum:\", \"v24@0:8q16\", (void *)_I_ViewController_setNum_&#125;&#125;&#125;;static struct _class_ro_t _OBJC_METACLASS_RO_$_ViewController __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; 1, sizeof(struct _class_t), sizeof(struct _class_t), 0, \"ViewController\", 0, 0, 0, 0, 0, &#125;;static struct _class_ro_t _OBJC_CLASS_RO_$_ViewController __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; 0, __OFFSETOFIVAR__(struct ViewController, _str), sizeof(struct ViewController_IMPL), 0, \"ViewController\", (const struct _method_list_t *)&amp;_OBJC_$_INSTANCE_METHODS_ViewController, 0, (const struct _ivar_list_t *)&amp;_OBJC_$_INSTANCE_VARIABLES_ViewController, 0, 0, &#125;;extern \"C\" __declspec(dllimport) struct _class_t OBJC_METACLASS_$_UIViewController;extern \"C\" __declspec(dllimport) struct _class_t OBJC_METACLASS_$_NSObject;extern \"C\" __declspec(dllexport) struct _class_t OBJC_METACLASS_$_ViewController __attribute__ ((used, section (\"__DATA,__objc_data\"))) = &#123; 0, // &amp;OBJC_METACLASS_$_NSObject, 0, // &amp;OBJC_METACLASS_$_UIViewController, 0, // (void *)&amp;_objc_empty_cache, 0, // unused, was (void *)&amp;_objc_empty_vtable, &amp;_OBJC_METACLASS_RO_$_ViewController,&#125;;extern \"C\" __declspec(dllimport) struct _class_t OBJC_CLASS_$_UIViewController;extern \"C\" __declspec(dllexport) struct _class_t OBJC_CLASS_$_ViewController __attribute__ ((used, section (\"__DATA,__objc_data\"))) = &#123; 0, // &amp;OBJC_METACLASS_$_ViewController, 0, // &amp;OBJC_CLASS_$_UIViewController, 0, // (void *)&amp;_objc_empty_cache, 0, // unused, was (void *)&amp;_objc_empty_vtable, &amp;_OBJC_CLASS_RO_$_ViewController,&#125;;static void OBJC_CLASS_SETUP_$_ViewController(void ) &#123; OBJC_METACLASS_$_ViewController.isa = &amp;OBJC_METACLASS_$_NSObject; OBJC_METACLASS_$_ViewController.superclass = &amp;OBJC_METACLASS_$_UIViewController; OBJC_METACLASS_$_ViewController.cache = &amp;_objc_empty_cache; OBJC_CLASS_$_ViewController.isa = &amp;OBJC_METACLASS_$_ViewController; OBJC_CLASS_$_ViewController.superclass = &amp;OBJC_CLASS_$_UIViewController; OBJC_CLASS_$_ViewController.cache = &amp;_objc_empty_cache;&#125;#pragma section(\".objc_inithooks$B\", long, read, write)__declspec(allocate(\".objc_inithooks$B\")) static void *OBJC_CLASS_SETUP[] = &#123; (void *)&amp;OBJC_CLASS_SETUP_$_ViewController,&#125;;static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (\"__DATA, __objc_classlist,regular,no_dead_strip\")))= &#123; &amp;OBJC_CLASS_$_ViewController,&#125;;static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;; 在上述 setter 方法中可以看到，copy修饰的不可变系统类属性会调用用objc_setProperty方法，但是其它属性所有权修饰符修饰的属性都是直接复制。 在runtime源码的objc-accessors.mm文件中， objc_setProperty 方法实现如下： 123456void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) &#123; bool copy = (shouldCopy &amp;&amp; shouldCopy != MUTABLE_COPY); bool mutableCopy = (shouldCopy == MUTABLE_COPY); reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);&#125; 方法会确定下一个方法的入参是 copy 还是 mutableCopy，然后调用 reallySetProperty 方法： 1234567891011121314151617181920212223242526272829303132static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)&#123; if (offset == 0) &#123; object_setClass(self, newValue); return; &#125; id oldValue; id *slot = (id*) ((char*)self + offset); if (copy) &#123; newValue = [newValue copyWithZone:nil]; &#125; else if (mutableCopy) &#123; newValue = [newValue mutableCopyWithZone:nil]; &#125; else &#123; if (*slot == newValue) return; newValue = objc_retain(newValue); &#125; if (!atomic) &#123; oldValue = *slot; *slot = newValue; &#125; else &#123; spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125; objc_release(oldValue);&#125; 方法首先会判断，如果偏移为0，说明是要更新当前类，调用 object_setClass 来初始化类，然后更新 isa。 1234567891011121314151617181920/************************************************************************ object_setClass.**********************************************************************/Class object_setClass(id obj, Class cls)&#123; if (!obj) return nil; // Prevent a deadlock between the weak reference machinery // and the +initialize machinery by ensuring that no // weakly-referenced object has an un-+initialized isa. // Unresolved future classes are not so protected. if (!cls-&gt;isFuture() &amp;&amp; !cls-&gt;isInitialized()) &#123; // use lookUpImpOrForward to indirectly provoke +initialize // to avoid duplicating the code to actually send +initialize lookUpImpOrForward(cls, SEL_initialize, nil, YES/*initialize*/, YES/*cache*/, NO/*resolver*/); &#125; return obj-&gt;changeIsa(cls);&#125; 根据偏移获取当前属性值 根据入参判断，如果入参 copy 为 true，调用 copyWithZone:方法，如果入参 mutableCopy 为 true，调用 mutableCopyWithZone:方法，否则，判断如果新属性值和旧值相等，调用 objc_retain(newValue)，增加引用计数 判断入参atomic，如果不为true，则保存旧属性值为oldValue，并使用新值更新属性值；否则，在进行前面操作的同时，使用PropertyLocks进行加锁，保证操作的原子性 调用 objc_release 释放旧值 总结参考： Pro Multithreading and Memory Management for iOS and OS X Advanced Memory Management Programming Guide 深入理解 GCD https://juejin.cn/post/6844904063465685000 https://draveness.me/autoreleasepool/#AutoreleasePoolPage","categories":[{"name":"刨根问底","slug":"刨根问底","permalink":"http://heseng91.github.io/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"}],"tags":[]}],"categories":[{"name":"精益求精","slug":"精益求精","permalink":"http://heseng91.github.io/categories/%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE/"},{"name":"刨根问底","slug":"刨根问底","permalink":"http://heseng91.github.io/categories/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/"},{"name":"App优化","slug":"App优化","permalink":"http://heseng91.github.io/categories/App%E4%BC%98%E5%8C%96/"},{"name":"性能优化","slug":"性能优化","permalink":"http://heseng91.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[]}