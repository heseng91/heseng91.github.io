{"meta":{"title":"和僧","subtitle":"","description":"技术博客","author":"和僧","url":"http://heseng91.github.io","root":"/"},"pages":[],"posts":[{"title":"刨根问底」之Runtime消息发送和转发","slug":"刨根问底」之Runtime消息发送和转发","date":"2021-10-30T20:31:49.770Z","updated":"2021-10-30T21:04:14.036Z","comments":true,"path":"2021/10/31/刨根问底」之Runtime消息发送和转发/","link":"","permalink":"http://heseng91.github.io/2021/10/31/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/","excerpt":"","text":"「刨根问底」之Runtime消息发送和转发上篇文章Runtime类和对象的定义 中提到了源代码到可执行文件需要需要经过编译和链接。其中编译通常会先预处理，再编译。iOS中预编译是使用Clang完成的。 下面新建一个工程并修改一下main.m文件如下： 12345678910#import &lt;UIKit&#x2F;UIKit.h&gt;#import &quot;AppDelegate.h&quot;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; UIViewController *vc &#x3D; [[UIViewController alloc] init]; [vc viewDidLoad]; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 打开终端，cd到工程目录，然后执行如下命令，对源文件进行clang rewrite， 1xcrun -sdk iphonesimulator13.2 clang -rewrite-objc -F &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneOS13.2.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneOS.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks SecondViewController.m iphonesimulator13.2中 13.2 为当前xcode SDK版本号（指令xcodebuild -showsdks即可查看），在得到的main.cpp文件末尾，可以找到源代码clang后的代码： 1234567int main(int argc, char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; UIViewController *vc = ((UIViewController *(*)(id, SEL))(void *)objc_msgSend)((id)((UIViewController *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"UIViewController\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")); ((void (*)(id, SEL))(void *)objc_msgSend)((id)vc, sel_registerName(\"viewDidLoad\")); return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AppDelegate\"), sel_registerName(\"class\")))); &#125;&#125; 从中可以得知: [receiver message] 其实会被编译器转化为： 1objc_msgSend(receiver, selector) 本篇就来详细分析一下Objective-C消息发送和转发机制。 消息发送和转发流程可以概括为： 消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现； 消息转发（Message Forwarding）是在查找 IMP 失败后执行一系列转发流程的慢速通道，如果不作转发处理，则会打日志和抛出异常。 本文将从源码角度分析消息发送和转发的原理。能够很好地阅读本文的前提是你对 Objective-C Runtime 已经有一定的了解，关于什么是消息，Class 的结构，selector、IMP、元类等概念将不再赘述。本文用到的源码为 objc4-756.2，汇编语言架构为 arm64。 objc_msgSend函数简介此函数是消息发送必经之路。objc_msgSend函数究竟会干什么事情呢？从这篇「objc_msgSend() Tour」文章里面可以得到一个比较详细的结论。 1234567891. Check for ignored selectors (GC) and short-circuit.2. Check for nil target. If nil &amp; nil receiver handler configured, jump to handler If nil &amp; no handler (default), cleanup and return.3. Search the class’s method cache for the method IMP(use hash to find&amp;store method in cache) -1. If found, jump to it. -2. Not found: lookup the method IMP in the class itself corresponding its hierarchy chain. If found, load it into cache and jump to it. If not found, jump to forwarding mechanism. 总结一下objc_msgSend会做以下几件事情： 检测这个 selector是不是要忽略的。 检查target是不是为nil。 如果这里有相应的nil的处理函数，就跳转到相应的函数中。如果没有处理nil的函数，就自动清理现场并返回。这一点就是为何在OC中给nil发送消息不会崩溃的原因。 确定不是给nil发消息之后，在该class的缓存中查找方法对应的IMP实现。 如果找到，就跳转进去执行。如果没有找到，就在方法分发表里面继续查找，一直找到NSObject为止。 如果还没有找到，那就需要开始消息转发阶段了。至此，发送消息Messaging阶段完成。这一阶段主要完成的是通过selecter快速查找IMP的过程。 源码解析在这篇文章Obj-C Optimization: The faster objc_msgSend中看到了这样一段C版本的objc_msgSend的源码。 Objective-C 123456789101112131415161718192021222324252627282930313233#include &lt;objc/objc-runtime.h&gt;id c_objc_msgSend( struct objc_class /* ahem */ *self, SEL _cmd, ...)&#123; struct objc_class *cls; struct objc_cache *cache; unsigned int hash; struct objc_method *method; unsigned int index; if( self) &#123; cls = self-&gt;isa; cache = cls-&gt;cache; hash = cache-&gt;mask; index = (unsigned int) _cmd &amp; hash; do &#123; method = cache-&gt;buckets[ index]; if( ! method) goto recache; index = (index + 1) &amp; cache-&gt;mask; &#125; while( method-&gt;method_name != _cmd); return( (*method-&gt;method_imp)( (id) self, _cmd)); &#125; return( (id) self);recache: /* ... */ return( 0);&#125; 该源码中有一个do-while循环，这个循环就是前面提到的在方法分发表里面查找method的过程。 _objc_msgSend源码分析不过在 objc4-756.2里面objc_msgSend 是用汇编语言写的，针对不同架构有不同的实现。objc-msg-arm64.s文件中实现是如下一段汇编代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&#x2F;&#x2F; objc_msgSend 汇编入口 ENTRY _objc_msgSend &#x2F;&#x2F; 无窗口 UNWIND _objc_msgSend, NoFrame&#x2F;&#x2F; p0：objc_msgSend的第一个参数，即消息接受者&#x2F;&#x2F; cmp: 比较&#x2F;&#x2F; #0：nil&#x2F;&#x2F; 判断p0是否为空 cmp p0, #0 &#x2F;&#x2F; nil check and tagged pointer check&#x2F;&#x2F; 支持taggedpointer的流程#if SUPPORT_TAGGED_POINTERS&#x2F;&#x2F; b.le: 执行标号，判断上面cmp值是小于等于，如果receiver为nil或taggedpointer，则执行LNilOrTagged b.le LNilOrTagged &#x2F;&#x2F; (MSB tagged pointer looks negative)#else&#x2F;&#x2F; b.eq: 执行标号，判断上面cmp值是等于，如果receiver为nil，则执行LReturnZero&#x2F;&#x2F; p0为空，返回空 b.eq LReturnZero#endif&#x2F;&#x2F; p0不为空，即receiver 存在的流程&#x2F;&#x2F; ldr 把数据从内存中某处读取到寄存器&#x2F;&#x2F; p13 &#x3D; x0栈内存中的值，从x0寄存器指向的地址中取出 isa，并把isa赋值给p13 ldr p13, [x0] &#x2F;&#x2F; p13 &#x3D; isa&#x2F;&#x2F; 在64位架构下通过 p16 &#x3D; isa（p13） &amp; ISA_MASK，获取shiftcls，从而得到class信息 GetClassFromIsa_p16 p13 &#x2F;&#x2F; p16 &#x3D; classLGetIsaDone:&#x2F;&#x2F; 如果isa存在，调用CacheLookup，开始cache查找流程(快速查找流程sel-&gt;imp)&#x2F;&#x2F; 找到就返回imp，没找到就返回objc_msgSend_uncached CacheLookup NORMAL &#x2F;&#x2F; calls imp or objc_msgSend_uncached&#x2F;&#x2F; 支持taggedpointer#if SUPPORT_TAGGED_POINTERS&#x2F;&#x2F; LNilOrTagged条件判断逻辑LNilOrTagged:&#x2F;&#x2F; 等于空，返回空 b.eq LReturnZero &#x2F;&#x2F; nil check &#x2F;&#x2F; tagged &#x2F;&#x2F; adrp 计算指定的数据地址到当前pc寄存器值相对偏移 &#x2F;&#x2F; 得到包含_objc_debug_taggedpointer_classes地址的page的基址，arm64架构中page大小为16kb。 &#x2F;&#x2F; 并将该page的基址存到寄存器X10中； adrp x10, _objc_debug_taggedpointer_classes@PAGE &#x2F;&#x2F; add 加 &#x2F;&#x2F; x10 &#x3D; x10 + _objc_debug_taggedpointer_classes@PAGEOFF（偏移量） &#x2F;&#x2F; 即计算出_objc_debug_taggedpointer_classes的地址，并存到寄存器X10中 add x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF &#x2F;&#x2F; ubfx 无符号位段提取（ubfx Xd, Xn, #lsb, #width。表示从Wn寄存器的第lsb位开始，提取width位到Wd寄存器，剩余高位用0填充） &#x2F;&#x2F; 从x0寄存器的第60位开始，提取4位到x11寄存器，剩余高位用0填充，即提取指针的最后四位（标记tagged pointer的位）存到x11寄存器 ubfx x11, x0, #60, #4 &#x2F;&#x2F; ldr 加载字到寄存器 &#x2F;&#x2F; lsl 逻辑或算术左移 &#x2F;&#x2F; x16 &#x3D; x10 + (x11&lt;&lt;3)， 获取taggedpointer标识位，并存到x16寄存器 ldr x16, [x10, x11, LSL #3] adrp x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE add x10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF cmp x10, x16 &#x2F;&#x2F; b.ne 判断上面cmp的值是不等于 执行标号，否则直接往下走 b.ne LGetIsaDone &#x2F;&#x2F; ext tagged adrp x10, _objc_debug_taggedpointer_ext_classes@PAGE add x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF ubfx x11, x0, #52, #8 ldr x16, [x10, x11, LSL #3] b LGetIsaDone&#x2F;&#x2F; SUPPORT_TAGGED_POINTERS#endifLReturnZero: &#x2F;&#x2F; x0 is already zero &#x2F;&#x2F; 1、首先先把 x1 清空，x0 这里是 self，已经是0，所以不需要清空 mov x1, #0 &#x2F;&#x2F; 2、清空 v 寄存器 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 ret END_ENTRY _objc_msgSend 主要有以下几步 【第一步】判断objc_msgSend方法的第一个参数receiver是否为空 判断receiver如果为空，则直接返回空，即LReturnZero； 如果支持tagged pointer对象，判断如果为tagged pointer对象，跳转至【第二步】 否则，如果receiver不为tagged pointer对象且不为空，从receiver中取出isa存入p13寄存器， 通过 GetClassFromIsa_p16中，arm64架构下通过 isa &amp; ISA_MASK 获取shiftcls位域的类信息，即class，GetClassFromIsa_p16的汇编实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&#x2F;&#x2F; .macro 汇编宏定义.macro GetClassFromIsa_p16 &#x2F;* src *&#x2F;#if SUPPORT_INDEXED_ISA&#x2F;&#x2F; mov指令是数据传送指令，用于将一个数据从源地址传送到目标地址，其特点是不破坏源地址单元的内容。&#x2F;&#x2F; 把传入的值src赋值给p16寄存器，p16 &#x3D; class &#x2F;&#x2F; Indexed isa mov p16, $0 &#x2F;&#x2F; optimistically set dst &#x3D; src&#x2F;&#x2F; # define ISA_INDEX_IS_NPI_BIT 0&#x2F;&#x2F; tbz 条件执行&#x2F;&#x2F; 判断p16寄存器中存储的class指针最后一位如果不为0，即如果是tagged pointer，则直接跳转到1，直接结束 tbz p16, #ISA_INDEX_IS_NPI_BIT, 1f &#x2F;&#x2F; done if not non-pointer isa&#x2F;&#x2F; adrp 计算指定的数据地址到当前pc寄存器值相对偏移 &#x2F;&#x2F; 得到包含_objc_indexed_classes地址的page的基址，arm64架构中page大小为16kb。 &#x2F;&#x2F; 并将该page的基址存到寄存器X10中； &#x2F;&#x2F; isa in p16 is indexed adrp x10, _objc_indexed_classes@PAGE&#x2F;&#x2F; x10 &#x3D; x10 + _objc_indexed_classes@PAGEOFF（_objc_indexed_classes在page中的偏移量），即计算出_objc_debug_taggedpointer_classes的地址，并存到寄存器X10中 add x10, x10, _objc_indexed_classes@PAGEOFF&#x2F;&#x2F; ubfx:有符号和无符号位域提取。 将一个寄存器中相邻的位复制到另一个寄存器的最低有效位，并用符号或零扩展到 32 位。&#x2F;&#x2F; 从p16的第ISA_INDEX_SHIFT位开始，提取 ISA_INDEX_BITS 位 到 p16寄存器，剩余的高位用0补充&#x2F;&#x2F; # define ISA_INDEX_SHIFT 2&#x2F;&#x2F; # define ISA_INDEX_BITS 15&#x2F;&#x2F; 从p16寄存器的第2位开始，提取15位到p16寄存器，剩余高位用0填充 ubfx p16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS &#x2F;&#x2F; extract index&#x2F;&#x2F; #define PTRSHIFT 3 &#x2F;&#x2F; 1&lt;&lt;PTRSHIFT &#x3D;&#x3D; PTRSIZE&#x2F;&#x2F; #define UXTP UXTX ldr p16, [x10, p16, UXTP #PTRSHIFT] &#x2F;&#x2F; load class from array1:&#x2F;&#x2F; 如果是64位#elif __LP64__ &#x2F;&#x2F; 64-bit packed isa&#x2F;&#x2F; p16 &#x3D; class &#x3D; isa &amp; ISA_MASK(位运算 &amp; 即获取isa中的shiftcls信息) and p16, $0, #ISA_MASK#else &#x2F;&#x2F; 32-bit raw isa mov p16, $0#endif&#x2F;&#x2F; 宏定义结束.endmacro 然后走到【第二步】 【第二步】获取isa完毕，调用CacheLookup NORMAL在缓存中查找方法。 CacheLookup源码分析1&#x2F;&#x2F; 定义CacheLookup宏.macro CacheLookup&#x2F;&#x2F; ldp:从栈取&#x2F;存数据&#x2F;&#x2F; #define CACHE (2 * __SIZEOF_POINTER__)，其中 __SIZEOF_POINTER__表示pointer的大小 ，即 2*8 &#x3D; 16&#x2F;&#x2F; p11 &#x3D; mask|buckets，从x16（即isa）中平移16字节，获取cache地址。isa距离cache 正好16字节：isa（8字节）+ superClass（8字节）&#x2F;&#x2F; 从cache中分别取出 buckets 和 occupied|mask 存入 p10（存储buckets） 和 p11（存储occupied|mask） &#x2F;&#x2F; p1 &#x3D; SEL, p16 &#x3D; isa ldp p10, p11, [x16, #CACHE] &#x2F;&#x2F; p10 &#x3D; buckets, p11 &#x3D; occupied|mask#if !__LP64__ and w11, w11, 0xffff &#x2F;&#x2F; p11 &#x3D; mask#endif&#x2F;&#x2F; and 按位“与”操作，key &amp; mask得到cache_hash and w12, w1, w11 &#x2F;&#x2F; x12 &#x3D; _cmd &amp; mask add p12, p10, p12, LSL #(1+PTRSHIFT) &#x2F;&#x2F; p12 &#x3D; buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))&#x2F;&#x2F; 从x12（即p12）中取出 bucket 分别将imp和sel 存入 p17（存储imp） 和 p9（存储sel） ldp p17, p9, [x12] &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket&#x2F;&#x2F; 比较 sel 与 p1（传入的参数cmd）1: cmp p9, p1 &#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)&#x2F;&#x2F; 如果不相等，即没有找到，跳转至 2f b.ne 2f &#x2F;&#x2F; scan more&#x2F;&#x2F; 如果相等，即缓存命中，执行cacheHit直接调用或返回imp CacheHit $0 &#x2F;&#x2F; call or return imp 2: &#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket&#x2F;&#x2F; 如果一直都找不到，因为是normal，跳转至__objc_msgSend_uncached CheckMiss $0 &#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0&#x2F;&#x2F; 判断p12（当前的bucket）是否 是 p10（buckets数组第一个元素，） cmp p12, p10 &#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets&#x2F;&#x2F; 如果想等，跳转至 3f b.eq 3f&#x2F;&#x2F; 从x12（即p12 buckets首地址）- 实际需要平移的内存大小BUCKET_SIZE，得到得到第二个bucket元素，imp-sel分别存入p17-p9，即向前查找 ldp p17, p9, [x12, #-BUCKET_SIZE]! &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket&#x2F;&#x2F; 跳转至第1步，继续对比 sel 与 cmd b 1b &#x2F;&#x2F; loop3: &#x2F;&#x2F; wrap: p12 &#x3D; first bucket, w11 &#x3D; mask&#x2F;&#x2F; mask左移4位，直接定位到buckets的最后一个元素，缓存查找顺序是向前查找 add p12, p12, w11, UXTW #(1+PTRSHIFT) &#x2F;&#x2F; p12 &#x3D; buckets + (mask &lt;&lt; 1+PTRSHIFT) &#x2F;&#x2F; Clone scanning loop to miss instead of hang when cache is corrupt. &#x2F;&#x2F; The slow path may detect any corruption and halt later. ldp p17, p9, [x12] &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket1: cmp p9, p1 &#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd) b.ne 2f &#x2F;&#x2F; scan more CacheHit $0 &#x2F;&#x2F; call or return imp 2: &#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket CheckMiss $0 &#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0&#x2F;&#x2F; 判断p12（当前遍历到的bucket）是否等于 p10（buckets数组第一个元素）即前面已经没有了 cmp p12, p10 &#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets b.eq 3f&#x2F;&#x2F; 偏移获取前一个bucket，并取出imp和sel分别存入p17、p9，即向前查找 ldp p17, p9, [x12, #-BUCKET_SIZE]! &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket&#x2F;&#x2F; 跳转至第1步，继续对比 sel 与 cmd b 1b &#x2F;&#x2F; loop3: &#x2F;&#x2F; double wrap&#x2F;&#x2F; 跳转至JumpMiss 因为是normal ，跳转至__objc_msgSend_uncached JumpMiss $0 .endmacro 主要分为以下几步 【第一步】通过isa首地址平移16字节（因为在objc_class中，首地址距离cache正好16字节，即isa首地址 占8字节，superClass占8字节），获取cahce，并将cache中的buckets存放到p10寄存器中，将cache中的occupied|mask存放到p11寄存器中 【第二步】由mask根据哈希算法计算出下标 将objc_msgSend的参数p1（即第二个参数_cmd）和p11中存放的msak进行&amp;运算，得到需要查找存储sel-imp的bucket下标index，即p12 = index = _cmd &amp; mask。 【第三步】根据所得的哈希下标index 和 buckets首地址，取出哈希下标对应的bucket，并存放到p12寄存器中p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT)) 其中PTRSHIFT等于3，左移4位（即2^4 = 16字节）即是一个bucket实际占用的大小,结构体bucket_t中sel占8字节，imp占8字节 根据计算的哈希下标index 乘以单个bucket占用的内存大小，得到bucket相当于buckets首地址的偏移量 通过首地址 + 实际偏移量，获取哈希下标index对应的bucket 【第四步】根据获取的bucket，取出其中的imp和sel分别存入p17和p9寄存器 【第五步】遍历buckets查找缓存的方法 比较sel和传入的参数cmd是否相等，如果不相等，即没找到，执行下一步，否则如果相等，即缓存命中，执行CacheHit函数返回imp 1&#x2F;&#x2F; CacheHit: x17 &#x3D; cached IMP, x12 &#x3D; address of cached IMP, x1 &#x3D; SEL.macro CacheHit.if $0 &#x3D;&#x3D; NORMAL TailCallCachedImp x17, x12, x1 &#x2F;&#x2F; authenticate and call imp.elseif $0 &#x3D;&#x3D; GETIMP mov p0, p17 cbz p0, 9f &#x2F;&#x2F; don&#39;t ptrauth a nil imp AuthAndResignAsIMP x0, x12, x1 &#x2F;&#x2F; authenticate imp and re-sign as IMP9: ret &#x2F;&#x2F; return IMP.elseif $0 &#x3D;&#x3D; LOOKUP &#x2F;&#x2F; No nil check for ptrauth: the caller would crash anyway when they &#x2F;&#x2F; jump to a nil IMP. We don&#39;t care if that jump also fails ptrauth. AuthAndResignAsIMP x17, x12, x1 &#x2F;&#x2F; authenticate imp and re-sign as IMP ret &#x2F;&#x2F; return imp via x17.else.abort oops.endif.endmacro 这里传入的$0是normal会调用TailCallCachedImp执行imp 1.macro TailCallCachedImp &#x2F;&#x2F; $0 &#x3D; cached imp, $1 &#x3D; address of cached imp, $2 &#x3D; SEL &#x2F;&#x2F; eor 逻辑异或 eor $1, $1, $2 &#x2F;&#x2F; mix SEL into ptrauth modifier brab $0, $1.endmacro 调用CheckMiss，判断是否一直找不到（bucket-&gt;sel == 0），即遇到空通，说明cache中没有该method。因此可见cache解决hash冲突的方式为开放寻址法（线性探测）。 1.macro CheckMiss &#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0.if $0 &#x3D;&#x3D; GETIMP cbz p9, LGetImpMiss.elseif $0 &#x3D;&#x3D; NORMAL cbz p9, __objc_msgSend_uncached.elseif $0 &#x3D;&#x3D; LOOKUP cbz p9, __objc_msgLookup_uncached.else.abort oops.endif.endmacro 因为$0是normal，如果一直都找不到，会跳转至__objc_msgSend_uncached，即进入慢速查找流程。否则执行下一步 如果根据index获取的bucket 等于 buckets的第一个元素，则将当前bucket设置为buckets的最后一个元素（通过buckets首地址+mask*16（等同于左移4位）直接定位到buckets的最后一个元素），并读取bucket的imp和sel`分别存入p17和p9寄存器，然后执行【第六步】；否则执行下一步 通过地址偏移，得到前一个bucket元素，并读取bucket的imp和sel`分别存入p17和p9寄存器，然后重复1 【第六步】第二次遍历查找：重复【第五步】的操作，与【第五步】中唯一区别是，如果当前的bucket还是等于 buckets的第一个元素，则直接跳转至JumpMiss， 1.macro JumpMiss.if $0 &#x3D;&#x3D; GETIMP b LGetImpMiss.elseif $0 &#x3D;&#x3D; NORMAL b __objc_msgSend_uncached.elseif $0 &#x3D;&#x3D; LOOKUP b __objc_msgLookup_uncached.else.abort oops.endif.endmacro 此时的$0是normal，也是直接跳转至__objc_msgSend_uncached，即进入慢速查找流程。 __objc_msgSend_uncached源码分析__objc_msgSend_uncached源码实现如下 1STATIC_ENTRY __objc_msgSend_uncachedUNWIND __objc_msgSend_uncached, FrameWithNoSaves&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION&#x2F;&#x2F; Out-of-band p16 is the class to search MethodTableLookupTailCallFunctionPointer x17END_ENTRY __objc_msgSend_uncached 该方法中主要调用了MethodTableLookup方法。 1.macro MethodTableLookup &#x2F;&#x2F; push frame SignLR stp fp, lr, [sp, #-16]! mov fp, sp &#x2F;&#x2F; save parameter registers: x0..x8, q0..q7 sub sp, sp, #(10*8 + 8*16) stp q0, q1, [sp, #(0*16)] stp q2, q3, [sp, #(2*16)] stp q4, q5, [sp, #(4*16)] stp q6, q7, [sp, #(6*16)] stp x0, x1, [sp, #(8*16+0*8)] stp x2, x3, [sp, #(8*16+2*8)] stp x4, x5, [sp, #(8*16+4*8)] stp x6, x7, [sp, #(8*16+6*8)] str x8, [sp, #(8*16+8*8)] &#x2F;&#x2F; receiver and selector already in x0 and x1 mov x2, x16 bl __class_lookupMethodAndLoadCache3 &#x2F;&#x2F; IMP in x0 mov x17, x0 &#x2F;&#x2F; restore registers and return ldp q0, q1, [sp, #(0*16)] ldp q2, q3, [sp, #(2*16)] ldp q4, q5, [sp, #(4*16)] ldp q6, q7, [sp, #(6*16)] ldp x0, x1, [sp, #(8*16+0*8)] ldp x2, x3, [sp, #(8*16+2*8)] ldp x4, x5, [sp, #(8*16+4*8)] ldp x6, x7, [sp, #(8*16+6*8)] ldr x8, [sp, #(8*16+8*8)] mov sp, fp ldp fp, lr, [sp], #16 AuthenticateLR.endmacro MethodTableLookup 可以算是个接口层宏，主要用于保存环境与准备参数，来调用 __class_lookupMethodAndLoadCache3函数（在objc-class-new.mm中）。 1/************************************************************************ _class_lookupMethodAndLoadCache.* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().* This lookup avoids optimistic cache scan because the dispatcher * already tried that.**********************************************************************/IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)&#123; return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/);&#125; __class_lookupMethodAndLoadCache3函数也是个接口层（C编写），此函数提供相应参数配置，实际功能在lookUpImpOrForward函数中。 1/************************************************************************ lookUpImpOrForward.* The standard IMP lookup. * initialize==NO tries to avoid +initialize (but sometimes fails)* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)* Most callers should use initialize==YES and cache==YES.* inst is an instance of cls or a subclass thereof, or nil if none is known. * If cls is an un-initialized metaclass then a non-nil inst is faster.* May return _objc_msgForward_impcache. IMPs destined for external use * must be converted to _objc_msgForward or _objc_msgForward_stret.* If you don't want forwarding at all, use lookUpImpOrNil() instead.**********************************************************************/IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = nil; bool triedResolver = NO;// runtimeLock 本质上是对 Darwin 提供的线程读写锁 pthread_rwlock_t 的一层封装，提供了一些便捷的方法。 runtimeLock.assertUnlocked(); // Optimistic cache lookup// 如果使用缓存（cache 参数为 YES），那就调用 cache_getImp 方法从缓存查找 IMP。cache_getImp 是用汇编语言写的，也可以在 objc-msg-arm64.s 找到，其依然用了前文中说过的 CacheLookup 宏。因为 _class_lookupMethodAndLoadCache3 调用 lookUpImpOrForward 时 cache 参数为 NO，这步直接略过。 if (cache) &#123; imp = cache_getImp(cls, sel); if (imp) return imp; &#125; // runtimeLock is held during isRealized and isInitialized checking // to prevent races against concurrent realization. // runtimeLock is held during method search to make // method-lookup + cache-fill atomic with respect to method addition. // Otherwise, a category could be added but ignored indefinitely because // the cache was re-filled with the old value after the cache flush on // behalf of the category. runtimeLock.lock();// 判断是否是一个已知的类：判断当前类是否是已经被认可的类，即已经加载的类。 checkIsKnownClass(cls);// 判断类是否已经Realized，如果没有，需要先Realized if (!cls-&gt;isRealized()) &#123; cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock); // runtimeLock may have been dropped but is now locked again &#125;// 判断如果入参传入的initialize为true，且类未实例化，需要先实例化 if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; cls = initializeAndLeaveLocked(cls, inst, runtimeLock); // runtimeLock may have been dropped but is now locked again // If sel == initialize, class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won't happen. 2778172 &#125; retry: // runtimeLock 上锁 runtimeLock.assertLocked(); // Try this class's cache.// 调用 cache_getImp 方法从缓存查找 IMP。 imp = cache_getImp(cls, sel);// 如果找到直接返回imp。 if (imp) goto done; // Try this class's method lists. &#123;// 在当前类中的方法列表（method list）中进行查找，也就是根据 selector 查找 Method ， Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123;// 如果在当前类的方法列表成功找到了Method// 获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。 log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);// 将找到的IMP直接返回imp imp = meth-&gt;imp; goto done; &#125; &#125;// 如果在当前类中的方法列表（method list）中没有找到Method，尝试在逐级在父类的缓存和方法列表中查找 // Try superclass caches and method lists. &#123;// Provides an upper bound for any iteration of classes, to prevent spins when runtime metadata is corrupted. unsigned attempts = unreasonableClassCount();// 在继承层级中递归向父类中查找，和上一步类似，也是先查找缓存，缓存没中就查找方法列表 for (Class curClass = cls-&gt;superclass; curClass != nil; curClass = curClass-&gt;superclass) &#123; // Halt if there is a cycle in the superclass chain. if (--attempts == 0) &#123; _objc_fatal(\"Memory corruption in class list.\"); &#125; // Superclass cache.// 调用 cache_getImp 方法从父类的缓存查找 IMP。 imp = cache_getImp(curClass, sel); if (imp) &#123;// 如果找到的imp不是_objc_msgForward_impcache if (imp != (IMP)_objc_msgForward_impcache) &#123; // Found the method in a superclass. Cache it in this class.// 将父类链中查找到的imp并填充到当前类的缓存中。 log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; &#125; else &#123;// 如果找到的imp是_objc_msgForward_impcache，推出循环 // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; &#125; &#125;// 在当前父类中的方法列表（method list）中进行查找，也就是根据 selector 查找到 Method 后，获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。 // Superclass method list. Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done; &#125; &#125; &#125; // No implementation found. Try method resolver once.// 参数 resolver 为 YES且是第一次执行到这里的时侯，进行动态方法解析 if (resolver &amp;&amp; !triedResolver) &#123;// 释放锁 runtimeLock.unlock();// 间接地发送 +resolveInstanceMethod 或 +resolveClassMethod 消息。函数中实现了方法解析逻辑。如果 cls 是元类则会发送 +resolveClassMethod，然后根据 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 函数的结果来判断是否发送 +resolveInstanceMethod；如果不是元类，则只需要发送 +resolveInstanceMethod 消息。这里调用 +resolveInstanceMethod 或 +resolveClassMethod 时再次用到了 objc_msgSend，而且第三个参数正是传入 lookUpImpOrForward 的那个 sel。在发送方法解析消息之后还会调用 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 来判断是否已经添加上 sel 对应的 IMP 了，打印出结果。 resolveMethod(cls, sel, inst);// 读入锁加锁 runtimeLock.lock(); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; &#125; // No implementation found, and method resolver didn't help. // Use forwarding.// 将 _objc_msgForward_impcache 当做 IMP 并写入缓存 imp = (IMP)_objc_msgForward_impcache; cache_fill(cls, sel, imp, inst); done: runtimeLock.unlock(); return imp;&#125; 首先了lookUpImpOrForward方法，对 assert 进行 unlock： 1runtimeLock.assertUnlocked(); runtimeLock 本质上是对 Darwin 提供的线程读写锁 pthread_rwlock_t 的一层封装，提供了一些便捷的方法。 接着，lookUpImpOrForward做了如下两件事： 如果使用缓存（cache 参数为 YES），那就调用 cache_getImp 方法从缓存查找 IMP。cache_getImp 是用汇编语言写的，实现如下 1STATIC_ENTRY _cache_getImp GetClassFromIsa_p16 p0 CacheLookup GETIMPLGetImpMiss: mov p0, #0 ret END_ENTRY _cache_getImp 其依然用了之前说过的 CacheLookup 宏。因为 _class_lookupMethodAndLoadCache3 调用 lookUpImpOrForward 时 cache 参数为 NO，这步直接略过。 如果是第一次用到这个类且 initialize 参数为 YES（initialize &amp;&amp; !cls-&gt;isInitialized()），需要进行初始化工作，也就是开辟一个用于读写数据的空间。先对 runtimeLock 加锁，然后调用 cls 的 initialize 方法，并将cls-&gt;isInitialized()置为true。 然后，会继续在类的继承体系中查找： 考虑到运行时类中的方法可能会增加，需要先加锁，使得方法查找和缓存填充成为原子操作。 1runtimeLock.assertLocked(); 之后的逻辑如下： 查找当前类中的缓存，跟之前一样，使用 cache_getImp 汇编程序入口。如果命中缓存获取到了 IMP，则直接跳到第 6 步；否则执行下一步。 在当前类的方法列表（method list）中进行查找，也就是根据 selector 查找到 Method 后，获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。查找过程如下： 首先调用 getMethodNoSuper_nolock()方法， 1static method_t *getMethodNoSuper_nolock(Class cls, SEL sel)&#123; runtimeLock.assertLocked(); assert(cls-&gt;isRealized()); // fixme nil cls? // fixme nil sel? for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(), end = cls-&gt;data()-&gt;methods.endLists(); mlists != end; ++mlists) &#123; method_t *m = search_method_list(*mlists, sel); if (m) return m; &#125; return nil;&#125; 在getMethodNoSuper_nolock方法中，会遍历methodList。遍历过程中会调用search_method_list函数。 1/************************************************************************ getMethodNoSuper_nolock* fixme* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static method_t *search_method_list(const method_list_t *mlist, SEL sel)&#123; int methodListIsFixedUp = mlist-&gt;isFixedUp(); int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t); // methodList有序 if (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, 1)) &#123; // 二分法查找method return findMethodInSortedMethodList(sel, mlist); &#125; else &#123; // 如果methodList无序，则线性遍历，查找method // Linear search of unsorted method list for (auto&amp; meth : *mlist) &#123; if (meth.name == sel) return &amp;meth; &#125; &#125;#if DEBUG // sanity-check negative results if (mlist-&gt;isFixedUp()) &#123; for (auto&amp; meth : *mlist) &#123; if (meth.name == sel) &#123; _objc_fatal(\"linear search worked when binary search did not\"); &#125; &#125; &#125;#endif return nil;&#125; 在search_method_list函数中，会去判断当前methodList是否有序，如果有序，会调用findMethodInSortedMethodList方法，这个方法里面的实现是一个二分搜索。 1static method_t *findMethodInSortedMethodList(SEL key, const method_list_t *list)&#123; assert(list); const method_t * const first = &amp;list-&gt;first; const method_t *base = first; const method_t *probe; uintptr_t keyValue = (uintptr_t)key; uint32_t count; // base相当于low，count是max，probe是middle for (count = list-&gt;count; count != 0; count &gt;&gt;= 1) &#123;// probe = 从首地址 + count/2 probe = base + (count &gt;&gt; 1); uintptr_t probeValue = (uintptr_t)probe-&gt;name; // 如果查找的sel == 中间位置（probe）的probeValue if (keyValue == probeValue) &#123; // `probe` is a match. // Rewind looking for the *first* occurrence of this value. // This is required for correct category overrides. // -- while 平移 -- 排除分类重名方法 // 循环在methodlist中查找第一个满足(keyValue == probeValue)的元素。因为在methodlist中分类方法会插入在本类方法之前 while (probe &gt; first &amp;&amp; keyValue == (uintptr_t)probe[-1].name) &#123; probe--; &#125; return (method_t *)probe; &#125;// 如果keyValue 大于 probeValue，就往probe即中间位置的右边查找 if (keyValue &gt; probeValue) &#123; base = probe + 1; count--; &#125; &#125; return nil;&#125; 如果成功查找到 Method 对象，则调用log_and_fill_cache()，将获取到的 Method 中的 IMP（也就是 method_imp 属性），填充到缓存中， 1/************************************************************************ log_and_fill_cache* Log this method call. If the logger permits it, fill the method cache.* cls is the method whose cache should be filled. * implementer is the class that owns the implementation in question.**********************************************************************/static voidlog_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)&#123;#if SUPPORT_MESSAGE_LOGGING if (objcMsgLogEnabled) &#123; bool cacheIt = logMessageSend(implementer-&gt;isMetaClass(), cls-&gt;nameForLogging(), implementer-&gt;nameForLogging(), sel); if (!cacheIt) return; &#125;#endif cache_fill (cls, sel, imp, receiver);&#125; 忽略debug的log逻辑，方法仅仅是调用cache_fill。 1void cache_fill(Class cls, SEL sel, IMP imp, id receiver)&#123;#if !DEBUG_TASK_THREADS mutex_locker_t lock(cacheUpdateLock); cache_fill_nolock(cls, sel, imp, receiver);#else _collecting_in_critical(); return;#endif&#125; cache_fill又会来到cache_fill_nolock，这个函数的作用是将方法的SEL和IMP写入_buckets，同时更新_mask和_occupied。 1static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)&#123; cacheUpdateLock.assertLocked();// 如果类未初始化，直接return // Never cache before +initialize is done if (!cls-&gt;isInitialized()) return; // Make sure the entry wasn't added to the cache by some other thread // before we grabbed the cacheUpdateLock.// 在获取cacheUpdateLock之前，确保其他线程没有将该方法写入缓存 if (cache_getImp(cls, sel)) return;// 获取 cls 的 cache_t指针 cache_t *cache = getCache(cls); // Use the cache as-is if it is less than 3/4 full// newOccupied为新的方法缓存数，等于 当前方法缓存数+1 mask_t newOccupied = cache-&gt;occupied() + 1;// 获取当前cache_t的总容量，为 mask+1 mask_t capacity = cache-&gt;capacity(); if (cache-&gt;isConstantEmptyCache()) &#123;// 当第一次调用类的实例方法时（如`init`） // Cache is read-only. Replace it. cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE); &#125; else if (newOccupied &lt;= capacity / 4 * 3) &#123;// 新的方法缓存数 不大于 总容量的3/4，按原样使用，无需扩容 // Cache is less than 3/4 full. Use it as-is. &#125; else &#123; // Cache is too full. Expand it.// 新的方法缓存数 大于 总容量的3/4，需要扩容 cache-&gt;expand(); &#125; // Scan for the first unused slot and insert there. // There is guaranteed to be an empty slot because the // minimum size is 4 and we resized at 3/4 full.// 根据sel获取bucket，此bucket的sel一般为0（说明这个位置还没缓存方法），// 也可能与实参sel相等（hash冲突，可能性很低） bucket_t *bucket = cache-&gt;find(sel, receiver);// 当且仅当bucket的sel为0时，执行_occupied++ if (bucket-&gt;sel() == 0) cache-&gt;incrementOccupied();// 更新bucket的sel和imp bucket-&gt;set&lt;Atomic&gt;(sel, imp);&#125; 从上面的源码不难看出，cache_fill_nolock主要是cache_t缓存方法的调度中心，在这里会： 决定执行_buckets的哪一种缓存策略（初始化后缓存、直接缓存、扩容后缓存，三者取一）； 然后通过方法的sel找到一个bucket，并更新这个bucket的sel和imp。（如果这个bucket的sel为0，说明是个空桶，正好可以缓存方法，于是执行_occupied++）。 缓存填充完成，然后就直接跳到第 6 步；否则如果当前类的method list没有找到method，则执行下一步。 在继承层级中递归向父类中查找，情况跟上一步类似，也是先查找缓存，缓存没中就查找方法列表。这里跟上一步不同的地方在于缓存策略，有个 _objc_msgForward_impcache 汇编程序入口作为缓存中消息转发的标记。也就是说如果在缓存中找到了 IMP，但如果发现其内容是 _objc_msgForward_impcache，那就终止在类的继承层级中递归查找，进入下一步；否则跳到第 7 步。 当传入 lookUpImpOrForward 的参数 resolver 为 YES 并且是第一次进入第 5 步时，时进入动态方法解析；否则进入下一步。这步消息转发前的最后一次机会。此时释放读入锁（runtimeLock.unlock()），接着调用resolveMethod()进行动态方法解析 1/************************************************************************ resolveMethod* Call +resolveClassMethod or +resolveInstanceMethod.* Returns nothing; any result would be potentially out-of-date already.* Does not check if the method already exists.**********************************************************************/static void resolveMethod(Class cls, SEL sel, id inst)&#123; runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); if (! cls-&gt;isMetaClass()) &#123; // try [cls resolveInstanceMethod:sel] resolveInstanceMethod(cls, sel, inst); &#125; else &#123; // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; resolveInstanceMethod(cls, sel, inst); &#125; &#125;&#125; 该方法中会判断，如果 cls 是元类则会发送 +resolveClassMethod。 1/************************************************************************ resolveClassMethod* Call +resolveClassMethod, looking for a method to be added to class cls.* cls should be a metaclass.* Does not check if the method already exists.**********************************************************************/static void resolveClassMethod(Class cls, SEL sel, id inst)&#123; runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); assert(cls-&gt;isMetaClass()); if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; // Resolver not implemented. return; &#125; Class nonmeta; &#123; mutex_locker_t lock(runtimeLock); nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst); // +initialize path should have realized nonmeta already if (!nonmeta-&gt;isRealized()) &#123; _objc_fatal(\"nonmeta class %s (%p) unexpectedly not realized\", nonmeta-&gt;nameForLogging(), nonmeta); &#125; &#125; BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(nonmeta, SEL_resolveClassMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); if (resolved &amp;&amp; PrintResolving) &#123; if (imp) &#123; _objc_inform(\"RESOLVE: method %c[%s %s] \" \"dynamically resolved to %p\", cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); &#125; else &#123; // Method resolver didn't add anything? _objc_inform(\"RESOLVE: +[%s resolveClassMethod:%s] returned YES\" \", but no new implementation of %c[%s %s] was found\", cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); &#125; &#125;&#125; 然后根据 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 函数的结果来判断是否发送 +resolveInstanceMethod 1/************************************************************************ resolveInstanceMethod* Call +resolveInstanceMethod, looking for a method to be added to class cls.* cls may be a metaclass or a non-meta class.* Does not check if the method already exists.**********************************************************************/static void resolveInstanceMethod(Class cls, SEL sel, id inst)&#123; runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; // Resolver not implemented. return; &#125; BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(cls, SEL_resolveInstanceMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveInstanceMethod adds to self a.k.a. cls IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); if (resolved &amp;&amp; PrintResolving) &#123; if (imp) &#123; _objc_inform(\"RESOLVE: method %c[%s %s] \" \"dynamically resolved to %p\", cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); &#125; else &#123; // Method resolver didn't add anything? _objc_inform(\"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES\" \", but no new implementation of %c[%s %s] was found\", cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); &#125; &#125;&#125; 如果不是元类，则只需要发送 +resolveInstanceMethod 消息。这里调用 +resolveInstanceMethod 或 +resolveClassMethod 时再次用到了 objc_msgSend，而且第三个参数正是传入 lookUpImpOrForward 的那个 sel。在发送方法解析消息之后还会调用 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 来判断是否已经添加上 sel 对应的 IMP 了，打印出结果。 lookUpImpOrNil 跟 lookUpImpOrForward 的功能很相似，只是将 lookUpImpOrForward 实现中的 _objc_msgForward_impcache 替换成了 nil: 1/************************************************************************ lookUpImpOrNil.* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache**********************************************************************/IMP lookUpImpOrNil(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver); if (imp == _objc_msgForward_impcache) return nil; else return imp;&#125; 此时不仅没查找到 IMP，动态方法解析也不奏效，只能将 _objc_msgForward_impcache 当做 IMP 并写入缓存。这也就是之前第 3 步中为何查找到 _objc_msgForward_impcache 就表明了要进入消息转发了。 解锁 runtimeLock.unlock()，并将之前找到的 IMP 返回。。 消息转发前面说到如果没有找到方法，会将 _objc_msgForward_impcache 当成imp写入缓存。_objc_msgForward_impcache 只是个内部的函数指针，只存储于类的方法缓存中，需要被转化为 _objc_msgForward 和 _objc_msgForward_stret 才能被外部调用。转换的方式也很简单，就是增加个静态入口 __objc_msgForward_impcache。 _objc_msgForward_impcache 在objc-msg-arm64.s中汇编的实现如下： 1&#x2F;********************************************************************** id _objc_msgForward(id self, SEL _cmd,...);** _objc_msgForward is the externally-callable* function returned by things like method_getImplementation().* _objc_msgForward_impcache is the function pointer actually stored in* method caches.*********************************************************************&#x2F; STATIC_ENTRY __objc_msgForward_impcache &#x2F;&#x2F; No stret specialization. b __objc_msgForward END_ENTRY __objc_msgForward_impcache _objc_msgForward_impcache只是入口。实际的实现函数是 objc_msgForward 1ENTRY __objc_msgForward adrp x17, __objc_forward_handler@PAGE ldr p17, [x17, __objc_forward_handler@PAGEOFF] TailCallFunctionPointer x17 END_ENTRY __objc_msgForward objc_msgForward 函数中会调用__objc_forward_handler函数。 1// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel)&#123; _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \" \"(no message forward handler is installed)\", class_isMetaClass(object_getClass(self)) ? '+' : '-', object_getClassName(self), sel_getName(sel), self);&#125;void *_objc_forward_handler = (void*)objc_defaultForwardHandler; 在Objc2.0中会有一个objc_defaultForwardHandler，看源码实现我们可以看到熟悉的语句。当我们给一个对象发送一个没有实现的方法的时候，如果其父类也没有这个方法，则会崩溃，报错信息类似于这样：unrecognized selector sent to instance，然后接着会跳出一些堆栈信息。这些信息就是从这里而来。 1// Default forward handler (nil) goes to forward:: dispatch.void *_objc_forward_handler = nil;void *_objc_forward_stret_handler = nil;#else// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel)&#123; _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \" \"(no message forward handler is installed)\", class_isMetaClass(object_getClass(self)) ? '+' : '-', object_getClassName(self), sel_getName(sel), self);&#125;void *_objc_forward_handler = (void*)objc_defaultForwardHandler;#if SUPPORT_STRETstruct stret &#123; int i[100]; &#125;;__attribute__((noreturn)) struct stret objc_defaultForwardStretHandler(id self, SEL sel)&#123; objc_defaultForwardHandler(self, sel);&#125;void *_objc_forward_stret_handler = (void*)objc_defaultForwardStretHandler;#endif#endifvoid objc_setForwardHandler(void *fwd, void *fwd_stret)&#123; _objc_forward_handler = fwd;#if SUPPORT_STRET _objc_forward_stret_handler = fwd_stret;#endif&#125; 要设置转发只要重写_objc_forward_handler方法即可。在objc_setForwardHandler方法中，可以设置ForwardHandler。 当你想要弄清objc_setForwardHandler的调用，以及之后的消息转发调用栈的时候，会发现在objc4-756.2找不到源码。这是因为objc_setForwardHandler的实现是在 Core Foundation（CoreFoundation.framework）中。虽然 CF 是开源的，但是苹果在这里做了点手脚。关于objc_setForwardHandler的调用，以及之后的消息转发调用栈的问题，需要用到逆向的知识。推荐大家看这篇文章就会明白其中的原理。 Objective-C 消息发送与转发机制原理iOS会在 CF runtime 连接到进程时初始化调用__CFInitialize() 函数，把 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 作为参数调用 objc_setForwardHandler 方法。 从函数调用栈可以看出 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 这两个 Forward Handler 做了啥： 12021-09-05 21:05:39.018585+0800 Test[46006:16033328] -[Person eat]: unrecognized selector sent to instance 0x600000db81002021-09-05 21:05:39.023782+0800 Test[46006:16033328] *** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[Person eat]: unrecognized selector sent to instance 0x600000db8100&#39;*** First throw call stack:( 0 CoreFoundation 0x00007fff23c7127e __exceptionPreprocess + 350 1 libobjc.A.dylib 0x00007fff513fbb20 objc_exception_throw + 48 2 CoreFoundation 0x00007fff23c91fd4 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132 3 CoreFoundation 0x00007fff23c75c4c ___forwarding___ + 1436 4 CoreFoundation 0x00007fff23c77f78 _CF_forwarding_prep_0 + 120 5 Test 0x000000010ba3e226 main + 54 6 libdyld.dylib 0x00007fff5227ec25 start + 1)libc++abi.dylib: terminating with uncaught exception of type NSException 这个日志场景熟悉得不能再熟悉了，可以看出 _CF_forwarding_prep_0 函数调用了 ___forwarding___ 函数，接着又调用了 doesNotRecognizeSelector 方法，最后抛出异常。 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 函数都调用了 ___forwarding___，只是传入参数不同。 消息转发的逻辑几乎都写在 ___forwarding___ 函数中了，实现比较复杂，反编译出的伪代码也不是很直观。Objective-C 消息发送与转发机制原理 的结果如下： 1int __forwarding__(void *frameStackPointer, int isStret) &#123; id receiver = *(id *)frameStackPointer; SEL sel = *(SEL *)(frameStackPointer + 8); const char *selName = sel_getName(sel); Class receiverClass = object_getClass(receiver); // 调用 forwardingTargetForSelector: if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123; id forwardingTarget = [receiver forwardingTargetForSelector:sel]; if (forwardingTarget &amp;&amp; forwarding != receiver) &#123; if (isStret == 1) &#123; int ret; objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...); return ret; &#125; return objc_msgSend(forwardingTarget, sel, ...); &#125; &#125; // 僵尸对象 const char *className = class_getName(receiverClass); const char *zombiePrefix = \"_NSZombie_\"; size_t prefixLen = strlen(zombiePrefix); // 0xa if (strncmp(className, zombiePrefix, prefixLen) == 0) &#123; CFLog(kCFLogLevelError, @\"*** -[%s %s]: message sent to deallocated instance %p\", className + prefixLen, selName, receiver); &lt;breakpoint-interrupt&gt; &#125; // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123; NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel]; if (methodSignature) &#123; BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct; if (signatureIsStret != isStret) &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'. Signature thinks it does%s return a struct, and compiler thinks it does%s.\", selName, signatureIsStret ? \"\" : not, isStret ? \"\" : not); &#125; if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123; NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer]; [receiver forwardInvocation:invocation]; void *returnValue = NULL; [invocation getReturnValue:&amp;value]; return returnValue; &#125; else &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation dropping message\", receiver, className); return 0; &#125; &#125; &#125; SEL *registeredSel = sel_getUid(selName); // selector 是否已经在 Runtime 注册过 if (sel != registeredSel) &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort\", sel, selName, registeredSel); &#125; // doesNotRecognizeSelector else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123; [receiver doesNotRecognizeSelector:sel]; &#125; else &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector abort\", receiver, className); &#125; // The point of no return. kill(getpid(), 9);&#125; 这么一大坨代码就是整个消息转发路径的逻辑，概括如下： 先调用 forwardingTargetForSelector 方法获取新的 target 作为 receiver 重新执行 selector，如果返回的内容不合法（为 nil 或者跟旧 receiver 一样），那就进入第二步。 调用 methodSignatureForSelector 获取方法签名后，判断返回类型信息是否正确，再调用 forwardInvocation 执行 NSInvocation 对象，并将结果返回。如果对象没实现 methodSignatureForSelector 方法，进入第三步。 调用 doesNotRecognizeSelector 方法。 doesNotRecognizeSelector 之前其实还有个判断 selector 在 Runtime 中是否注册过的逻辑，但在我们正常发消息的时候不会出此问题。但如果手动创建一个 NSInvocation 对象并调用 invoke，并将第二个参数设置成一个不存在的 selector，那就会导致这个问题，并输入日志 “does not match selector known to Objective C runtime”。较真儿的读者可能会有疑问：何这段逻辑判断干脆用不到却还存在着？难道除了 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 函数还有其他函数也调用 ___forwarding___ 么？莫非消息转发还有其他路径？其实并不是！原因是 ___forwarding___ 调用了 ___invoking___ 函数，所以上面的伪代码直接把 ___invoking___ 函数的逻辑也『翻译』过来了。除了 ___forwarding___ 函数，以下方法也会调用___invoking___ 函数: 1-[NSInvocation invoke]-[NSInvocation invokeUsingIMP:]-[NSInvocation invokeSuper] doesNotRecognizeSelector 方法其实在 libobj.A.dylib 中已经废弃了，而是在 CF 框架中实现，而且也不是开源的。从函数调用栈可以发现 doesNotRecognizeSelector 之后会抛出异常，而 Runtime 中废弃的实现只是打日志后直接杀掉进程（__builtin_trap()）。下面是 CF 中实现的伪代码： 1void -[NSObject doesNotRecognizeSelector:](void * self, void * _cmd, void * arg2) &#123; r14 &#x3D; ___CFFullMethodName([self class], self, arg2); _CFLog(0x3, @&quot;%@: unrecognized selector sent to instance %p&quot;, r14, self, r8, r9, stack[2048]); rbx &#x3D; _CFMakeCollectable(_CFStringCreateWithFormat(___kCFAllocatorSystemDefault, 0x0, @&quot;%@: unrecognized selector sent to instance %p&quot;)); if (*(int8_t *)___CFOASafe !&#x3D; 0x0) &#123; ___CFRecordAllocationEvent(); &#125; rax &#x3D; _objc_rootAutorelease(rbx); rax &#x3D; [NSException exceptionWithName:@&quot;NSInvalidArgumentException&quot; reason:rax userInfo:0x0]; objc_exception_throw(rax); return;&#125;void +[NSObject doesNotRecognizeSelector:](void * self, void * _cmd, void * arg2) &#123; r14 &#x3D; ___CFFullMethodName([self class], self, arg2); _CFLog(0x3, @&quot;%@: unrecognized selector sent to class %p&quot;, r14, self, r8, r9, stack[2048]); rbx &#x3D; _CFMakeCollectable(_CFStringCreateWithFormat(___kCFAllocatorSystemDefault, 0x0, @&quot;%@: unrecognized selector sent to class %p&quot;)); if (*(int8_t *)___CFOASafe !&#x3D; 0x0) &#123; ___CFRecordAllocationEvent(); &#125; rax &#x3D; _objc_rootAutorelease(rbx); rax &#x3D; [NSException exceptionWithName:@&quot;NSInvalidArgumentException&quot; reason:rax userInfo:0x0]; objc_exception_throw(rax); return;&#125; 也就是说我们可以 override doesNotRecognizeSelector 或者捕获其抛出的异常。 总结过滤了部分不会进入的分支路径和跟主题无关的细节，整体流程如下： 参考： iOS-底层原理 12：消息流程分析之快速查找（https://blog.51cto.com/u_12801393/2955213） Objc-msg-arm64源码深入分析（https://www.jianshu.com/p/835ae53372ba） OC底层原理11-objc_msgSend源码分析(方法查找快流程)（https://www.jianshu.com/p/62ecc3f31467） OC底层原理12-lookUpImpOrForward源码分析(方法查找慢流程)（https://www.jianshu.com/p/740ee19690c3） objc_msgSend 源码跟踪（https://www.jianshu.com/p/c8aedd333f2d） 深入解构objc_msgSend函数的实现（http://www.cocoachina.com/articles/24536） f","categories":[],"tags":[]},{"title":"刨根问底之-Runtime类和对象的定义","slug":"刨根问底之-Runtime类和对象的定义","date":"2021-10-30T18:40:17.933Z","updated":"2021-10-30T20:24:01.599Z","comments":true,"path":"2021/10/31/刨根问底之-Runtime类和对象的定义/","link":"","permalink":"http://heseng91.github.io/2021/10/31/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E4%B9%8B-Runtime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/","excerpt":"","text":"「刨根问底」之Objective-C 2.0 中类与对象的定义runtime简介依照苹果文档的说法，runtime是： 12The Objective-C language defers as many decisions as it can from compile time and link time to runtime. （尽量将决定放到运行的时候，而不是在编译和链接过程） 如何理解这段话呢，我们首先要知道，一段代码从写完到最终执行的过程中发生了什么。 从代码到可执行文件的过程具体过程见下图： 主要过程可以简化成三个： 123- 编译- 链接- 运行 编译：将代码转换成底层可执行的语言（如汇编），简单来讲，就是把你能看懂的语言，转换成系统底层可以看懂的东西，这中间通常会有优化，先预处理，再编译。 链接：在编译的过程中，如果有调用其他的类的方法等，是不会检查或者报警的，编译的时候会默认你已经实现了。而链接就是去检查调用的方法或者类等是否确实存在。 运行：执行最终的可执行文件 如果是普通的C语言代码，我们使用的是传统的编译运行，那么一个函数的执行内容，在编译阶段其实就确定了，执行的时候只要去执行对应的内存地址的程序就好。 因为Objc是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个 Objc 运行框架的一块基石。 Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 maxOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime之发送消息（objc_msgSend）还记得刚学 Objective-C 时把 [receiver message] 当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。其实 [receiver message] 会被编译器转化为： 1objc_msgSend(receiver, selector) 如果消息含有参数，则为： 1objc_msgSend(receiver, selector, arg1, arg2, ...) 如果消息的接收者能够找到对应的 selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个 selector 对应的实现内容，要么就干脆玩完崩溃掉。 消息发送等下章详细表述。本文基于源码为 objc4-756.2，先来介绍一下 Objective-C 2.0 中类与对象的相关定义，仅作为参考，暂不做深入的分析。 Runtime 基础数据结构前面提到的objc_msgSend:的真身是这样的： 1id objc_msgSend ( id self, SEL op, ... ); 下面将会逐渐展开介绍一些术语，其实它们都对应着数据结构。 SELobjc_msgSend函数第二个参数类型为SEL，它是selector在Objc中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL: 1typedef struct objc_selector *SEL; 其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获得一个 SEL 类型的方法选择器。 不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(参见：NSNumber 一堆抽象工厂方法)，Cocoa 中也有好多长长的方法。 idobjc_msgSend 第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针： 1typedef struct objc_object *id; 那objc_object又是啥呢，参考 objc-private.h 文件部分源码： 12345678910111213struct objc_object &#123;private: isa_t isa;public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // getIsa() allows this to be a tagged pointer object Class getIsa(); ... 此处省略其他方法声明&#125; objc_object 结构体包含一个 isa 指针，类型为 isa_t 联合体。根据 isa 就可以顺藤摸瓜找到对象所属的类。 PS: isa 指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用 class 方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见官方文档 isa_tobjc_object 中的 isa 是一个 isa_t 类型的共用体（union），在objc-private.h 文件中定义如下： 123456789101112union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 其中 ISA_BITFIELD在 isa.h文件中定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#if SUPPORT_PACKED_ISA // extra_rc must be the MSB-most field (so it matches carry/overflow flags) // nonpointer must be the LSB (fixme or get rid of it) // shiftcls must occupy the same bits that a real class pointer would // bits + RC_ONE is equivalent to extra_rc + 1 // RC_HALF is the high bit of extra_rc (i.e. half of its range) // future expansion: // uintptr_t fast_rr : 1; // no r/r overrides // uintptr_t lock : 2; // lock for atomic property, @synch // uintptr_t extraBytes : 1; // allocated with extra bytes# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18)# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 8# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7)# else# error unknown architecture for packed isa# endif SUPPORT_PACKED_ISA 用于标记是否支持优化的 isa 指针，其字面含义意思是 isa 的内容不再是类的指针了，而是包含了更多信息，比如引用计数，析构状态，被其他 weak 变量引用情况。判断方法也是根据设备类型： 12345678// Define SUPPORT_PACKED_ISA=1 on platforms that store the class in the isa // field as a maskable pointer with other data around it.#if (!__LP64__ || TARGET_OS_WIN32 || \\ (TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_IOSMAC))# define SUPPORT_PACKED_ISA 0#else# define SUPPORT_PACKED_ISA 1#endif 综合看来目前只有 arm64 架构的设备支持，下面列出了 isa 指针中变量对应的含义： 变量名 含义 nonpointer 0 表示普通的 isa 指针，1 表示使用优化，存储引用计数 has_assoc 表示该对象是否包含 associated object，如果没有，则析构时会更快 has_cxx_dtor 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls 类的指针 magic 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。 weakly_referenced 表示该对象是否有过 weak 对象，如果没有，则析构时更快 deallocating 表示该对象是否正在析构 has_sidetable_rc 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_rc 存储引用计数值减一后的结果 ClassClass 其实是一个指向 objc_class 结构体的指针： 1typedef struct objc_class *Class; 而 objc_class 包含很多方法，主要都为围绕它的几个成员做文章： 123456789101112struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125; ...// 省略其他方法&#125; objc_class 继承于 objc_object，也就是说一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似 [NSObject alloc] 的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 [NSObject alloc] 这条消息发给类对象的时候，objc_msgSend() 会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。 上图实线是 superclass 指针，虚线是isa指针。 有趣的是根元类的超类是 NSObject，而 isa 指向了自己，而 NSObject的超类为 nil，也就是它没有超类。 cache_t1234567struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;... //省略其他方法&#125; 其中，bucket_t *_buckets 是一个散列表，用来存储 Method 方法列表，而 bucket_t 结构体定义如下，包含了一个 unsigned long 类型的 _key 和一个 IMP 类型的 _imp，存储了指针与 IMP 的键值对。IMP 是一个函数指针，指向了一个方法的具体实现。 1234567891011121314struct bucket_t &#123;private: // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64.#if __arm64__ uintptr_t _imp; SEL _sel;#else SEL _sel; uintptr_t _imp;#endif... 省略其他方法&#125;; cache_t 中另外两个变量 _mask 和 _occupied，它们的类型为 mask_t，定义如下，其实是一个 unsigned int。 12345#if __LP64__typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t;#endif _mask 和 _occupied 对应于 vtable： _mask：分配用来缓存 bucket 的总数。 _occupied：表明目前实际占用的缓存 bucket 的个数。 cache 的作用主要是对方法调用的性能进行优化。通俗地讲，每当实例对象接收到一个消息时，它不会直接在其 isa 指向的类（或类的 isa 指向的父类）的方法列表中遍历查找能够响应消息的方法实现，因为这样效率太低了，而是优先在 cache 中查找。Runtime 系统会把被调用过的方法存到该类对象的 cache 中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。 有关缓存的实现细节，可以查看 objc-cache.mm 文件。 class_data_bits_tobjc_class 中最复杂的是 bits，class_data_bits_t 结构体所包含的信息太多了，主要包含 class_rw_t, retain/release/autorelease/retainCount 和 alloc 等信息，很多存取方法也是围绕它展开。查看 objc-runtime-new.h 源码如下： 123456789101112131415161718struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;private: bool getBit(uintptr_t bit) &#123; return bits &amp; bit; &#125;...public: class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;...省略其他方法&#125; 注意 objc_class 的 data 方法直接将 class_data_bits_t 的data 方法返回，最终是返回 class_rw_t，保了好几层。 可以看到 class_data_bits_t 里又包了一个 bits，这个指针跟不同的 FAST_ 前缀的 flag 掩码做按位与操作，就可以获取不同的数据。bits 在内存中每个位的含义有三种排列顺序： 32 位： 0 1 2 - 31 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_DATA_MASK 64 位兼容版： 0 1 2 3 - 46 47 - 63 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_HAS_DEFAULT_RR FAST_DATA_MASK 空闲 64 位不兼容版： 0 1 2 3 - 46 47 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_ALLOC FAST_DATA_MASK FAST_HAS_CXX_CTOR 48 49 50 51 52 - 63 FAST_HAS_DEFAULT_AWZ FAST_HAS_DEFAULT_RR FAST_REQUIRES_RAW_ISA FAST_HAS_CXX_DTOR 空闲 其中 64 位不兼容版每个宏对应的含义如下： 1234567891011121314151617181920212223242526// class is a Swift class from the pre-stable Swift ABI#define FAST_IS_SWIFT_LEGACY (1UL&lt;&lt;0)// class is a Swift class from the stable Swift ABI#define FAST_IS_SWIFT_STABLE (1UL&lt;&lt;1)// summary bit for fast alloc path: !hasCxxCtor and // !instancesRequireRawIsa and instanceSize fits into shiftedSize#define FAST_ALLOC (1UL&lt;&lt;2)// data pointer#define FAST_DATA_MASK 0x00007ffffffffff8UL// class or superclass has .cxx_construct implementation#define FAST_HAS_CXX_CTOR (1UL&lt;&lt;47)// class or superclass has default alloc/allocWithZone: implementation// Note this is is stored in the metaclass.#define FAST_HAS_DEFAULT_AWZ (1UL&lt;&lt;48)// class or superclass has default retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference#define FAST_HAS_DEFAULT_RR (1UL&lt;&lt;49)// class's instances requires raw isa// This bit is aligned with isa_t-&gt;hasCxxDtor to save an instruction.#define FAST_REQUIRES_RAW_ISA (1UL&lt;&lt;50)// class or superclass has .cxx_destruct implementation#define FAST_HAS_CXX_DTOR (1UL&lt;&lt;51)// instance size in units of 16 bytes// or 0 if the instance size is too big in this field// This field must be LAST#define FAST_SHIFTED_SIZE_SHIFT 52 这里面除了 FAST_DATA_MASK 是用一段空间存储数据外，其他宏都是只用 1 bit 存储 bool 值。class_data_bits_t 提供了三个方法用于位操作：getBit, setBits 和 clearBits，对应到存储 bool 值的掩码也有封装函数，比如： 123456bool hasCxxCtor() &#123; return getBit(FAST_HAS_CXX_CTOR);&#125;void setHasCxxCtor() &#123; setBits(FAST_HAS_CXX_CTOR);&#125; 重头戏在于最大的那块存储区域–FAST_DATA_MASK，它其实就存储了指向 class_rw_t 的指针： 123class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK);&#125; 对这片内存读写处于并发环境，但并不需要加锁，因为会通过对一些状态（realization or construction）判断来决定是否可读写。 class_data_bits_t 甚至还包含了一些对 class_rw_t 中 flags 成员存取的封装函数。 class_rw_tobjc_class 包含了 class_data_bits_t，class_data_bits_t 存储了 class_rw_t 的指针。 1234567891011121314151617181920212223struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;#if SUPPORT_INDEXED_ISA uint32_t index;#endif...省略操作 flags 的相关方法&#125; class_rw_t 中使用的 method_array_t, property_array_t, protocol_array_t 都继承自 list_array_tt&lt;Element, List&gt;, 它可以不断扩张，因为它可以存储 list 指针，内容有三种： 空 一个 entsize_list_tt 指针 entsize_list_tt 指针数组 class_rw_t 的内容是可以在运行时被动态修改的，可以说运行时对类的拓展大都是存储在这里的。 class_rw_t-&gt;flags 存储的值并不是编辑器设置的，其中有些值可能将来会作为 ABI 的一部分。下面这些 RW_ 前缀的宏标记了 flags 一些位置的含义。这些 bool 值标记了类的一些状态，涉及到声明周期和内存管理。有些位目前甚至还空着。 12345678910111213141516171819202122232425262728293031// Values for class_rw_t-&gt;flags// These are not emitted by the compiler and are never used in class_ro_t. // Their presence should be considered in future ABI versions.// class_t-&gt;data is class_rw_t, not class_ro_t#define RW_REALIZED (1&lt;&lt;31)// class is unresolved future class#define RW_FUTURE (1&lt;&lt;30)// class is initialized#define RW_INITIALIZED (1&lt;&lt;29)// class is initializing#define RW_INITIALIZING (1&lt;&lt;28)// class_rw_t-&gt;ro is heap copy of class_ro_t#define RW_COPIED_RO (1&lt;&lt;27)// class allocated but not yet registered#define RW_CONSTRUCTING (1&lt;&lt;26)// class allocated and registered#define RW_CONSTRUCTED (1&lt;&lt;25)// available for use; was RW_FINALIZE_ON_MAIN_THREAD// #define RW_24 (1&lt;&lt;24)// class +load has been called#define RW_LOADED (1&lt;&lt;23)#if !SUPPORT_NONPOINTER_ISA// class instances may have associative references#define RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS (1&lt;&lt;22)#endif// class has instance-specific GC layout#define RW_HAS_INSTANCE_SPECIFIC_LAYOUT (1 &lt;&lt; 21)// class does not allow associated objects on its instances#define RW_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;20)// class has started realizing but not yet completed it#define RW_REALIZING (1&lt;&lt;19) demangledName 是计算机语言用于解决实体名称唯一性的一种方法，做法是向名称中添加一些类型信息，用于从编译器中向链接器传递更多语义信息。 class_ro_tclass_rw_t 提供了运行时对类拓展的能力，而 class_ro_t 存储的大多是类在编译时就已经确定的信息。二者都存有类的方法、属性（成员变量）、协议等信息，不过存储它们的列表实现方式不同。 class_ro_t 中的 method_list_t, ivar_list_t, property_list_t 结构体都继承自 entsize_list_tt&lt;Element, List, FlagMask&gt;。结构为 xxx_list_t 的列表元素结构为 xxx_t，命名很工整。protocol_list_t 与前三个不同，它存储的是 protocol_t * 指针列表，实现比较简单。 entsize_list_tt 实现了 non-fragile 特性的数组结构。假如苹果在新版本的 SDK 中向 NSObject 类增加了一些内容，NSObject 的占据的内存区域会扩大，开发者以前编译出的二进制中的子类就会与新的 NSObject 内存有重叠部分。于是在编译期会给 instanceStart 和 instanceSize 赋值，确定好编译时每个类的所占内存区域起始偏移量和大小，这样只需将子类与基类的这两个变量作对比即可知道子类是否与基类有重叠，如果有，也可知道子类需要挪多少偏移量。更多细节可以参考后面的章节 Non Fragile ivars。 123456789101112131415161718192021222324struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; // This field exists only when RO_HAS_SWIFT_INITIALIZER is set. _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0];...省略其他方法&#125;; class_ro_t-&gt;flags 存储了很多在编译时期就确定的类的信息，也是 ABI 的一部分。下面这些 RO_ 前缀的宏标记了 flags 一些位置的含义。其中后三个并不需要被编译器赋值，是预留给运行时加载和初始化类的标志位，涉及到与 class_rw_t 的类型强转。运行时会用到它做判断，后面会讲解。 1234567891011121314151617181920212223242526272829303132333435// class_data_bits_t is the class_t-&gt;data field (class_rw_t pointer plus flags)// The extra bits are optimized for the retain/release and alloc/dealloc paths.// Values for class_ro_t-&gt;flags// These are emitted by the compiler and are part of the ABI.// Note: See CGObjCNonFragileABIMac::BuildClassRoTInitializer in clang// class is a metaclass#define RO_META (1&lt;&lt;0)// class is a root class#define RO_ROOT (1&lt;&lt;1)// class has .cxx_construct/destruct implementations#define RO_HAS_CXX_STRUCTORS (1&lt;&lt;2)// class has +load implementation// #define RO_HAS_LOAD_METHOD (1&lt;&lt;3)// class has visibility=hidden set#define RO_HIDDEN (1&lt;&lt;4)// class has attribute(objc_exception): OBJC_EHTYPE_$_ThisClass is non-weak#define RO_EXCEPTION (1&lt;&lt;5)// class has ro field for Swift metadata initializer callback#define RO_HAS_SWIFT_INITIALIZER (1&lt;&lt;6)// class compiled with ARC#define RO_IS_ARC (1&lt;&lt;7)// class has .cxx_destruct but no .cxx_construct (with RO_HAS_CXX_STRUCTORS)#define RO_HAS_CXX_DTOR_ONLY (1&lt;&lt;8)// class is not ARC but has ARC-style weak ivar layout #define RO_HAS_WEAK_WITHOUT_ARC (1&lt;&lt;9)// class does not allow associated objects on instances#define RO_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;10)// class is in an unloadable bundle - must never be set by compiler#define RO_FROM_BUNDLE (1&lt;&lt;29)// class is unrealized future class - must never be set by compiler#define RO_FUTURE (1&lt;&lt;30)// class is realized - must never be set by compiler#define RO_REALIZED (1&lt;&lt;31) realizeClass在某个类初始化之前，objc_class-&gt;data() 返回的指针指向的其实是个 class_ro_t 结构体。等到 static Class realizeClass(Class cls) 静态方法在类第一次初始化时被调用，它会: 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针 初始化一个 class_rw_t 结构体 设置结构体 ro 的值以及 flag 最后设置正确的 data。 将 class_ro_t 指针赋值给 class_rw_t-&gt;ro。这种偷天换日的行为是靠 RO_FUTURE 标志位来记录的： 123456789101112131415161718192021222324252627/************************************************************************ realizeClassWithoutSwift* Performs first-time initialization on class cls, * including allocating its read-write data.* Does not perform any Swift-side initialization.* Returns the real class structure for the class. * Locking: runtimeLock must be write-locked by the caller**********************************************************************/static Class realizeClassWithoutSwift(Class cls)&#123;... ro = (const class_ro_t *)cls-&gt;data(); if (ro-&gt;flags &amp; RO_FUTURE) &#123; // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro; cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE); &#125; else &#123; // Normal class. Allocate writeable class data. rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); rw-&gt;ro = ro; rw-&gt;flags = RW_REALIZED|RW_REALIZING; cls-&gt;setData(rw); &#125;...省略逻辑实现&#125; 注意之前 RO 和 RW flags 宏标记的一个细节： 12345#define RO_FUTURE (1&lt;&lt;30)#define RO_REALIZED (1&lt;&lt;31)#define RW_REALIZED (1&lt;&lt;31)#define RW_FUTURE (1&lt;&lt;30) 也就是说 ro = (const class_ro_t *)cls-&gt;data(); 这种强转对于接下来的 ro-&gt;flags &amp; RO_FUTURE 操作完全是 OK 的，两种结构体第一个成员都是 flags，RO_FUTURE 与 RW_FUTURE 值一样的。 经过 realizeClass 函数处理的类才是『真正的』类，调用它时不能对类做写操作。 Ivar在 objc-private.h 中，Ivar 被定义为一个指向 ivar_t 结构体的指针： 1#if __OBJC2__typedef struct ivar_t *Ivar; ivar_t 结构体在 objc-runtime-new.h 中定义： 123456789101112131415161718192021struct ivar_t &#123;#if __x86_64__ // *offset was originally 64-bit on some x86_64 platforms. // We read and write only 32 bits of it. // Some metadata provides all 64 bits. This is harmless for unsigned // little-endian values. // Some code uses all 64 bits. class_addIvar() over-allocates the // offset for their benefit.#endif int32_t *offset; const char *name; const char *type; // alignment is sometimes -1; use alignment() instead uint32_t alignment_raw; uint32_t size; uint32_t alignment() const &#123; if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT; return 1 &lt;&lt; alignment_raw; &#125;&#125;; Ivar 用于表示类中实例变量（成员变量）的类型，ivar_t 中定义了实例变量的名字和类型。而ivar 的修饰信息存放在了 Class 的 Ivar Layout 中。ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型。 举个例子说明，若类定义为： 1234567@interfaceFoo : NSObject &#123; __strong id ivar0; __weak id ivar1; __weak id ivar2;&#125;@end 则储存 strong ivar 的 ivarLayout 的值为 0x012000 储存 weak ivar 的 weakIvarLayout 的值为 0x1200 一个 uint8_t 在 16 进制下是两位，所以编码的值每两位一对儿，以上面的 ivarLayout 为例： 前两位 01 表示有 0 个非 strong 对象和 1 个 strong 对象 之后两位 20 表示有 2 个非 strong 对象和 0 个 strong 对象 最后两位 00 为结束符，就像 cstring 的 \\0 一样 同理，上面的 weakIvarLayout： 前两位 12 表示有 1 个非 weak 对象和接下来连续 2 个 weak 对象 00 结束符 这样，用两个 layout 编码值就可以排查出一个 ivar 是属于 strong 还是 weak 的，若都没有找到，就说明这个对象是 unsafe_unretained. Property我们知道，@property 用于声明类中的属性，在 Runtime 系统中，objc_property_t 是一个指向objc_property 结构体的指针，在 objc-private.h 中定义： 1#if __OBJC2__typedef struct property_t *objc_property_t; property_t 结构体在 objc-runtime-new.h 中定义： 1234struct property_t &#123; const char *name; const char *attributes;&#125;; MethodMethod是一种代表类中的某个方法的类型。 1#if __OBJC2__typedef struct method_t *Method; 而 objc_method 在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现： 1234567891011121314struct method_t &#123; SEL name; const char *types; MethodListIMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;; 方法名类型为 SEL，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。 方法类型 types 是个char指针，其实存储着方法的参数类型和返回值类型。 imp 指向了方法的实现，本质上是一个函数指针，后面会详细讲到。 CategoryCategory 为现有的类提供了拓展性，它是 category_t 结构体的指针。 1#if __OBJC2__typedef struct category_t *Category; category_t 存储了类别中可以拓展的实例方法、类方法、协议、实例属性和类属性。类属性是 Objective-C 2016 年新增的特性，沾 Swift 的光。所以 category_t 中有些成员变量是为了兼容 Swift 的特性，Objective-C 暂没提供接口，仅做了底层数据结构上的兼容。 1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; 在 App 启动加载镜像文件时，会在 _read_images 函数间接调用到 attachCategories 函数，完成向类中添加 Category 的工作。原理就是向 class_rw_t 中的 method_array_t, property_array_t, protocol_array_t 数组中分别添加 method_list_t, property_list_t, protocol_list_t 指针。之前讲过 xxx_array_t 可以存储对应 xxx_list_t 的指针数组。 在调用 attachCategories 函数之前，会先使用 unattachedCategoriesForClass 函数获取类中还未添加的类别列表。这个列表类型为 locstamped_category_list_t，它封装了 category_t 以及对应的 header_info。header_info 存储了实体在镜像中的加载和初始化状态，以及一些偏移量，在加载 Mach-O 文件相关函数中经常用到。 123456789101112struct locstamped_category_t &#123; category_t *cat; struct header_info *hi;&#125;;struct locstamped_category_list_t &#123; uint32_t count;#if __LP64__ uint32_t reserved;#endif locstamped_category_t list[0];&#125;; 所以更具体来说 attachCategories 做的就是将 locstamped_category_list_t.list 列表中每个 locstamped_category_t.cat 中的那方法、协议和属性分别添加到类的 class_rw_t 对应列表中。header_info 中的信息决定了是否是元类，从而选择应该是添加实例方法还是类方法、实例属性还是类属性等。源码在 objc-runtime-new.mm 文件中，很好理解。 protocol_t虽然 Objective-C 的 Category 和 protocol 拓展能力有限，但也得为了将就 Swift 的感受，充个胖子。 flags 32 位指针最后两位是给加载 Mach-O 的 fix-up 阶段使用的，前 16 位预留给 Swift 用的。 protocol 主要内容其实是（可选）方法，其次就是继承其他 protocol。Swift 还支持 protocol 多继承，所以需要 protocols 数组来做兼容。 123456789101112131415161718192021222324struct protocol_t : objc_object &#123; const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; const char *demangledName(); const char *nameForLogging() &#123; return demangledName(); &#125;... 省略一些封装的便捷 get 方法&#125;; IMPIMP在objc.h中的定义是： 1typedef void (*IMP)(void /* id, SEL, ... */ ); 它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。既然得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面会提到。 你会发现 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址；反之亦然。 总结我们可以用如下这张图来分别表示 Objective-C 2.0 版本中类和对象的定义，及相关数据结构的关系： 拓展Tagged Pointerisa 这里还涉及到 Tagged Pointer 等概念。因为 isa_t 使用 union 实现，所以可能表示多种形态，既可以当成是指针，也可以存储标志位。 Tagged Pointer：一种特殊标记的对象，Tagged Pointer 通过在其最后一个 bit 位设置为特殊标记位，并且把数据直接保存在指针本身中。Tagged Pointer 是一个”伪”对象，使用 Tagged Pointer 有 3 倍的访问速度提升，100 倍的创建、销毁速度提升。 Tips：Advances in Objective-C 在我们查看对象指针时，在 64 位系统中，我们会看到 16 进制地址如0x00000001003041e0，我们把它转换为二进制表示如下图 在 64 位系统中，我们有 64 位可以表示一个对象指针，但是我们通常没有真正使用到所有这些位。由于内存对齐要求的存在，低位始终为0，对象必须始终位于指针大小倍数的地址中。由于地址空间有限，所以高位也始终为0。所以实际上我们只在一个真正的对象指针中使用了中间的这些位，而不会用到用到2^64，这些高位和低位总是0。 苹果从这些始终为0的位中选择了低位并把它设置为1。以标识这不是一个真正的对象指针，然后就可以给其他位赋予一些其他的意义，苹果称这种指针为tagged pointer。 例如：NSNumber指针，苹果在其它位中塞入的是一个数值。（PS：这些值实际上是通过与进程启动时初始化的随机值相结合而被混淆的）。 在设置为 1 表示为 Tagged Pointer 对象之后，在最低位之后的 3 位，苹果给他赋予类型意义，由于只有 3 位，所以它可以表示 7 种数据类型 12345678OBJC_TAG_NSAtom &#x3D; 0, OBJC_TAG_1 &#x3D; 1, OBJC_TAG_NSString &#x3D; 2, OBJC_TAG_NSNumber &#x3D; 3, OBJC_TAG_NSIndexPath &#x3D; 4, OBJC_TAG_NSManagedObjectID &#x3D; 5, OBJC_TAG_NSDate &#x3D; 6, OBJC_TAG_7 &#x3D; 7 在剩余的字段中，我们可以赋予他所包含的数据。在 Intel 中，我们 Tagged Pointer 对象的表示如下 OBJC_TAG_7类型的 Tagged Pointer 是个例外，它可以将接下来后 8 位作为它的扩展类型字段，基于此我们可以多支持 256 中类型的 Tagged Pointer，如 UIColors 或 NSIndexSets 之类的对象。 OC对象占用的大小初始OC对象占用内存OC中对象大部分继承至NSObject。NSObject类的定义如下： 123456789OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ROOT_CLASSOBJC_EXPORT@interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125; 上文中提到Class其实就是一个指向 struct objc_class 结构体类型的指针.。那么也就是说 NSObject 对象对应的结构体只包含一个 isa 指针变量 ，一个指针变量在 64 位的机器上大小是 8 个字节。 那是不是说一个 NSObject 对象就占用8个字节大小的内存呢？实际上不是的. 答案其实是: 所有的OC对象至少为16字节. 我们先来验证一下。 12345678910#import &lt;Foundation&#x2F;Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; &#x2F;&#x2F; insert code here... NSObject *obj &#x3D; [[NSObject alloc] init]; NSLog(@&quot;Hello, World! %@&quot;,obj); &#125; return 0;&#125; 打印语句加个断点。 lldb中打印得出：对象实际占用的内存大小为8，实际分配的内存大小为16。 lldb查看布情况，可以看出创建的对象后面几个字节全部为 00。 我们可以通过阅读 objc4 的源码来找到答案。通过查看跟踪 obj4 中 alloc 和 allocWithZone 两个函数的实现，会发现这个连个函数都会调用一个 instanceSize 的函数： 123456size_t instanceSize(size_t extraBytes) &#123; size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16bytes. if (size &lt; 16) size = 16; return size; &#125; 上面源码中我们看出了答案, 最少会开辟16个字节. 那么为什么非要用 16 个字节来存储 8 个字节的内容呢? 这里简单解释一下 . 其实这里主要是涉及到硬件问题, 因为不同厂商之间需要一套标准化方案来解决不同厂商之间规则不同导致内存读取使用出现不统一的情况.为了解决这种问题而产生的 字节对齐. 讲到这里,我还想继续看下 当这个对象包含多个属性时使用内存情况. 以便我们彻底搞明白 OC 对象使用内存情况. 包含其他属性占用内存情况创建一个 Person 类,继承与 NSObject , 其包含三个 int 属性。修改main.m 文件如下： 12345678910111213141516171819202122#import &lt;Foundation&#x2F;Foundation.h&gt;@interface Person : NSObject@property (nonatomic, assign) int age;@property (nonatomic, assign) int height;@property (nonatomic, assign) int row;@end@implementation Person@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *obj &#x3D; [[Person alloc] init]; obj.age &#x3D; 4; obj.height &#x3D; 5; obj.row &#x3D; 6; NSLog(@&quot;Hello, World! %@&quot;,obj); &#125; return 0;&#125; lldb打印对象内存情况如下 ![屏幕快照 2021-08-22 下午11.50.02](/Users/ethenfarben/Desktop/屏幕快照 2021-08-22 下午11.50.02.png) 对象实际占用内存大小为24，实际分配的内存大小为32。 ![屏幕快照 2021-08-22 下午11.41.12](/Users/ethenfarben/Desktop/屏幕快照 2021-08-22 下午11.41.12.png) 这里就出现一个比较奇怪的现象 , 实际需要内存大小 24, 为什么呢 ? 其实这里就是 结构体内存分配的原理了. 结构体每个成员相对于结构体首地址的偏移量都是这个成员大小的整数倍，如果有需要，编译器会在成员之间加上填充字节 结构体的总大小为结构体最宽成员大小的整数倍。 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。 对于结构体成员属性中包含结构体变量的复合型结构体，在确定最宽基本类型成员时，应当包括复合类型成员的子成员。但在确定复合类型成员的偏移位置时则是将复合类型作为整体看待。 由于原本结构体 isa指针占用8个 , age属性占用4个, height占用 4个, row属性再占用4个 , 这中间由于满足整除并没有自动偏移补充. 而由于 : 结构体的总大小为结构体最宽成员大小的整数倍 , 而且对线开辟满足 16 字节对齐原则 ( 可以在 libmaclloc 源码查找到 ) , 因此实际总占用内存为24. 而实际开辟则满足对齐标准开辟为 32. 在 libmaclloc 源码 , nano_malloc.c 中 1234567891011121314static MALLOC_INLINE size_tsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)&#123; size_t k, slot_bytes; if (0 == size) &#123; size = NANO_REGIME_QUANTA_SIZE; // Historical behavior &#125; k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // round up and shift for number of quanta slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; // multiply by power of two quanta size *pKey = k - 1; // Zero-based! return slot_bytes;&#125; 其中NANO_REGIME_QUANTA_SIZE 和 SHIFT_NANO_QUANTUM在nano_zone_common.h中定义如下： 12#define SHIFT_NANO_QUANTUM 4#define NANO_REGIME_QUANTA_SIZE (1 &lt;&lt; SHIFT_NANO_QUANTUM) &#x2F;&#x2F; 16 所以16字节对齐算法为：size + (2^4 - 1) &gt;&gt; 4 &lt;&lt; 4。 总结 (只考虑64位): OC对象 最少占用 16个字节内存 . 当对象中包含属性, 会按属性占用内存开辟空间. 在结构体内存分配原则下自动偏移和补齐 . 对象最终满足 16字节对齐标准 . 属性最终满足 8字节对齐标准 . 可以通过 #pragma pack() 自定义对齐方式 . 更新在2020年WWDC中，Runtime又有了一些更新。详见：2020 – Advancements in the Objective-C runtime主要更新内容如下: 数据结构的变化在介绍更新之前，先了解一下二进制类在磁盘中的表示。 ![屏幕快照 2021-08-21 下午9.40.03](/Users/ethenfarben/Desktop/屏幕快照 2021-08-21 下午9.40.03.png) 首先是类对象本身，包含最常访问的信息：指向元类，超类和方法缓存的指针，在类结构之中有指向包含更多数据的结构体class_ro_t的指针，包含了类的名称，方法，协议，实例变量等等编译期确定的信息。 当类被 Runtime 加载之后，类的结构会发生一些变化，在了解这些变化之前，我们需要知道2个概念： Clean Memory：加载后不会发生更改的内存块，class_ro_t属于Clean Memory，因为它是只读的。 Dirty Memory：运行时会进行更改的内存块，类一旦被加载，就会变成Dirty Memory，例如，我们可以在 Runtime 给类动态的添加方法。 这里要明确，Dirty Memory比Clean Memory要昂贵得多。因为它需要更多的内存信息，并且只要进程正在运行，就必须保留它。对于我们来说，越多的Clean Memory显然是更好的，因为它可以节约更多的内存。我们可以通过分离出永不更改的数据部分，将大多数类数据保留为Clean Memory，如何怎么做的呢？ 在介绍优化方法之前，我们先来看一下，在类加载之后，类的结构会变成如何呢？ ![屏幕快照 2021-08-21 下午9.44.24](/Users/ethenfarben/Desktop/屏幕快照 2021-08-21 下午9.44.24.png) 在类加载到 Runtime 中后会被分配用于读取/写入数据的结构体class_rw_t。 Tips：class_ro_t是只读的，存放的是编译期间就确定的字段信息；而class_rw_t是在 runtime 时才创建的，它会先将class_ro_t的内容拷贝一份，再将类的分类的属性、方法、协议等信息添加进去，之所以要这么设计是因为 Objective-C 是动态语言，你可以在运行时更改它们方法，属性等，并且分类可以在不改变类设计的前提下，将新方法添加到类中。 事实证明，class_rw_t会占用比class_ro_t占用更多的内存，在 iPhone 中，我们在系统测量了大约 30MB 的这些class_rw_t结构。应该如何优化这些内存呢？通过测量实际设备上的使用情况，我们发现大约 10％ 的类实际会存在动态的更改行为，如动态添加方法，使用 Category 方法等。因此，我们能可以把这部分动态的部分提取出来，我们称之为class_rw_ext_t，所以，结构会变成这个样子。 ![屏幕快照 2021-08-21 下午10.05.15](/Users/ethenfarben/Desktop/屏幕快照 2021-08-21 下午10.05.15.png) 经过拆分，可以把 90% 的类优化为Clean Memory，在系统层面，取得效果是节省了大约 14MB 的内存，使内存可用于更有效的用途。 Tips：head xxxxx | egrep &#39;class_rw|COUNT’ 你可以使用此命令来查看 class_rw_t 消耗的内存。xxxx可以替换为需要测量的 App 名称。如：head Mail | egrep &#39;class_rw|COUNT’\\&#39;查看 Mail 应用的使用情况。 Tagged pointer格式的变化相比于之前的Tagged pointer，在 ARM64 中格式有些变化。 ![屏幕快照 2021-08-22 上午5.33.02](/Users/ethenfarben/Desktop/屏幕快照 2021-08-22 上午5.33.02.png) 不同于以往，苹果使用最高位代表 Tagged Pointer 标识位，低位 3 位标识 Tagged Pointer 的类型，接下去的位来表示包含的数据（可能包含扩展类型字段），为什么我们使用高位指示 ARM上 的 Tagged Pointer，而不是像 Intel 一样使用低位标记？ 它实际是对 objc_msgSend 的微小优化。我们希望 msgSend 中最常用的路径尽可能快。最常用的路径表示普通对象指针。我们有两种不常见的情况：Tagged Pointer 指针和 nil。事实证明，当我们使用最高位时，可以通过一次比较来检查两者。与分别检查 nil 和 Tagged Pointer 指针相比，这会为 msgSend 中的节省了条件分支。 应用判断类有没有初始化很多技术博客里都提到了，ObjC类的meta class里，自带了一个标记自己有没有初始化过的flag，即class_rw_t–&gt;flags里的RW_INITIALIZED。objc_class类中有提供了封装的函数供外部快速获取该flag值。调用相关代码如下： 12345678910111213141516171819202122// objc_class 代码片段struct objc_class : objc_object &#123;... class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125;... bool isInitialized() &#123; return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED; &#125; void setInitialized();... // NOT identical to this-&gt;ISA when this is a metaclass Class getMeta() &#123; if (isMetaClass()) return (Class)this; else return this-&gt;ISA(); &#125;...&#125; 123456789101112struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;...public: class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;...&#125; 12345struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags;...&#125; 可惜的是，这些方法对我们app来说，是不可见的，没办法直接调用。所以如果想要在运行过程中获取类的初始化状态，只能另想办法。从方法的调用情况看到方法的过程大概分为4步： 我们要先找到类的meta class。 获取objc_class的成员变量bits（class_data_bits_t结构体） 调用class_data_bits_t结构体的data()方法，对结构体的bits属性进行位运算，获取class_rw_t结构体 最后获取class_rw_t结构体的成员变量flags并进行位运算 因为runtime源代码是用C++来写的，所以我们可以通过偏移地址获取到用到的变量，直接用指针来搞定问题。 针对第一步，获取类的meta class，是个runtime里可见的方法，直接调用objc_getMetaClass()方法就能拿到。 第二步获取objc_class的成员变量bits。回到objc_class的头部几行： 1234567891011struct objc_class : objc_object &#123; objc_class(const objc_class&amp;) = delete;// 0 bytes objc_class(objc_class&amp;&amp;) = delete;// 0 bytes void operator=(const objc_class&amp;) = delete;// 0 bytes void operator=(objc_class&amp;&amp;) = delete;// 0 bytes // Class ISA; Class superclass; // 8 bytes cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags...&#125; 首先objc_class 继承至 objc_object，对于子结构体来说，是需要继承父结构体的成员变量的。runtime源代码是用C++来写的，函数都不会占用类meta信息（或者说实例）的内存地址，只有成员变量会占用地址。objc_object父结构如前表述，仅包含isa这个成员变量，占用类实例的头8个bytes，也就是64位CPU的一个指针的长度；而下面的一堆方法，在实例里面一点内存都不占用。然后看完整个结构体，只有这么一个成员变量，所以总长度也就8个bytes。 objc_class内前面几行那几个函数禁用语句，不会产生内存地址的偏移，先不管它们。 superclass作为一个指针（对，Class类型实际上是一个指向结构体的指针），长度为8 bytes。 接下来是cache_t类型的变量cache，它占用了多少bytes我们就要展开看看了。 123456789101112131415161718192021#if __LP64__typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t;#endif...struct cache_t &#123;private: explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;// 8 bytes union &#123; struct &#123; explicit_atomic&lt;mask_t&gt; _maybeMask;//4 bytes#if __LP64__ uint16_t _flags;//2 bytes#endif uint16_t _occupied;//2 bytes &#125;; explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;// 8 bytes &#125;;...&#125; 首先说一下explicit_atomic&lt;T&gt;，它只是负责把模板里的类型包成atomic的，不会对变量占用的内存长度产生影响。 然后要说一下union，C++的老朋友了，联合体内部的成员取最长的一个内存长度，就是联合体的内存长度，这里就是8 bytes。 mask_t的定义在文件头就能找到，其实在64位CPU下就是一个uint32_t而已。 基于上面的介绍，可以推断出整个cache_t结构体的长度就是8 bytes + 8 bytes = 16 bytes。 综上，bits 偏移量为：父结构体objc_object的isa成员变量（8 bytes）+ objc_class结构体的superclass成员变量（8 bytes）+ objc_class结构体的cache成员变量（16 bytes） = 32 bytes。 第三步、第四步，很凑巧的是bits和flags都是两个结构体里的第一个成员变量，那么我们就不需要继续计算偏移了，只需要关注data()函数的具体取值方法即可。 最终我们从一个Class类型，取到它有没有被初始化过的代码大致如下： 1234567Class metaCls &#x3D; objc_getMetaClass(class_getName(cls));if (metaCls) &#123; uint64_t *bits &#x3D; (__bridge void *)metaCls + 32; &#x2F;&#x2F; 在 metaClass 基地址上加上 32 bits 的偏移 uint32_t *data &#x3D; (uint32_t *)(*bits &amp; FAST_DATA_MASK); &#x2F;&#x2F; 模拟 data() 函数取值 return (*data &amp; RW_INITIALIZED); &#x2F;&#x2F; 模拟 isInitialized() 函数最后一步与操作&#125;return NO;","categories":[],"tags":[]},{"title":"刨根问底Autorelease","slug":"autorelease-pool","date":"2020-07-14T01:40:47.208Z","updated":"2020-07-14T03:27:40.046Z","comments":true,"path":"2020/07/14/autorelease-pool/","link":"","permalink":"http://heseng91.github.io/2020/07/14/autorelease-pool/","excerpt":"","text":"Autorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用[obj autorelease]来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？刨根问底，一起来探究下黑幕背后的Autorelease机制。 Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Hello World!","slug":"hello-world","date":"2020-07-13T17:40:23.790Z","updated":"2020-07-14T03:27:36.902Z","comments":true,"path":"2020/07/14/hello-world/","link":"","permalink":"http://heseng91.github.io/2020/07/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}