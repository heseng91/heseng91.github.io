{"meta":{"title":"和僧","subtitle":"","description":"技术博客","author":"和僧","url":"http://heseng91.github.io","root":"/"},"pages":[],"posts":[{"title":"「性能优化」之启动优化","slug":"「性能优化」之启动优化","date":"2021-10-30T21:15:27.276Z","updated":"2021-11-22T19:53:32.644Z","comments":true,"path":"2021/10/31/「性能优化」之启动优化/","link":"","permalink":"http://heseng91.github.io/2021/10/31/%E3%80%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E3%80%8D%E4%B9%8B%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/","excerpt":"","text":"「性能优化」之启动优化启动是 App 给用户的第一印象，启动越慢用户流失的概率就越高，良好的启动速度是用户体验不可缺少的一环。本文先梳理app构建和启动流程，并结合app构建和启动流程讲述一些可优化点。 因为启动涉及面很广，牵扯很多概念。鉴于网上相关概念定义已经比较多了，本文将通过技术的发展及实际问题来介绍这个技术 or 概念。 IPA 构建编译和链接技术发展史计算机只能处理由0和1两个二进制数组成的数据。各种用二进制编码方式表示的指令，叫做机器指令码。 在计算机早期阶段，必须用机器码写程序。具体来讲，就是先在纸上用英语写一个高层次的版本，也就是对程序的高层次描述，叫 “伪代码”，然后用”操作码表”把伪代码转成二进制机器码，再给计算机喂码。 机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，而且需要人工计算每个子程序或者跳转的目标地址，当程序修改的时候，这些位置需要重新计算，十分繁琐又耗时，并且很容易出错。 于是，先驱者发明了汇编语言。汇编语言使用使用接近人类的各种符号和标记来帮助记忆，于是程序员不再使用0和1写代码，转而使用 “jmp”这样的助记符；汇编语言还可以用符号来标记位置。比如如果一种计算机，它的每条指令是一个字节，也就是8位，我们假设有一种跳转指令，它的高4位是0001，表示这是一条跳转指令，低4位存放的是跳转目的地的绝对地址。 1234560 0001 01001 ...2 ...3 ...4 1000 01115 ... 那么以上表示的就是程序的第一条指令为一个跳转指令，它的目的地址是第5条指令。使用汇编后，如果我们把刚开始第5条指令开始的子程序命名为“foo”，那么第一条指令的汇编就是：jmp foo，相比 00010100要好记太多。 然而虽然使用汇编语言之后，方便了人类记忆和编码，但是计算机并不认识助记符和符号（symbol），于是就需要使用二进制编制”汇编器” 来转译”助记符”或者叫做”汇编语言”，形成”机器码” 这样计算机就可以读懂了。汇编器在每次汇编程序的时候，会重新计算“foo”这个符号的地址，然后把所有引用到“foo”的指令修正到这个正确的地址。整个过程不需要人工参与，极大地提高了生产力。随着生产力的提高，软件的规模也开始日渐庞大，代码量开始快速膨胀。人们开始思考将不同功能的代码以一定的方式组织起来，使得更加容易阅读和理解，以便于日后修改和重复使用。自然而然，人们开始将代码按照功能和性质划分，分别形成不同的功能模块，不同的模块之间按照层次结构或其他结构来组织。随着软件规模变大，多则数百万行，如果都放在一个模块肯定无法想象。所以大型软件往往拥有成千上万个模块，这些模块互相依赖又相对独立。在一个程序被分割成多个模块以后，这些模块之间最后如何组合形成一个单一的程序是须解决的问题。模块之间如何组合的问题可以归结为模块之间如何通信的问题，通信可分两种，一种是模块间的函数调用，另外一种是模块间的变量访问。函数访问须知道目标函数的地址，变量访问也须知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是模块间符号的引用。模块间依靠符号来通信类似于拼图版，定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域，两者一拼刚好完美组合，这个模块的拼接过程就是：链接。从原理上来讲，链接的工作无非就是把一些指令对其它符号的引用加以修正。 汇编只是修饰了一下机器码。一般来说，一条汇编指令对应一条机器指令，所以汇编码和底层硬件的连接很紧密。汇编器仍然强迫程序员思考，用什么寄存器和内存地址。所以汇编语言编写起来也不容易，阅读和理解很难。而且汇编语言的编写严格依赖于特定的机器，所以在一种计算机编写的代码在应用于另一种算机时可能需要完全重写。 为了进一步将程序员从直接使用地址编程的梦魇中解救出来，人们开始探索以一个更类似于数学定义或自然语言的简洁形式来编写程序的操作，它应与任何机器都无关，而且也可由一个程序翻译为可执行的代码。在这种背景下，以后很多人开始创作编程语言，编译器也应运而生。这些语言中就包括上世纪80年代初被发明的Objective-C，它需要编译器专门把高级语言转换成低级语言。大多数编译器由两部分组成：前端和后端。 前端负责词法分析、语法分析、生成中间代码； 后端以中间代码作为输入，进行与架构无关的代码优化，接着针对不同架构生成汇编不同的机器码。 前后端依赖统一格式的中间代码（IR），使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个 CPU 架构只需要修改后端即可。 Objective-C/C/C++ 使用的编译器前端是clang，swift 是 swiftc，后端都是 LLVM。 clang 编译源代码转化生成mach-o的大致流程如下： pipeline除了代码文件之外，现代移动软件不可避免为会有一些资源文件（如 storyboard，asset ），这些资源文件也需要编译以加快加载速度，然后，同资源文件一起打包成.app。最后出乎安全考虑，还需要对.app进行签名，防篡改。 以单 Target 为例，整个构建流程如下： 源文件(.m/.c/.swift 等)是单独编译的，输出对应的目标文件(.o) 目标文件和静态库/动态库一起，链接出最后的 Mach-O Mach-O 会被裁剪，去掉一些不必要的信息 资源文件如 storyboard，asset 也会编译，编译后加载速度会变快 Mach-O 和资源文件一起，打包出最后的.app 对.app 签名，防篡改 主要可分为如下几个阶段： 编译编译器构成如下： 编译的具体转化过程如下： 1、预处理（preprocessor）：预处理会进行头文件引入、宏替换、注释处理、条件编译（#ifdef）等操作； 2、词法分析（lexical anaysis）：词法分析器读入源文件的字符流，将它们组织成有意义的词素（lexeme）序列，对于每个词素，词法分析器产生词法单元（token）作为输出； 3、语法分析（semantic analysis）：词法分析的 Token 流会被解析成一颗抽象语法树（abstract syntax tree - AST）。有了抽象语法树，clang 就可以对这个树进行分析，找出代码中的错误。比如类型不匹配，亦或 Objective-C 中向 target 发送了一个未实现的消息。AST 是开发者编写 clang 插件主要交互的数据结构，clang 也提供很多 API 去读取 AST。更多细节：Introduction to the Clang AST； 4、CodeGen：CodeGen 遍历语法树，生成 LLVM IR 代码。LLVM IR 是前端的输出，后端的输入。Objective-C 代码在这一步会进行 runtime 的桥接：property 合成、ARC 处理等。LLVM 会对生成的 IR 进行优化，优化会调用相应的 Pass 进行处理。Pass 由多个节点组成，都是 Pass 类的子类，每个节点负责做特定的优化，更多细节：Writing an LLVM Pass； 5、生成汇编代码：LLVM 对 IR 进行优化后，会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出； 6、汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出目标文件（object file）。 链接连接器把编译产生的 .o 文件和（dylib、a、tbd）文件，生成一个 mach-o 文件。链接的过程并不产生新的代码，只会做一些移动和补丁。 tbd 的全称是 text-based stub library，是因为链接的过程中只需要符号就可以了，所以 Xcode 6 开始，像 UIKit 等系统库就不提供完整的 Mach-O，而是提供一个只包含符号等信息的 tbd 文件。 裁剪编译完 Mach-O 之后会进行裁剪(strip)，是因为里面有些信息，如调试符号，是不需要带到线上去的。裁剪有多种级别，一般的配置如下： All Symbols，主二进制 Non-Global Symbols，动态库 Debugging Symbols，二方静态库 为什么二方库在出静态库的时候要选择 Debugging Symbols 呢？是因为像 order_file 等链接期间的优化是基于符号的，如果把符号裁剪掉，那么这些优化也就不会生效了。 签名 &amp; 上传裁剪完二进制后，会和编译好的资源文件一起打包成.app 文件，接着对这个文件进行签名。签名的作用是保证文件内容不多不少，没有被篡改过。接着会把包上传到 iTunes Connect，上传后会对__TEXT段加密，加密会减弱 IPA 的压缩效果，增加包大小，也会降低启动速度（iOS 13 优化了加密过程，不会对包大小和启动耗时有影响）。 以上就是ipa构建相关，接下来重点了解一下App启动流程。 启动流程概念从appstore下载的安装包，是保存在磁盘中的，要运行就需要载入到内存。 下面介绍一下链接和装入技术的发展史： 一、静态链接、静态装入这种方法最早被采用，其特点是简单，不需要操作系统提供任何额外的支持。程序的不同模块可以并行开发，分别独立编译为相应的目标文件。在得到了所有的目标文件后，静态链接、静态装入的做法是将所有目标文件链接成一个可执行映象，随后在创建进程时将该可执行映象一次全部装入内存。 举个简单的例子，假设我们开发了两个程序Program1和Program2，Program1由main1.c、utilities.c以及errhdl1.c三部分组成，分别对应程序的主框架、一些公用的辅助函数（其作用相当于库）以及错误处理部分，这三部分代码编译后分别得到各自对应的目标文件main1.o、utilities.o以及errhdl1.o。同样，Program2由main2.c、utilities.c以及errhdl2.c三部分组成，三部分代码编译后分别得到各自对应的目标文件main2.o、utilities.o以及errhdl2.o。值得注意的是，这里Program1和Program2使用了相同的公用辅助函数utilities.o。当我们采用静态链接、静态装入的方法，同时运行这两个程序时内存和硬盘的使用情况如下图所示： 这种方式会带来如下问题： 安全问题 ：由于在内存条中使用的都是真实物理地址，而且内存条中各个应用进程都是按顺序依次排列的。 那么在 进程1 中通过地址偏移就可以访问到 其他进程 的内存。 内存空间浪费问题：假如程序在运行过程中没有出现任何错误，那么错误处理部分的代码就不应该被装入内存。但是操作系统在创建进程时将程序的可执行映象一次全部装入内存，之后进程才能开始运行。造成很大的内存浪费。 硬盘空间浪费问题：就硬盘的使用来讲，既然两个程序共享使用了utilities，那么我们只要在硬盘上保存utilities.o的一份拷贝应该就足够了，但这并没有在硬盘保存的可执行程序映象上体现出来。相反，utilities.o被链接进了每一个用到它的程序的可执行映象。 二、静态链接、动态装入前面提到，静态链接、静态装入由于直接暴露的是物理地址，所以进程可以访问到任何物理地址，地址空间缺乏保护，会有比较严重的安全问题。另外，内存紧张的问题在早期的系统中显得更加突出，因此人们首先想到的是要解决内存空间使用方面的问题。为了给进程提供独立而互不访问的内存空间同时提高内存使用效率，于是虚拟内存应运而生了。 虚拟内存工作原理虚拟内存是在物理内存之上建立的一层逻辑地址，保证内存访问安全的同时为应用提供了连续的地址空间。 引用了虚拟内存后，在进程创建时，虚拟内存管理器会为每个进程创建一个称作逻辑地址的空间，并将这些地址空间分割成了大小一致的块，这样的块称之为“页”。分页的概念，下面会详细讲述。对进程而言，它的逻辑地址空间中的地址总是可访问的。因此进程会认为自己拥有连续的可用的内存（一个连续完整的地址空间），但是实际上这个内存地址只是一个虚拟地址，虚拟地址需要经过一张映射表映射后才可以获取到真实的物理地址，这样就限制了对真实物理地址的访问。映射表是进程和它的内存管理单元（MMU）维护的一个页表，该页表将程序的逻辑内存地址空间和实际的物理内存地址空间做了映射。映射过程如下： 1、cpu通过虚拟内存地址，找到对应进程的映射表。 2、通过映射表找到其对应的真实物理地址，进而找到数据。 这个过程又被称为 地址翻译，是由操作系统以及 cpu上集成的 硬件单元 MMU 协同来完成的。找到数据后，mmap到内存。mmap的全称是 memory map，是一种内存映射技术，可以把文件映射到虚拟内存的地址空间里，这样就可以像直接操作内存那样来读写文件。 整个虚拟内存的工作原理这里用一张图来展示： 虚拟内存解决效率问题刚刚提到虚拟内存空间会被分页，实际上物理内存也会被划分为大小相同的页（page）。虚拟内存空间和物理内存空间都以页作为内存空间的最小单位，而映射表同样是以页为单位的。换句话说，映射表最小只会映射到一页，并不会映射到具体每一个地址。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。 对内存分页之后，可以对物理内存进行离散使用。由于存在映射过程，所以虚拟内存对应的物理内存可以任意存放，也不需要一一对应，这样就方便了操作系统对物理内存的管理，也能够可以最大化利用物理内存。同时，也可以采用一些页面调度（Paging）算法，利用翻译过程中也存在的局部性原理，将大概率被使用的帧地址加入到 TLB 或者页表之中，提高翻译的效率。 由于可以对物理内存进行离散使用，人们就可以采用动态装入的方式来优化内存浪费问题。其想法也非常简单，即一个函数只有当它被调用时，其所在的模块才会被装入内存。 仍然以上面提到的两个程序Program1和Program2为例，假如Program1运行过程中出现了错误而Program2在运行过程中没有出现任何错误。当我们采用静态链接、动态装入的方法，同时运行这两个程序时内存和硬盘的使用情况如下图所示： （ 上图中我们也看出，实际物理内存并不是连续以及某个进程完整的）。 当应用被加载到内存中时，并不会将整个应用加载到内存中 。只会放用到的那一部分。也就是动态载入的概念，换句话说就是应用使用多少，实际物理内存就实际存储多少。映射表左侧的 0和 1代表当前地址有没有在物理内存中。当应用访问到某个地址，映射表中为 0，也就是说并没有被加载到物理内存中时，系统就会立刻阻塞整个进程， 触发一个我们所熟知的 缺页中断 - Page Fault。当一个缺页中断被触发，操作系统会从磁盘中重新读取这页数据到物理内存上，然后将映射表中虚拟内存指向对应（如果当前内存已满，操作系统会通过置换页算法 找一页数据进行覆盖，这也是为什么开再多的应用也不会崩掉， 但是之前开的应用再打开时，就重新启动了的根本原因）。通过这种分页和覆盖机制，就完美的解决了内存浪费和效率问题。 安全问题：针对静态链接、静态装入阶段通过地址偏移就可以访问到 其他进程 的内存的安全问题，引用虚拟内存后就不存在了。因为每个进程的映射表是单独的，实际上在进程中每次进行地址翻译，都会先使用界限寄存器判断是否越界，没有越界才会加上基址寄存器的值，转换为物理内存地址。这样就能保证真实物理地址永远在规定范围内，也就不存在通过偏移获取到其他进程的内存空间的问题了。 但是随之而来的确是另外一个安全问题。当应用开发完成以后由于采用了虚拟内存 , 那么其中一个函数无论如何运行，运行多少次，都会是虚拟内存中的固定地址。假设应用有一个函数，基于首地址偏移量为 0x00a000，那么虚拟地址从 0x000000 ~ 0xffffff，基于这个，那么这个函数我无论如何只需要通过 0x00a000这个虚拟地址就可以拿到其真实实现地址。而这种机制就给了很多黑客可操作性的空间，他们可以很轻易的提前写好程序获取固定函数的实现进行修改 hook操作。 为了解决这个问题 , ASLR应运而生。 其原理就是 每次虚拟地址在映射真实地址之前，增加一个随机偏移值，以此来解决我们刚刚所提到的这个问题。 三、动态链接、动态装入采用静态链接、动态装入的方法后看似只剩下硬盘空间使用效率不高的问题了，实际上内存使用效率不高的问题仍然没有完全解决。图2中，既然两个程序用到的是相同的utilities.o，那么理想的情况是系统中只保存一份utilities.o的拷贝，无论是在内存中还是在硬盘上，于是人们想到了动态链接。 下面我们就来看看上面提到的两个程序Program1和Program2在采用动态链接、动态装入的方法，同时运行这两个程序时内存和硬盘的使用情况（见下图）。仍然假设Program1运行过程中出现了错误而Program2在运行过程中没有出现任何错误。 动态链接的这一特性对于库的升级（比如错误的修正）是至关重要的。当一个库升级到一个新版本时，所有用到这个库的程序将自动使用新的版本。如果不使用动态链接技术，那么所有这些程序都需要被重新链接才能得以访问新版的库。为了避免程序意外使用到一些不兼容的新版的库，通常在程序和库中都包含各自的版本信息。内存中可能会同时存在着一个库的几个版本，但是每个程序可以通过版本信息来决定它到底应该使用哪一个。如果对库只做了微小的改动，库的版本号将保持不变；如果改动较大，则相应递增版本号。因此，如果新版库中含有与早期不兼容的改动，只有那些使用新版库进行编译的程序才会受到影响，而在新版库安装之前进行过链接的程序将继续使用以前的库。这样的系统被称作共享库系统。 相比之前的静态链接，动态链接有以下几点好处： 代码共用：图中，无论是硬盘还是内存中都只存在一份utilities.o的拷贝。内存中，两个进程通过将地址映射到相同的utilities.o实现对其的共享。解决了共享的目标文件存在多个副本浪费磁盘和内存空间的问题； 提高载入速度：减少物理页面的换入换出，还增加了CPU的缓存命中率，因为不同进程间的数据和指令访问都集中在了同一个共享模块上； 易于维护：由于被依赖的 lib 是程序执行时才 link 的，所以这些 lib 很容易做更新。系统升级只需要替换掉对应的共享模块，当程序下次启动时新版本的共享模块会被自动装载并链接起来，程序就无感的对接到了新版本。 减少可执行文件体积：相比静态链接，动态链接在编译时不需要打进去，所以可执行文件的体积要小很多 dyld引入动态装载后，就不得不提dyld，全名 The dynamic link editor，他是苹果的平台用于加载链接库的帮助程序，主要提供动态加载的支持。APP启动的时候会把 dyld 加载到进程的地址空间里，然后把后续的启动过程交给 dyld。dyld是开源的，我们可以在官网下载它的源码来阅读理解。 dyld发展简史dyld 1.0 (1996-2004)dyld 最初是作为NeXTStep 3.3的一部分于1996年上市的，所以其实没有版本号的，为了方便追溯苹果将当时的dyld版本命名的为1.0。dyld诞生背景： dyld 1.0 发明之前NeXT使用的都是静态二进制数据 POSIX dlopen调用还没有标准化：当时人们采用的是定制拓展的方式来在Unix上支持dlopen。在NeXTStep上使用的是不同的拓展。为了在NeXTStep上运行标准的Unix软件，有人在macOS 10的早期版本上编写了第三方包装程序。问题是由于并不完全支持相同的语义，在一些奇怪的边缘情况下，会不起作用，而且也会导致程序运行的比较慢。 没有广泛使用C++动态库：很重要的一点，dyld 1.0 发布时，大多数系统还没有使用大型c++动态库。c++有一些特性，比如初始化命令，在静态系统中可以很好的运行，但是在动态系统中很难至少是性能方面很难高性能的运行。基于c++的庞大代码库会导致动态链接器需要做很多工作，而且速度相当慢。 在发布macOS 10.0(Cheetah)前，苹果为dyld增加了一个特性，即Prebinding预绑定。预绑定会尝试查找每个系统dylib和程序二进制文件中需要修正地址，然后动态加载程序会尝试加载所有这些地址中需要的文件，如果加载成功，它会编辑所有的二进制文件，使用预计算地址替换需要修正的地址。这样当下一次需要加载到相同的地址时，就不需要做任何额外的工作了。这大大加快了启动速度，但这意味着我们在每次启动时都要编辑你的二进制文件，这不仅不安全，也会有一些其它的问题。 dyld 2 (2004-2007)鉴于dyld已经不能满足软件需要，并且也会有安全问题等等的问题。dyld 2作为苹果macOS Tiger的一部分被出了。dyld 2 是对dyld的完全重写，可以正确支持C++ initializer语义，同时扩展了mach-o格式并更新dyld,以获得了高效率C++库的支持。dyld 2使用正确的语义完整实现了本地的dlopen和dlsym功能，由此苹果弃用了传统API。dyld 2 是为提升速度而设计，因此只有有限的完整性检查，当时不像今天有这么多的恶意软件。也正因为只有有限的完整性检查，dyld 2会有安全问题，为此苹果不得不重新调整一些功能，使它在今天的平台上更安全。最后由于启动速度的大幅提升，我们可以减少Prebinding的工作量。相较于dyld 1的编辑程序数据，现在仅会编辑系统库，且可以仅在软件更新时做这些事情。现在Prebinding被用于所有的优化，但那是推动力。因此在软件更新过程中，可能会看到“优化系统性能”类似的文字。这就是在更新时进行Prebinding。当今这已被用于所有的优化。 dyld 2.x (2007-2017)相较于 dyld 2，过去的几年里我们做了很多非常重要的改进。 1、首先，我们添加了大量的架构和平台。 自从dyld 2在PowerPC发布之后，增加了x86、x86_64、arm、arm64和许多的衍生平台。 还推出了iOS、tvOS和watchOS，这些都需要新的dyld功能 2、通过多种方式增加安全性 增加 codeSigning代码签名 ASLR（Address space layout randomization）地址空间配置随机加载：每次加载库时，可能位于不同的地址 bound checking边界检查：mach-o文件中增加了Header的边界检查功能，从而避免恶意二进制数据的注入 3、提升性能 用share cache共享缓存完全替代prebinding。share cache是一个包含大多数系统dylibs的单一文件，由苹果在iOS 3.1和macOS Snow Leopard中引入。由于是单一文件，我们可以以下通过多种方式优化： 重新排列二进制文件以提高加载速度 预链接dylibs 预构建dyld和obc在运行时使用的数据结构 尽管dyld 2.x已经有了比较多的改进，但是仍有一些不足： 1、首先，性能方面：针对一些不能复现的场景，我们希望能采集到启动速度全面的数据。除此之外，我们还在思考，怎样最小化或者理论上最小化app启动过程中的工作量，以及我们要怎样实现这一目标； 2、其次，安全方面：如前所述，苹果在dyld 2中通过多种方式增加了安全性。但是后面再想增加更多安全性已经很困难了，因此需要有更积极的安全检查，也需要预先为安全方面。 3、最后，可测试性和可靠性：苹果发布了大量优秀的测试框架，例如XCTest，这些框架都依赖于动态链接器的底层功能来将这些库插入到进程中，从根本上说不能用于测试现有的dyld代码，所以很难验证其安全性和性能。 dyld 3 (2017-至今)鉴于以上原因，苹果在2017年WWDC推出了全新的动态链接器，dyld 3。dyld 3是苹果对动态连接的一次全新思考。2017 年开始Apple OS平台上的所有系统程序都已经默认使用dyld 3。iOS 13 开始 Apple 对三方 App 启用了 dyld3。 那么dyld 3相比 dyld 2是怎么做优化的呢？要回答这个问题，需要先简要介绍分别介绍一下app的启动流程。 用户点击图标之后，会发送一个系统调用 execve 到内核，内核创建进程。接着会把主二进制 mmap 进来，读取 load command 中的LC_LOAD_DYLINKER，找到 dyld 的的路径。然后 mmap dyld 到虚拟内存，找到 dyld 的入口函数_dyld_start，把 PC 寄存器设置成_dyld_start，接下来启动流程交给了 dyld。 dyld 2的工作流程图如下： 1、首先，dyld 会解析mach-o header，从中找到依赖的库。然后这些库也可能依赖其它库，所以dyld会不断递归找到所有依赖的库，并形成一张动态库的依赖图。一个iOS应用平均3 到 600 动态链接库，所以这个步骤包含了较大的工作量。 2、接着dyld会把依赖的动态库映射到应用地址空间。 3、然后开始符号查找，比如，如果我们的应用使用了printf函数，dyld会从系统库中找到函数地址。 4、下一步，会对每个 Mach-O 做 fixup，包括 Rebase 和 Bind。 Rebase：修复内部指针。这是因为引入用了ASLR后， Mach-O 在 mmap 到虚拟内存的时候，起始地址会有一个随机的偏移量 slide，需要把内部的指针指向加上这个 slide。 Bind：修复外部指针。这个比较好理解，因为像 printf 等外部函数，只有运行时才知道它的地址是什么，bind 就是把指针指向第三步中找到的函数地址。 5、最后，我们可以运行所有的initializers。 LibSystem Initializer：Bind &amp; Rebase 之后，首先会执行 LibSystem 的 Initializer，做一些最基本的初始化，包括：初始化 libdispatch、初始化 objc runtime，注册 sel，加载 category Load &amp; Static Initializer：接下来会进行 main 函数之前的一些初始化，主要包括+load 和 static initializer。 dyld 2是纯粹的in-process，即在程序进程内执行的，也就意味着只有当应用程序被启动时，dyld 2才能开始执行任务。 相比dyld 2，dyld 3将安全敏感的部分和占用大量资源的部分移至进程外。 安全敏感部分：在苹果看来，最大的安全敏感部分是：Parse mach-o headers 和 Find dependencies。因为被撰改的mach-o headers存在被攻击的风险，另外如果我们项目中使用了@rpath（搜索路径），通过篡改这些篡改这些路径或在正确的地方插入库，人们可以破坏应用程序。 占用大量资源的部分：这里主要指的是symbol lookups。对于给定的库，除非执行了软件更新或更改了磁盘上的库，否则该库中的符号将始终处于相同的偏移量。所以这是可以缓存的。 以下是dyld 2 和 dyld 3流程对比： dyld 3主要被分为三个组件： 1、进程外的Mach-O分析器/编译器：负责预先处理所有可能影响启动速度的 search path、@rpaths 和环境变量，然后分析 Mach-O 的 Header 和依赖，并完成了所有符号查找的工作，最后将这些结果创建成了一个启动闭包。启动闭包是为了提升速度而生，是内存映射文件，不需要以任何复杂的方式解析，比Mach-O简单的多，它包含了启动app所需的一切。 2、一个启动闭包缓存服务：系统 App 的启动闭包被构建在前文提到的 Shared Cache 中， 我们甚至不需要打开一个单独的文件。对于第三方的 App，会系统库发生变化时，即 App 安装或者升级的时候构建启动闭包。所以默认情况下，在App运行之前，启动闭包就已经在iOS上预先构建了。 3、进程内执行启动闭包的引擎：这是进程内执行的部分，主要负责：验证启动闭包的安全性、映射 dylib 到内存、每个 Mach-O 做 fixup、以及Run initiazlizers最后跳转到 main 函数。相比dyld 2，不再需要解析 Mach-O 的 Header 和依赖，也不需要进行符号查找。因为这是启动流程中花费大部分时间的步骤，所以将会为你带来更快的应用启动。 dyld 3将安全敏感的部分和占用大量资源的部分移至进程之外，并创建一个启动闭包写到磁盘里。这样后续启动的时候，就可以直接读入缓存，不再需要调用进程外的mach-o解析器或编译器，进程内执行的操作尽可能少，从而增强应用程序安全性。这样也加快了启动速度，俗话说，最快的代码是从未编写的代码，紧随其后的是几乎从未执行的代码。mach-o解析器或编译器被移至进程外之后，就变成了是一个常规的daemon进程，苹果就可以使用测试框架来测试，也就能在未来更好地改进它。 main函数之后dyld 执行完毕之后， 会把启动流程交给 App，开始执行 main 函数。main 函数里要做的最重要的事情就是初始化 UIKit。UIKit 主要会做两个大的初始化：初始化 UIApplication 和 启动主线程的 Runloop。UIKit 初始化之后，就进入了我们熟悉的 UIApplicationDelegate 回调了。 Runloop线程在执行完代码就会退出，很明显主线程是不能退出的，那么就需要一种机制：事件来的时候执行任务，否则让线程休眠，Runloop 就是实现这个功能的。 Runloop 本质上是一个While 循环，在图中橙色部分的 mach_msg_trap 就是触发一个系统调用，让线程休眠，等待事件到来，唤醒 Runloop，继续执行这个 while循环。 Runloop 主要处理几种任务：Source0，Source1，Timer，GCD MainQueue，Block。在循环的合适时机，会以 Observer 的方式通知外部执行到了哪里。 那么，Runloop 与启动又有什么关系呢？ App 的 LifeCycle 方法是基于 Runloop 的 Source0 的 首帧渲染是基于 Runloop Block 的 Runloop 在启动上主要有几点应用： 精准统计启动时间 找到一个时机，在启动结束去执行一些预热任务 利用 Runloop 打散耗时的启动预热任务 Tips : 会有一些逻辑要在启动之后 delay 一小段时间再回到主线程上执行，对于性能较差的设备，主线程 Runloop 可能一直处于忙的状态，所以这个 delay 的任务并不一定能按时执行。 AppLifeCycleUIKit 初始化之后，就进入了我们熟悉的 UIApplicationDelegate 回调了，在这些会调里去做一些业务上的初始化： willFinishLaunch didFinishLaunch didFinishLaunchNotification 要特别提一下 didFinishLaunchNotification，是因为大家在埋点的时候通常会忽略还有这个通知的存在，导致把这部分时间算到 UI 渲染里。 First Frame Render一般会用 Root Controller 的 viewDidApper 作为渲染的终点，但其实这时候首帧已经渲染完成一小段时间了，Apple 在 MetricsKit 里对启动终点定义是第一个CA::Transaction::commit()。 什么是 CATransaction 呢？我们先来看一下渲染的大致流程。 回到过去的 CRT 显示器时期，CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。 了解了显示器的显示原理之后，我们来看下渲染的大致流程。通常来说，渲染是由计算机系统中 CPU、GPU、显示器按下图方式共同协同完成的。 1、首先，在VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。 2、app 本身并不负责渲染，渲染是在一个单独的进程 RenderServer 做的。在完成对显示内容的计算之后，app通过 IPC 将渲染任务及相关数据进行打包并发送至 Render Server。 3、Render Server 主要执行 Open GL、Core Graphics 等相关程序处理完数据后再传递至 GPU。 4、GPU 进行变换、合成、渲染，渲染完成后将渲染结果放入帧缓冲区。 5、视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。 如果上述步骤串联执行，它们执行所消耗的时间将远远超过 16.67 ms。为了满足对屏幕的 60 FPS 刷新率的支持，需要将这些步骤进行分解，通过流水线的方式并行执行，如下图所示。 整个流水线一共有下面几个步骤： Handle Events：这个过程中会先处理点击事件，这个过程中有可能会需要改变页面的布局和界面层次。 Commit Transaction：此时 app 会通过 CPU 处理显示内容的前置计算，比如视图的创建、布局计算、图片解码、文本绘制等任务。之后将计算好的图层进行打包发给 Render Server。 Decode：打包好的图层被传输到 Render Server 之后，首先会进行解码。注意完成解码之后需要等待下一个 RunLoop 才会执行下一步 Draw Calls。 Draw Calls：解码完成后，Core Animation 会调用下层渲染框架（比如 OpenGL 或者 Metal）的方法进行绘制，进而调用到 GPU。 Render：这一阶段主要由 GPU 进行渲染。 Display：显示阶段，需要等 render 结束的下一个 RunLoop 触发显示。 Commit Transaction一般开发当中能影响到的就是 Handle Events 和 Commit Transaction 这两个阶段，这也是开发者接触最多的部分。Handle Events 就是处理触摸事件，而 Commit Transaction 这部分中主要进行的是：Layout、Display、Prepare、Commit 等四个具体的操作。 Layout：构建视图 这个阶段主要处理视图的构建和布局，具体步骤包括： 调用重载的 layoutSubviews 方法 创建视图，并通过 addSubview 方法添加子视图 计算视图布局，即所有的 Layout Constraint Display：绘制视图 这个阶段主要是交给 Core Graphics 进行视图的绘制，得到三角形、线段、顶点等数据，这部分信息被叫做图元（primitives）： 根据上一阶段 Layout 的结果创建得到图元信息。 如果重写了 drawRect: 方法，那么会调用重载的 drawRect: 方法，在 drawRect: 方法中手动绘制得到 bitmap 数据，从而自定义视图的绘制。 注意正常情况下 Display 阶段只会得到图元 primitives 信息，而位图 bitmap 是在 GPU 中根据图元信息绘制得到的。但是如果重写了 drawRect: 方法，这个方法会直接调用 Core Graphics 绘制方法得到 bitmap 数据，同时系统会额外申请一块内存，用于暂存绘制好的 bitmap。 由于重写了 drawRect: 方法，导致绘制过程从 GPU 转移到了 CPU，这就导致了一定的效率损失。与此同时，这个过程会额外使用 CPU 和内存，因此需要高效绘制，否则容易造成 CPU 卡顿或者内存爆炸。 Prepare：Core Animation 额外的工作 这一步主要是：图片解码和转换 Commit：打包并发送 这一步主要是：图层打包并发送到 Render Server。 启动pipeline详细回顾下整个启动过程，以及各个阶段耗时的影响因素： 1、用户点击图标之后，会发送一个系统调用 execve 到内核，内核创建进程； 2、接着会把主二进制 mmap 进来，读取 load command 中的LC_LOAD_DYLINKER，找到 dyld 的的路径； 3、然后 mmap dyld 到虚拟内存，找到 dyld 的入口函数_dyld_start，把 PC 寄存器设置成_dyld_start，接下来启动流程交给了 dyld。 4、重启手机/更新/下载 App 的第一次启动，会创建启动闭包，并存储在沙盒的 tmp/com.apple.dyld 目录。闭包包含的内容有： dependends，依赖动态库列表 fixup：bind &amp; rebase 的地址 initializer-order：初始化调用顺序 optimizeObjc: Objective C 的元数据 其他：main entry, uuid… 5、有了闭包之后，就可以用闭包启动 App 了。这时候很多动态库还没有加载进来，会首先对这些动态库 mmap 加载到虚拟内存里； 6、接着会对每个 Mach-O 做 fixup，包括 Rebase 和 Bind； Rebase：修复内部指针。这是因为引入用了ASLR后， Mach-O 在 mmap 到虚拟内存的时候，起始地址会有一个随机的偏移量 slide，需要把内部的指针指向加上这个 slide。 Bind：修复外部指针。这个比较好理解，因为像 printf 等外部函数，只有运行时才知道它的地址是什么，bind 就是把指针指向第三步中找到的函数地址。 7、Bind &amp; Rebase 之后，首先会执行 LibSystem 的 Initializer，做一些最基本的初始化： 初始化 libdispatch 初始化 objc runtime，注册 sel，加载 category 这里没有初始化 objc 的类方法等信息，是因为启动闭包的缓存数据已经包含了 optimizeObjc。 8、接下来会进行 main 函数之前的一些初始化，主要包括+load 和 static initializer。想要查看代码里有哪些 load 和 static initializer，可以在 Build Settings 里可以配置 write linkmap，这样在生成的 linkmap 文件里就可以找到有哪些文件里包含 load 或者 static initializer： __mod_init_func，static initializer __objc_nlclslist，实现+load 的类 __objc_nlcatlist，实现+load 的 Category 不是所有的 static 变量都会产生static initializer，对于在编译期间就能确定的变量是会直接 inline。会导致静态初始化的代码有： __attribute__((constructor)) static class object static object in global namespace 9、接着，dyld 会把启动流程交给 App，开始执行 main 函数，main 函数调用了UIApplicationMain 函数来初始化 UIKit。UIKit 主要会做两个大的初始化： 初始化 UIApplication 启动主线程的 Runloop 10、UIKit 初始化之后，基于 Runloop 的 Source0 的 App LifeCycle 方法就被触发了。在这些会调里去做一些业务上的初始化： willFinishLaunch didFinishLaunch didFinishLaunchNotification 11、Layout，这个阶段主要处理视图的构建和布局。在didFinishLaunch方法中我们会初始化keyWindow 并设置 rootViewController。当第一次访问rootViewController的view时会调用view的get方法，进而调用loadView来创建UIViewController的view。view创建完毕加载到内存后会调用viewDidLoad方法，在viewDidLoad方法中进行页面布局，接着调用Layoutsubviews； 12、Display，这个阶段主要是交给 Core Graphics 进行视图的绘制，得到三角形、线段、顶点等图元数据。如果重写了 drawRect: 方法，那么会调用重载的 drawRect: 方法； 13、prepare，这个阶段主要是图片解码和转换； 14、commit，这个阶段主要是打包 Render Tree 通过 XPC 的方式发给 Render Server。这也是是Apple 在 MetricsKit 里对启动终点的定义，即第一个CA::Transaction::commit()。首帧渲染是基于 Runloop Block 的，可以基于Runloop来精准统计启动时间。11、12、13、14 四步统称为Commit Transaction。 15、随后，请求网络并更新数据，至此整个启动流程结束。 参考： 抖音品质建设 - iOS启动优化《原理篇》 iOS 优化篇 - 启动优化之Clang插桩实现二进制重排 程序的链接和装入及linux下动态链接的实现","categories":[],"tags":[]},{"title":"刨根问底」之Runtime消息发送和转发","slug":"刨根问底」之Runtime消息发送和转发","date":"2021-10-30T20:31:49.770Z","updated":"2021-11-13T08:42:06.722Z","comments":true,"path":"2021/10/31/刨根问底」之Runtime消息发送和转发/","link":"","permalink":"http://heseng91.github.io/2021/10/31/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E3%80%8D%E4%B9%8BRuntime%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%92%8C%E8%BD%AC%E5%8F%91/","excerpt":"","text":"「刨根问底」之Runtime消息发送和转发上篇文章Runtime类和对象的定义 中提到了源代码到可执行文件需要需要经过编译和链接。其中编译通常会先预处理，再编译。iOS中预编译是使用Clang完成的。 下面新建一个工程并修改一下main.m文件如下： 12345678910#import &lt;UIKit&#x2F;UIKit.h&gt;#import &quot;AppDelegate.h&quot;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; UIViewController *vc &#x3D; [[UIViewController alloc] init]; [vc viewDidLoad]; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 打开终端，cd到工程目录，然后执行如下命令，对源文件进行clang rewrite， 1xcrun -sdk iphonesimulator13.2 clang -rewrite-objc -F &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneOS13.2.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneOS.sdk&#x2F;System&#x2F;Library&#x2F;Frameworks SecondViewController.m iphonesimulator13.2中 13.2 为当前xcode SDK版本号（指令xcodebuild -showsdks即可查看），在得到的main.cpp文件末尾，可以找到源代码clang后的代码： 1234567int main(int argc, char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; UIViewController *vc = ((UIViewController *(*)(id, SEL))(void *)objc_msgSend)((id)((UIViewController *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"UIViewController\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")); ((void (*)(id, SEL))(void *)objc_msgSend)((id)vc, sel_registerName(\"viewDidLoad\")); return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AppDelegate\"), sel_registerName(\"class\")))); &#125;&#125; 从中可以得知: [receiver message] 其实会被编译器转化为： 1objc_msgSend(receiver, selector) 本篇就来详细分析一下Objective-C消息发送和转发机制。 消息发送和转发流程可以概括为： 消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现； 消息转发（Message Forwarding）是在查找 IMP 失败后执行一系列转发流程的慢速通道，如果不作转发处理，则会打日志和抛出异常。 本文将从源码角度分析消息发送和转发的原理。能够很好地阅读本文的前提是你对 Objective-C Runtime 已经有一定的了解，关于什么是消息，Class 的结构，selector、IMP、元类等概念将不再赘述。本文用到的源码为 objc4-756.2，汇编语言架构为 arm64。 objc_msgSend函数简介此函数是消息发送必经之路。objc_msgSend函数究竟会干什么事情呢？从这篇「objc_msgSend() Tour」文章里面可以得到一个比较详细的结论。 1234567891. Check for ignored selectors (GC) and short-circuit.2. Check for nil target. If nil &amp; nil receiver handler configured, jump to handler If nil &amp; no handler (default), cleanup and return.3. Search the class’s method cache for the method IMP(use hash to find&amp;store method in cache) -1. If found, jump to it. -2. Not found: lookup the method IMP in the class itself corresponding its hierarchy chain. If found, load it into cache and jump to it. If not found, jump to forwarding mechanism. 总结一下objc_msgSend会做以下几件事情： 检测这个 selector是不是要忽略的。 检查target是不是为nil。 如果这里有相应的nil的处理函数，就跳转到相应的函数中。如果没有处理nil的函数，就自动清理现场并返回。这一点就是为何在OC中给nil发送消息不会崩溃的原因。 确定不是给nil发消息之后，在该class的缓存中查找方法对应的IMP实现。 如果找到，就跳转进去执行。如果没有找到，就在方法分发表里面继续查找，一直找到NSObject为止。 如果还没有找到，那就需要开始消息转发阶段了。至此，发送消息Messaging阶段完成。这一阶段主要完成的是通过selecter快速查找IMP的过程。 源码解析在这篇文章Obj-C Optimization: The faster objc_msgSend中看到了这样一段C版本的objc_msgSend的源码。 Objective-C 123456789101112131415161718192021222324252627282930313233#include &lt;objc/objc-runtime.h&gt;id c_objc_msgSend( struct objc_class /* ahem */ *self, SEL _cmd, ...)&#123; struct objc_class *cls; struct objc_cache *cache; unsigned int hash; struct objc_method *method; unsigned int index; if( self) &#123; cls = self-&gt;isa; cache = cls-&gt;cache; hash = cache-&gt;mask; index = (unsigned int) _cmd &amp; hash; do &#123; method = cache-&gt;buckets[ index]; if( ! method) goto recache; index = (index + 1) &amp; cache-&gt;mask; &#125; while( method-&gt;method_name != _cmd); return( (*method-&gt;method_imp)( (id) self, _cmd)); &#125; return( (id) self);recache: /* ... */ return( 0);&#125; 该源码中有一个do-while循环，这个循环就是前面提到的在方法分发表里面查找method的过程。 _objc_msgSend源码分析不过在 objc4-756.2里面objc_msgSend 是用汇编语言写的，针对不同架构有不同的实现。objc-msg-arm64.s文件中实现是如下一段汇编代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&#x2F;&#x2F; objc_msgSend 汇编入口 ENTRY _objc_msgSend &#x2F;&#x2F; 无窗口 UNWIND _objc_msgSend, NoFrame&#x2F;&#x2F; p0：objc_msgSend的第一个参数，即消息接受者&#x2F;&#x2F; cmp: 比较&#x2F;&#x2F; #0：nil&#x2F;&#x2F; 判断p0是否为空 cmp p0, #0 &#x2F;&#x2F; nil check and tagged pointer check&#x2F;&#x2F; 支持taggedpointer的流程#if SUPPORT_TAGGED_POINTERS&#x2F;&#x2F; b.le: 执行标号，判断上面cmp值是小于等于，如果receiver为nil或taggedpointer，则执行LNilOrTagged b.le LNilOrTagged &#x2F;&#x2F; (MSB tagged pointer looks negative)#else&#x2F;&#x2F; b.eq: 执行标号，判断上面cmp值是等于，如果receiver为nil，则执行LReturnZero&#x2F;&#x2F; p0为空，返回空 b.eq LReturnZero#endif&#x2F;&#x2F; p0不为空，即receiver 存在的流程&#x2F;&#x2F; ldr 把数据从内存中某处读取到寄存器&#x2F;&#x2F; p13 &#x3D; x0栈内存中的值，从x0寄存器指向的地址中取出 isa，并把isa赋值给p13 ldr p13, [x0] &#x2F;&#x2F; p13 &#x3D; isa&#x2F;&#x2F; 在64位架构下通过 p16 &#x3D; isa（p13） &amp; ISA_MASK，获取shiftcls，从而得到class信息 GetClassFromIsa_p16 p13 &#x2F;&#x2F; p16 &#x3D; classLGetIsaDone:&#x2F;&#x2F; 如果isa存在，调用CacheLookup，开始cache查找流程(快速查找流程sel-&gt;imp)&#x2F;&#x2F; 找到就返回imp，没找到就返回objc_msgSend_uncached CacheLookup NORMAL &#x2F;&#x2F; calls imp or objc_msgSend_uncached&#x2F;&#x2F; 支持taggedpointer#if SUPPORT_TAGGED_POINTERS&#x2F;&#x2F; LNilOrTagged条件判断逻辑LNilOrTagged:&#x2F;&#x2F; 等于空，返回空 b.eq LReturnZero &#x2F;&#x2F; nil check &#x2F;&#x2F; tagged &#x2F;&#x2F; adrp 计算指定的数据地址到当前pc寄存器值相对偏移 &#x2F;&#x2F; 得到包含_objc_debug_taggedpointer_classes地址的page的基址，arm64架构中page大小为16kb。 &#x2F;&#x2F; 并将该page的基址存到寄存器X10中； adrp x10, _objc_debug_taggedpointer_classes@PAGE &#x2F;&#x2F; add 加 &#x2F;&#x2F; x10 &#x3D; x10 + _objc_debug_taggedpointer_classes@PAGEOFF（偏移量） &#x2F;&#x2F; 即计算出_objc_debug_taggedpointer_classes的地址，并存到寄存器X10中 add x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF &#x2F;&#x2F; ubfx 无符号位段提取（ubfx Xd, Xn, #lsb, #width。表示从Wn寄存器的第lsb位开始，提取width位到Wd寄存器，剩余高位用0填充） &#x2F;&#x2F; 从x0寄存器的第60位开始，提取4位到x11寄存器，剩余高位用0填充，即提取指针的最后四位（标记tagged pointer的位）存到x11寄存器 ubfx x11, x0, #60, #4 &#x2F;&#x2F; ldr 加载字到寄存器 &#x2F;&#x2F; lsl 逻辑或算术左移 &#x2F;&#x2F; x16 &#x3D; x10 + (x11&lt;&lt;3)， 获取taggedpointer标识位，并存到x16寄存器 ldr x16, [x10, x11, LSL #3] adrp x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE add x10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF cmp x10, x16 &#x2F;&#x2F; b.ne 判断上面cmp的值是不等于 执行标号，否则直接往下走 b.ne LGetIsaDone &#x2F;&#x2F; ext tagged adrp x10, _objc_debug_taggedpointer_ext_classes@PAGE add x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF ubfx x11, x0, #52, #8 ldr x16, [x10, x11, LSL #3] b LGetIsaDone&#x2F;&#x2F; SUPPORT_TAGGED_POINTERS#endifLReturnZero: &#x2F;&#x2F; x0 is already zero &#x2F;&#x2F; 1、首先先把 x1 清空，x0 这里是 self，已经是0，所以不需要清空 mov x1, #0 &#x2F;&#x2F; 2、清空 v 寄存器 movi d0, #0 movi d1, #0 movi d2, #0 movi d3, #0 ret END_ENTRY _objc_msgSend 主要有以下几步 【第一步】判断objc_msgSend方法的第一个参数receiver是否为空 判断receiver如果为空，则直接返回空，即LReturnZero； 如果支持tagged pointer对象，判断如果为tagged pointer对象，跳转至【第二步】 否则，如果receiver不为tagged pointer对象且不为空，从receiver中取出isa存入p13寄存器， 通过 GetClassFromIsa_p16中，arm64架构下通过 isa &amp; ISA_MASK 获取shiftcls位域的类信息，即class，GetClassFromIsa_p16的汇编实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&#x2F;&#x2F; .macro 汇编宏定义.macro GetClassFromIsa_p16 &#x2F;* src *&#x2F;#if SUPPORT_INDEXED_ISA&#x2F;&#x2F; mov指令是数据传送指令，用于将一个数据从源地址传送到目标地址，其特点是不破坏源地址单元的内容。&#x2F;&#x2F; 把传入的值src赋值给p16寄存器，p16 &#x3D; class &#x2F;&#x2F; Indexed isa mov p16, $0 &#x2F;&#x2F; optimistically set dst &#x3D; src&#x2F;&#x2F; # define ISA_INDEX_IS_NPI_BIT 0&#x2F;&#x2F; tbz 条件执行&#x2F;&#x2F; 判断p16寄存器中存储的class指针最后一位如果不为0，即如果是tagged pointer，则直接跳转到1，直接结束 tbz p16, #ISA_INDEX_IS_NPI_BIT, 1f &#x2F;&#x2F; done if not non-pointer isa&#x2F;&#x2F; adrp 计算指定的数据地址到当前pc寄存器值相对偏移 &#x2F;&#x2F; 得到包含_objc_indexed_classes地址的page的基址，arm64架构中page大小为16kb。 &#x2F;&#x2F; 并将该page的基址存到寄存器X10中； &#x2F;&#x2F; isa in p16 is indexed adrp x10, _objc_indexed_classes@PAGE&#x2F;&#x2F; x10 &#x3D; x10 + _objc_indexed_classes@PAGEOFF（_objc_indexed_classes在page中的偏移量），即计算出_objc_debug_taggedpointer_classes的地址，并存到寄存器X10中 add x10, x10, _objc_indexed_classes@PAGEOFF&#x2F;&#x2F; ubfx:有符号和无符号位域提取。 将一个寄存器中相邻的位复制到另一个寄存器的最低有效位，并用符号或零扩展到 32 位。&#x2F;&#x2F; 从p16的第ISA_INDEX_SHIFT位开始，提取 ISA_INDEX_BITS 位 到 p16寄存器，剩余的高位用0补充&#x2F;&#x2F; # define ISA_INDEX_SHIFT 2&#x2F;&#x2F; # define ISA_INDEX_BITS 15&#x2F;&#x2F; 从p16寄存器的第2位开始，提取15位到p16寄存器，剩余高位用0填充 ubfx p16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS &#x2F;&#x2F; extract index&#x2F;&#x2F; #define PTRSHIFT 3 &#x2F;&#x2F; 1&lt;&lt;PTRSHIFT &#x3D;&#x3D; PTRSIZE&#x2F;&#x2F; #define UXTP UXTX ldr p16, [x10, p16, UXTP #PTRSHIFT] &#x2F;&#x2F; load class from array1:&#x2F;&#x2F; 如果是64位#elif __LP64__ &#x2F;&#x2F; 64-bit packed isa&#x2F;&#x2F; p16 &#x3D; class &#x3D; isa &amp; ISA_MASK(位运算 &amp; 即获取isa中的shiftcls信息) and p16, $0, #ISA_MASK#else &#x2F;&#x2F; 32-bit raw isa mov p16, $0#endif&#x2F;&#x2F; 宏定义结束.endmacro 然后走到【第二步】 【第二步】获取isa完毕，调用CacheLookup NORMAL在缓存中查找方法。 CacheLookup源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&#x2F;&#x2F; 定义CacheLookup宏.macro CacheLookup &#x2F;&#x2F; ldp:从栈取&#x2F;存数据 &#x2F;&#x2F; #define CACHE (2 * __SIZEOF_POINTER__)，其中 __SIZEOF_POINTER__表示pointer的大小 ，即 2*8 &#x3D; 16 &#x2F;&#x2F; p11 &#x3D; mask|buckets，从x16（即isa）中平移16字节，获取cache地址。isa距离cache 正好16字节：isa（8字节）+ superClass（8字节） &#x2F;&#x2F; 从cache中分别取出 buckets 和 occupied|mask 存入 p10（存储buckets） 和 p11（存储occupied|mask） &#x2F;&#x2F; p1 &#x3D; SEL, p16 &#x3D; isa ldp p10, p11, [x16, #CACHE] &#x2F;&#x2F; p10 &#x3D; buckets, p11 &#x3D; occupied|mask#if !__LP64__ and w11, w11, 0xffff &#x2F;&#x2F; p11 &#x3D; mask#endif &#x2F;&#x2F; and 按位“与”操作，key &amp; mask得到cache_hash and w12, w1, w11 &#x2F;&#x2F; x12 &#x3D; _cmd &amp; mask add p12, p10, p12, LSL #(1+PTRSHIFT) &#x2F;&#x2F; p12 &#x3D; buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT)) &#x2F;&#x2F; 从x12（即p12）中取出 bucket 分别将imp和sel 存入 p17（存储imp） 和 p9（存储sel） ldp p17, p9, [x12] &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket&#x2F;&#x2F; 比较 sel 与 p1（传入的参数cmd）1: cmp p9, p1 &#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd) &#x2F;&#x2F; 如果不相等，即没有找到，跳转至 2f b.ne 2f &#x2F;&#x2F; scan more &#x2F;&#x2F; 如果相等，即缓存命中，执行cacheHit直接调用或返回imp CacheHit $0 &#x2F;&#x2F; call or return imp 2: &#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket &#x2F;&#x2F; 如果一直都找不到，因为是normal，跳转至__objc_msgSend_uncached CheckMiss $0 &#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0 &#x2F;&#x2F; 判断p12（当前的bucket）是否 是 p10（buckets数组第一个元素，） cmp p12, p10 &#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets &#x2F;&#x2F; 如果想等，跳转至 3f b.eq 3f &#x2F;&#x2F; 从x12（即p12 buckets首地址）- 实际需要平移的内存大小BUCKET_SIZE，得到得到第二个bucket元素，imp-sel分别存入p17-p9，即向前查找 ldp p17, p9, [x12, #-BUCKET_SIZE]! &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket &#x2F;&#x2F; 跳转至第1步，继续对比 sel 与 cmd b 1b &#x2F;&#x2F; loop3: &#x2F;&#x2F; wrap: p12 &#x3D; first bucket, w11 &#x3D; mask &#x2F;&#x2F; mask左移4位，直接定位到buckets的最后一个元素，缓存查找顺序是向前查找 add p12, p12, w11, UXTW #(1+PTRSHIFT) &#x2F;&#x2F; p12 &#x3D; buckets + (mask &lt;&lt; 1+PTRSHIFT) &#x2F;&#x2F; Clone scanning loop to miss instead of hang when cache is corrupt. &#x2F;&#x2F; The slow path may detect any corruption and halt later. ldp p17, p9, [x12] &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *bucket1: cmp p9, p1 &#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd) b.ne 2f &#x2F;&#x2F; scan more CacheHit $0 &#x2F;&#x2F; call or return imp 2: &#x2F;&#x2F; not hit: p12 &#x3D; not-hit bucket &#x2F;&#x2F; 判断p12（当前遍历到的bucket）是否等于 p10（buckets数组第一个元素）即前面已经没有了 CheckMiss $0 &#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0 cmp p12, p10 &#x2F;&#x2F; wrap if bucket &#x3D;&#x3D; buckets b.eq 3f &#x2F;&#x2F; 偏移获取前一个bucket，并取出imp和sel分别存入p17、p9，即向前查找 ldp p17, p9, [x12, #-BUCKET_SIZE]! &#x2F;&#x2F; &#123;imp, sel&#125; &#x3D; *--bucket &#x2F;&#x2F; 跳转至第1步，继续对比 sel 与 cmd b 1b &#x2F;&#x2F; loop3: &#x2F;&#x2F; double wrap &#x2F;&#x2F; 跳转至JumpMiss 因为是normal ，跳转至__objc_msgSend_uncached JumpMiss $0 .endmacro 主要分为以下几步 【第一步】通过isa首地址平移16字节（因为在objc_class中，首地址距离cache正好16字节，即isa首地址 占8字节，superClass占8字节），获取cahce，并将cache中的buckets存放到p10寄存器中，将cache中的occupied|mask存放到p11寄存器中 【第二步】由mask根据哈希算法计算出下标 将objc_msgSend的参数p1（即第二个参数_cmd）和p11中存放的msak进行&amp;运算，得到需要查找存储sel-imp的bucket下标index，即p12 = index = _cmd &amp; mask。 【第三步】根据所得的哈希下标index 和 buckets首地址，取出哈希下标对应的bucket，并存放到p12寄存器中p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT)) 其中PTRSHIFT等于3，左移4位（即2^4 = 16字节）即是一个bucket实际占用的大小,结构体bucket_t中sel占8字节，imp占8字节 根据计算的哈希下标index 乘以单个bucket占用的内存大小，得到bucket相当于buckets首地址的偏移量 通过首地址 + 实际偏移量，获取哈希下标index对应的bucket 【第四步】根据获取的bucket，取出其中的imp和sel分别存入p17和p9寄存器 【第五步】遍历buckets查找缓存的方法 比较sel和传入的参数cmd是否相等，如果不相等，即没找到，执行下一步，否则如果相等，即缓存命中，执行CacheHit函数返回imp 123456789101112131415161718&#x2F;&#x2F; CacheHit: x17 &#x3D; cached IMP, x12 &#x3D; address of cached IMP, x1 &#x3D; SEL.macro CacheHit.if $0 &#x3D;&#x3D; NORMAL TailCallCachedImp x17, x12, x1 &#x2F;&#x2F; authenticate and call imp.elseif $0 &#x3D;&#x3D; GETIMP mov p0, p17 cbz p0, 9f &#x2F;&#x2F; don&#39;t ptrauth a nil imp AuthAndResignAsIMP x0, x12, x1 &#x2F;&#x2F; authenticate imp and re-sign as IMP9: ret &#x2F;&#x2F; return IMP.elseif $0 &#x3D;&#x3D; LOOKUP &#x2F;&#x2F; No nil check for ptrauth: the caller would crash anyway when they &#x2F;&#x2F; jump to a nil IMP. We don&#39;t care if that jump also fails ptrauth. AuthAndResignAsIMP x17, x12, x1 &#x2F;&#x2F; authenticate imp and re-sign as IMP ret &#x2F;&#x2F; return imp via x17.else.abort oops.endif.endmacro 这里传入的$0是normal会调用TailCallCachedImp执行imp 12345.macro TailCallCachedImp &#x2F;&#x2F; $0 &#x3D; cached imp, $1 &#x3D; address of cached imp, $2 &#x3D; SEL eor $1, $1, $2 &#x2F;&#x2F; mix SEL into ptrauth modifier brab $0, $1.endmacro 调用CheckMiss，判断是否一直找不到（bucket-&gt;sel == 0），即遇到空通，说明cache中没有该method。因此可见cache解决hash冲突的方式为开放寻址法（线性探测）。 123456789101112.macro CheckMiss &#x2F;&#x2F; miss if bucket-&gt;sel &#x3D;&#x3D; 0.if $0 &#x3D;&#x3D; GETIMP cbz p9, LGetImpMiss.elseif $0 &#x3D;&#x3D; NORMAL cbz p9, __objc_msgSend_uncached.elseif $0 &#x3D;&#x3D; LOOKUP cbz p9, __objc_msgLookup_uncached.else.abort oops.endif.endmacro 因为$0是normal，如果一直都找不到，会跳转至__objc_msgSend_uncached，即进入慢速查找流程。否则执行下一步 如果根据index获取的bucket 等于 buckets的第一个元素，则将当前bucket设置为buckets的最后一个元素（通过buckets首地址+mask*16（等同于左移4位）直接定位到buckets的最后一个元素），并读取bucket的imp和sel`分别存入p17和p9寄存器，然后执行【第六步】；否则执行下一步 通过地址偏移，得到前一个bucket元素，并读取bucket的imp和sel`分别存入p17和p9寄存器，然后重复1 【第六步】第二次遍历查找：重复【第五步】的操作，与【第五步】中唯一区别是，如果当前的bucket还是等于 buckets的第一个元素，则直接跳转至JumpMiss， 1234567891011.macro JumpMiss.if $0 &#x3D;&#x3D; GETIMP b LGetImpMiss.elseif $0 &#x3D;&#x3D; NORMAL b __objc_msgSend_uncached.elseif $0 &#x3D;&#x3D; LOOKUP b __objc_msgLookup_uncached.else.abort oops.endif.endmacro 此时的$0是normal，也是直接跳转至__objc_msgSend_uncached，即进入慢速查找流程。 __objc_msgSend_uncached源码分析__objc_msgSend_uncached源码实现如下 12345678910STATIC_ENTRY __objc_msgSend_uncachedUNWIND __objc_msgSend_uncached, FrameWithNoSaves&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION&#x2F;&#x2F; Out-of-band p16 is the class to searchMethodTableLookupTailCallFunctionPointer x17END_ENTRY __objc_msgSend_uncached 该方法中主要调用了MethodTableLookup方法。 123456789101112131415161718192021222324252627282930313233343536373839404142.macro MethodTableLookup &#x2F;&#x2F; push frame SignLR stp fp, lr, [sp, #-16]! mov fp, sp &#x2F;&#x2F; save parameter registers: x0..x8, q0..q7 sub sp, sp, #(10*8 + 8*16) stp q0, q1, [sp, #(0*16)] stp q2, q3, [sp, #(2*16)] stp q4, q5, [sp, #(4*16)] stp q6, q7, [sp, #(6*16)] stp x0, x1, [sp, #(8*16+0*8)] stp x2, x3, [sp, #(8*16+2*8)] stp x4, x5, [sp, #(8*16+4*8)] stp x6, x7, [sp, #(8*16+6*8)] str x8, [sp, #(8*16+8*8)] &#x2F;&#x2F; receiver and selector already in x0 and x1 mov x2, x16 bl __class_lookupMethodAndLoadCache3 &#x2F;&#x2F; IMP in x0 mov x17, x0 &#x2F;&#x2F; restore registers and return ldp q0, q1, [sp, #(0*16)] ldp q2, q3, [sp, #(2*16)] ldp q4, q5, [sp, #(4*16)] ldp q6, q7, [sp, #(6*16)] ldp x0, x1, [sp, #(8*16+0*8)] ldp x2, x3, [sp, #(8*16+2*8)] ldp x4, x5, [sp, #(8*16+4*8)] ldp x6, x7, [sp, #(8*16+6*8)] ldr x8, [sp, #(8*16+8*8)] mov sp, fp ldp fp, lr, [sp], #16 AuthenticateLR.endmacro MethodTableLookup 可以算是个接口层宏，主要用于保存环境与准备参数，来调用 __class_lookupMethodAndLoadCache3函数（在objc-class-new.mm中）。 1234567891011/************************************************************************ _class_lookupMethodAndLoadCache.* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().* This lookup avoids optimistic cache scan because the dispatcher * already tried that.**********************************************************************/IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)&#123; return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/);&#125; __class_lookupMethodAndLoadCache3函数也是个接口层（C编写），此函数提供相应参数配置，实际功能在lookUpImpOrForward函数中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154/************************************************************************ lookUpImpOrForward.* The standard IMP lookup. * initialize==NO tries to avoid +initialize (but sometimes fails)* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)* Most callers should use initialize==YES and cache==YES.* inst is an instance of cls or a subclass thereof, or nil if none is known. * If cls is an un-initialized metaclass then a non-nil inst is faster.* May return _objc_msgForward_impcache. IMPs destined for external use * must be converted to _objc_msgForward or _objc_msgForward_stret.* If you don't want forwarding at all, use lookUpImpOrNil() instead.**********************************************************************/IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = nil; bool triedResolver = NO; // runtimeLock 本质上是对 Darwin 提供的线程读写锁 pthread_rwlock_t 的一层封装，提供了一些便捷的方法。 runtimeLock.assertUnlocked(); // Optimistic cache lookup // 如果使用缓存（cache 参数为 YES），那就调用 cache_getImp 方法从缓存查找 IMP。cache_getImp 是用汇编语言写的，也可以在 objc-msg-arm64.s 找到，其依然用了前文中说过的 CacheLookup 宏。因为 _class_lookupMethodAndLoadCache3 调用 lookUpImpOrForward 时 cache 参数为 NO，这步直接略过。 if (cache) &#123; imp = cache_getImp(cls, sel); if (imp) return imp; &#125; // runtimeLock is held during isRealized and isInitialized checking // to prevent races against concurrent realization. // runtimeLock is held during method search to make // method-lookup + cache-fill atomic with respect to method addition. // Otherwise, a category could be added but ignored indefinitely because // the cache was re-filled with the old value after the cache flush on // behalf of the category. runtimeLock.lock(); // 判断是否是一个已知的类：判断当前类是否是已经被认可的类，即已经加载的类。 checkIsKnownClass(cls); // 判断类是否已经Realized，如果没有，需要先Realized if (!cls-&gt;isRealized()) &#123; cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock); // runtimeLock may have been dropped but is now locked again &#125; // 判断如果入参传入的initialize为true，且类未实例化，需要先实例化 if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; cls = initializeAndLeaveLocked(cls, inst, runtimeLock); // runtimeLock may have been dropped but is now locked again // If sel == initialize, class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won't happen. 2778172 &#125; retry: // runtimeLock 上锁 runtimeLock.assertLocked(); // Try this class's cache. // 调用 cache_getImp 方法从缓存查找 IMP。 imp = cache_getImp(cls, sel); // 如果找到直接返回imp。 if (imp) goto done; // Try this class's method lists. &#123; // 在当前类中的方法列表（method list）中进行查找，也就是根据 selector 查找 Method Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123; // 如果在当前类的方法列表成功找到了Method// 获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。 log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); // 将找到的IMP直接返回imp imp = meth-&gt;imp; goto done; &#125; &#125; // 如果在当前类中的方法列表（method list）中没有找到Method，尝试在逐级在父类的缓存和方法列表中查找 // Try superclass caches and method lists. &#123; unsigned attempts = unreasonableClassCount(); // 在继承层级中递归向父类中查找，和上一步类似，也是先查找缓存，缓存没中就查找方法列表 for (Class curClass = cls-&gt;superclass; curClass != nil; curClass = curClass-&gt;superclass) &#123; // Halt if there is a cycle in the superclass chain. if (--attempts == 0) &#123; _objc_fatal(\"Memory corruption in class list.\"); &#125; // Superclass cache. // 调用 cache_getImp 方法从父类的缓存查找 IMP。 imp = cache_getImp(curClass, sel); if (imp) &#123; // 如果找到的imp不是_objc_msgForward_impcache if (imp != (IMP)_objc_msgForward_impcache) &#123; // Found the method in a superclass. Cache it in this class. // 将父类链中查找到的imp并填充到当前类的缓存中。 log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; &#125; else &#123; // 如果找到的imp是_objc_msgForward_impcache，退出循环 // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; &#125; &#125; // 在当前父类中的方法列表（method list）中进行查找，也就是根据 selector 查找到 Method 后，获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。 // Superclass method list. Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done; &#125; &#125; &#125; // No implementation found. Try method resolver once. // 参数 resolver 为 YES且是第一次执行到这里的时侯，进行动态方法解析 if (resolver &amp;&amp; !triedResolver) &#123; // 释放锁 runtimeLock.unlock(); // 间接地发送 +resolveInstanceMethod 或 +resolveClassMethod 消息。函数中实现了方法解析逻辑。如果 cls 是元类则会发送 +resolveClassMethod，然后根据 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 函数的结果来判断是否发送 +resolveInstanceMethod；如果不是元类，则只需要发送 +resolveInstanceMethod 消息。这里调用 +resolveInstanceMethod 或 +resolveClassMethod 时再次用到了 objc_msgSend，而且第三个参数正是传入 lookUpImpOrForward 的那个 sel。在发送方法解析消息之后还会调用 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 来判断是否已经添加上 sel 对应的 IMP 了，打印出结果。 resolveMethod(cls, sel, inst); // 读入锁加锁 runtimeLock.lock(); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; &#125; // No implementation found, and method resolver didn't help. // Use forwarding. // 将 _objc_msgForward_impcache 当做 IMP 并写入缓存 imp = (IMP)_objc_msgForward_impcache; cache_fill(cls, sel, imp, inst); done: runtimeLock.unlock(); return imp;&#125; 首先了lookUpImpOrForward方法，对 assert 进行 unlock： 1runtimeLock.assertUnlocked(); runtimeLock 本质上是对 Darwin 提供的线程读写锁 pthread_rwlock_t 的一层封装，提供了一些便捷的方法。 接着，lookUpImpOrForward做了如下两件事： 如果使用缓存（cache 参数为 YES），那就调用 cache_getImp 方法从缓存查找 IMP。cache_getImp 是用汇编语言写的，实现如下 12345678910STATIC_ENTRY _cache_getImp GetClassFromIsa_p16 p0 CacheLookup GETIMPLGetImpMiss: mov p0, #0 ret END_ENTRY _cache_getImp 其依然用了之前说过的 CacheLookup 宏。因为 _class_lookupMethodAndLoadCache3 调用 lookUpImpOrForward 时 cache 参数为 NO，这步直接略过。 如果是第一次用到这个类且 initialize 参数为 YES（initialize &amp;&amp; !cls-&gt;isInitialized()），需要进行初始化工作，也就是开辟一个用于读写数据的空间。先对 runtimeLock 加锁，然后调用 cls 的 initialize 方法，并将cls-&gt;isInitialized()置为true。 然后，会继续在类的继承体系中查找： 考虑到运行时类中的方法可能会增加，需要先加锁，使得方法查找和缓存填充成为原子操作。 1runtimeLock.assertLocked(); 之后的逻辑如下： 查找当前类中的缓存，跟之前一样，使用 cache_getImp 汇编程序入口。如果命中缓存获取到了 IMP，则直接跳到第 6 步；否则执行下一步。 在当前类的方法列表（method list）中进行查找，也就是根据 selector 查找到 Method 后，获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。查找过程如下： 首先调用 getMethodNoSuper_nolock()方法， 1234567891011121314151617181920static method_t *getMethodNoSuper_nolock(Class cls, SEL sel)&#123; runtimeLock.assertLocked(); assert(cls-&gt;isRealized()); // fixme nil cls? // fixme nil sel? for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(), end = cls-&gt;data()-&gt;methods.endLists(); mlists != end; ++mlists) &#123; method_t *m = search_method_list(*mlists, sel); if (m) return m; &#125; return nil;&#125; 在getMethodNoSuper_nolock方法中，会遍历methodList。遍历过程中会调用search_method_list函数。 1234567891011121314151617181920212223242526272829303132/************************************************************************ getMethodNoSuper_nolock* fixme* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/static method_t *search_method_list(const method_list_t *mlist, SEL sel)&#123; int methodListIsFixedUp = mlist-&gt;isFixedUp(); int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t); if (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, 1)) &#123; return findMethodInSortedMethodList(sel, mlist); &#125; else &#123; // Linear search of unsorted method list for (auto&amp; meth : *mlist) &#123; if (meth.name == sel) return &amp;meth; &#125; &#125;#if DEBUG // sanity-check negative results if (mlist-&gt;isFixedUp()) &#123; for (auto&amp; meth : *mlist) &#123; if (meth.name == sel) &#123; _objc_fatal(\"linear search worked when binary search did not\"); &#125; &#125; &#125;#endif return nil;&#125; 在search_method_list函数中，会去判断当前methodList是否有序，如果有序，会调用findMethodInSortedMethodList方法，这个方法里面的实现是一个二分搜索。 123456789101112131415161718192021222324252627282930313233343536373839static method_t *findMethodInSortedMethodList(SEL key, const method_list_t *list)&#123; assert(list); const method_t * const first = &amp;list-&gt;first; const method_t *base = first; const method_t *probe; uintptr_t keyValue = (uintptr_t)key; uint32_t count; // base相当于low，count是max，probe是middle for (count = list-&gt;count; count != 0; count &gt;&gt;= 1) &#123; // probe = 从首地址 + count/2 probe = base + (count &gt;&gt; 1); uintptr_t probeValue = (uintptr_t)probe-&gt;name; // 如果查找的sel == 中间位置（probe）的probeValue if (keyValue == probeValue) &#123; // `probe` is a match. // Rewind looking for the *first* occurrence of this value. // This is required for correct category overrides. // -- while 平移 -- 排除分类重名方法 // 循环在methodlist中查找第一个满足(keyValue == probeValue)的元素。因为在methodlist中分类方法会插入在本类方法之前 while (probe &gt; first &amp;&amp; keyValue == (uintptr_t)probe[-1].name) &#123; probe--; &#125; return (method_t *)probe; &#125; // 如果keyValue 大于 probeValue，就往probe即中间位置的右边查找 if (keyValue &gt; probeValue) &#123; base = probe + 1; count--; &#125; &#125; return nil;&#125; 如果成功查找到 Method 对象，则调用log_and_fill_cache()，将获取到的 Method 中的 IMP（也就是 method_imp 属性），填充到缓存中， 1234567891011121314151617181920/************************************************************************ log_and_fill_cache* Log this method call. If the logger permits it, fill the method cache.* cls is the method whose cache should be filled. * implementer is the class that owns the implementation in question.**********************************************************************/static voidlog_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)&#123;#if SUPPORT_MESSAGE_LOGGING if (objcMsgLogEnabled) &#123; bool cacheIt = logMessageSend(implementer-&gt;isMetaClass(), cls-&gt;nameForLogging(), implementer-&gt;nameForLogging(), sel); if (!cacheIt) return; &#125;#endif cache_fill (cls, sel, imp, receiver);&#125; 忽略debug的log逻辑，方法仅仅是调用cache_fill。 12345678910void cache_fill(Class cls, SEL sel, IMP imp, id receiver)&#123;#if !DEBUG_TASK_THREADS mutex_locker_t lock(cacheUpdateLock); cache_fill_nolock(cls, sel, imp, receiver);#else _collecting_in_critical(); return;#endif&#125; cache_fill又会来到cache_fill_nolock，这个函数的作用是将方法的SEL和IMP写入_buckets，同时更新_mask和_occupied。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)&#123; cacheUpdateLock.assertLocked(); // 如果类未初始化，直接return // Never cache before +initialize is done if (!cls-&gt;isInitialized()) return; // Make sure the entry wasn't added to the cache by some other thread // before we grabbed the cacheUpdateLock. // 在获取cacheUpdateLock之前，确保其他线程没有将该方法写入缓存 if (cache_getImp(cls, sel)) return; // 获取 cls 的 cache_t指针 cache_t *cache = getCache(cls); // Use the cache as-is if it is less than 3/4 full // newOccupied为新的方法缓存数，等于 当前方法缓存数+1 mask_t newOccupied = cache-&gt;occupied() + 1; // 获取当前cache_t的总容量，为 mask+1 mask_t capacity = cache-&gt;capacity(); if (cache-&gt;isConstantEmptyCache()) &#123; // 当第一次调用类的实例方法时（如`init`） // Cache is read-only. Replace it. cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE); &#125; else if (newOccupied &lt;= capacity / 4 * 3) &#123; // 新的方法缓存数 不大于 总容量的3/4，按原样使用，无需扩容 // Cache is less than 3/4 full. Use it as-is. &#125; else &#123; // Cache is too full. Expand it. // 新的方法缓存数 大于 总容量的3/4，需要扩容 cache-&gt;expand(); &#125; // Scan for the first unused slot and insert there. // There is guaranteed to be an empty slot because the // minimum size is 4 and we resized at 3/4 full. // 根据sel获取bucket，此bucket的sel一般为0（说明这个位置还没缓存方法）， // 也可能与实参sel相等（hash冲突，可能性很低） bucket_t *bucket = cache-&gt;find(sel, receiver); // 当且仅当bucket的sel为0时，执行_occupied++ if (bucket-&gt;sel() == 0) cache-&gt;incrementOccupied(); // 更新bucket的sel和imp bucket-&gt;set&lt;Atomic&gt;(sel, imp);&#125; 从上面的源码不难看出，cache_fill_nolock主要是cache_t缓存方法的调度中心，在这里会： 决定执行_buckets的哪一种缓存策略（初始化后缓存、直接缓存、扩容后缓存，三者取一）； 然后通过方法的sel找到一个bucket，并更新这个bucket的sel和imp。（如果这个bucket的sel为0，说明是个空桶，正好可以缓存方法，于是执行_occupied++）。 缓存填充完成，然后就直接跳到第 6 步；否则如果当前类的method list没有找到method，则执行下一步。 在继承层级中递归向父类中查找，情况跟上一步类似，也是先查找缓存，缓存没中就查找方法列表。这里跟上一步不同的地方在于缓存策略，有个 _objc_msgForward_impcache 汇编程序入口作为缓存中消息转发的标记。也就是说如果在缓存中找到了 IMP，但如果发现其内容是 _objc_msgForward_impcache，那就终止在类的继承层级中递归查找，进入下一步；否则跳到第 7 步。 当传入 lookUpImpOrForward 的参数 resolver 为 YES 并且是第一次进入第 5 步时，时进入动态方法解析；否则进入下一步。这步消息转发前的最后一次机会。此时释放读入锁（runtimeLock.unlock()），接着调用resolveMethod()进行动态方法解析 1234567891011121314151617181920212223242526/************************************************************************ resolveMethod* Call +resolveClassMethod or +resolveInstanceMethod.* Returns nothing; any result would be potentially out-of-date already.* Does not check if the method already exists.**********************************************************************/static void resolveMethod(Class cls, SEL sel, id inst)&#123; runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); if (! cls-&gt;isMetaClass()) &#123; // try [cls resolveInstanceMethod:sel] resolveInstanceMethod(cls, sel, inst); &#125; else &#123; // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; resolveInstanceMethod(cls, sel, inst); &#125; &#125;&#125; 该方法中会判断，如果 cls 是元类则会发送 +resolveClassMethod。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/************************************************************************ resolveClassMethod* Call +resolveClassMethod, looking for a method to be added to class cls.* cls should be a metaclass.* Does not check if the method already exists.**********************************************************************/static void resolveClassMethod(Class cls, SEL sel, id inst)&#123; runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); assert(cls-&gt;isMetaClass()); if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; // Resolver not implemented. return; &#125; Class nonmeta; &#123; mutex_locker_t lock(runtimeLock); nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst); // +initialize path should have realized nonmeta already if (!nonmeta-&gt;isRealized()) &#123; _objc_fatal(\"nonmeta class %s (%p) unexpectedly not realized\", nonmeta-&gt;nameForLogging(), nonmeta); &#125; &#125; BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(nonmeta, SEL_resolveClassMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); if (resolved &amp;&amp; PrintResolving) &#123; if (imp) &#123; _objc_inform(\"RESOLVE: method %c[%s %s] \" \"dynamically resolved to %p\", cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); &#125; else &#123; // Method resolver didn't add anything? _objc_inform(\"RESOLVE: +[%s resolveClassMethod:%s] returned YES\" \", but no new implementation of %c[%s %s] was found\", cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); &#125; &#125;&#125; 然后根据 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 函数的结果来判断是否发送 +resolveInstanceMethod 12345678910111213141516171819202122232425262728293031323334353637383940414243/************************************************************************ resolveInstanceMethod* Call +resolveInstanceMethod, looking for a method to be added to class cls.* cls may be a metaclass or a non-meta class.* Does not check if the method already exists.**********************************************************************/static void resolveInstanceMethod(Class cls, SEL sel, id inst)&#123; runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; // Resolver not implemented. return; &#125; BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(cls, SEL_resolveInstanceMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveInstanceMethod adds to self a.k.a. cls IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); if (resolved &amp;&amp; PrintResolving) &#123; if (imp) &#123; _objc_inform(\"RESOLVE: method %c[%s %s] \" \"dynamically resolved to %p\", cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); &#125; else &#123; // Method resolver didn't add anything? _objc_inform(\"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES\" \", but no new implementation of %c[%s %s] was found\", cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); &#125; &#125;&#125; 如果不是元类，则只需要发送 +resolveInstanceMethod 消息。这里调用 +resolveInstanceMethod 或 +resolveClassMethod 时再次用到了 objc_msgSend，而且第三个参数正是传入 lookUpImpOrForward 的那个 sel。在发送方法解析消息之后还会调用 lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/) 来判断是否已经添加上 sel 对应的 IMP 了，打印出结果。 lookUpImpOrNil 跟 lookUpImpOrForward 的功能很相似，只是将 lookUpImpOrForward 实现中的 _objc_msgForward_impcache 替换成了 nil: 1234567891011/************************************************************************ lookUpImpOrNil.* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache**********************************************************************/IMP lookUpImpOrNil(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver); if (imp == _objc_msgForward_impcache) return nil; else return imp;&#125; 此时不仅没查找到 IMP，动态方法解析也不奏效，只能将 _objc_msgForward_impcache 当做 IMP 并写入缓存。这也就是之前第 3 步中为何查找到 _objc_msgForward_impcache 就表明了要进入消息转发了。 解锁 runtimeLock.unlock()，并将之前找到的 IMP 返回。。 消息转发前面说到如果没有找到方法，会将 _objc_msgForward_impcache 当成imp写入缓存。_objc_msgForward_impcache 只是个内部的函数指针，只存储于类的方法缓存中，需要被转化为 _objc_msgForward 和 _objc_msgForward_stret 才能被外部调用。转换的方式也很简单，就是增加个静态入口 __objc_msgForward_impcache。 _objc_msgForward_impcache 在objc-msg-arm64.s中汇编的实现如下： 123456STATIC_ENTRY __objc_msgForward_impcache&#x2F;&#x2F; No stret specialization.b __objc_msgForwardEND_ENTRY __objc_msgForward_impcache _objc_msgForward_impcache只是入口。实际的实现函数是 objc_msgForward 1234567ENTRY __objc_msgForwardadrp x17, __objc_forward_handler@PAGEldr p17, [x17, __objc_forward_handler@PAGEOFF]TailCallFunctionPointer x17END_ENTRY __objc_msgForward objc_msgForward 函数中会调用__objc_forward_handler函数。 12345678910// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel)&#123; _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \" \"(no message forward handler is installed)\", class_isMetaClass(object_getClass(self)) ? '+' : '-', object_getClassName(self), sel_getName(sel), self);&#125;void *_objc_forward_handler = (void*)objc_defaultForwardHandler; 在Objc2.0中会有一个objc_defaultForwardHandler，看源码实现我们可以看到熟悉的语句。当我们给一个对象发送一个没有实现的方法的时候，如果其父类也没有这个方法，则会崩溃，报错信息类似于这样：unrecognized selector sent to instance，然后接着会跳出一些堆栈信息。这些信息就是从这里而来。 123456789101112131415161718192021222324252627282930313233343536373839404142/************************************************************************ objc_setForwardHandler**********************************************************************/#if !__OBJC2__// Default forward handler (nil) goes to forward:: dispatch.void *_objc_forward_handler = nil;void *_objc_forward_stret_handler = nil;#else// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel)&#123; _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \" \"(no message forward handler is installed)\", class_isMetaClass(object_getClass(self)) ? '+' : '-', object_getClassName(self), sel_getName(sel), self);&#125;void *_objc_forward_handler = (void*)objc_defaultForwardHandler;#if SUPPORT_STRETstruct stret &#123; int i[100]; &#125;;__attribute__((noreturn)) struct stret objc_defaultForwardStretHandler(id self, SEL sel)&#123; objc_defaultForwardHandler(self, sel);&#125;void *_objc_forward_stret_handler = (void*)objc_defaultForwardStretHandler;#endif#endifvoid objc_setForwardHandler(void *fwd, void *fwd_stret)&#123; _objc_forward_handler = fwd;#if SUPPORT_STRET _objc_forward_stret_handler = fwd_stret;#endif&#125; 要设置转发只要重写_objc_forward_handler方法即可。在objc_setForwardHandler方法中，可以设置ForwardHandler。 当你想要弄清objc_setForwardHandler的调用，以及之后的消息转发调用栈的时候，会发现在objc4-756.2找不到源码。这是因为objc_setForwardHandler的实现是在 Core Foundation（CoreFoundation.framework）中。虽然 CF 是开源的，但是苹果在这里做了点手脚。关于objc_setForwardHandler的调用，以及之后的消息转发调用栈的问题，需要用到逆向的知识。推荐大家看这篇文章就会明白其中的原理。 Objective-C 消息发送与转发机制原理iOS会在 CF runtime 连接到进程时初始化调用__CFInitialize() 函数，把 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 作为参数调用 objc_setForwardHandler 方法。 从函数调用栈可以看出 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 这两个 Forward Handler 做了啥： 122021-09-05 21:05:39.018585+0800 Test[46006:16033328] -[Person eat]: unrecognized selector sent to instance 0x600000db81002021-09-05 21:05:39.023782+0800 Test[46006:16033328] *** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[Person eat]: unrecognized selector sent to instance 0x600000db8100&#39;*** First throw call stack:( 0 CoreFoundation 0x00007fff23c7127e __exceptionPreprocess + 350 1 libobjc.A.dylib 0x00007fff513fbb20 objc_exception_throw + 48 2 CoreFoundation 0x00007fff23c91fd4 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132 3 CoreFoundation 0x00007fff23c75c4c ___forwarding___ + 1436 4 CoreFoundation 0x00007fff23c77f78 _CF_forwarding_prep_0 + 120 5 Test 0x000000010ba3e226 main + 54 6 libdyld.dylib 0x00007fff5227ec25 start + 1)libc++abi.dylib: terminating with uncaught exception of type NSException 这个日志场景熟悉得不能再熟悉了，可以看出 _CF_forwarding_prep_0 函数调用了 ___forwarding___ 函数，接着又调用了 doesNotRecognizeSelector 方法，最后抛出异常。 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 函数都调用了 ___forwarding___，只是传入参数不同。 消息转发的逻辑几乎都写在 ___forwarding___ 函数中了，实现比较复杂，反编译出的伪代码也不是很直观。Objective-C 消息发送与转发机制原理 的结果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485int __forwarding__(void *frameStackPointer, int isStret) &#123; id receiver = *(id *)frameStackPointer; SEL sel = *(SEL *)(frameStackPointer + 8); const char *selName = sel_getName(sel); Class receiverClass = object_getClass(receiver); // 调用 forwardingTargetForSelector: if (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123; id forwardingTarget = [receiver forwardingTargetForSelector:sel]; if (forwardingTarget &amp;&amp; forwarding != receiver) &#123; if (isStret == 1) &#123; int ret; objc_msgSend_stret(&amp;ret,forwardingTarget, sel, ...); return ret; &#125; return objc_msgSend(forwardingTarget, sel, ...); &#125; &#125; // 僵尸对象 const char *className = class_getName(receiverClass); const char *zombiePrefix = \"_NSZombie_\"; size_t prefixLen = strlen(zombiePrefix); // 0xa if (strncmp(className, zombiePrefix, prefixLen) == 0) &#123; CFLog(kCFLogLevelError, @\"*** -[%s %s]: message sent to deallocated instance %p\", className + prefixLen, selName, receiver); &lt;breakpoint-interrupt&gt; &#125; // 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation if (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123; NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel]; if (methodSignature) &#123; BOOL signatureIsStret = [methodSignature _frameDescriptor]-&gt;returnArgInfo.flags.isStruct; if (signatureIsStret != isStret) &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'. Signature thinks it does%s return a struct, and compiler thinks it does%s.\", selName, signatureIsStret ? \"\" : not, isStret ? \"\" : not); &#125; if (class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123; NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer]; [receiver forwardInvocation:invocation]; void *returnValue = NULL; [invocation getReturnValue:&amp;value]; return returnValue; &#125; else &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: object %p of class '%s' does not implement forwardInvocation: -- dropping message\", receiver, className); return 0; &#125; &#125; &#125; SEL *registeredSel = sel_getUid(selName); // selector 是否已经在 Runtime 注册过 if (sel != registeredSel) &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort\", sel, selName, registeredSel); &#125; // doesNotRecognizeSelector else if (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123; [receiver doesNotRecognizeSelector:sel]; &#125; else &#123; CFLog(kCFLogLevelWarning , @\"*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort\", receiver, className); &#125; // The point of no return. kill(getpid(), 9);&#125; 这么一大坨代码就是整个消息转发路径的逻辑，概括如下： 先调用 forwardingTargetForSelector 方法获取新的 target 作为 receiver 重新执行 selector，如果返回的内容不合法（为 nil 或者跟旧 receiver 一样），那就进入第二步。 调用 methodSignatureForSelector 获取方法签名后，判断返回类型信息是否正确，再调用 forwardInvocation 执行 NSInvocation 对象，并将结果返回。如果对象没实现 methodSignatureForSelector 方法，进入第三步。 调用 doesNotRecognizeSelector 方法。 doesNotRecognizeSelector 之前其实还有个判断 selector 在 Runtime 中是否注册过的逻辑，但在我们正常发消息的时候不会出此问题。但如果手动创建一个 NSInvocation 对象并调用 invoke，并将第二个参数设置成一个不存在的 selector，那就会导致这个问题，并输入日志 “does not match selector known to Objective C runtime”。较真儿的读者可能会有疑问：何这段逻辑判断干脆用不到却还存在着？难道除了 __CF_forwarding_prep_0 和 ___forwarding_prep_1___ 函数还有其他函数也调用 ___forwarding___ 么？莫非消息转发还有其他路径？其实并不是！原因是 ___forwarding___ 调用了 ___invoking___ 函数，所以上面的伪代码直接把 ___invoking___ 函数的逻辑也『翻译』过来了。除了 ___forwarding___ 函数，以下方法也会调用___invoking___ 函数: 123-[NSInvocation invoke]-[NSInvocation invokeUsingIMP:]-[NSInvocation invokeSuper] doesNotRecognizeSelector 方法其实在 libobj.A.dylib 中已经废弃了，而是在 CF 框架中实现，而且也不是开源的。从函数调用栈可以发现 doesNotRecognizeSelector 之后会抛出异常，而 Runtime 中废弃的实现只是打日志后直接杀掉进程（__builtin_trap()）。下面是 CF 中实现的伪代码： 123456789101112131415161718192021222324void -[NSObject doesNotRecognizeSelector:](void * self, void * _cmd, void * arg2) &#123; r14 &#x3D; ___CFFullMethodName([self class], self, arg2); _CFLog(0x3, @&quot;%@: unrecognized selector sent to instance %p&quot;, r14, self, r8, r9, stack[2048]); rbx &#x3D; _CFMakeCollectable(_CFStringCreateWithFormat(___kCFAllocatorSystemDefault, 0x0, @&quot;%@: unrecognized selector sent to instance %p&quot;)); if (*(int8_t *)___CFOASafe !&#x3D; 0x0) &#123; ___CFRecordAllocationEvent(); &#125; rax &#x3D; _objc_rootAutorelease(rbx); rax &#x3D; [NSException exceptionWithName:@&quot;NSInvalidArgumentException&quot; reason:rax userInfo:0x0]; objc_exception_throw(rax); return;&#125;void +[NSObject doesNotRecognizeSelector:](void * self, void * _cmd, void * arg2) &#123; r14 &#x3D; ___CFFullMethodName([self class], self, arg2); _CFLog(0x3, @&quot;%@: unrecognized selector sent to class %p&quot;, r14, self, r8, r9, stack[2048]); rbx &#x3D; _CFMakeCollectable(_CFStringCreateWithFormat(___kCFAllocatorSystemDefault, 0x0, @&quot;%@: unrecognized selector sent to class %p&quot;)); if (*(int8_t *)___CFOASafe !&#x3D; 0x0) &#123; ___CFRecordAllocationEvent(); &#125; rax &#x3D; _objc_rootAutorelease(rbx); rax &#x3D; [NSException exceptionWithName:@&quot;NSInvalidArgumentException&quot; reason:rax userInfo:0x0]; objc_exception_throw(rax); return;&#125; 也就是说我们可以 override doesNotRecognizeSelector 或者捕获其抛出的异常。 总结过滤了部分不会进入的分支路径和跟主题无关的细节，整体流程如下： 参考： iOS-底层原理 12：消息流程分析之快速查找（https://blog.51cto.com/u_12801393/2955213） Objc-msg-arm64源码深入分析（https://www.jianshu.com/p/835ae53372ba） OC底层原理11-objc_msgSend源码分析(方法查找快流程)（https://www.jianshu.com/p/62ecc3f31467） OC底层原理12-lookUpImpOrForward源码分析(方法查找慢流程)（https://www.jianshu.com/p/740ee19690c3） objc_msgSend 源码跟踪（https://www.jianshu.com/p/c8aedd333f2d） 深入解构objc_msgSend函数的实现（http://www.cocoachina.com/articles/24536） Objective-C 消息发送与转发机制原理","categories":[],"tags":[]},{"title":"刨根问底之-Runtime类和对象的定义","slug":"刨根问底之-Runtime类和对象的定义","date":"2021-10-30T18:40:17.933Z","updated":"2021-11-13T08:43:33.803Z","comments":true,"path":"2021/10/31/刨根问底之-Runtime类和对象的定义/","link":"","permalink":"http://heseng91.github.io/2021/10/31/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E4%B9%8B-Runtime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/","excerpt":"","text":"「刨根问底」之Objective-C 2.0 中类与对象的定义runtime简介依照苹果文档的说法，runtime是： 12The Objective-C language defers as many decisions as it can from compile time and link time to runtime. （尽量将决定放到运行的时候，而不是在编译和链接过程） 如何理解这段话呢，我们首先要知道，一段代码从写完到最终执行的过程中发生了什么。 从代码到可执行文件的过程具体过程见下图： 主要过程可以简化成三个： 123- 编译- 链接- 运行 编译：将代码转换成底层可执行的语言（如汇编），简单来讲，就是把你能看懂的语言，转换成系统底层可以看懂的东西，这中间通常会有优化，先预处理，再编译。 链接：在编译的过程中，如果有调用其他的类的方法等，是不会检查或者报警的，编译的时候会默认你已经实现了。而链接就是去检查调用的方法或者类等是否确实存在。 运行：执行最终的可执行文件 如果是普通的C语言代码，我们使用的是传统的编译运行，那么一个函数的执行内容，在编译阶段其实就确定了，执行的时候只要去执行对应的内存地址的程序就好。 因为Objc是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个 Objc 运行框架的一块基石。 Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 maxOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime之发送消息（objc_msgSend）还记得刚学 Objective-C 时把 [receiver message] 当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。其实 [receiver message] 会被编译器转化为： 1objc_msgSend(receiver, selector) 如果消息含有参数，则为： 1objc_msgSend(receiver, selector, arg1, arg2, ...) 如果消息的接收者能够找到对应的 selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个 selector 对应的实现内容，要么就干脆玩完崩溃掉。 消息发送等下章详细表述。本文基于源码为 objc4-756.2，先来介绍一下 Objective-C 2.0 中类与对象的相关定义，仅作为参考，暂不做深入的分析。 Runtime 基础数据结构前面提到的objc_msgSend:的真身是这样的： 1id objc_msgSend ( id self, SEL op, ... ); 下面将会逐渐展开介绍一些术语，其实它们都对应着数据结构。 SELobjc_msgSend函数第二个参数类型为SEL，它是selector在Objc中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL: 1typedef struct objc_selector *SEL; 其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获得一个 SEL 类型的方法选择器。 不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(参见：NSNumber 一堆抽象工厂方法)，Cocoa 中也有好多长长的方法。 idobjc_msgSend 第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针： 1typedef struct objc_object *id; 那objc_object又是啥呢，参考 objc-private.h 文件部分源码： 12345678910111213struct objc_object &#123;private: isa_t isa;public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // getIsa() allows this to be a tagged pointer object Class getIsa(); ... 此处省略其他方法声明&#125; objc_object 结构体包含一个 isa 指针，类型为 isa_t 联合体。根据 isa 就可以顺藤摸瓜找到对象所属的类。 PS: isa 指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用 class 方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见官方文档 isa_tobjc_object 中的 isa 是一个 isa_t 类型的共用体（union），在objc-private.h 文件中定义如下： 123456789101112union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 其中 ISA_BITFIELD在 isa.h文件中定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#if SUPPORT_PACKED_ISA // extra_rc must be the MSB-most field (so it matches carry/overflow flags) // nonpointer must be the LSB (fixme or get rid of it) // shiftcls must occupy the same bits that a real class pointer would // bits + RC_ONE is equivalent to extra_rc + 1 // RC_HALF is the high bit of extra_rc (i.e. half of its range) // future expansion: // uintptr_t fast_rr : 1; // no r/r overrides // uintptr_t lock : 2; // lock for atomic property, @synch // uintptr_t extraBytes : 1; // allocated with extra bytes# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18)# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 8# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7)# else# error unknown architecture for packed isa# endif SUPPORT_PACKED_ISA 用于标记是否支持优化的 isa 指针，其字面含义意思是 isa 的内容不再是类的指针了，而是包含了更多信息，比如引用计数，析构状态，被其他 weak 变量引用情况。判断方法也是根据设备类型： 12345678// Define SUPPORT_PACKED_ISA=1 on platforms that store the class in the isa // field as a maskable pointer with other data around it.#if (!__LP64__ || TARGET_OS_WIN32 || \\ (TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_IOSMAC))# define SUPPORT_PACKED_ISA 0#else# define SUPPORT_PACKED_ISA 1#endif 综合看来目前只有 arm64 架构的设备支持，下面列出了 isa 指针中变量对应的含义： 变量名 含义 nonpointer 0 表示普通的 isa 指针，1 表示使用优化，存储引用计数 has_assoc 表示该对象是否包含 associated object，如果没有，则析构时会更快 has_cxx_dtor 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls 类的指针 magic 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。 weakly_referenced 表示该对象是否有过 weak 对象，如果没有，则析构时更快 deallocating 表示该对象是否正在析构 has_sidetable_rc 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_rc 存储引用计数值减一后的结果 ClassClass 其实是一个指向 objc_class 结构体的指针： 1typedef struct objc_class *Class; 而 objc_class 包含很多方法，主要都为围绕它的几个成员做文章： 123456789101112struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125; ...// 省略其他方法&#125; objc_class 继承于 objc_object，也就是说一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似 [NSObject alloc] 的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 [NSObject alloc] 这条消息发给类对象的时候，objc_msgSend() 会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。 上图实线是 superclass 指针，虚线是isa指针。 有趣的是根元类的超类是 NSObject，而 isa 指向了自己，而 NSObject的超类为 nil，也就是它没有超类。 cache_t1234567struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;... //省略其他方法&#125; 其中，bucket_t *_buckets 是一个散列表，用来存储 Method 方法列表，而 bucket_t 结构体定义如下，包含了一个 unsigned long 类型的 _key 和一个 IMP 类型的 _imp，存储了指针与 IMP 的键值对。IMP 是一个函数指针，指向了一个方法的具体实现。 1234567891011121314struct bucket_t &#123;private: // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64.#if __arm64__ uintptr_t _imp; SEL _sel;#else SEL _sel; uintptr_t _imp;#endif... 省略其他方法&#125;; cache_t 中另外两个变量 _mask 和 _occupied，它们的类型为 mask_t，定义如下，其实是一个 unsigned int。 12345#if __LP64__typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t;#endif _mask 和 _occupied 对应于 vtable： _mask：分配用来缓存 bucket 的总数。 _occupied：表明目前实际占用的缓存 bucket 的个数。 cache 的作用主要是对方法调用的性能进行优化。通俗地讲，每当实例对象接收到一个消息时，它不会直接在其 isa 指向的类（或类的 isa 指向的父类）的方法列表中遍历查找能够响应消息的方法实现，因为这样效率太低了，而是优先在 cache 中查找。Runtime 系统会把被调用过的方法存到该类对象的 cache 中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。 有关缓存的实现细节，可以查看 objc-cache.mm 文件。 class_data_bits_tobjc_class 中最复杂的是 bits，class_data_bits_t 结构体所包含的信息太多了，主要包含 class_rw_t, retain/release/autorelease/retainCount 和 alloc 等信息，很多存取方法也是围绕它展开。查看 objc-runtime-new.h 源码如下： 123456789101112131415161718struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;private: bool getBit(uintptr_t bit) &#123; return bits &amp; bit; &#125;...public: class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;...省略其他方法&#125; 注意 objc_class 的 data 方法直接将 class_data_bits_t 的data 方法返回，最终是返回 class_rw_t，保了好几层。 可以看到 class_data_bits_t 里又包了一个 bits，这个指针跟不同的 FAST_ 前缀的 flag 掩码做按位与操作，就可以获取不同的数据。bits 在内存中每个位的含义有三种排列顺序： 32 位： 0 1 2 - 31 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_DATA_MASK 64 位兼容版： 0 1 2 3 - 46 47 - 63 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_HAS_DEFAULT_RR FAST_DATA_MASK 空闲 64 位不兼容版： 0 1 2 3 - 46 47 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_ALLOC FAST_DATA_MASK FAST_HAS_CXX_CTOR 48 49 50 51 52 - 63 FAST_HAS_DEFAULT_AWZ FAST_HAS_DEFAULT_RR FAST_REQUIRES_RAW_ISA FAST_HAS_CXX_DTOR 空闲 其中 64 位不兼容版每个宏对应的含义如下： 1234567891011121314151617181920212223242526// class is a Swift class from the pre-stable Swift ABI#define FAST_IS_SWIFT_LEGACY (1UL&lt;&lt;0)// class is a Swift class from the stable Swift ABI#define FAST_IS_SWIFT_STABLE (1UL&lt;&lt;1)// summary bit for fast alloc path: !hasCxxCtor and // !instancesRequireRawIsa and instanceSize fits into shiftedSize#define FAST_ALLOC (1UL&lt;&lt;2)// data pointer#define FAST_DATA_MASK 0x00007ffffffffff8UL// class or superclass has .cxx_construct implementation#define FAST_HAS_CXX_CTOR (1UL&lt;&lt;47)// class or superclass has default alloc/allocWithZone: implementation// Note this is is stored in the metaclass.#define FAST_HAS_DEFAULT_AWZ (1UL&lt;&lt;48)// class or superclass has default retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference#define FAST_HAS_DEFAULT_RR (1UL&lt;&lt;49)// class's instances requires raw isa// This bit is aligned with isa_t-&gt;hasCxxDtor to save an instruction.#define FAST_REQUIRES_RAW_ISA (1UL&lt;&lt;50)// class or superclass has .cxx_destruct implementation#define FAST_HAS_CXX_DTOR (1UL&lt;&lt;51)// instance size in units of 16 bytes// or 0 if the instance size is too big in this field// This field must be LAST#define FAST_SHIFTED_SIZE_SHIFT 52 这里面除了 FAST_DATA_MASK 是用一段空间存储数据外，其他宏都是只用 1 bit 存储 bool 值。class_data_bits_t 提供了三个方法用于位操作：getBit, setBits 和 clearBits，对应到存储 bool 值的掩码也有封装函数，比如： 123456bool hasCxxCtor() &#123; return getBit(FAST_HAS_CXX_CTOR);&#125;void setHasCxxCtor() &#123; setBits(FAST_HAS_CXX_CTOR);&#125; 重头戏在于最大的那块存储区域–FAST_DATA_MASK，它其实就存储了指向 class_rw_t 的指针： 123class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK);&#125; 对这片内存读写处于并发环境，但并不需要加锁，因为会通过对一些状态（realization or construction）判断来决定是否可读写。 class_data_bits_t 甚至还包含了一些对 class_rw_t 中 flags 成员存取的封装函数。 class_rw_tobjc_class 包含了 class_data_bits_t，class_data_bits_t 存储了 class_rw_t 的指针。 1234567891011121314151617181920212223struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;#if SUPPORT_INDEXED_ISA uint32_t index;#endif...省略操作 flags 的相关方法&#125; class_rw_t 中使用的 method_array_t, property_array_t, protocol_array_t 都继承自 list_array_tt&lt;Element, List&gt;, 它可以不断扩张，因为它可以存储 list 指针，内容有三种： 空 一个 entsize_list_tt 指针 entsize_list_tt 指针数组 class_rw_t 的内容是可以在运行时被动态修改的，可以说运行时对类的拓展大都是存储在这里的。 class_rw_t-&gt;flags 存储的值并不是编辑器设置的，其中有些值可能将来会作为 ABI 的一部分。下面这些 RW_ 前缀的宏标记了 flags 一些位置的含义。这些 bool 值标记了类的一些状态，涉及到声明周期和内存管理。有些位目前甚至还空着。 12345678910111213141516171819202122232425262728293031// Values for class_rw_t-&gt;flags// These are not emitted by the compiler and are never used in class_ro_t. // Their presence should be considered in future ABI versions.// class_t-&gt;data is class_rw_t, not class_ro_t#define RW_REALIZED (1&lt;&lt;31)// class is unresolved future class#define RW_FUTURE (1&lt;&lt;30)// class is initialized#define RW_INITIALIZED (1&lt;&lt;29)// class is initializing#define RW_INITIALIZING (1&lt;&lt;28)// class_rw_t-&gt;ro is heap copy of class_ro_t#define RW_COPIED_RO (1&lt;&lt;27)// class allocated but not yet registered#define RW_CONSTRUCTING (1&lt;&lt;26)// class allocated and registered#define RW_CONSTRUCTED (1&lt;&lt;25)// available for use; was RW_FINALIZE_ON_MAIN_THREAD// #define RW_24 (1&lt;&lt;24)// class +load has been called#define RW_LOADED (1&lt;&lt;23)#if !SUPPORT_NONPOINTER_ISA// class instances may have associative references#define RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS (1&lt;&lt;22)#endif// class has instance-specific GC layout#define RW_HAS_INSTANCE_SPECIFIC_LAYOUT (1 &lt;&lt; 21)// class does not allow associated objects on its instances#define RW_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;20)// class has started realizing but not yet completed it#define RW_REALIZING (1&lt;&lt;19) demangledName 是计算机语言用于解决实体名称唯一性的一种方法，做法是向名称中添加一些类型信息，用于从编译器中向链接器传递更多语义信息。 class_ro_tclass_rw_t 提供了运行时对类拓展的能力，而 class_ro_t 存储的大多是类在编译时就已经确定的信息。二者都存有类的方法、属性（成员变量）、协议等信息，不过存储它们的列表实现方式不同。 class_ro_t 中的 method_list_t, ivar_list_t, property_list_t 结构体都继承自 entsize_list_tt&lt;Element, List, FlagMask&gt;。结构为 xxx_list_t 的列表元素结构为 xxx_t，命名很工整。protocol_list_t 与前三个不同，它存储的是 protocol_t * 指针列表，实现比较简单。 entsize_list_tt 实现了 non-fragile 特性的数组结构。假如苹果在新版本的 SDK 中向 NSObject 类增加了一些内容，NSObject 的占据的内存区域会扩大，开发者以前编译出的二进制中的子类就会与新的 NSObject 内存有重叠部分。于是在编译期会给 instanceStart 和 instanceSize 赋值，确定好编译时每个类的所占内存区域起始偏移量和大小，这样只需将子类与基类的这两个变量作对比即可知道子类是否与基类有重叠，如果有，也可知道子类需要挪多少偏移量。更多细节可以参考后面的章节 Non Fragile ivars。 123456789101112131415161718192021222324struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; // This field exists only when RO_HAS_SWIFT_INITIALIZER is set. _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0];...省略其他方法&#125;; class_ro_t-&gt;flags 存储了很多在编译时期就确定的类的信息，也是 ABI 的一部分。下面这些 RO_ 前缀的宏标记了 flags 一些位置的含义。其中后三个并不需要被编译器赋值，是预留给运行时加载和初始化类的标志位，涉及到与 class_rw_t 的类型强转。运行时会用到它做判断，后面会讲解。 1234567891011121314151617181920212223242526272829303132333435// class_data_bits_t is the class_t-&gt;data field (class_rw_t pointer plus flags)// The extra bits are optimized for the retain/release and alloc/dealloc paths.// Values for class_ro_t-&gt;flags// These are emitted by the compiler and are part of the ABI.// Note: See CGObjCNonFragileABIMac::BuildClassRoTInitializer in clang// class is a metaclass#define RO_META (1&lt;&lt;0)// class is a root class#define RO_ROOT (1&lt;&lt;1)// class has .cxx_construct/destruct implementations#define RO_HAS_CXX_STRUCTORS (1&lt;&lt;2)// class has +load implementation// #define RO_HAS_LOAD_METHOD (1&lt;&lt;3)// class has visibility=hidden set#define RO_HIDDEN (1&lt;&lt;4)// class has attribute(objc_exception): OBJC_EHTYPE_$_ThisClass is non-weak#define RO_EXCEPTION (1&lt;&lt;5)// class has ro field for Swift metadata initializer callback#define RO_HAS_SWIFT_INITIALIZER (1&lt;&lt;6)// class compiled with ARC#define RO_IS_ARC (1&lt;&lt;7)// class has .cxx_destruct but no .cxx_construct (with RO_HAS_CXX_STRUCTORS)#define RO_HAS_CXX_DTOR_ONLY (1&lt;&lt;8)// class is not ARC but has ARC-style weak ivar layout #define RO_HAS_WEAK_WITHOUT_ARC (1&lt;&lt;9)// class does not allow associated objects on instances#define RO_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;10)// class is in an unloadable bundle - must never be set by compiler#define RO_FROM_BUNDLE (1&lt;&lt;29)// class is unrealized future class - must never be set by compiler#define RO_FUTURE (1&lt;&lt;30)// class is realized - must never be set by compiler#define RO_REALIZED (1&lt;&lt;31) realizeClass在某个类初始化之前，objc_class-&gt;data() 返回的指针指向的其实是个 class_ro_t 结构体。等到 static Class realizeClass(Class cls) 静态方法在类第一次初始化时被调用，它会: 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针 初始化一个 class_rw_t 结构体 设置结构体 ro 的值以及 flag 最后设置正确的 data。 将 class_ro_t 指针赋值给 class_rw_t-&gt;ro。这种偷天换日的行为是靠 RO_FUTURE 标志位来记录的： 123456789101112131415161718192021222324252627/************************************************************************ realizeClassWithoutSwift* Performs first-time initialization on class cls, * including allocating its read-write data.* Does not perform any Swift-side initialization.* Returns the real class structure for the class. * Locking: runtimeLock must be write-locked by the caller**********************************************************************/static Class realizeClassWithoutSwift(Class cls)&#123;... ro = (const class_ro_t *)cls-&gt;data(); if (ro-&gt;flags &amp; RO_FUTURE) &#123; // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro; cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE); &#125; else &#123; // Normal class. Allocate writeable class data. rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); rw-&gt;ro = ro; rw-&gt;flags = RW_REALIZED|RW_REALIZING; cls-&gt;setData(rw); &#125;...省略逻辑实现&#125; 注意之前 RO 和 RW flags 宏标记的一个细节： 12345#define RO_FUTURE (1&lt;&lt;30)#define RO_REALIZED (1&lt;&lt;31)#define RW_REALIZED (1&lt;&lt;31)#define RW_FUTURE (1&lt;&lt;30) 也就是说 ro = (const class_ro_t *)cls-&gt;data(); 这种强转对于接下来的 ro-&gt;flags &amp; RO_FUTURE 操作完全是 OK 的，两种结构体第一个成员都是 flags，RO_FUTURE 与 RW_FUTURE 值一样的。 经过 realizeClass 函数处理的类才是『真正的』类，调用它时不能对类做写操作。 Ivar在 objc-private.h 中，Ivar 被定义为一个指向 ivar_t 结构体的指针： 1#if __OBJC2__typedef struct ivar_t *Ivar; ivar_t 结构体在 objc-runtime-new.h 中定义： 123456789101112131415161718192021struct ivar_t &#123;#if __x86_64__ // *offset was originally 64-bit on some x86_64 platforms. // We read and write only 32 bits of it. // Some metadata provides all 64 bits. This is harmless for unsigned // little-endian values. // Some code uses all 64 bits. class_addIvar() over-allocates the // offset for their benefit.#endif int32_t *offset; const char *name; const char *type; // alignment is sometimes -1; use alignment() instead uint32_t alignment_raw; uint32_t size; uint32_t alignment() const &#123; if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT; return 1 &lt;&lt; alignment_raw; &#125;&#125;; Ivar 用于表示类中实例变量（成员变量）的类型，ivar_t 中定义了实例变量的名字和类型。而ivar 的修饰信息存放在了 Class 的 Ivar Layout 中。ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型。 举个例子说明，若类定义为： 1234567@interfaceFoo : NSObject &#123; __strong id ivar0; __weak id ivar1; __weak id ivar2;&#125;@end 则储存 strong ivar 的 ivarLayout 的值为 0x012000 储存 weak ivar 的 weakIvarLayout 的值为 0x1200 一个 uint8_t 在 16 进制下是两位，所以编码的值每两位一对儿，以上面的 ivarLayout 为例： 前两位 01 表示有 0 个非 strong 对象和 1 个 strong 对象 之后两位 20 表示有 2 个非 strong 对象和 0 个 strong 对象 最后两位 00 为结束符，就像 cstring 的 \\0 一样 同理，上面的 weakIvarLayout： 前两位 12 表示有 1 个非 weak 对象和接下来连续 2 个 weak 对象 00 结束符 这样，用两个 layout 编码值就可以排查出一个 ivar 是属于 strong 还是 weak 的，若都没有找到，就说明这个对象是 unsafe_unretained. Property我们知道，@property 用于声明类中的属性，在 Runtime 系统中，objc_property_t 是一个指向objc_property 结构体的指针，在 objc-private.h 中定义： 1#if __OBJC2__typedef struct property_t *objc_property_t; property_t 结构体在 objc-runtime-new.h 中定义： 1234struct property_t &#123; const char *name; const char *attributes;&#125;; MethodMethod是一种代表类中的某个方法的类型。 1#if __OBJC2__typedef struct method_t *Method; 而 objc_method 在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现： 1234567891011121314struct method_t &#123; SEL name; const char *types; MethodListIMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;; 方法名类型为 SEL，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。 方法类型 types 是个char指针，其实存储着方法的参数类型和返回值类型。 imp 指向了方法的实现，本质上是一个函数指针，后面会详细讲到。 CategoryCategory 为现有的类提供了拓展性，它是 category_t 结构体的指针。 1#if __OBJC2__typedef struct category_t *Category; category_t 存储了类别中可以拓展的实例方法、类方法、协议、实例属性和类属性。类属性是 Objective-C 2016 年新增的特性，沾 Swift 的光。所以 category_t 中有些成员变量是为了兼容 Swift 的特性，Objective-C 暂没提供接口，仅做了底层数据结构上的兼容。 1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; 在 App 启动加载镜像文件时，会在 _read_images 函数间接调用到 attachCategories 函数，完成向类中添加 Category 的工作。原理就是向 class_rw_t 中的 method_array_t, property_array_t, protocol_array_t 数组中分别添加 method_list_t, property_list_t, protocol_list_t 指针。之前讲过 xxx_array_t 可以存储对应 xxx_list_t 的指针数组。 在调用 attachCategories 函数之前，会先使用 unattachedCategoriesForClass 函数获取类中还未添加的类别列表。这个列表类型为 locstamped_category_list_t，它封装了 category_t 以及对应的 header_info。header_info 存储了实体在镜像中的加载和初始化状态，以及一些偏移量，在加载 Mach-O 文件相关函数中经常用到。 123456789101112struct locstamped_category_t &#123; category_t *cat; struct header_info *hi;&#125;;struct locstamped_category_list_t &#123; uint32_t count;#if __LP64__ uint32_t reserved;#endif locstamped_category_t list[0];&#125;; 所以更具体来说 attachCategories 做的就是将 locstamped_category_list_t.list 列表中每个 locstamped_category_t.cat 中的那方法、协议和属性分别添加到类的 class_rw_t 对应列表中。header_info 中的信息决定了是否是元类，从而选择应该是添加实例方法还是类方法、实例属性还是类属性等。源码在 objc-runtime-new.mm 文件中，很好理解。 protocol_t虽然 Objective-C 的 Category 和 protocol 拓展能力有限，但也得为了将就 Swift 的感受，充个胖子。 flags 32 位指针最后两位是给加载 Mach-O 的 fix-up 阶段使用的，前 16 位预留给 Swift 用的。 protocol 主要内容其实是（可选）方法，其次就是继承其他 protocol。Swift 还支持 protocol 多继承，所以需要 protocols 数组来做兼容。 123456789101112131415161718192021222324struct protocol_t : objc_object &#123; const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; const char *demangledName(); const char *nameForLogging() &#123; return demangledName(); &#125;... 省略一些封装的便捷 get 方法&#125;; IMPIMP在objc.h中的定义是： 1typedef void (*IMP)(void /* id, SEL, ... */ ); 它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。既然得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面会提到。 你会发现 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址；反之亦然。 总结我们可以用如下这张图来分别表示 Objective-C 2.0 版本中类和对象的定义，及相关数据结构的关系： 拓展Tagged Pointerisa 这里还涉及到 Tagged Pointer 等概念。因为 isa_t 使用 union 实现，所以可能表示多种形态，既可以当成是指针，也可以存储标志位。 Tagged Pointer：一种特殊标记的对象，Tagged Pointer 通过在其最后一个 bit 位设置为特殊标记位，并且把数据直接保存在指针本身中。Tagged Pointer 是一个”伪”对象，使用 Tagged Pointer 有 3 倍的访问速度提升，100 倍的创建、销毁速度提升。 Tips：Advances in Objective-C 在我们查看对象指针时，在 64 位系统中，我们会看到 16 进制地址如0x00000001003041e0，我们把它转换为二进制表示如下图 在 64 位系统中，我们有 64 位可以表示一个对象指针，但是我们通常没有真正使用到所有这些位。由于内存对齐要求的存在，低位始终为0，对象必须始终位于指针大小倍数的地址中。由于地址空间有限，所以高位也始终为0。所以实际上我们只在一个真正的对象指针中使用了中间的这些位，而不会用到用到2^64，这些高位和低位总是0。 苹果从这些始终为0的位中选择了低位并把它设置为1。以标识这不是一个真正的对象指针，然后就可以给其他位赋予一些其他的意义，苹果称这种指针为tagged pointer。 例如：NSNumber指针，苹果在其它位中塞入的是一个数值。（PS：这些值实际上是通过与进程启动时初始化的随机值相结合而被混淆的）。 在设置为 1 表示为 Tagged Pointer 对象之后，在最低位之后的 3 位，苹果给他赋予类型意义，由于只有 3 位，所以它可以表示 7 种数据类型 12345678OBJC_TAG_NSAtom &#x3D; 0, OBJC_TAG_1 &#x3D; 1, OBJC_TAG_NSString &#x3D; 2, OBJC_TAG_NSNumber &#x3D; 3, OBJC_TAG_NSIndexPath &#x3D; 4, OBJC_TAG_NSManagedObjectID &#x3D; 5, OBJC_TAG_NSDate &#x3D; 6, OBJC_TAG_7 &#x3D; 7 在剩余的字段中，我们可以赋予他所包含的数据。在 Intel 中，我们 Tagged Pointer 对象的表示如下 OBJC_TAG_7类型的 Tagged Pointer 是个例外，它可以将接下来后 8 位作为它的扩展类型字段，基于此我们可以多支持 256 中类型的 Tagged Pointer，如 UIColors 或 NSIndexSets 之类的对象。 OC对象占用的大小初始OC对象占用内存OC中对象大部分继承至NSObject。NSObject类的定义如下： 123456789OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ROOT_CLASSOBJC_EXPORT@interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125; 上文中提到Class其实就是一个指向 struct objc_class 结构体类型的指针.。那么也就是说 NSObject 对象对应的结构体只包含一个 isa 指针变量 ，一个指针变量在 64 位的机器上大小是 8 个字节。 那是不是说一个 NSObject 对象就占用8个字节大小的内存呢？实际上不是的. 答案其实是: 所有的OC对象至少为16字节. 我们先来验证一下。 12345678910#import &lt;Foundation&#x2F;Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; &#x2F;&#x2F; insert code here... NSObject *obj &#x3D; [[NSObject alloc] init]; NSLog(@&quot;Hello, World! %@&quot;,obj); &#125; return 0;&#125; 打印语句加个断点。 lldb中打印得出：对象实际占用的内存大小为8，实际分配的内存大小为16。 lldb查看布情况，可以看出创建的对象后面几个字节全部为 00。 我们可以通过阅读 objc4 的源码来找到答案。通过查看跟踪 obj4 中 alloc 和 allocWithZone 两个函数的实现，会发现这个连个函数都会调用一个 instanceSize 的函数： 123456size_t instanceSize(size_t extraBytes) &#123; size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16bytes. if (size &lt; 16) size = 16; return size; &#125; 上面源码中我们看出了答案, 最少会开辟16个字节. 那么为什么非要用 16 个字节来存储 8 个字节的内容呢? 这里简单解释一下 . 其实这里主要是涉及到硬件问题, 因为不同厂商之间需要一套标准化方案来解决不同厂商之间规则不同导致内存读取使用出现不统一的情况.为了解决这种问题而产生的 字节对齐. 讲到这里,我还想继续看下 当这个对象包含多个属性时使用内存情况. 以便我们彻底搞明白 OC 对象使用内存情况. 包含其他属性占用内存情况创建一个 Person 类,继承与 NSObject , 其包含三个 int 属性。修改main.m 文件如下： 12345678910111213141516171819202122#import &lt;Foundation&#x2F;Foundation.h&gt;@interface Person : NSObject@property (nonatomic, assign) int age;@property (nonatomic, assign) int height;@property (nonatomic, assign) int row;@end@implementation Person@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *obj &#x3D; [[Person alloc] init]; obj.age &#x3D; 4; obj.height &#x3D; 5; obj.row &#x3D; 6; NSLog(@&quot;Hello, World! %@&quot;,obj); &#125; return 0;&#125; lldb打印对象内存情况如下 ![屏幕快照 2021-08-22 下午11.50.02](/Users/ethenfarben/Desktop/屏幕快照 2021-08-22 下午11.50.02.png) 对象实际占用内存大小为24，实际分配的内存大小为32。 ![屏幕快照 2021-08-22 下午11.41.12](/Users/ethenfarben/Desktop/屏幕快照 2021-08-22 下午11.41.12.png) 这里就出现一个比较奇怪的现象 , 实际需要内存大小 24, 为什么呢 ? 其实这里就是 结构体内存分配的原理了. 结构体每个成员相对于结构体首地址的偏移量都是这个成员大小的整数倍，如果有需要，编译器会在成员之间加上填充字节 结构体的总大小为结构体最宽成员大小的整数倍。 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。 对于结构体成员属性中包含结构体变量的复合型结构体，在确定最宽基本类型成员时，应当包括复合类型成员的子成员。但在确定复合类型成员的偏移位置时则是将复合类型作为整体看待。 由于原本结构体 isa指针占用8个 , age属性占用4个, height占用 4个, row属性再占用4个 , 这中间由于满足整除并没有自动偏移补充. 而由于 : 结构体的总大小为结构体最宽成员大小的整数倍 , 而且对线开辟满足 16 字节对齐原则 ( 可以在 libmaclloc 源码查找到 ) , 因此实际总占用内存为24. 而实际开辟则满足对齐标准开辟为 32. 在 libmaclloc 源码 , nano_malloc.c 中 1234567891011121314static MALLOC_INLINE size_tsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)&#123; size_t k, slot_bytes; if (0 == size) &#123; size = NANO_REGIME_QUANTA_SIZE; // Historical behavior &#125; k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // round up and shift for number of quanta slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; // multiply by power of two quanta size *pKey = k - 1; // Zero-based! return slot_bytes;&#125; 其中NANO_REGIME_QUANTA_SIZE 和 SHIFT_NANO_QUANTUM在nano_zone_common.h中定义如下： 12#define SHIFT_NANO_QUANTUM 4#define NANO_REGIME_QUANTA_SIZE (1 &lt;&lt; SHIFT_NANO_QUANTUM) &#x2F;&#x2F; 16 所以16字节对齐算法为：size + (2^4 - 1) &gt;&gt; 4 &lt;&lt; 4。 总结 (只考虑64位): OC对象 最少占用 16个字节内存 . 当对象中包含属性, 会按属性占用内存开辟空间. 在结构体内存分配原则下自动偏移和补齐 . 对象最终满足 16字节对齐标准 . 属性最终满足 8字节对齐标准 . 可以通过 #pragma pack() 自定义对齐方式 . 更新在2020年WWDC中，Runtime又有了一些更新。详见：2020 – Advancements in the Objective-C runtime主要更新内容如下: 数据结构的变化在介绍更新之前，先了解一下二进制类在磁盘中的表示。 ![屏幕快照 2021-08-21 下午9.40.03](/Users/ethenfarben/Desktop/屏幕快照 2021-08-21 下午9.40.03.png) 首先是类对象本身，包含最常访问的信息：指向元类，超类和方法缓存的指针，在类结构之中有指向包含更多数据的结构体class_ro_t的指针，包含了类的名称，方法，协议，实例变量等等编译期确定的信息。 当类被 Runtime 加载之后，类的结构会发生一些变化，在了解这些变化之前，我们需要知道2个概念： Clean Memory：加载后不会发生更改的内存块，class_ro_t属于Clean Memory，因为它是只读的。 Dirty Memory：运行时会进行更改的内存块，类一旦被加载，就会变成Dirty Memory，例如，我们可以在 Runtime 给类动态的添加方法。 这里要明确，Dirty Memory比Clean Memory要昂贵得多。因为它需要更多的内存信息，并且只要进程正在运行，就必须保留它。对于我们来说，越多的Clean Memory显然是更好的，因为它可以节约更多的内存。我们可以通过分离出永不更改的数据部分，将大多数类数据保留为Clean Memory，如何怎么做的呢？ 在介绍优化方法之前，我们先来看一下，在类加载之后，类的结构会变成如何呢？ ![屏幕快照 2021-08-21 下午9.44.24](/Users/ethenfarben/Desktop/屏幕快照 2021-08-21 下午9.44.24.png) 在类加载到 Runtime 中后会被分配用于读取/写入数据的结构体class_rw_t。 Tips：class_ro_t是只读的，存放的是编译期间就确定的字段信息；而class_rw_t是在 runtime 时才创建的，它会先将class_ro_t的内容拷贝一份，再将类的分类的属性、方法、协议等信息添加进去，之所以要这么设计是因为 Objective-C 是动态语言，你可以在运行时更改它们方法，属性等，并且分类可以在不改变类设计的前提下，将新方法添加到类中。 事实证明，class_rw_t会占用比class_ro_t占用更多的内存，在 iPhone 中，我们在系统测量了大约 30MB 的这些class_rw_t结构。应该如何优化这些内存呢？通过测量实际设备上的使用情况，我们发现大约 10％ 的类实际会存在动态的更改行为，如动态添加方法，使用 Category 方法等。因此，我们能可以把这部分动态的部分提取出来，我们称之为class_rw_ext_t，所以，结构会变成这个样子。 ![屏幕快照 2021-08-21 下午10.05.15](/Users/ethenfarben/Desktop/屏幕快照 2021-08-21 下午10.05.15.png) 经过拆分，可以把 90% 的类优化为Clean Memory，在系统层面，取得效果是节省了大约 14MB 的内存，使内存可用于更有效的用途。 Tips：head xxxxx | egrep &#39;class_rw|COUNT’ 你可以使用此命令来查看 class_rw_t 消耗的内存。xxxx可以替换为需要测量的 App 名称。如：head Mail | egrep &#39;class_rw|COUNT’\\&#39;查看 Mail 应用的使用情况。 Tagged pointer格式的变化相比于之前的Tagged pointer，在 ARM64 中格式有些变化。 ![屏幕快照 2021-08-22 上午5.33.02](/Users/ethenfarben/Desktop/屏幕快照 2021-08-22 上午5.33.02.png) 不同于以往，苹果使用最高位代表 Tagged Pointer 标识位，低位 3 位标识 Tagged Pointer 的类型，接下去的位来表示包含的数据（可能包含扩展类型字段），为什么我们使用高位指示 ARM上 的 Tagged Pointer，而不是像 Intel 一样使用低位标记？ 它实际是对 objc_msgSend 的微小优化。我们希望 msgSend 中最常用的路径尽可能快。最常用的路径表示普通对象指针。我们有两种不常见的情况：Tagged Pointer 指针和 nil。事实证明，当我们使用最高位时，可以通过一次比较来检查两者。与分别检查 nil 和 Tagged Pointer 指针相比，这会为 msgSend 中的节省了条件分支。 应用判断类有没有初始化很多技术博客里都提到了，ObjC类的meta class里，自带了一个标记自己有没有初始化过的flag，即class_rw_t–&gt;flags里的RW_INITIALIZED。objc_class类中有提供了封装的函数供外部快速获取该flag值。调用相关代码如下： 12345678910111213141516171819202122// objc_class 代码片段struct objc_class : objc_object &#123;... class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125;... bool isInitialized() &#123; return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED; &#125; void setInitialized();... // NOT identical to this-&gt;ISA when this is a metaclass Class getMeta() &#123; if (isMetaClass()) return (Class)this; else return this-&gt;ISA(); &#125;...&#125; 123456789101112struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;...public: class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;...&#125; 12345struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags;...&#125; 可惜的是，这些方法对我们app来说，是不可见的，没办法直接调用。所以如果想要在运行过程中获取类的初始化状态，只能另想办法。从方法的调用情况看到方法的过程大概分为4步： 我们要先找到类的meta class。 获取objc_class的成员变量bits（class_data_bits_t结构体） 调用class_data_bits_t结构体的data()方法，对结构体的bits属性进行位运算，获取class_rw_t结构体 最后获取class_rw_t结构体的成员变量flags并进行位运算 因为runtime源代码是用C++来写的，所以我们可以通过偏移地址获取到用到的变量，直接用指针来搞定问题。 针对第一步，获取类的meta class，是个runtime里可见的方法，直接调用objc_getMetaClass()方法就能拿到。 第二步获取objc_class的成员变量bits。回到objc_class的头部几行： 1234567891011struct objc_class : objc_object &#123; objc_class(const objc_class&amp;) = delete;// 0 bytes objc_class(objc_class&amp;&amp;) = delete;// 0 bytes void operator=(const objc_class&amp;) = delete;// 0 bytes void operator=(objc_class&amp;&amp;) = delete;// 0 bytes // Class ISA; Class superclass; // 8 bytes cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags...&#125; 首先objc_class 继承至 objc_object，对于子结构体来说，是需要继承父结构体的成员变量的。runtime源代码是用C++来写的，函数都不会占用类meta信息（或者说实例）的内存地址，只有成员变量会占用地址。objc_object父结构如前表述，仅包含isa这个成员变量，占用类实例的头8个bytes，也就是64位CPU的一个指针的长度；而下面的一堆方法，在实例里面一点内存都不占用。然后看完整个结构体，只有这么一个成员变量，所以总长度也就8个bytes。 objc_class内前面几行那几个函数禁用语句，不会产生内存地址的偏移，先不管它们。 superclass作为一个指针（对，Class类型实际上是一个指向结构体的指针），长度为8 bytes。 接下来是cache_t类型的变量cache，它占用了多少bytes我们就要展开看看了。 123456789101112131415161718192021#if __LP64__typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t;#endif...struct cache_t &#123;private: explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;// 8 bytes union &#123; struct &#123; explicit_atomic&lt;mask_t&gt; _maybeMask;//4 bytes#if __LP64__ uint16_t _flags;//2 bytes#endif uint16_t _occupied;//2 bytes &#125;; explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;// 8 bytes &#125;;...&#125; 首先说一下explicit_atomic&lt;T&gt;，它只是负责把模板里的类型包成atomic的，不会对变量占用的内存长度产生影响。 然后要说一下union，C++的老朋友了，联合体内部的成员取最长的一个内存长度，就是联合体的内存长度，这里就是8 bytes。 mask_t的定义在文件头就能找到，其实在64位CPU下就是一个uint32_t而已。 基于上面的介绍，可以推断出整个cache_t结构体的长度就是8 bytes + 8 bytes = 16 bytes。 综上，bits 偏移量为：父结构体objc_object的isa成员变量（8 bytes）+ objc_class结构体的superclass成员变量（8 bytes）+ objc_class结构体的cache成员变量（16 bytes） = 32 bytes。 第三步、第四步，很凑巧的是bits和flags都是两个结构体里的第一个成员变量，那么我们就不需要继续计算偏移了，只需要关注data()函数的具体取值方法即可。 最终我们从一个Class类型，取到它有没有被初始化过的代码大致如下： 1234567Class metaCls &#x3D; objc_getMetaClass(class_getName(cls));if (metaCls) &#123; uint64_t *bits &#x3D; (__bridge void *)metaCls + 32; &#x2F;&#x2F; 在 metaClass 基地址上加上 32 bits 的偏移 uint32_t *data &#x3D; (uint32_t *)(*bits &amp; FAST_DATA_MASK); &#x2F;&#x2F; 模拟 data() 函数取值 return (*data &amp; RW_INITIALIZED); &#x2F;&#x2F; 模拟 isInitialized() 函数最后一步与操作&#125;return NO;","categories":[],"tags":[]},{"title":"刨根问底Autorelease","slug":"autorelease-pool","date":"2020-07-14T01:40:47.208Z","updated":"2020-07-14T03:27:40.046Z","comments":true,"path":"2020/07/14/autorelease-pool/","link":"","permalink":"http://heseng91.github.io/2020/07/14/autorelease-pool/","excerpt":"","text":"Autorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用[obj autorelease]来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？刨根问底，一起来探究下黑幕背后的Autorelease机制。 Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Hello World!","slug":"hello-world","date":"2020-07-13T17:40:23.790Z","updated":"2020-07-14T03:27:36.902Z","comments":true,"path":"2020/07/14/hello-world/","link":"","permalink":"http://heseng91.github.io/2020/07/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}