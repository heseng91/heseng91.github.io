{"meta":{"title":"和僧","subtitle":"","description":"技术博客","author":"和僧","url":"http://heseng91.github.io","root":"/"},"pages":[],"posts":[{"title":"刨根问底之-Runtime类和对象的定义","slug":"刨根问底之-Runtime类和对象的定义","date":"2021-10-30T18:40:17.933Z","updated":"2021-10-30T19:31:15.836Z","comments":true,"path":"2021/10/31/刨根问底之-Runtime类和对象的定义/","link":"","permalink":"http://heseng91.github.io/2021/10/31/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E4%B9%8B-Runtime%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89/","excerpt":"","text":"「刨根问底」之Objective-C 2.0 中类与对象的定义runtime简介依照苹果文档的说法，runtime是： 12The Objective-C language defers as many decisions as it can from compile time and link time to runtime. （尽量将决定放到运行的时候，而不是在编译和链接过程） 如何理解这段话呢，我们首先要知道，一段代码从写完到最终执行的过程中发生了什么。 从代码到可执行文件的过程具体过程见下图： 主要过程可以简化成三个： 123- 编译- 链接- 运行 编译：将代码转换成底层可执行的语言（如汇编），简单来讲，就是把你能看懂的语言，转换成系统底层可以看懂的东西，这中间通常会有优化，先预处理，再编译。 链接：在编译的过程中，如果有调用其他的类的方法等，是不会检查或者报警的，编译的时候会默认你已经实现了。而链接就是去检查调用的方法或者类等是否确实存在。 运行：执行最终的可执行文件 如果是普通的C语言代码，我们使用的是传统的编译运行，那么一个函数的执行内容，在编译阶段其实就确定了，执行的时候只要去执行对应的内存地址的程序就好。 因为Objc是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个 Objc 运行框架的一块基石。 Runtime其实有两个版本: “modern” 和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。而 maxOS 较老的32位程序仍采用 Objective-C 1 中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime之发送消息（objc_msgSend）还记得刚学 Objective-C 时把 [receiver message] 当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。其实 [receiver message] 会被编译器转化为： 1objc_msgSend(receiver, selector) 如果消息含有参数，则为： 1objc_msgSend(receiver, selector, arg1, arg2, ...) 如果消息的接收者能够找到对应的 selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个 selector 对应的实现内容，要么就干脆玩完崩溃掉。 消息发送等下章详细表述。本文基于源码为 objc4-756.2，先来介绍一下 Objective-C 2.0 中类与对象的相关定义，仅作为参考，暂不做深入的分析。 Runtime 基础数据结构前面提到的objc_msgSend:的真身是这样的： 1id objc_msgSend ( id self, SEL op, ... ); 下面将会逐渐展开介绍一些术语，其实它们都对应着数据结构。 SELobjc_msgSend函数第二个参数类型为SEL，它是selector在Objc中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL: 1typedef struct objc_selector *SEL; 其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获得一个 SEL 类型的方法选择器。 不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(参见：NSNumber 一堆抽象工厂方法)，Cocoa 中也有好多长长的方法。 idobjc_msgSend 第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针： 1typedef struct objc_object *id; 那objc_object又是啥呢，参考 objc-private.h 文件部分源码： 12345678910111213struct objc_object &#123;private: isa_t isa;public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // getIsa() allows this to be a tagged pointer object Class getIsa(); ... 此处省略其他方法声明&#125; objc_object 结构体包含一个 isa 指针，类型为 isa_t 联合体。根据 isa 就可以顺藤摸瓜找到对象所属的类。 PS: isa 指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用 class 方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见官方文档 isa_tobjc_object 中的 isa 是一个 isa_t 类型的共用体（union），在objc-private.h 文件中定义如下： 123456789101112union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct &#123; ISA_BITFIELD; // defined in isa.h &#125;;#endif&#125;; 其中 ISA_BITFIELD在 isa.h文件中定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#if SUPPORT_PACKED_ISA // extra_rc must be the MSB-most field (so it matches carry/overflow flags) // nonpointer must be the LSB (fixme or get rid of it) // shiftcls must occupy the same bits that a real class pointer would // bits + RC_ONE is equivalent to extra_rc + 1 // RC_HALF is the high bit of extra_rc (i.e. half of its range) // future expansion: // uintptr_t fast_rr : 1; // no r/r overrides // uintptr_t lock : 2; // lock for atomic property, @synch // uintptr_t extraBytes : 1; // allocated with extra bytes# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18)# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 8# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7)# else# error unknown architecture for packed isa# endif SUPPORT_PACKED_ISA 用于标记是否支持优化的 isa 指针，其字面含义意思是 isa 的内容不再是类的指针了，而是包含了更多信息，比如引用计数，析构状态，被其他 weak 变量引用情况。判断方法也是根据设备类型： 12345678// Define SUPPORT_PACKED_ISA=1 on platforms that store the class in the isa // field as a maskable pointer with other data around it.#if (!__LP64__ || TARGET_OS_WIN32 || \\ (TARGET_OS_SIMULATOR &amp;&amp; !TARGET_OS_IOSMAC))# define SUPPORT_PACKED_ISA 0#else# define SUPPORT_PACKED_ISA 1#endif 综合看来目前只有 arm64 架构的设备支持，下面列出了 isa 指针中变量对应的含义： 变量名 含义 nonpointer 0 表示普通的 isa 指针，1 表示使用优化，存储引用计数 has_assoc 表示该对象是否包含 associated object，如果没有，则析构时会更快 has_cxx_dtor 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls 类的指针 magic 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化。 weakly_referenced 表示该对象是否有过 weak 对象，如果没有，则析构时更快 deallocating 表示该对象是否正在析构 has_sidetable_rc 表示该对象的引用计数值是否过大无法存储在 isa 指针 extra_rc 存储引用计数值减一后的结果 ClassClass 其实是一个指向 objc_class 结构体的指针： 1typedef struct objc_class *Class; 而 objc_class 包含很多方法，主要都为围绕它的几个成员做文章： 123456789101112struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125; ...// 省略其他方法&#125; objc_class 继承于 objc_object，也就是说一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似 [NSObject alloc] 的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 [NSObject alloc] 这条消息发给类对象的时候，objc_msgSend() 会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。 上图实线是 superclass 指针，虚线是isa指针。 有趣的是根元类的超类是 NSObject，而 isa 指向了自己，而 NSObject的超类为 nil，也就是它没有超类。 cache_t1234567struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;... //省略其他方法&#125; 其中，bucket_t *_buckets 是一个散列表，用来存储 Method 方法列表，而 bucket_t 结构体定义如下，包含了一个 unsigned long 类型的 _key 和一个 IMP 类型的 _imp，存储了指针与 IMP 的键值对。IMP 是一个函数指针，指向了一个方法的具体实现。 1234567891011121314struct bucket_t &#123;private: // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64.#if __arm64__ uintptr_t _imp; SEL _sel;#else SEL _sel; uintptr_t _imp;#endif... 省略其他方法&#125;; cache_t 中另外两个变量 _mask 和 _occupied，它们的类型为 mask_t，定义如下，其实是一个 unsigned int。 12345#if __LP64__typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t;#endif _mask 和 _occupied 对应于 vtable： _mask：分配用来缓存 bucket 的总数。 _occupied：表明目前实际占用的缓存 bucket 的个数。 cache 的作用主要是对方法调用的性能进行优化。通俗地讲，每当实例对象接收到一个消息时，它不会直接在其 isa 指向的类（或类的 isa 指向的父类）的方法列表中遍历查找能够响应消息的方法实现，因为这样效率太低了，而是优先在 cache 中查找。Runtime 系统会把被调用过的方法存到该类对象的 cache 中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。 有关缓存的实现细节，可以查看 objc-cache.mm 文件。 class_data_bits_tobjc_class 中最复杂的是 bits，class_data_bits_t 结构体所包含的信息太多了，主要包含 class_rw_t, retain/release/autorelease/retainCount 和 alloc 等信息，很多存取方法也是围绕它展开。查看 objc-runtime-new.h 源码如下： 123456789101112131415161718struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;private: bool getBit(uintptr_t bit) &#123; return bits &amp; bit; &#125;...public: class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;...省略其他方法&#125; 注意 objc_class 的 data 方法直接将 class_data_bits_t 的data 方法返回，最终是返回 class_rw_t，保了好几层。 可以看到 class_data_bits_t 里又包了一个 bits，这个指针跟不同的 FAST_ 前缀的 flag 掩码做按位与操作，就可以获取不同的数据。bits 在内存中每个位的含义有三种排列顺序： 32 位： 0 1 2 - 31 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_DATA_MASK 64 位兼容版： 0 1 2 3 - 46 47 - 63 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_HAS_DEFAULT_RR FAST_DATA_MASK 空闲 64 位不兼容版： 0 1 2 3 - 46 47 FAST_IS_SWIFT_LEGACY FAST_IS_SWIFT_STABLE FAST_ALLOC FAST_DATA_MASK FAST_HAS_CXX_CTOR 48 49 50 51 52 - 63 FAST_HAS_DEFAULT_AWZ FAST_HAS_DEFAULT_RR FAST_REQUIRES_RAW_ISA FAST_HAS_CXX_DTOR 空闲 其中 64 位不兼容版每个宏对应的含义如下： 1234567891011121314151617181920212223242526// class is a Swift class from the pre-stable Swift ABI#define FAST_IS_SWIFT_LEGACY (1UL&lt;&lt;0)// class is a Swift class from the stable Swift ABI#define FAST_IS_SWIFT_STABLE (1UL&lt;&lt;1)// summary bit for fast alloc path: !hasCxxCtor and // !instancesRequireRawIsa and instanceSize fits into shiftedSize#define FAST_ALLOC (1UL&lt;&lt;2)// data pointer#define FAST_DATA_MASK 0x00007ffffffffff8UL// class or superclass has .cxx_construct implementation#define FAST_HAS_CXX_CTOR (1UL&lt;&lt;47)// class or superclass has default alloc/allocWithZone: implementation// Note this is is stored in the metaclass.#define FAST_HAS_DEFAULT_AWZ (1UL&lt;&lt;48)// class or superclass has default retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference#define FAST_HAS_DEFAULT_RR (1UL&lt;&lt;49)// class's instances requires raw isa// This bit is aligned with isa_t-&gt;hasCxxDtor to save an instruction.#define FAST_REQUIRES_RAW_ISA (1UL&lt;&lt;50)// class or superclass has .cxx_destruct implementation#define FAST_HAS_CXX_DTOR (1UL&lt;&lt;51)// instance size in units of 16 bytes// or 0 if the instance size is too big in this field// This field must be LAST#define FAST_SHIFTED_SIZE_SHIFT 52 这里面除了 FAST_DATA_MASK 是用一段空间存储数据外，其他宏都是只用 1 bit 存储 bool 值。class_data_bits_t 提供了三个方法用于位操作：getBit, setBits 和 clearBits，对应到存储 bool 值的掩码也有封装函数，比如： 123456bool hasCxxCtor() &#123; return getBit(FAST_HAS_CXX_CTOR);&#125;void setHasCxxCtor() &#123; setBits(FAST_HAS_CXX_CTOR);&#125; 重头戏在于最大的那块存储区域–FAST_DATA_MASK，它其实就存储了指向 class_rw_t 的指针： 123class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK);&#125; 对这片内存读写处于并发环境，但并不需要加锁，因为会通过对一些状态（realization or construction）判断来决定是否可读写。 class_data_bits_t 甚至还包含了一些对 class_rw_t 中 flags 成员存取的封装函数。 class_rw_tobjc_class 包含了 class_data_bits_t，class_data_bits_t 存储了 class_rw_t 的指针。 1234567891011121314151617181920212223struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;#if SUPPORT_INDEXED_ISA uint32_t index;#endif...省略操作 flags 的相关方法&#125; class_rw_t 中使用的 method_array_t, property_array_t, protocol_array_t 都继承自 list_array_tt&lt;Element, List&gt;, 它可以不断扩张，因为它可以存储 list 指针，内容有三种： 空 一个 entsize_list_tt 指针 entsize_list_tt 指针数组 class_rw_t 的内容是可以在运行时被动态修改的，可以说运行时对类的拓展大都是存储在这里的。 class_rw_t-&gt;flags 存储的值并不是编辑器设置的，其中有些值可能将来会作为 ABI 的一部分。下面这些 RW_ 前缀的宏标记了 flags 一些位置的含义。这些 bool 值标记了类的一些状态，涉及到声明周期和内存管理。有些位目前甚至还空着。 12345678910111213141516171819202122232425262728293031// Values for class_rw_t-&gt;flags// These are not emitted by the compiler and are never used in class_ro_t. // Their presence should be considered in future ABI versions.// class_t-&gt;data is class_rw_t, not class_ro_t#define RW_REALIZED (1&lt;&lt;31)// class is unresolved future class#define RW_FUTURE (1&lt;&lt;30)// class is initialized#define RW_INITIALIZED (1&lt;&lt;29)// class is initializing#define RW_INITIALIZING (1&lt;&lt;28)// class_rw_t-&gt;ro is heap copy of class_ro_t#define RW_COPIED_RO (1&lt;&lt;27)// class allocated but not yet registered#define RW_CONSTRUCTING (1&lt;&lt;26)// class allocated and registered#define RW_CONSTRUCTED (1&lt;&lt;25)// available for use; was RW_FINALIZE_ON_MAIN_THREAD// #define RW_24 (1&lt;&lt;24)// class +load has been called#define RW_LOADED (1&lt;&lt;23)#if !SUPPORT_NONPOINTER_ISA// class instances may have associative references#define RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS (1&lt;&lt;22)#endif// class has instance-specific GC layout#define RW_HAS_INSTANCE_SPECIFIC_LAYOUT (1 &lt;&lt; 21)// class does not allow associated objects on its instances#define RW_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;20)// class has started realizing but not yet completed it#define RW_REALIZING (1&lt;&lt;19) demangledName 是计算机语言用于解决实体名称唯一性的一种方法，做法是向名称中添加一些类型信息，用于从编译器中向链接器传递更多语义信息。 class_ro_tclass_rw_t 提供了运行时对类拓展的能力，而 class_ro_t 存储的大多是类在编译时就已经确定的信息。二者都存有类的方法、属性（成员变量）、协议等信息，不过存储它们的列表实现方式不同。 class_ro_t 中的 method_list_t, ivar_list_t, property_list_t 结构体都继承自 entsize_list_tt&lt;Element, List, FlagMask&gt;。结构为 xxx_list_t 的列表元素结构为 xxx_t，命名很工整。protocol_list_t 与前三个不同，它存储的是 protocol_t * 指针列表，实现比较简单。 entsize_list_tt 实现了 non-fragile 特性的数组结构。假如苹果在新版本的 SDK 中向 NSObject 类增加了一些内容，NSObject 的占据的内存区域会扩大，开发者以前编译出的二进制中的子类就会与新的 NSObject 内存有重叠部分。于是在编译期会给 instanceStart 和 instanceSize 赋值，确定好编译时每个类的所占内存区域起始偏移量和大小，这样只需将子类与基类的这两个变量作对比即可知道子类是否与基类有重叠，如果有，也可知道子类需要挪多少偏移量。更多细节可以参考后面的章节 Non Fragile ivars。 123456789101112131415161718192021222324struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; // This field exists only when RO_HAS_SWIFT_INITIALIZER is set. _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0];...省略其他方法&#125;; class_ro_t-&gt;flags 存储了很多在编译时期就确定的类的信息，也是 ABI 的一部分。下面这些 RO_ 前缀的宏标记了 flags 一些位置的含义。其中后三个并不需要被编译器赋值，是预留给运行时加载和初始化类的标志位，涉及到与 class_rw_t 的类型强转。运行时会用到它做判断，后面会讲解。 1234567891011121314151617181920212223242526272829303132333435// class_data_bits_t is the class_t-&gt;data field (class_rw_t pointer plus flags)// The extra bits are optimized for the retain/release and alloc/dealloc paths.// Values for class_ro_t-&gt;flags// These are emitted by the compiler and are part of the ABI.// Note: See CGObjCNonFragileABIMac::BuildClassRoTInitializer in clang// class is a metaclass#define RO_META (1&lt;&lt;0)// class is a root class#define RO_ROOT (1&lt;&lt;1)// class has .cxx_construct/destruct implementations#define RO_HAS_CXX_STRUCTORS (1&lt;&lt;2)// class has +load implementation// #define RO_HAS_LOAD_METHOD (1&lt;&lt;3)// class has visibility=hidden set#define RO_HIDDEN (1&lt;&lt;4)// class has attribute(objc_exception): OBJC_EHTYPE_$_ThisClass is non-weak#define RO_EXCEPTION (1&lt;&lt;5)// class has ro field for Swift metadata initializer callback#define RO_HAS_SWIFT_INITIALIZER (1&lt;&lt;6)// class compiled with ARC#define RO_IS_ARC (1&lt;&lt;7)// class has .cxx_destruct but no .cxx_construct (with RO_HAS_CXX_STRUCTORS)#define RO_HAS_CXX_DTOR_ONLY (1&lt;&lt;8)// class is not ARC but has ARC-style weak ivar layout #define RO_HAS_WEAK_WITHOUT_ARC (1&lt;&lt;9)// class does not allow associated objects on instances#define RO_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;10)// class is in an unloadable bundle - must never be set by compiler#define RO_FROM_BUNDLE (1&lt;&lt;29)// class is unrealized future class - must never be set by compiler#define RO_FUTURE (1&lt;&lt;30)// class is realized - must never be set by compiler#define RO_REALIZED (1&lt;&lt;31) realizeClass在某个类初始化之前，objc_class-&gt;data() 返回的指针指向的其实是个 class_ro_t 结构体。等到 static Class realizeClass(Class cls) 静态方法在类第一次初始化时被调用，它会: 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针 初始化一个 class_rw_t 结构体 设置结构体 ro 的值以及 flag 最后设置正确的 data。 将 class_ro_t 指针赋值给 class_rw_t-&gt;ro。这种偷天换日的行为是靠 RO_FUTURE 标志位来记录的： 123456789101112131415161718192021222324252627/************************************************************************ realizeClassWithoutSwift* Performs first-time initialization on class cls, * including allocating its read-write data.* Does not perform any Swift-side initialization.* Returns the real class structure for the class. * Locking: runtimeLock must be write-locked by the caller**********************************************************************/static Class realizeClassWithoutSwift(Class cls)&#123;... ro = (const class_ro_t *)cls-&gt;data(); if (ro-&gt;flags &amp; RO_FUTURE) &#123; // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro; cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE); &#125; else &#123; // Normal class. Allocate writeable class data. rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); rw-&gt;ro = ro; rw-&gt;flags = RW_REALIZED|RW_REALIZING; cls-&gt;setData(rw); &#125;...省略逻辑实现&#125; 注意之前 RO 和 RW flags 宏标记的一个细节： 12345#define RO_FUTURE (1&lt;&lt;30)#define RO_REALIZED (1&lt;&lt;31)#define RW_REALIZED (1&lt;&lt;31)#define RW_FUTURE (1&lt;&lt;30) 也就是说 ro = (const class_ro_t *)cls-&gt;data(); 这种强转对于接下来的 ro-&gt;flags &amp; RO_FUTURE 操作完全是 OK 的，两种结构体第一个成员都是 flags，RO_FUTURE 与 RW_FUTURE 值一样的。 经过 realizeClass 函数处理的类才是『真正的』类，调用它时不能对类做写操作。 Ivar在 objc-private.h 中，Ivar 被定义为一个指向 ivar_t 结构体的指针： 1#if __OBJC2__typedef struct ivar_t *Ivar; ivar_t 结构体在 objc-runtime-new.h 中定义： 123456789101112131415161718192021struct ivar_t &#123;#if __x86_64__ // *offset was originally 64-bit on some x86_64 platforms. // We read and write only 32 bits of it. // Some metadata provides all 64 bits. This is harmless for unsigned // little-endian values. // Some code uses all 64 bits. class_addIvar() over-allocates the // offset for their benefit.#endif int32_t *offset; const char *name; const char *type; // alignment is sometimes -1; use alignment() instead uint32_t alignment_raw; uint32_t size; uint32_t alignment() const &#123; if (alignment_raw == ~(uint32_t)0) return 1U &lt;&lt; WORD_SHIFT; return 1 &lt;&lt; alignment_raw; &#125;&#125;; Ivar 用于表示类中实例变量（成员变量）的类型，ivar_t 中定义了实例变量的名字和类型。而ivar 的修饰信息存放在了 Class 的 Ivar Layout 中。ivarLayout 和 weakIvarLayout 分别记录了哪些 ivar 是 strong 或是 weak，都未记录的就是基本类型和 __unsafe_unretained 的对象类型。 举个例子说明，若类定义为： 1234567@interfaceFoo : NSObject &#123; __strong id ivar0; __weak id ivar1; __weak id ivar2;&#125;@end 则储存 strong ivar 的 ivarLayout 的值为 0x012000 储存 weak ivar 的 weakIvarLayout 的值为 0x1200 一个 uint8_t 在 16 进制下是两位，所以编码的值每两位一对儿，以上面的 ivarLayout 为例： 前两位 01 表示有 0 个非 strong 对象和 1 个 strong 对象 之后两位 20 表示有 2 个非 strong 对象和 0 个 strong 对象 最后两位 00 为结束符，就像 cstring 的 \\0 一样 同理，上面的 weakIvarLayout： 前两位 12 表示有 1 个非 weak 对象和接下来连续 2 个 weak 对象 00 结束符 这样，用两个 layout 编码值就可以排查出一个 ivar 是属于 strong 还是 weak 的，若都没有找到，就说明这个对象是 unsafe_unretained. Property我们知道，@property 用于声明类中的属性，在 Runtime 系统中，objc_property_t 是一个指向objc_property 结构体的指针，在 objc-private.h 中定义： 1#if __OBJC2__typedef struct property_t *objc_property_t; property_t 结构体在 objc-runtime-new.h 中定义： 1234struct property_t &#123; const char *name; const char *attributes;&#125;; MethodMethod是一种代表类中的某个方法的类型。 1#if __OBJC2__typedef struct method_t *Method; 而 objc_method 在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现： 1234567891011121314struct method_t &#123; SEL name; const char *types; MethodListIMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;; 方法名类型为 SEL，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。 方法类型 types 是个char指针，其实存储着方法的参数类型和返回值类型。 imp 指向了方法的实现，本质上是一个函数指针，后面会详细讲到。 CategoryCategory 为现有的类提供了拓展性，它是 category_t 结构体的指针。 1#if __OBJC2__typedef struct category_t *Category; category_t 存储了类别中可以拓展的实例方法、类方法、协议、实例属性和类属性。类属性是 Objective-C 2016 年新增的特性，沾 Swift 的光。所以 category_t 中有些成员变量是为了兼容 Swift 的特性，Objective-C 暂没提供接口，仅做了底层数据结构上的兼容。 1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; 在 App 启动加载镜像文件时，会在 _read_images 函数间接调用到 attachCategories 函数，完成向类中添加 Category 的工作。原理就是向 class_rw_t 中的 method_array_t, property_array_t, protocol_array_t 数组中分别添加 method_list_t, property_list_t, protocol_list_t 指针。之前讲过 xxx_array_t 可以存储对应 xxx_list_t 的指针数组。 在调用 attachCategories 函数之前，会先使用 unattachedCategoriesForClass 函数获取类中还未添加的类别列表。这个列表类型为 locstamped_category_list_t，它封装了 category_t 以及对应的 header_info。header_info 存储了实体在镜像中的加载和初始化状态，以及一些偏移量，在加载 Mach-O 文件相关函数中经常用到。 123456789101112struct locstamped_category_t &#123; category_t *cat; struct header_info *hi;&#125;;struct locstamped_category_list_t &#123; uint32_t count;#if __LP64__ uint32_t reserved;#endif locstamped_category_t list[0];&#125;; 所以更具体来说 attachCategories 做的就是将 locstamped_category_list_t.list 列表中每个 locstamped_category_t.cat 中的那方法、协议和属性分别添加到类的 class_rw_t 对应列表中。header_info 中的信息决定了是否是元类，从而选择应该是添加实例方法还是类方法、实例属性还是类属性等。源码在 objc-runtime-new.mm 文件中，很好理解。 protocol_t虽然 Objective-C 的 Category 和 protocol 拓展能力有限，但也得为了将就 Swift 的感受，充个胖子。 flags 32 位指针最后两位是给加载 Mach-O 的 fix-up 阶段使用的，前 16 位预留给 Swift 用的。 protocol 主要内容其实是（可选）方法，其次就是继承其他 protocol。Swift 还支持 protocol 多继承，所以需要 protocols 数组来做兼容。 123456789101112131415161718192021222324struct protocol_t : objc_object &#123; const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; const char *demangledName(); const char *nameForLogging() &#123; return demangledName(); &#125;... 省略一些封装的便捷 get 方法&#125;; IMPIMP在objc.h中的定义是： 1typedef void (*IMP)(void /* id, SEL, ... */ ); 它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。既然得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面会提到。 你会发现 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址；反之亦然。 总结我们可以用如下这张图来分别表示 Objective-C 2.0 版本中类和对象的定义，及相关数据结构的关系： 拓展∂çTagged Pointerisa 这里还涉及到 Tagged Pointer 等概念。因为 isa_t 使用 union 实现，所以可能表示多种形态，既可以当成是指针，也可以存储标志位。 Tagged Pointer：一种特殊标记的对象，Tagged Pointer 通过在其最后一个 bit 位设置为特殊标记位，并且把数据直接保存在指针本身中。Tagged Pointer 是一个”伪”对象，使用 Tagged Pointer 有 3 倍的访问速度提升，100 倍的创建、销毁速度提升。 Tips：Advances in Objective-C 在我们查看对象指针时，在 64 位系统中，我们会看到 16 进制地址如0x00000001003041e0，我们把它转换为二进制表示如下图 在 64 位系统中，我们有 64 位可以表示一个对象指针，但是我们通常没有真正使用到所有这些位。由于内存对齐要求的存在，低位始终为0，对象必须始终位于指针大小倍数的地址中。由于地址空间有限，所以高位也始终为0。所以实际上我们只在一个真正的对象指针中使用了中间的这些位，而不会用到用到2^64，这些高位和低位总是0。 苹果从这些始终为0的位中选择了低位并把它设置为1。以标识这不是一个真正的对象指针，然后就可以给其他位赋予一些其他的意义，苹果称这种指针为tagged pointer。 例如：NSNumber指针，苹果在其它位中塞入的是一个数值。（PS：这些值实际上是通过与进程启动时初始化的随机值相结合而被混淆的）。 在设置为 1 表示为 Tagged Pointer 对象之后，在最低位之后的 3 位，苹果给他赋予类型意义，由于只有 3 位，所以它可以表示 7 种数据类型 12345678OBJC_TAG_NSAtom &#x3D; 0, OBJC_TAG_1 &#x3D; 1, OBJC_TAG_NSString &#x3D; 2, OBJC_TAG_NSNumber &#x3D; 3, OBJC_TAG_NSIndexPath &#x3D; 4, OBJC_TAG_NSManagedObjectID &#x3D; 5, OBJC_TAG_NSDate &#x3D; 6, OBJC_TAG_7 &#x3D; 7 在剩余的字段中，我们可以赋予他所包含的数据。在 Intel 中，我们 Tagged Pointer 对象的表示如下 OBJC_TAG_7类型的 Tagged Pointer 是个例外，它可以将接下来后 8 位作为它的扩展类型字段，基于此我们可以多支持 256 中类型的 Tagged Pointer，如 UIColors 或 NSIndexSets 之类的对象。 OC对象占用的大小初始OC对象占用内存OC中对象大部分继承至NSObject。NSObject类的定义如下： 123456789OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ROOT_CLASSOBJC_EXPORT@interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125; 上文中提到Class其实就是一个指向 struct objc_class 结构体类型的指针.。那么也就是说 NSObject 对象对应的结构体只包含一个 isa 指针变量 ，一个指针变量在 64 位的机器上大小是 8 个字节。 那是不是说一个 NSObject 对象就占用8个字节大小的内存呢？实际上不是的. 答案其实是: 所有的OC对象至少为16字节. 我们先来验证一下。 12345678910#import &lt;Foundation&#x2F;Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; &#x2F;&#x2F; insert code here... NSObject *obj &#x3D; [[NSObject alloc] init]; NSLog(@&quot;Hello, World! %@&quot;,obj); &#125; return 0;&#125; 打印语句加个断点。 lldb中打印得出：对象实际占用的内存大小为8，实际分配的内存大小为16。 lldb查看布情况，可以看出创建的对象后面几个字节全部为 00。 我们可以通过阅读 objc4 的源码来找到答案。通过查看跟踪 obj4 中 alloc 和 allocWithZone 两个函数的实现，会发现这个连个函数都会调用一个 instanceSize 的函数： 123456size_t instanceSize(size_t extraBytes) &#123; size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16bytes. if (size &lt; 16) size = 16; return size; &#125; 上面源码中我们看出了答案, 最少会开辟16个字节. 那么为什么非要用 16 个字节来存储 8 个字节的内容呢? 这里简单解释一下 . 其实这里主要是涉及到硬件问题, 因为不同厂商之间需要一套标准化方案来解决不同厂商之间规则不同导致内存读取使用出现不统一的情况.为了解决这种问题而产生的 字节对齐. 讲到这里,我还想继续看下 当这个对象包含多个属性时使用内存情况. 以便我们彻底搞明白 OC 对象使用内存情况. 包含其他属性占用内存情况创建一个 Person 类,继承与 NSObject , 其包含三个 int 属性。修改main.m 文件如下： 12345678910111213141516171819202122#import &lt;Foundation&#x2F;Foundation.h&gt;@interface Person : NSObject@property (nonatomic, assign) int age;@property (nonatomic, assign) int height;@property (nonatomic, assign) int row;@end@implementation Person@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *obj &#x3D; [[Person alloc] init]; obj.age &#x3D; 4; obj.height &#x3D; 5; obj.row &#x3D; 6; NSLog(@&quot;Hello, World! %@&quot;,obj); &#125; return 0;&#125; lldb打印对象内存情况如下 ![屏幕快照 2021-08-22 下午11.50.02](/Users/ethenfarben/Desktop/屏幕快照 2021-08-22 下午11.50.02.png) 对象实际占用内存大小为24，实际分配的内存大小为32。 ![屏幕快照 2021-08-22 下午11.41.12](/Users/ethenfarben/Desktop/屏幕快照 2021-08-22 下午11.41.12.png) 这里就出现一个比较奇怪的现象 , 实际需要内存大小 24, 为什么呢 ? 其实这里就是 结构体内存分配的原理了. 结构体每个成员相对于结构体首地址的偏移量都是这个成员大小的整数倍，如果有需要，编译器会在成员之间加上填充字节 结构体的总大小为结构体最宽成员大小的整数倍。 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。 对于结构体成员属性中包含结构体变量的复合型结构体，在确定最宽基本类型成员时，应当包括复合类型成员的子成员。但在确定复合类型成员的偏移位置时则是将复合类型作为整体看待。 由于原本结构体 isa指针占用8个 , age属性占用4个, height占用 4个, row属性再占用4个 , 这中间由于满足整除并没有自动偏移补充. 而由于 : 结构体的总大小为结构体最宽成员大小的整数倍 , 而且对线开辟满足 16 字节对齐原则 ( 可以在 libmaclloc 源码查找到 ) , 因此实际总占用内存为24. 而实际开辟则满足对齐标准开辟为 32. 在 libmaclloc 源码 , nano_malloc.c 中 1234567891011121314static MALLOC_INLINE size_tsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)&#123; size_t k, slot_bytes; if (0 == size) &#123; size = NANO_REGIME_QUANTA_SIZE; // Historical behavior &#125; k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // round up and shift for number of quanta slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; // multiply by power of two quanta size *pKey = k - 1; // Zero-based! return slot_bytes;&#125; 其中NANO_REGIME_QUANTA_SIZE 和 SHIFT_NANO_QUANTUM在nano_zone_common.h中定义如下： 12#define SHIFT_NANO_QUANTUM 4#define NANO_REGIME_QUANTA_SIZE (1 &lt;&lt; SHIFT_NANO_QUANTUM) &#x2F;&#x2F; 16 所以16字节对齐算法为：size + (2^4 - 1) &gt;&gt; 4 &lt;&lt; 4。 总结 (只考虑64位): OC对象 最少占用 16个字节内存 . 当对象中包含属性, 会按属性占用内存开辟空间. 在结构体内存分配原则下自动偏移和补齐 . 对象最终满足 16字节对齐标准 . 属性最终满足 8字节对齐标准 . 可以通过 #pragma pack() 自定义对齐方式 . 更新在2020年WWDC中，Runtime又有了一些更新。详见：2020 – Advancements in the Objective-C runtime主要更新内容如下: 数据结构的变化在介绍更新之前，先了解一下二进制类在磁盘中的表示。 ![屏幕快照 2021-08-21 下午9.40.03](/Users/ethenfarben/Desktop/屏幕快照 2021-08-21 下午9.40.03.png) 首先是类对象本身，包含最常访问的信息：指向元类，超类和方法缓存的指针，在类结构之中有指向包含更多数据的结构体class_ro_t的指针，包含了类的名称，方法，协议，实例变量等等编译期确定的信息。 当类被 Runtime 加载之后，类的结构会发生一些变化，在了解这些变化之前，我们需要知道2个概念： Clean Memory：加载后不会发生更改的内存块，class_ro_t属于Clean Memory，因为它是只读的。 Dirty Memory：运行时会进行更改的内存块，类一旦被加载，就会变成Dirty Memory，例如，我们可以在 Runtime 给类动态的添加方法。 这里要明确，Dirty Memory比Clean Memory要昂贵得多。因为它需要更多的内存信息，并且只要进程正在运行，就必须保留它。对于我们来说，越多的Clean Memory显然是更好的，因为它可以节约更多的内存。我们可以通过分离出永不更改的数据部分，将大多数类数据保留为Clean Memory，如何怎么做的呢？ 在介绍优化方法之前，我们先来看一下，在类加载之后，类的结构会变成如何呢？ ![屏幕快照 2021-08-21 下午9.44.24](/Users/ethenfarben/Desktop/屏幕快照 2021-08-21 下午9.44.24.png) 在类加载到 Runtime 中后会被分配用于读取/写入数据的结构体class_rw_t。 Tips：class_ro_t是只读的，存放的是编译期间就确定的字段信息；而class_rw_t是在 runtime 时才创建的，它会先将class_ro_t的内容拷贝一份，再将类的分类的属性、方法、协议等信息添加进去，之所以要这么设计是因为 Objective-C 是动态语言，你可以在运行时更改它们方法，属性等，并且分类可以在不改变类设计的前提下，将新方法添加到类中。 事实证明，class_rw_t会占用比class_ro_t占用更多的内存，在 iPhone 中，我们在系统测量了大约 30MB 的这些class_rw_t结构。应该如何优化这些内存呢？通过测量实际设备上的使用情况，我们发现大约 10％ 的类实际会存在动态的更改行为，如动态添加方法，使用 Category 方法等。因此，我们能可以把这部分动态的部分提取出来，我们称之为class_rw_ext_t，所以，结构会变成这个样子。 ![屏幕快照 2021-08-21 下午10.05.15](/Users/ethenfarben/Desktop/屏幕快照 2021-08-21 下午10.05.15.png) 经过拆分，可以把 90% 的类优化为Clean Memory，在系统层面，取得效果是节省了大约 14MB 的内存，使内存可用于更有效的用途。 Tips：head xxxxx | egrep &#39;class_rw|COUNT’ 你可以使用此命令来查看 class_rw_t 消耗的内存。xxxx可以替换为需要测量的 App 名称。如：head Mail | egrep &#39;class_rw|COUNT’\\&#39;查看 Mail 应用的使用情况。 Tagged pointer格式的变化相比于之前的Tagged pointer，在 ARM64 中格式有些变化。 ![屏幕快照 2021-08-22 上午5.33.02](/Users/ethenfarben/Desktop/屏幕快照 2021-08-22 上午5.33.02.png) 不同于以往，苹果使用最高位代表 Tagged Pointer 标识位，低位 3 位标识 Tagged Pointer 的类型，接下去的位来表示包含的数据（可能包含扩展类型字段），为什么我们使用高位指示 ARM上 的 Tagged Pointer，而不是像 Intel 一样使用低位标记？ 它实际是对 objc_msgSend 的微小优化。我们希望 msgSend 中最常用的路径尽可能快。最常用的路径表示普通对象指针。我们有两种不常见的情况：Tagged Pointer 指针和 nil。事实证明，当我们使用最高位时，可以通过一次比较来检查两者。与分别检查 nil 和 Tagged Pointer 指针相比，这会为 msgSend 中的节省了条件分支。 应用判断类有没有初始化很多技术博客里都提到了，ObjC类的meta class里，自带了一个标记自己有没有初始化过的flag，即class_rw_t–&gt;flags里的RW_INITIALIZED。objc_class类中有提供了封装的函数供外部快速获取该flag值。调用相关代码如下： 12345678910111213141516171819202122// objc_class 代码片段struct objc_class : objc_object &#123;... class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125;... bool isInitialized() &#123; return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED; &#125; void setInitialized();... // NOT identical to this-&gt;ISA when this is a metaclass Class getMeta() &#123; if (isMetaClass()) return (Class)this; else return this-&gt;ISA(); &#125;...&#125; 123456789101112struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;...public: class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;...&#125; 12345struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags;...&#125; 可惜的是，这些方法对我们app来说，是不可见的，没办法直接调用。所以如果想要在运行过程中获取类的初始化状态，只能另想办法。从方法的调用情况看到方法的过程大概分为4步： 我们要先找到类的meta class。 获取objc_class的成员变量bits（class_data_bits_t结构体） 调用class_data_bits_t结构体的data()方法，对结构体的bits属性进行位运算，获取class_rw_t结构体 最后获取class_rw_t结构体的成员变量flags并进行位运算 因为runtime源代码是用C++来写的，所以我们可以通过偏移地址获取到用到的变量，直接用指针来搞定问题。 针对第一步，获取类的meta class，是个runtime里可见的方法，直接调用objc_getMetaClass()方法就能拿到。 第二步获取objc_class的成员变量bits。回到objc_class的头部几行： 1234567891011struct objc_class : objc_object &#123; objc_class(const objc_class&amp;) = delete;// 0 bytes objc_class(objc_class&amp;&amp;) = delete;// 0 bytes void operator=(const objc_class&amp;) = delete;// 0 bytes void operator=(objc_class&amp;&amp;) = delete;// 0 bytes // Class ISA; Class superclass; // 8 bytes cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags...&#125; 首先objc_class 继承至 objc_object，对于子结构体来说，是需要继承父结构体的成员变量的。runtime源代码是用C++来写的，函数都不会占用类meta信息（或者说实例）的内存地址，只有成员变量会占用地址。objc_object父结构如前表述，仅包含isa这个成员变量，占用类实例的头8个bytes，也就是64位CPU的一个指针的长度；而下面的一堆方法，在实例里面一点内存都不占用。然后看完整个结构体，只有这么一个成员变量，所以总长度也就8个bytes。 objc_class内前面几行那几个函数禁用语句，不会产生内存地址的偏移，先不管它们。 superclass作为一个指针（对，Class类型实际上是一个指向结构体的指针），长度为8 bytes。 接下来是cache_t类型的变量cache，它占用了多少bytes我们就要展开看看了。 123456789101112131415161718192021#if __LP64__typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t;#endif...struct cache_t &#123;private: explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;// 8 bytes union &#123; struct &#123; explicit_atomic&lt;mask_t&gt; _maybeMask;//4 bytes#if __LP64__ uint16_t _flags;//2 bytes#endif uint16_t _occupied;//2 bytes &#125;; explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;// 8 bytes &#125;;...&#125; 首先说一下explicit_atomic&lt;T&gt;，它只是负责把模板里的类型包成atomic的，不会对变量占用的内存长度产生影响。 然后要说一下union，C++的老朋友了，联合体内部的成员取最长的一个内存长度，就是联合体的内存长度，这里就是8 bytes。 mask_t的定义在文件头就能找到，其实在64位CPU下就是一个uint32_t而已。 基于上面的介绍，可以推断出整个cache_t结构体的长度就是8 bytes + 8 bytes = 16 bytes。 综上，bits 偏移量为：父结构体objc_object的isa成员变量（8 bytes）+ objc_class结构体的superclass成员变量（8 bytes）+ objc_class结构体的cache成员变量（16 bytes） = 32 bytes。 第三步、第四步，很凑巧的是bits和flags都是两个结构体里的第一个成员变量，那么我们就不需要继续计算偏移了，只需要关注data()函数的具体取值方法即可。 最终我们从一个Class类型，取到它有没有被初始化过的代码大致如下： 1234567Class metaCls &#x3D; objc_getMetaClass(class_getName(cls));if (metaCls) &#123; uint64_t *bits &#x3D; (__bridge void *)metaCls + 32; &#x2F;&#x2F; 在 metaClass 基地址上加上 32 bits 的偏移 uint32_t *data &#x3D; (uint32_t *)(*bits &amp; FAST_DATA_MASK); &#x2F;&#x2F; 模拟 data() 函数取值 return (*data &amp; RW_INITIALIZED); &#x2F;&#x2F; 模拟 isInitialized() 函数最后一步与操作&#125;return NO;","categories":[],"tags":[]},{"title":"刨根问底Autorelease","slug":"autorelease-pool","date":"2020-07-14T01:40:47.208Z","updated":"2020-07-14T03:27:40.046Z","comments":true,"path":"2020/07/14/autorelease-pool/","link":"","permalink":"http://heseng91.github.io/2020/07/14/autorelease-pool/","excerpt":"","text":"Autorelease机制是iOS开发者管理对象内存的好伙伴，MRC中，调用[obj autorelease]来延迟内存的释放是一件简单自然的事，ARC下，我们甚至可以完全不知道Autorelease就能管理好内存。而在这背后，objc和编译器都帮我们做了哪些事呢，它们是如何协作来正确管理内存的呢？刨根问底，一起来探究下黑幕背后的Autorelease机制。 Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Hello World!","slug":"hello-world","date":"2020-07-13T17:40:23.790Z","updated":"2020-07-14T03:27:36.902Z","comments":true,"path":"2020/07/14/hello-world/","link":"","permalink":"http://heseng91.github.io/2020/07/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}